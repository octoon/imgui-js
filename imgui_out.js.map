{"version":3,"sources":["imgui_js/bind-imgui.cpp","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\emscripten/val.h","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\type_traits","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\emscripten/bind.h","./imgui_js/imgui\\imgui.h","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\string","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\memory","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\emscripten/wire.h","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\__string","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\vector","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\algorithm","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\__split_buffer","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\new","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\stdexcept","imgui_js/imgui/imgui.cpp","./imgui_js/imgui/imgui_internal.h","./imgui_js/imgui/imgui.h","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\string.h","imgui_js/imgui/imgui_widgets.cpp","./imgui_js/imgui/imstb_textedit.h","imgui_js/imgui/imgui_draw.cpp","./imgui_js/imgui/imstb_truetype.h","./imgui_js/imgui/imstb_rectpack.h","imgui_js/imgui/imgui_demo.cpp","D:\\emsdk\\emscripten\\1.38.21\\system\\lib\\embind\\bind.cpp","D:\\emsdk\\emscripten\\1.38.21\\system\\include\\libcxx\\typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAtCA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;;;;;AADA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;;;;AADA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH13BA;;;;;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGyrBA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;;AA9tBA;AA+tBA;AACA;;AAhuBA;AAiuBA;AACA;;AAluBA;AAmuBA;AACA;AACA;;AAruBA;AAsuBA;AAbA;;;;;AAyNA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHx4BA;AAAA;;;;;;AG+6BA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;;;;;AA5CA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67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ACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH3sBA;AAAA;AAAA;;;;;;;;;;;AGwsBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AHzsBA;;;;;AG6uBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH1uBA;AAAA;AAAA;;;;;;;;;;;AGksBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AHnsBA;;;;;AGuuBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHpuBA;;;;;AGmuBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH9tBA;;;;;AG6tBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH1tBA;;;;;AGytBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHttBA;;;;;AGqtBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHltBA;;;;;AGitBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH9sBA;;;;;AG6sBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH1sBA;;;;;AGysBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHtsBA;;;;;AGqsBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHlsBA;;;;;AGisBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH9rBA;;;;;AG6rBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH1rBA;;;;;AGyrBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHtrBA;;;;;AGqrBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHlrBA;;;;;AGirBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH7qBA;;;;;AG4qBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHzqBA;;;;;AGwqBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHrqBA;;;;;AGoqBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHjqBA;;;;;AGgqBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHzpBA;;;;;AGwpBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHjpBA;;;;;AGgpBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH3oBA;AAAA;AAAA;;;;;;;;;;;AGmmBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AHpmBA;;;;;AGwoBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHroBA;;;;;AGooBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHjoBA;;;;;AGgoBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH7nBA;;;;;AG4nBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHznBA;;;;;AGwnBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHrnBA;;;;;AGonBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHjnBA;;;;;AGgnBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH7mBA;;;;;AG4mBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHrmBA;AAAA;AAAA;;;;;;;;;;;AG6jBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH9jBA;AAAA;AAAA;;;;;;;;;;;AG2jBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH5jBA;AAAA;AAAA;;;;;;;;;;;AGyjBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AHxjBA;;;;;AG4lBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHzlBA;AAAA;AAAA;;;;;;;;;;;AGijBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH9iBA;AAAA;AAAA;;;;;;;;;;;AG2iBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH5iBA;AAAA;AAAA;;;;;;;;;;;AGyiBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH1iBA;AAAA;AAAA;;;;;;;;;;;AGuiBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AHxiBA;;;;;AG4kBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHzkBA;;;;;AGwkBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHrkBA;;;;;AGokBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHjkBA;;;;;AGgkBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH7jBA;;;;;AG4jBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHzjBA;;;;;AGwjBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHrjBA;AAAA;AAAA;;;;;;;;;;;AG6gBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH9gBA;AAAA;AAAA;;;;;;;;;;AG2gBA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH5gBA;;;;;;;;AGlbA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAA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AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHjiBA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG6TA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;;AA9tBA;AA+tBA;AACA;;AAhuBA;AAiuBA;AACA;;AAluBA;AAmuBA;AACA;AACA;;AAruBA;AAsuBA;AAbA;AH/TA;AAAA;;;;;;AGikBA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;;;;;AA5CA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AH1gBA;;;;;AG4hBA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AH3hBA;;;;;AG0hBA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHzhBA;;;;;AGwhBA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;;;;;AArBA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHtfA;AAAA;;;;;;AG6hBA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AH3hBA;;;;AGmgBA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHhgBA;;;;;;;;AG3hBA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;AH6hBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGyQA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;;AA9tBA;AA+tBA;AACA;;AAhuBA;AAiuBA;AACA;;AAluBA;AAmuBA;AACA;AACA;;AAruBA;AAsuBA;AAbA;;;;;AAyNA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHneA;;;;;AGqfA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHnfA;;;;;;AG0bA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH/aA;AAAA;;;;;;AG2fA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;;;;;AA5CA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHzcA;;;;;;AGmaA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;;;;;AAmCA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;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CA;;AAhuBA;AAiuBA;AACA;;AAluBA;AAmuBA;AACA;AACA;;AAruBA;AAsuBA;AAbA;;;;;AAyNA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHnIA;;;;;AGqJA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;;;;;AArBA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AH7HA;AAAA;;;;;;AGoKA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AH7JA;AAAA;;;;;;AG0JA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;;;;;AA5CA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHnGA;;;;;AG6DA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH3DA;;;;;AG0DA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;;;;;AAmCA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHxFA;AAAA;;;;;;AG+HA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AH7HA;;;;;AGqGA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;;;;;AArBA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AH7EA;AAAA;;;;;;AGoHA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AHrHA;;;;;AG6FA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AH5FA;;;;;AG2FA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AH1FA;;;;;AGyFA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;;;;;AArBA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHpDA;AAAA;;;;;;AG2FA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AHzFA;AAAA;;;;;;AGsFA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AHpFA;AAAA;;;;;;AGiFA;AACA;AAGA;AACA;AACA;AACA;;AAl+BA;AAm+BA;AACA;AAAA;AACA;AACA;;AAt+BA;AAu+BA;AACA;AAAA;AAVA;AHhEA;;;;;AGwCA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHvCA;;;;;;AGlBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHoBA;;;;;;AGrBA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;;;;;AAmCA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHHA;;;;;;AGnCA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHqCA;;;;;;AGtCA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHyCA;;;;;AGcA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHXA;;;;;;AG9CA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHgDA;;;;;;AGjDA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AHsDA;AAAA;AAAA;;;;;;;;;;;AG9FA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;AH6FA;;;;;;AGzDA;AAEA;AACA;AACA;AACA;AACA;;AAp5BA;AAq5BA;AACA;AAPA;AH4DA;AAAA;AAAA;;;;;;;;;;;AGpGA;AAIA;AACA;AACA;AACA;AACA;;AA/2BA;AAg3BA;AACA;AAPA;;;;;AAwEA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7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AFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHyHA;;;;;AGvGA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;;;;;AArBA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AH+HA;;;;;AG7GA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AH8GA;;;;;AG/GA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHgHA;;;;;AGjHA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;;;;;AArBA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;;;;;AAFA;AACA;AAEA;AACA;AACA;AACA;;AAx7BA;AAy7BA;AACA;AACA;AACA;;AA57BA;AA67BA;AACA;AAVA;AHiJA;;;;;AG/HA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHgIA;;;;;AGjIA;AAEA;AACA;AACA;AACA;;AA38BA;AA48BA;AACA;AAAA;AANA;AHkIA;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;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;;;;AARA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;;;;AARA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AACA;AACA;;AA1BA;AA2BA;AACA;AANA;AAOA;;;;;;;;AAjHA;AAAA;AAAA;;;;;;;;;;;AAyGA;AAEA;AACA;AA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;;;;AN/DA;AAAA;AAAA;;;;;;;;AD+ZA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AGnFA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APsWA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AIipCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AH12CA;AAAA;AAAA;AAEA;AAAA;AACA;;;;;;;;;AG4hCA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AAhuCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ADmTA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;AADA;AAAA;AAAA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;AP0WA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AI8oCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AJxoCA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AGnGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH+LA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AGvGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHmMA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AG3GA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHuMA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AG/GA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH2MA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AGnHA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH+MA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AGvHA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHmNA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AG3HA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHuNA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AG/HA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH2NA;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AGnIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH+NA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AGvIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHmOA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AKwnBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANneA;AAAA;;;;;;;;;AM6WA;;AJzhBA;;;AI+oBA;ANneA;AAAA;;;;;;;;;;;;;;;;;;;AG3IA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;AP4ZA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AKonBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN/dA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AC3IA;AACA;AAAA;AAFA;AAAA;AAIA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;AD1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AADA;AAAA;AAAA;AACA;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AOkBA;AAAA;;;;;;;;ANrEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AMgDA;;;;;;;;ANxDA;AAAA;AAAA;AAAA;;;;;;;;AMgMA;AAAA;;;;;;;;;;APxIA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG4QA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH4OA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGpJA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APqaA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGxJA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHoPA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG5JA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHwPA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AC9LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AE8BA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APqbA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AGxKA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;AP6bA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGhLA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHgRA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AI2kCA;AAAA;AAAA;AAAA;;;;;;;;;;;AA/UA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AJxvBA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AIwkCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAhXA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AJptBA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AIqkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;ADrwCA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APidA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AIkkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;ADtwCA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHgSA;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AGxMA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHoSA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AG5MA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;AP6dA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AGhNA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APieA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AGpNA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;;;;;;AAyHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AAAA;;;;;;;;AI9RA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APifA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;AGpOA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;;;;;;;;AJ8SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;;;;;;;;AI9RA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APigBA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AGpPA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APqgBA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;AGjcA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;AADA;AAAA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIpMA;AAAA;;;;;AA1JA;;;;;;;;APqsBA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;AGvZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AAAA;;;;;;;;AI9RA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;;;;;;;AJ8RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AAAA;AADA;AAAA;;;;;;;;AI7QA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AItNA;AAAA;;;;;AAxIA;;;;;AJqLA;;;;;;;;;;;AAyGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AADA;AAAA;;;;;;;;AI7QA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APgtBA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;AMkoCA;;;;ADpeA;AAAA;AAAA;AAAA;AL9pBA;;;;;;;;;AI+jCA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;ADhhDA;AAAA;AACA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;APqtBA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK2TA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANtKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AC5dA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AEKA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AH0iBA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKiTA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN5JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AGheA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AADA;AAAA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;AHgjBA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACpdA;AACA;AAAA;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;;;;;;;AG53BA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;AAAA;AADA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;AP8nCA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AG/3BA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAFA;AADA;AAAA;;;;;;;;AI9OA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;AJqLA;;;;;;;;;;;;;AAyHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AAAA;;;;;;;;AI9RA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AItNA;AAAA;;;;;AAxIA;;;;;;;;APsoCA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AKtHA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;AN2QA;AAAA;;;;;;;;;AMjYA;;AJzhBA;;;AI+oBA;AN2QA;AAAA;;;;;;;;;;;;;;AGz3BA;AAAA;AACA;AAAA;AACA;AAAA;AAFA;AAAA;AAGA;;;;;;;;AIhQA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;;;AJ8SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;AI9RA;;;;;;;;AAIA;AAAA;;;;;;;;AJ0UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AI9VA;;;;;;;;AP2qCA;;;;;;;;;AAA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AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APu+CA;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AGh2CA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APi/CA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKjfA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANsoBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AG13CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APqgDA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKrfA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN0oBA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKzfA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN8oBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AGl4CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;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Nm2BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAUA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AKxtBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;AN62BA;AAAA;;;;;;;;;AMn+BA;;AJzhBA;;;AI+oBA;AN62BA;AAAA;;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AK1tBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+2BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AK5tBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANi3BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AK9tBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANm3BA;AAAA;AAAA;;;;;;;;;;;;;;AGvmDA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APgvDA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AKhuBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANq3BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKluBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANu3BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKpuBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANy3BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKtuBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN23BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKxuBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN63BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AK1uBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;;;;;;;;;;;;;ADqJA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;AN+3BA;AAAA;AAAA;;;;;;;;;AMr/BA;;AJzhBA;;;AI+oBA;AN+3BA;AAAA;AAAA;;;;;;;;;;;;;;;AGnnDA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP4vDA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AK5uBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;;;;;;;;;;;;;ADqJA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANi4BA;AAAA;AAAA;;;;;;;;;AMv/BA;;AJzhBA;;;AI+oBA;ANi4BA;AAAA;AAAA;;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AK9uBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANm4BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKhvBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANq4BA;AAAA;AAAA;;;;;;;;AAMA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AKtvBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN24BA;AAAA;AAAA;;;;;;;;;;;;;;AG5oDA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP0wDA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AK1vBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;AN+4BA;AAAA;;;;;;;;;AMrgCA;;AJzhBA;;;AI+oBA;AN+4BA;AAAA;;;;;;;;;;;;;AGhpDA;AACA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP4wDA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AK5vBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANi5BA;AAAA;AAAA;;;;;;;;;;;;;AGlpDA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP8wDA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AK9vBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANm5BA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AGzoDA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APoxDA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG1p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;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+gCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGhxDA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;AJqLA;;;;;;;;AH0tDA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AK/3BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANohCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK/3BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANohCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK/3BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANohCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK/3BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANohCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAA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BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;;;;;;;;;;;ADqJA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANyjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AKp6BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;;;;;;;;AAu9BA;;;;ADpeA;AAAA;AAAA;AAAA;ALskBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AM/qCA;;AJzhBA;;;AI+oBA;;;;;;;;AAu9BA;;;;ADpeA;AAAA;AAAA;AAAA;ALskBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AGz0DA;AAAA;AAAA;;;;;;;;AHy0DA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG1zDA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APq8DA;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKr7BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN0kCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AG30DA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APy8DA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKz7BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN8kCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AG/0DA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP68DA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK77BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANklCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKj8BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANslCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKr8BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN0lCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AG31DA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APy9DA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKz8BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN8lCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AK78BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANkmCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKj9BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANsmCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKr9BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN0mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA/8DA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAgBA;AAAA;;;;;;;;;AAfA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AAEA;;;;;;;;;;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;AA3DA;AAAA;AAAA;;;;;;;;;;;;ACgJA;;AC46DA;AD56DA;AAEA;AACA;AAFA;AAAA;AAGA;;;;;;;;;;;;;;AA1GA;AACA;;ACihEA;;;ADzhEA;AAAA;;ACyhEA;ADzhEA;AAAA;AACA;AAAA;AAQA;;;;;AMpIA;AAAA;;;;;;;;;;;ANuIA;;;;;;;;;;AAxCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AMmEA;AAAA;AAAA;;;;;AAxMA;;;;;;;;;;;;;;;;;;;;;;;;AJ4QA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;AJqLA;;;;;;;;AHqzDA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AK19BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK19BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK19BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK19BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA/rBA;AAAA;AAAA;;;ASl2BA;;AHkbA;ANgbA;;;ASz4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ATy4BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;ASl2BA;;AHkbA;ANgbA;;;ASz4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ATy4BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;ASl2BA;;AHkbA;ANgbA;;;ASz4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ATy4BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;ASl2BA;;AHkbA;ANgbA;;;ASz4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ATy4BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjrCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP8/DA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK9+BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANmoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AGp4DA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APkgEA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKl/BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANuoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKt/BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN2oCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK1/BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+oCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AK9/BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANmpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AGp5DA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APkhEA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKlgCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANupCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AGx5DA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APshEA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKtgCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN2pCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK1gCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+pCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK9gCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANmqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AKnhCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANwqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AKnhCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANwqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AKnhCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANwqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AKnhCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANwqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAnvBA;AAAA;AAAA;;;ASv2BA;;AHkbA;ANqbA;;;AS94BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AT84BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;ASv2BA;;AHkbA;ANqbA;;;AS94BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AT84BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;ASv2BA;;AHkbA;ANqbA;;;AS94BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AT84BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;ASv2BA;;AHkbA;ANqbA;;;AS94BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AT84BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGtrCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APqjEA;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKriCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN0rCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKziCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN8rCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AK7iCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANksCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK7iCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANksCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK7iCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANksCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AK7iCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANksCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ASpnDA;;AHkbA;ANxyBA;;;;;;;;;;;ASsXA;;AHkbA;ANxyBA;;;;;;;;;;;ASsXA;;AHkbA;ANxyBA;;;;;;;;;;;ASsXA;;AHkbA;ANxyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGuCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APklEA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKlkCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANutCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKtkCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN2tCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AK1kCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+tCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK9kCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANmuCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA5iEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAbA;AACA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AAEA;;;;;;;;;;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;AGyDA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APkmEA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKllCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANuuCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAYA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AK9lCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANmvCA;AAAA;;;;;;;;;AMz2CA;;AJzhBA;;;AI+oBA;ANmvCA;AAAA;;;;;;;;;;AAGA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AKjmCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;;;;;;;;;;;;;ADqJA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANsvCA;AAAA;AAAA;;;;;;;;;AM52CA;;AJzhBA;;;AI+oBA;ANsvCA;AAAA;AAAA;;;;;;;;;;;;;;;;AGv/DA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APonEA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;AKpmCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANyvCA;AAAA;AAAA;;;;;;;;;;;;;AG1/DA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP4nEA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AK5mCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANiwCA;AAAA;AAAA;;;;;;;;AAGA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK/mCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANowCA;;;;;;;;;;;;;AK/mCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANowCA;AAAA;AAAA;;;;;;;;;AM13CA;;AJzhBA;;;AI+oBA;ANowCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AGrgEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APkoEA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AKlnCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANuwCA;AAAA;AAAA;;;;;;;;;;;;;;;AGxgEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APuoEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AKvnCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;AN4wCA;AAAA;;;;;;;;;AMl4CA;;AJzhBA;;;AI+oBA;AN4wCA;AAAA;;;;;;;;;AAGA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAaA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AKvoCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN4xCA;AAAA;AAAA;;;;;;;;AAGA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AK1oCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN+xCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAOA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKjpCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANsyCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AGviEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APoqEA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;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A;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANs1CA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AGvlEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP4tEA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AK5sCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANi2CA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AGrlEA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP+tEA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AK/sCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANo2CA;AAAA;AAAA;;;;;;;;;;;;;AGxlEA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APkuEA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AKltCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANu2CA;AAAA;AAAA;;;;;;;;;;;;;AG3lEA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APquEA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKrtCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN02CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AG9lEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIvHA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;AJqLA;;;;;;;;AHujEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AK5tCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANi3CA;AAAA;AAAA;;;;;;;;AAkBA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AK9uCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANm4CA;AAAA;AAAA;AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKrvCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN04CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AG3oEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APwwEA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKxvCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;AN64CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AG9oEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP8wEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AK9vCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANm5CA;AAAA;;;;;;;;;AMzgDA;;AJzhBA;;;AI+oBA;ANm5CA;AAAA;;;;;;;;;AAEA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AGtpEA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APkxEA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AKlwCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANu5CA;AAAA;;;;;;;;;AM7gDA;;AJzhBA;;;AI+oBA;ANu5CA;AAAA;;;;;;;;;;AAEA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AKpwCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANy5CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AGhqEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP4xEA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AKhxCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANq6CA;AAAA;;;;;;;;;AM3hDA;;AJzhBA;;;AI+oBA;ANq6CA;AAAA;;;;;;;;;;AAQA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAUA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKlyCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANu7CA;AAAA;AAAA;;;;;;;;;;AGxrEA;AACA;AAAA;AADA;AADA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP2zEA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AK3yCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;ACvOA;ANg8CA;AAAA;AAAA;;;;;;;;;AMtjDA;;AJzhBA;;;AI+oBA;ANg8CA;AAAA;AAAA;;;;;;;;;;;;;;;;ACvkEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AE3HA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APo0EA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKpzCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AC7VA;;AJzhBA;;;;AI+oBA;ANy8CA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ACrlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA+DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AE3HA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;APi1EA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;AAMA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AGhtEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;A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;AApBA;;;;;AJqLA;;;;;;;;AH0wEA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AGr0EA;AACA;AAAA;AADA;AAAA;AADA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;;;;;;AJ0HA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;;;;;;;;AJ0HA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AADA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;AJqLA;;;;;;;;;;;;AA3DA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP29EA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AGj2EA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAAA;;;;;;;;AIzGA;;;;;;;;AAIA;AAAA;;;;;AApBA;;;;;;;;AP+9EA;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAn+EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AADA;AAAA;AAAA;AACA;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAk+EA;;;;;;;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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;;;;;;;;;Ac9xDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;ACp4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AALA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;AA9NA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADolEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;ACt3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;ACmXA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADx9BA;AAAA;AAAA;AAAA;;;;;;;;;AC2lCA;AAAA;;;;;;;;;AAnIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAuVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA/SA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AF08BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;AEp/BA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAkIA;AAAA;;;;;;;;;AAlIA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AD9bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AC8bA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAiBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AFomCA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AACA;;;;;;;;;;;;AErmCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAUA;;AARA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;AArCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADxnCA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;ADimEA;AAAA;AAAA;AAAA;;AAAA;;;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AEn7BA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;AAnDA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AD10BA;AAAA;AAAA;;;;;;;;;ACm0BA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AFy/BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;AAaA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;AAnBA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;;;;;AACA;AAAA;;;;;;;;;;;;ACh7MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ADo6MA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;AADA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;ACl6MA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;ADm5EA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;AAGA;AAAA;AAAA;;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;;;;AAgzCA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;AAn7CA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAMA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAIA;AAAA;AAAA;;;;;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAyHA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAEA;AAAA;AACA;AAAA;;;;;AALA;AAAA;;;AAMA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAQA;AAAA;AAAA;;AAPA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AAAA;AAAA;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;ACr+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;ADkjFA;AAAA;AACA;AAAA;;AAAA;AAAA;AAQA;AAAA;AAAA;;AAPA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAIA;AAAA;AAAA;;AAHA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;AAlBA;AAAA;AACA;AAAA;;AAAA;AAIA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAfA;AAAA;;AACA;AAKA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAGA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;AA5jCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;AADA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;;;;;;;;AAqkGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAo5DA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAJA;AAAA;;;;;;;;;;;;;AEvzMA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;AFy1CA;AAAA;;AACA;AASA;AAAA;;AAPA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAmBA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;AAOA;AAAA;;;;;;;;AAQA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAMA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;AEh4CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD7mBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;ACugBA;;;;;;;;;;AF00DA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;AC1uFA;AAAA;;;;;;;;;;;;AD6+PA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;;AADA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AADA;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;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A;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;ACt+KA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;ADi4FA;AAAA;AAMA;AAGA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;AAPA;AAAA;AAAA;;AASA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAsnBA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;;;;;AAFA;;AAGA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;;;;;AApBA;AAAA;AAAA;;AAwBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAEA;;AAFA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAEA;;;;;;;AAsjFA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAFA;AAAA;AAAA;;;AAGA;AAAA;AAEA;AAAA;;;AADA;AACA;AAAA;;;;;;;;;;;;;;AAvyBA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;AACA;AAAA;;;;;AAEA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;;;AADA;AAAA;;;;AAGA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;;;;AExnIA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFqsDA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAQA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;;AACA;AAAA;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAGA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AASA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAKA;;AAjBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAKA;;AAhBA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAKA;;;;;;;;;;;;AEt3DA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAHA;AAAA;AAAA;;;;;;;;;AF0hOA;AACA;AAAA;AAAA;AACA;AAAA;;AAIA;;AAFA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;ACtwOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;ADslIA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgzDA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;;AAGA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAGA;AAAA;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAGA;;;AAKA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;AAAA;;;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AADA;AAAA;;;;AAKA;AACA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA34IA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA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YA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AACA;;;;;;;;;;;AAzoBA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjwCA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AAIA;AAAA;;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAGA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;AAKA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;;;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;;AAGA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;;;AAYA;AAAA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AAGA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AAGA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAFA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAn6BA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AACA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;AE30FA;AAAA;AAAA;;;;;;;;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AFywFA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AE5uFA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AFg/BA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAuuDA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;;;;;;;;;;;;;AEpuFA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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ACA;AAGA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAEA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AA7BA;AAAA;AAAA;;AA+BA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;;AAIA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;;AAgBA;;AAhBA;AAAA;AAAA;AAAA;;AAgBA;;AAbA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAEA;;;;;;;;;;ACv1MA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADmsLA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AC1sLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;ADuoMA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;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;;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAIA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAvBA;AAAA;AAAA;;AA2BA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;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AA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;AFo4HA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AE13HA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AApCA;AAAA;AAAA;;;;;;;;;AAaA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AFs5HA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;AACA;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;AAIA;AACA;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAKA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA+GA;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;AAAA;;;;AAEA;AAAA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AAKA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAWA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;AAWA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAUA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAUA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAJA;AAAA;;;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAWA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AATA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AASA;;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AAPA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAGA;;AAFA;AAEA;;;;;;;;;AA4BA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AEttJA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AF0tJA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA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AA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADw2QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA;;AApCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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A;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;AAGA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAQA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AACA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;AACA;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;;;;;AAGA;AAAA;;AACA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;;;;AACA;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;A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;AG4hBA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAoFA;;AApFA;AAAA;;AAoFA;;AAhFA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAAA;;;;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;;;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;;;AAAA;AAAA;;;AAAA;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AACA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;;AAEA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AH9lBA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;AAUA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AGimBA;AAAA;AACA;AAAA;AAAA;AAAA;;AAmBA;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;;AAYA;;AATA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;AHnpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG2pBA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AA8BA;AAAA;AAAA;;AA5BA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;AACA;AAAA;AAcA;AAAA;AAAA;;AAXA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AA8CA;AAAA;AAAA;;AA5CA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;AAyBA;AAAA;AAAA;;AAtBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;AH9sBA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AGitBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AACA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AACA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;AA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A;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AACA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;;AAKA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AANA;AAAA;AAAA;AACA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;;AACA;AAAA;AAoDA;AAAA;AAAA;;AAlDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AACA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;;AA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA1BA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAA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A;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;AADA;AAAA;;;;AAKA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;AA6CA;AAAA;AAAA;AAAA;;;;AAGA;;;;;;;AA9CA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;;AAIA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;;AACA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAQA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAKA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;AArBA;AAAA;AACA;AAAA;AAAA;;AAsBA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;;;;AASA;AAAA;AAAA;AAAA;;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAEA;AAAA;;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;;;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AACA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;AAAA;AAAA;;;;AAEA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;;;AAEA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;;;;AAEA;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AANA;AAAA;;;AASA;AAAA;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;AAEA;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAEA;;AAEA;AAAA;;;AAEA;AAAA;;;AAAA;AAAA;;;;AAKA;AAAA;;;AAAA;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AAAA;;;AAAA;AAAA;;;;AAmBA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAxCA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAxBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAuDA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;;;AAGA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;AAMA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;AAAA;;;AAAA;;;;;AAEA;AACA;;;;;;;AAEA;AAAA;AAAA;;;AAAA;;;;AAEA;AACA;;;;AAEA;AAAA;AAAA;;;AAAA;;;;AAEA;AACA;;;;AAEA;AAAA;AAAA;;;;AACA;;;AAEA;AAAA;;;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAMA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAKA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAAA;AAAA;;;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;AAKA;AAEA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;AAgJA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AApJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AALA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;AAUA;AAAA;AAAA;;AARA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAQA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;A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A;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7JA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;;AAQA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;;AAGA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAPA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AASA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;;;;;AAMA;AAAA;;AAGA;AAAA;;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7JA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;;AAGA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAPA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AASA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;;;;;AAMA;AAAA;;AAGA;AAAA;;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7JA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;;AAGA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAPA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AASA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;;;;;AAMA;AAAA;;AAGA;AAAA;;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7JA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;;;;AAAA;AAAA;;;;AAQA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAPA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AASA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;;;;;AAMA;AAAA;;AAGA;AAAA;;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7JA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;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AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGw0DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAoBA;AAAA;;AAlBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAdA;AAAA;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH/1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA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A;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AAMA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAXA;AAAA;AAAA;;AAaA;AACA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;;AAEA;AACA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;AACA;;AACA;;;;AAGA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AAAA;;AAEA;AAAA;;;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6eA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AA0CA;;;AA1CA;;AA0CA;;AAxCA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAEA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;;;AAAA;AAAA;;;;;;AACA;;AACA;AAAA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/JA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAqEA;AAAA;AAAA;;AAnEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;;AACA;AAAA;AAyDA;AAAA;AAAA;;AAtDA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;AACA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3XA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;;AACA;;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAKA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGA;AACA;;AAIA;AAAA;;;;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAgBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AAAA;AAAA;AAAA;AAAA;AAEA;;AA3BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AATA;AAAA;AAAA;AAAA;AAAA;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsBA;;;;;;;;;;;;AA1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAocA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAEA;AAAA;;;AAAA;;;;;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;AAreA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAHA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;AA4bA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;;;;;;;;;;;;;AAsIA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;AA2DA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAKA;AAAA;AAAA;;AAHA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AA0IA;AAAA;AAAA;;AAxIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AA6FA;AAAA;AAAA;;AArFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AACA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AACA;;;;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;;AAGA;AAAA;;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA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A;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAyFA;;AAvFA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAA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AA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAKA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;;;AAMA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAEA;AACA;AAAA;;;;;AAEA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AACA;;;;AALA;;;AASA;AAAA;;AACA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAkBA;AAAA;AAAA;;;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;AH1oKA;AAAA;;;;;;;AGipKA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAoCA;AAAA;AAAA;;AAlCA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AAMA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEp8KA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;;;;;;;;AL1JA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;AK6JA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;;;;;;;;;;AJoiCA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;AADA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAUA;;AARA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAfA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAUA;;AARA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAfA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAUA;;AARA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAfA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAUA;;AARA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AI9iCA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;AAAA;AACA;;;;;;;;;AJkgCA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;AA+KA;;AA5KA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AA2IA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAnBA;AAAA;AAAA;;AAsBA;;AAlKA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;AAQA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;AAmDA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AA9BA;AAAA;AAAA;;AAkCA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;;AAlGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAzBA;AAAA;AAAA;;AA6BA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;;;AAoEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BA;;;;;;;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AA;AAAA;AACA;AAAA;;;;;AAIA;AAAA;;;AAEA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;;;;;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAzXA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AAGA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;;;AAGA;AAAA;;AAEA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AA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;;;;;;;;;;;AAbA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AK6gCA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAVA;AAAA;AAAA;;AAYA;AAAA;;;;;;;;;;;;AJgKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AI3JA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AASA;;;;;;;;;;;;;;;;;;;;;;;;AASA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;AASA;;;;;;;;AL1jCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAhBA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AKmmCA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAuDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;AJjBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AIoBA;AAAA;;AAAA;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AA8CA;AACA;AACA;AACA;;;;;;;;;;;;;AA7CA;AAAA;;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAJA;AAAA;AAAA;;AAQA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAJA;AAAA;AAAA;;AAMA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;AAIA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AAIA;AAAA;;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AACA;;;;;;;;AJNA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AIq0BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;AJh5BA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAUA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAHA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAGA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AIkEA;AAAA;AAAA;;AAEA;AAAA;;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AADA;AAAA;AACA;;;;;;;;;AJnFA;AAAA;AAAA;;;;;;;;;;;;;;AI4JA;AAAA;;AAAA;AAAA;;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AAyHA;AAAA;;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAdA;AAAA;AAAA;;AAkBA;AACA;AAAA;AACA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAA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AAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AARA;AAUA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAgdA;AAAA;AAAA;AAAA;AAAA;;AACA;AAKA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAEA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+rDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD5wDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AArXA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AATA;AAAA;AAAA;;;AAMA;AAAA;;AAOA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;AAnDA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAeA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAjBA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AJ9lBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AIiQA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;;;;;;;;;;AJwSA;AAAA;AAAA;AAAA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;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;;;AAQA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;AAAA;AApDA;AAAA;AAAA;;;AA+CA;AAAA;;;AAOA;;;;;;;;;;;;;AA3pDA;AAAA;AAAA;AAA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;;;;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAQA;;AAAA;AAAA;AAAA;;;;AAeA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAhDA;AAAA;AAAA;;;;AAqDA;AAAA;AAAA;;;AArJA;AAAA;;;AAmBA;AAAA;;;AA4BA;AAAA;;;AAqCA;AAAA;;;AAmEA;;;;;;;;;;;AAzaA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiOA;AAAA;AAAA;;AAiCA;;AAhCA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AA8BA;;AA7BA;AAAA;AAAA;AAAA;AAAA;;AA6BA;;AA5BA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;;AANA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;;AAHA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;AAnSA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAcA;AAAA;;AAZA;AAAA;AAAA;;;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAHA;AAQA;AAAA;;;AAHA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AA2iBA;AAAA;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AADA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AADA;AAAA;AAAA;;AAIA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAGA;;;;;;;;;;;;;AA3EA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAXA;AAAA;AAAA;;AAaA;;;;;;;;;;;;;;AAsIA;AAAA;;AAGA;;AAFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AASA;AAAA;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAyBA;;AAtBA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;AA7zDA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAAA;AAQA;AAAA;;AANA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AACA;AAAA;;;;;;;;ANt3CA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AMkgEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAlrBA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAYA;AAAA;;AAXA;AAAA;AAAA;AAAA;;AAAA;AAWA;AAAA;;AATA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AA7TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqsBA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;AAQA;AAAA;;;;;;;;;AAGA;AAAA;;;;;;;;;;AAaA;AAAA;;;;;;;;;AAGA;AAAA;;;;;;;;;;AAaA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;AAKA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;;;;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AALA;AAAA;AAAA;;;;;AAUA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;AAeA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAUA;AAAA;AAAA;AACA;;;AAIA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;AAnHA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AACA;AAAA;AACA;;;;;;AA7EA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;AAUA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;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AAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAeA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAeA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAQA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AAEA;A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AAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AACA;;;;;;;;;;AL7qFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AK8mFA;AAAA;;;AAAA;;AACA;AAAA;;AAAA;;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;;;;;;;;AL5nFA;AAAA;AAAA;;;;;;;AQnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;AAOA;AAAA;;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;AAcA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AACA;AAA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;;AAAA;AAAA;;AAAA;;;AAEA;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAKA;AACA;AACA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;AAAA;;;AAEA;;AAEA;AAAA;;AAAA;;AAEA;AACA;;;AAEA;;AAAA;;AAEA;AAAA;AACA;AACA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AACA;AAAA;;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvnCA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AACA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAEA;;AACA;AAAA;;AACA;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAGA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;;AAIA;AAAA;;AAEA;AAAA;;AACA;;AAEA;;AACA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAOA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;;AAAA;AAAA;;AAAA;;;AACA;AAGA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAhBA;AAAA;AAAA;;AAkBA;AACA;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAgFA;AACA;;AA/EA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAGA;;AAAA;AAAA;;;;AAEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAAA;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAhBA;AAAA;AAAA;;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AA/BA;AAAA;AAAA;;AAkCA;;AAEA;;AAEA;AA7DA;AAAA;AAAA;;AAgEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxXA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAqGA;AACA;;AApGA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AA+CA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;;AACA;AAEA;AACA;;;;;;;;;;;;;AA0SA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AAAA;AACA;;AA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AA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAUA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;;AAEA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;AAOA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAIA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;;AAKA;AAEA;AAAA;;;AAAA;AAAA;;;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AACA;;AAEA;;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAjBA;AAAA;AAAA;;AAmBA;AACA;;AAGA;AACA;AAAA;AAAA;AAAA;AAEA;AAKA;AAAA;;;AAAA;AAAA;;;;AAAA;;;AAGA;AACA;AACA;AACA;AAAA;;;AAEA;AACA;AACA;AAAA;;;;AAEA;AACA;AAAA;AAAA;;;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;;AACA;;AAEA;;AAGA;;AAIA;AACA;AACA;;AAGA;;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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A;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAGA;;AAEA;AAGA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AALA;AAAA;AAAA;;AAQA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;;AACA;AARA;AAAA;AAAA;;AAWA;;AAGA;;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;AACA;;AAGA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAAA;AACA;AAAA;AACA;;AAGA;;AAGA;;AAEA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;AAGA;;AAEA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;;AACA;AACA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;AAAA;;AATA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAvBA;AAAA;AAAA;;AAyBA;;AAGA;;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;AACA;;AACA;AACA;AAAA;AACA;;AACA;;AAEA;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAC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A;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;;;;AjBjDA;AAAA;;;;;;;;AiBjDA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;AjB0CA;AAAA;;;;;AAAA;AAAA;;;;;;;;AiBTA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AAAA;AACA;;;;;AjBQA;AAAA;;;;;AiBvBA;;;;;AjBbA;;;;;AiBaA;;;;;AAAA;;;;;AjBuBA;AAAA;;;;;AiBvBA;;;;;AjBbA;;;;;AAoCA;AAAA;;;;;AiBvBA;;;;;AjBbA;;;;;AiBaA;;;;;AAAA;;;;;AAAA;;;;;AjBuBA;AAAA;;;;;AiBvBA;;;;;AjBbA;;;;;AiBaA;;;;;AjBuBA;AAAA;;;;;AiBvBA;;;;;AjBbA;;;;;AiBaA;;;;;AjBbA;;;;;AAAA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAoCA;AAAA;;;;;AApCA;;;;;AAAA;;;;;;;;AiB3BA;;;AC2IA;AAAA;AD3IA;AAAA","file":"imgui_out.js","sourcesContent":["#include \"imgui.h\"\r\n\r\n#ifndef __FLT_MAX__\r\n#define __FLT_MAX__ 3.40282346638528859812e+38F\r\n#endif\r\n\r\n#if defined(IMGUI_DISABLE_DEMO_WINDOWS)\r\n// warning: unresolved symbol: _ZN5ImGui17ShowStyleSelectorEPKc\r\nbool ImGui::ShowStyleSelector(const char*) { return false; }\r\n// warning: unresolved symbol: _ZN5ImGui16ShowFontSelectorEPKc\r\nvoid ImGui::ShowFontSelector(const char*) {}\r\n#endif\r\n\r\n#include <emscripten/bind.h>\r\n\r\n#define FUNCTION(RET, ARGS, CODE...) \\\r\n    emscripten::optional_override([] ARGS -> RET { CODE })\r\n\r\n#define CLASS_MEMBER(CLASS, MEMBER) \\\r\n    .property(#MEMBER, &CLASS::MEMBER)\r\n\r\n#define CLASS_MEMBER_GET(CLASS, MEMBER, GET) \\\r\n    .property(#MEMBER, FUNCTION(emscripten::val, (const CLASS& that), GET))\r\n\r\n#define CLASS_MEMBER_SET(CLASS, MEMBER, SET) \\\r\n    .property(#MEMBER, NULL, FUNCTION(void, (CLASS& that, emscripten::val value), SET))\r\n\r\n#define CLASS_MEMBER_GET_SET(CLASS, MEMBER, GET, SET) \\\r\n    .property(#MEMBER, \\\r\n        FUNCTION(emscripten::val, (const CLASS& that), GET), \\\r\n        FUNCTION(void, (CLASS& that, emscripten::val value), SET))\r\n\r\n#define CLASS_MEMBER_GET_RAW_POINTER(CLASS, MEMBER) \\\r\n    .property(#MEMBER, FUNCTION(emscripten::val, (const CLASS& that), { \\\r\n        auto p = that.MEMBER; return p == NULL ? emscripten::val::null() : emscripten::val(p); \\\r\n    }))\r\n\r\n#define CLASS_MEMBER_GET_SET_RAW_POINTER(CLASS, MEMBER) \\\r\n    .property(#MEMBER, FUNCTION(emscripten::val, (const CLASS& that), { \\\r\n        auto p = that.MEMBER; return p == NULL ? emscripten::val::null() : emscripten::val(p); \\\r\n    }), FUNCTION(void, (CLASS& that, emscripten::val value), { \\\r\n        that.MEMBER = value.isNull() ? NULL : value.as<decltype(that.MEMBER)>(emscripten::allow_raw_pointers()); \\\r\n    }))\r\n\r\n#define CLASS_MEMBER_GET_RAW_REFERENCE(CLASS, MEMBER) \\\r\n    .property(#MEMBER, FUNCTION(emscripten::val, (const CLASS& that), { \\\r\n        auto p = &that.MEMBER; return emscripten::val(p); \\\r\n    }))\r\n\r\n#define CLASS_METHOD(CLASS, METHOD) \\\r\n    .function(#METHOD, &CLASS::METHOD)\r\n\r\n#include <malloc.h>\r\n\r\nemscripten::val get_mallinfo() {\r\n    const auto& i = mallinfo();\r\n    emscripten::val rv(emscripten::val::object());\r\n    rv.set(\"arena\", emscripten::val(i.arena));\r\n    rv.set(\"ordblks\", emscripten::val(i.ordblks));\r\n    rv.set(\"smblks\", emscripten::val(i.smblks));\r\n    rv.set(\"hblks\", emscripten::val(i.hblks));\r\n    rv.set(\"hblkhd\", emscripten::val(i.hblkhd));\r\n    rv.set(\"usmblks\", emscripten::val(i.usmblks));\r\n    rv.set(\"fsmblks\", emscripten::val(i.fsmblks));\r\n    rv.set(\"uordblks\", emscripten::val(i.uordblks));\r\n    rv.set(\"fordblks\", emscripten::val(i.fordblks));\r\n    rv.set(\"keepcost\", emscripten::val(i.keepcost));\r\n    return rv;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(mallinfo) {\r\n    emscripten::function(\"mallinfo\", &get_mallinfo);\r\n}\r\n\r\n#define TODO() printf(\"TODO: %s\\n\", __PRETTY_FUNCTION__)\r\n\r\nclass WrapImGuiContext {\r\nprivate:\r\n    static WrapImGuiContext* _current_wrap;\r\npublic:\r\n    static WrapImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL) {\r\n        return new WrapImGuiContext(shared_font_atlas);\r\n    }\r\n    static void DestroyContext(WrapImGuiContext* wrap) {\r\n        delete wrap;\r\n    }\r\n    static void SetCurrentContext(WrapImGuiContext* wrap) {\r\n        _current_wrap = wrap;\r\n        ImGui::SetCurrentContext(wrap == NULL ? NULL : wrap->ctx);\r\n    }\r\n    static WrapImGuiContext* GetCurrentContext() {\r\n        return _current_wrap;\r\n    }\r\nprivate:\r\n    static const char* _GetClipboardText(void* user_data) {\r\n        WrapImGuiContext* wrap_ctx = WrapImGuiContext::GetCurrentContext();\r\n        if (!wrap_ctx->_ImGuiIO_GetClipboardTextFn.isNull()) {\r\n            wrap_ctx->_ImGuiIO_ClipboardText = wrap_ctx->_ImGuiIO_GetClipboardTextFn(wrap_ctx->_ImGuiIO_ClipboardUserData).as<std::string>();\r\n        }\r\n        return wrap_ctx->_ImGuiIO_ClipboardText.c_str();\r\n    }\r\n    static void _SetClipboardText(void* user_data, const char* text) {\r\n        WrapImGuiContext* wrap_ctx = WrapImGuiContext::GetCurrentContext();\r\n        wrap_ctx->_ImGuiIO_ClipboardText = text;\r\n        if (!wrap_ctx->_ImGuiIO_SetClipboardTextFn.isNull()) {\r\n            wrap_ctx->_ImGuiIO_SetClipboardTextFn(wrap_ctx->_ImGuiIO_ClipboardUserData, wrap_ctx->_ImGuiIO_ClipboardText);\r\n        }\r\n    }\r\nprivate:\r\n    ImGuiContext* ctx;\r\npublic:\r\n    std::string _ImGuiIO_IniFilename = \"\";\r\n    std::string _ImGuiIO_LogFilename = \"\";\r\n    emscripten::val _ImGuiIO_UserData = emscripten::val::null();\r\n    std::string _ImGuiIO_ClipboardText = \"\";\r\n    emscripten::val _ImGuiIO_GetClipboardTextFn = emscripten::val::null();\r\n    emscripten::val _ImGuiIO_SetClipboardTextFn = emscripten::val::null();\r\n    emscripten::val _ImGuiIO_ClipboardUserData = emscripten::val::null();\r\n\r\n    emscripten::val _ImGui_SetNextWindowSizeConstraints_custom_callback = emscripten::val::undefined();\r\n\r\n    emscripten::val _ImGui_PlotLines_values_getter = emscripten::val::undefined();\r\n    emscripten::val _ImGui_PlotLines_data = emscripten::val::undefined();\r\n\r\n    emscripten::val _ImGui_PlotHistogram_values_getter = emscripten::val::undefined();\r\n    emscripten::val _ImGui_PlotHistogram_data = emscripten::val::undefined();\r\n\r\n    emscripten::val _ImGui_Combo_items_getter = emscripten::val::undefined();\r\n    emscripten::val _ImGui_Combo_data = emscripten::val::undefined();\r\n    int _ImGui_Combo_items_count = 0;\r\n    std::string _ImGui_Combo_text = \"\";\r\n\r\n    emscripten::val _ImGui_InputText_callback = emscripten::val::undefined();\r\n\r\n    emscripten::val _ImGui_InputTextMultiline_callback = emscripten::val::undefined();\r\n\r\n    emscripten::val _ImGui_ListBox_A_items = emscripten::val::undefined();\r\n    int _ImGui_ListBox_A_items_count = 0;\r\n    std::string _ImGui_ListBox_A_text = \"\";\r\n\r\n    emscripten::val _ImGui_ListBox_B_items_getter = emscripten::val::undefined();\r\n    emscripten::val _ImGui_ListBox_B_data = emscripten::val::undefined();\r\n    int _ImGui_ListBox_B_items_count = 0;\r\n    std::string _ImGui_ListBox_B_text = \"\";\r\n\r\n    emscripten::val _ImGui_DragDropPayload_data = emscripten::val::object();\r\n\r\n    emscripten::val _ImGui_SetAllocatorFunctions_alloc_func = emscripten::val::undefined();\r\n    emscripten::val _ImGui_SetAllocatorFunctions_free_func = emscripten::val::undefined();\r\n    emscripten::val _ImGui_SetAllocatorFunctions_user_data = emscripten::val::undefined();\r\n\r\npublic:\r\n    WrapImGuiContext(ImFontAtlas* shared_font_atlas = NULL): ctx(ImGui::CreateContext()) {\r\n        ImGuiContext* prev_ctx = ImGui::GetCurrentContext();\r\n        ImGui::SetCurrentContext(ctx);\r\n        ImGuiIO& io = ImGui::GetIO();\r\n        io.IniFilename = NULL;\r\n        io.LogFilename = NULL;\r\n        io.GetClipboardTextFn = WrapImGuiContext::_GetClipboardText;\r\n        io.SetClipboardTextFn = WrapImGuiContext::_SetClipboardText;\r\n        io.ClipboardUserData = NULL;\r\n        ImGui::SetCurrentContext(prev_ctx);\r\n    }\r\n    ~WrapImGuiContext() {\r\n        ImGuiContext* prev_ctx = ImGui::GetCurrentContext();\r\n        ImGui::SetCurrentContext(ctx);\r\n        ImGuiIO& io = ImGui::GetIO();\r\n        io.IniFilename = NULL;\r\n        io.LogFilename = NULL;\r\n        io.GetClipboardTextFn = NULL;\r\n        io.SetClipboardTextFn = NULL;\r\n        io.ClipboardUserData = NULL;\r\n        ImGui::SetCurrentContext(prev_ctx);\r\n        ImGui::DestroyContext(ctx);\r\n        ctx = NULL;\r\n    }\r\n};\r\n\r\nWrapImGuiContext* WrapImGuiContext::_current_wrap = NULL;\r\n\r\nEMSCRIPTEN_BINDINGS(WrapImGuiContext) {\r\n    emscripten::class_<WrapImGuiContext>(\"WrapImGuiContext\")\r\n    ;\r\n}\r\n\r\ntemplate <typename T>\r\nT import_value(const emscripten::val& value) {\r\n    return value.as<T>();\r\n}\r\n\r\ntemplate <typename T>\r\nemscripten::val export_value(const T& value) {\r\n    return emscripten::val(value);\r\n}\r\n\r\ntemplate <>\r\nfloat import_value(const emscripten::val& value) {\r\n    // return __import_float(value);\r\n    const double _value = value.as<double>();\r\n    if (double(+FLT_MAX) <= _value) return +FLT_MAX;\r\n    if (_value <= double(-FLT_MAX)) return -FLT_MAX;\r\n    return float(_value);\r\n}\r\n\r\ntemplate <typename T>\r\nclass import_maybe_null_value {\r\nprotected:\r\n    T _value;\r\n    const emscripten::val& _import;\r\npublic:\r\n    import_maybe_null_value(const emscripten::val& _import) : _import(_import) {\r\n        if (!_import.isNull()) { _import_value(); }\r\n    }\r\n    virtual void _import_value() {\r\n        _value = import_value<T>(_import);\r\n    }\r\n    operator T*() { return _import.isNull() ? NULL : &_value; }\r\n    operator const T*() const { return _import.isNull() ? NULL : &_value; }\r\n};\r\n\r\nclass import_maybe_null_string : public import_maybe_null_value<std::string> {\r\npublic:\r\n    import_maybe_null_string(const emscripten::val& _import) : import_maybe_null_value(_import) {}\r\n    operator const char*() const { return _import.isNull() ? NULL : _value.c_str(); }\r\n};\r\n\r\nemscripten::val export_maybe_null_string(const char* value) {\r\n    return value == NULL ? emscripten::val::null() : emscripten::val(value);\r\n}\r\n\r\ntemplate <typename T, size_t N = 1>\r\nclass access_value {\r\nprotected:\r\n    T _value[N];\r\n    emscripten::val& _access;\r\npublic:\r\n    access_value(emscripten::val& _access) : _access(_access) {\r\n        _import_value();\r\n    }\r\n    virtual ~access_value() {\r\n        _export_value();\r\n    }\r\n    virtual void _import_value() {\r\n        for (size_t i = 0; i < N; ++i) {\r\n            _value[i] = import_value<T>(_access[i]);\r\n        }\r\n    }\r\n    virtual void _export_value() {\r\n        for (size_t i = 0; i < N; ++i) {\r\n            _access.set(i, export_value<T>(_value[i]));\r\n        }\r\n    }\r\n    operator T&() { return _value[0]; }\r\n    operator const T&() const { return _value[0]; }\r\n    operator T*() { return &_value[0]; }\r\n    operator const T*() const { return &_value[0]; }\r\n};\r\n\r\ntemplate <typename T, size_t N = 1>\r\nclass access_maybe_null_value {\r\nprotected:\r\n    T _value[N];\r\n    emscripten::val& _access;\r\npublic:\r\n    access_maybe_null_value(emscripten::val& _access) : _access(_access) {\r\n        if (!_access.isNull()) { _import_value(); }\r\n    }\r\n    virtual ~access_maybe_null_value() {\r\n        if (!_access.isNull()) { _export_value(); }\r\n    }\r\n    virtual void _import_value() {\r\n        for (size_t i = 0; i < N; ++i) {\r\n            _value[i] = import_value<T>(_access[i]);\r\n        }\r\n    }\r\n    virtual void _export_value() {\r\n        for (size_t i = 0; i < N; ++i) {\r\n            _access.set(i, export_value<T>(_value[i]));\r\n        }\r\n    }\r\n    operator T*() { return _access.isNull() ? NULL : &_value[0]; }\r\n    operator const T*() const { return _access.isNull() ? NULL : &_value[0]; }\r\n};\r\n\r\ntemplate <typename T>\r\nclass access_typed_array {\r\nprotected:\r\n    std::vector<T> _value;\r\n    emscripten::val& _access;\r\npublic:\r\n    access_typed_array(emscripten::val& access): _access(access) {\r\n        _value.resize(_access[\"length\"].template as<size_t>());\r\n        emscripten::val(emscripten::typed_memory_view<T>(_value.size(), _value.data())).call<void>(\"set\", _access);\r\n    }\r\n    ~access_typed_array() {\r\n        _access.call<void>(\"set\", emscripten::typed_memory_view<T>(_value.size(), _value.data()));\r\n    }\r\n    T* data() { return _value.data(); }\r\n    const T* data() const { return _value.data(); }\r\n    size_t size() { return _value.size(); }\r\n    operator std::vector<T>&() { return _value; }\r\n    operator const std::vector<T>&() const { return _value; }\r\n};\r\n\r\nImVec2& import_ImVec2(const emscripten::val& value, ImVec2& out) {\r\n    out.x = import_value<float>(value[\"x\"]);\r\n    out.y = import_value<float>(value[\"y\"]);\r\n    return out;\r\n}\r\n\r\nImVec2 import_ImVec2(const emscripten::val& value) {\r\n    ImVec2 out; import_ImVec2(value, out); return out;\r\n}\r\n\r\nemscripten::val export_ImVec2(const ImVec2& value, emscripten::val out) {\r\n    out.set(\"x\", export_value<float>(value.x));\r\n    out.set(\"y\", export_value<float>(value.y));\r\n    return out;\r\n}\r\n\r\nemscripten::val export_ImVec2(const ImVec2& value) {\r\n    return export_ImVec2(value, emscripten::val::object());\r\n}\r\n\r\ntemplate <>\r\nImVec2 import_value(const emscripten::val& value) {\r\n    return import_ImVec2(value);\r\n}\r\n\r\nemscripten::val ImVec2_Set(emscripten::val that, emscripten::val x, emscripten::val y) {\r\n    that.set(\"x\", x);\r\n    that.set(\"y\", y);\r\n    return that;\r\n}\r\n\r\nemscripten::val ImVec2_Copy(emscripten::val that, emscripten::val other) {\r\n    that.set(\"x\", other[\"x\"]);\r\n    that.set(\"y\", other[\"y\"]);\r\n    return that;\r\n}\r\n\r\nbool ImVec2_Equals(const emscripten::val that, emscripten::val other) {\r\n    if (!that[\"x\"].strictlyEquals(other[\"x\"])) { return false; }\r\n    if (!that[\"y\"].strictlyEquals(other[\"y\"])) { return false; }\r\n    return true;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImVec2) {\r\n    emscripten::class_<ImVec2>(\"ImVec2\")\r\n        // no constructors for EmscriptenClassReference\r\n        // .constructor()\r\n        // .constructor<float, float>()\r\n        CLASS_MEMBER(ImVec2, x)\r\n        CLASS_MEMBER(ImVec2, y)\r\n        .function(\"Set\", &ImVec2_Set)\r\n        .function(\"Copy\", &ImVec2_Copy)\r\n        .function(\"Equals\", &ImVec2_Equals)\r\n    ;\r\n}\r\n\r\nImVec4& import_ImVec4(const emscripten::val& value, ImVec4& out) {\r\n    out.x = import_value<float>(value[\"x\"]);\r\n    out.y = import_value<float>(value[\"y\"]);\r\n    out.z = import_value<float>(value[\"z\"]);\r\n    out.w = import_value<float>(value[\"w\"]);\r\n    return out;\r\n}\r\n\r\nImVec4 import_ImVec4(const emscripten::val& value) {\r\n    ImVec4 out; import_ImVec4(value, out); return out;\r\n}\r\n\r\nemscripten::val export_ImVec4(const ImVec4& value, emscripten::val out) {\r\n    out.set(\"x\", export_value<float>(value.x));\r\n    out.set(\"y\", export_value<float>(value.y));\r\n    out.set(\"z\", export_value<float>(value.z));\r\n    out.set(\"w\", export_value<float>(value.w));\r\n    return out;\r\n}\r\n\r\nemscripten::val export_ImVec4(const ImVec4& value) {\r\n    return export_ImVec4(value, emscripten::val::object());\r\n}\r\n\r\ntemplate <>\r\nImVec4 import_value(const emscripten::val& value) {\r\n    return import_ImVec4(value);\r\n}\r\n\r\nemscripten::val ImVec4_Set(emscripten::val that, const emscripten::val x, const emscripten::val y, const emscripten::val z, const emscripten::val w) {\r\n    that.set(\"x\", x);\r\n    that.set(\"y\", y);\r\n    that.set(\"z\", z);\r\n    that.set(\"w\", w);\r\n    return that;\r\n}\r\n\r\nemscripten::val ImVec4_Copy(emscripten::val that, emscripten::val other) {\r\n    that.set(\"x\", other[\"x\"]);\r\n    that.set(\"y\", other[\"y\"]);\r\n    that.set(\"z\", other[\"z\"]);\r\n    that.set(\"w\", other[\"w\"]);\r\n    return that;\r\n}\r\n\r\nbool ImVec4_Equals(const emscripten::val that, emscripten::val other) {\r\n    if (!that[\"x\"].strictlyEquals(other[\"x\"])) { return false; }\r\n    if (!that[\"y\"].strictlyEquals(other[\"y\"])) { return false; }\r\n    if (!that[\"z\"].strictlyEquals(other[\"z\"])) { return false; }\r\n    if (!that[\"w\"].strictlyEquals(other[\"w\"])) { return false; }\r\n    return true;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImVec4) {\r\n    emscripten::class_<ImVec4>(\"ImVec4\")\r\n        // no constructors for EmscriptenClassReference\r\n        // .constructor()\r\n        // .constructor<float, float, float, float>()\r\n        CLASS_MEMBER(ImVec4, x)\r\n        CLASS_MEMBER(ImVec4, y)\r\n        CLASS_MEMBER(ImVec4, z)\r\n        CLASS_MEMBER(ImVec4, w)\r\n        .function(\"Set\", &ImVec4_Set)\r\n        .function(\"Copy\", &ImVec4_Copy)\r\n        .function(\"Equals\", &ImVec4_Equals)\r\n    ;\r\n}\r\n\r\n// Shared state of InputText(), passed to callback when a ImGuiInputTextFlags_Callback* flag is used and the corresponding callback is triggered.\r\n// struct ImGuiInputTextCallbackData\r\nEMSCRIPTEN_BINDINGS(ImGuiInputTextCallbackData) {\r\n    emscripten::class_<ImGuiInputTextCallbackData>(\"ImGuiInputTextCallbackData\")\r\n        // ImGuiInputTextFlags EventFlag;      // One of ImGuiInputTextFlags_Callback* // Read-only\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, EventFlag)\r\n        // ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, Flags)\r\n        // void*               UserData;       // What user passed to InputText()      // Read-only\r\n        // bool                ReadOnly;       // Read-only mode                       // Read-only\r\n        // CLASS_MEMBER(ImGuiInputTextCallbackData, ReadOnly)\r\n\r\n        // CharFilter event:\r\n        // ImWchar             EventChar;      // Character input                      // Read-write (replace character or set to zero)\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, EventChar)\r\n\r\n        // Completion,History,Always events:\r\n        // If you modify the buffer contents make sure you update 'BufTextLen' and set 'BufDirty' to true.\r\n        // ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, EventKey)\r\n        // char*               Buf;            // Current text buffer                  // Read-write (pointed data only, can't replace the actual pointer)\r\n        CLASS_MEMBER_GET_SET(ImGuiInputTextCallbackData, Buf, \r\n            { return emscripten::val(std::string(that.Buf)); },\r\n            { strncpy(that.Buf, value.as<std::string>().c_str(), that.BufSize - 1); }\r\n        )\r\n        // int                 BufTextLen;     // Current text length in bytes         // Read-write\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, BufTextLen)\r\n        // int                 BufSize;        // Maximum text length in bytes         // Read-only\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, BufSize)\r\n        // bool                BufDirty;       // Set if you modify Buf/BufTextLen!!   // Write\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, BufDirty)\r\n        // int                 CursorPos;      //                                      // Read-write\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, CursorPos)\r\n        // int                 SelectionStart; //                                      // Read-write (== to SelectionEnd when no selection)\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, SelectionStart)\r\n        // int                 SelectionEnd;   //                                      // Read-write\r\n        CLASS_MEMBER(ImGuiInputTextCallbackData, SelectionEnd)\r\n\r\n        // NB: Helper functions for text manipulation. Calling those function loses selection.\r\n        // IMGUI_API void    DeleteChars(int pos, int bytes_count);\r\n        CLASS_METHOD(ImGuiInputTextCallbackData, DeleteChars)\r\n        // IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);\r\n        .function(\"InsertChars\", FUNCTION(void, (ImGuiInputTextCallbackData& that, int pos, std::string text), {\r\n            that.InsertChars(pos, text.c_str(), NULL);\r\n        }))\r\n        // bool              HasSelection() const { return SelectionStart != SelectionEnd; }\r\n        CLASS_METHOD(ImGuiInputTextCallbackData, HasSelection)\r\n    ;\r\n}\r\n\r\n// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\r\n// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.\r\n// struct ImGuiSizeCallbackData\r\n// {\r\n//     void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()\r\n//     ImVec2  Pos;            // Read-only.   Window position, for reference.\r\n//     ImVec2  CurrentSize;    // Read-only.   Current window size.\r\n//     ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.\r\n// };\r\nEMSCRIPTEN_BINDINGS(ImGuiSizeCallbackData) {\r\n    emscripten::class_<ImGuiSizeCallbackData>(\"ImGuiSizeCallbackData\")\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiSizeCallbackData, Pos)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiSizeCallbackData, CurrentSize)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiSizeCallbackData, DesiredSize)\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImGuiListClipper) {\r\n    emscripten::class_<ImGuiListClipper>(\"ImGuiListClipper\")\r\n        .constructor()\r\n        .constructor<int>()\r\n        .constructor<int, float>()\r\n        CLASS_MEMBER(ImGuiListClipper, StartPosY)\r\n        CLASS_MEMBER(ImGuiListClipper, ItemsHeight)\r\n        CLASS_MEMBER(ImGuiListClipper, ItemsCount)\r\n        CLASS_MEMBER(ImGuiListClipper, StepNo)\r\n        CLASS_MEMBER(ImGuiListClipper, DisplayStart)\r\n        CLASS_MEMBER(ImGuiListClipper, DisplayEnd)\r\n        CLASS_METHOD(ImGuiListClipper, Step)\r\n        CLASS_METHOD(ImGuiListClipper, Begin)\r\n        CLASS_METHOD(ImGuiListClipper, End)\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImDrawCmd) {\r\n    emscripten::class_<ImDrawCmd>(\"ImDrawCmd\")\r\n        CLASS_MEMBER(ImDrawCmd, ElemCount)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImDrawCmd, ClipRect)\r\n        CLASS_MEMBER_GET(ImDrawCmd, TextureId, { return emscripten::val((int) that.TextureId); })\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImDrawList) {\r\n    emscripten::class_<ImDrawList>(\"ImDrawList\")\r\n        .function(\"IterateDrawCmds\", FUNCTION(void, (const ImDrawList* that, emscripten::val callback), {\r\n            unsigned int ElemStart = 0;\r\n            for (const ImDrawCmd* pcmd = that->CmdBuffer.begin(); pcmd != that->CmdBuffer.end(); pcmd++) {\r\n                callback(emscripten::val(pcmd), emscripten::val(ElemStart));\r\n                ElemStart += pcmd->ElemCount;\r\n            }\r\n        }), emscripten::allow_raw_pointers())\r\n\r\n        // This is what you have to render\r\n        // ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.\r\n        // ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those\r\n        CLASS_MEMBER_GET(ImDrawList, IdxBuffer, {\r\n            return emscripten::val(emscripten::typed_memory_view((size_t)(that.IdxBuffer.size() * sizeof(ImDrawIdx)), (char *) &that.IdxBuffer.front()));\r\n        })\r\n        CLASS_MEMBER_GET(ImDrawList, VtxBuffer, {\r\n            return emscripten::val(emscripten::typed_memory_view((size_t)(that.VtxBuffer.size() * sizeof(ImDrawVert)), (char *) &that.VtxBuffer.front()));\r\n        })\r\n        // ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.\r\n        CLASS_MEMBER(ImDrawList, Flags)\r\n\r\n        // [Internal, used while building lists]\r\n        // const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)\r\n        // const char*             _OwnerName;         // Pointer to owner window's name for debugging\r\n        // unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size\r\n        // ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n        // ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n        // ImVector<ImVec4>        _ClipRectStack;     // [Internal]\r\n        // ImVector<ImTextureID>   _TextureIdStack;    // [Internal]\r\n        // ImVector<ImVec2>        _Path;              // [Internal] current path building\r\n        // int                     _ChannelsCurrent;   // [Internal] current channel number (0)\r\n        // int                     _ChannelsCount;     // [Internal] number of active channels (1+)\r\n        // ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)\r\n\r\n        // ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }\r\n        // ~ImDrawList() { ClearFreeMemory(); }\r\n        // IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\r\n        .function(\"PushClipRect\", FUNCTION(void, (ImDrawList& that, emscripten::val clip_rect_min, emscripten::val clip_rect_max, bool intersect_with_current_clip_rect), {\r\n            that.PushClipRect(import_ImVec2(clip_rect_min), import_ImVec2(clip_rect_max), intersect_with_current_clip_rect);\r\n        }))\r\n        // IMGUI_API void  PushClipRectFullScreen();\r\n        CLASS_METHOD(ImDrawList, PushClipRectFullScreen)\r\n        // IMGUI_API void  PopClipRect();\r\n        CLASS_METHOD(ImDrawList, PopClipRect)\r\n        // IMGUI_API void  PushTextureID(const ImTextureID& texture_id);\r\n        .function(\"PushTextureID\", FUNCTION(void, (ImDrawList& that, emscripten::val texture_id), {\r\n            that.PushTextureID((ImTextureID) texture_id.as<int>());\r\n        }))\r\n        // IMGUI_API void  PopTextureID();\r\n        CLASS_METHOD(ImDrawList, PopTextureID)\r\n        // inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }\r\n        .function(\"GetClipRectMin\", FUNCTION(emscripten::val, (ImDrawList& that, emscripten::val out), {\r\n            return export_ImVec2(that.GetClipRectMin(), out);\r\n        }))\r\n        // inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }\r\n        .function(\"GetClipRectMax\", FUNCTION(emscripten::val, (ImDrawList& that, emscripten::val out), {\r\n            return export_ImVec2(that.GetClipRectMax(), out);\r\n        }))\r\n\r\n        // Primitives\r\n        // IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);\r\n        .function(\"AddLine\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, ImU32 col, float thickness), {\r\n            that.AddLine(import_ImVec2(a), import_ImVec2(b), col, thickness);\r\n        }))\r\n        // IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round\r\n        .function(\"AddRect\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, ImU32 col, float rounding, int rounding_corners_flags, float thickness), {\r\n            that.AddRect(import_ImVec2(a), import_ImVec2(b), col, rounding, rounding_corners_flags, thickness);\r\n        }))\r\n        // IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right\r\n        .function(\"AddRectFilled\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, ImU32 col, float rounding, int rounding_corners_flags), {\r\n            that.AddRectFilled(import_ImVec2(a), import_ImVec2(b), col, rounding, rounding_corners_flags);\r\n        }))\r\n        // IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);\r\n        .function(\"AddRectFilledMultiColor\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left), {\r\n            that.AddRectFilledMultiColor(import_ImVec2(a), import_ImVec2(b), col_upr_left, col_upr_right, col_bot_right, col_bot_left);\r\n        }))\r\n        // IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);\r\n        .function(\"AddQuad\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, emscripten::val c, emscripten::val d, ImU32 col, float thickness), {\r\n            that.AddQuad(import_ImVec2(a), import_ImVec2(b), import_ImVec2(c), import_ImVec2(d), col, thickness);\r\n        }))\r\n        // IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);\r\n        .function(\"AddQuadFilled\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, emscripten::val c, emscripten::val d, ImU32 col), {\r\n            that.AddQuadFilled(import_ImVec2(a), import_ImVec2(b), import_ImVec2(c), import_ImVec2(d), col);\r\n        }))\r\n        // IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);\r\n        .function(\"AddTriangle\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, emscripten::val c, ImU32 col, float thickness), {\r\n            that.AddTriangle(import_ImVec2(a), import_ImVec2(b), import_ImVec2(c), col, thickness);\r\n        }))\r\n        // IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);\r\n        .function(\"AddTriangleFilled\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, emscripten::val c, ImU32 col), {\r\n            that.AddTriangleFilled(import_ImVec2(a), import_ImVec2(b), import_ImVec2(c), col);\r\n        }))\r\n        // IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);\r\n        .function(\"AddCircle\", FUNCTION(void, (ImDrawList& that, emscripten::val centre, float radius, ImU32 col, int num_segments, float thickness), {\r\n            that.AddCircle(import_ImVec2(centre), radius, col, num_segments, thickness);\r\n        }))\r\n        // IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);\r\n        .function(\"AddCircleFilled\", FUNCTION(void, (ImDrawList& that, emscripten::val centre, float radius, ImU32 col, int num_segments), {\r\n            that.AddCircleFilled(import_ImVec2(centre), radius, col, num_segments);\r\n        }))\r\n        // IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);\r\n        .function(\"AddText_A\", FUNCTION(void, (ImDrawList& that, emscripten::val pos, ImU32 col, std::string text_begin), {\r\n            that.AddText(import_ImVec2(pos), col, text_begin.c_str(), NULL);\r\n        }))\r\n        // IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);\r\n        .function(\"AddText_B\", FUNCTION(void, (ImDrawList& that, emscripten::val font, float font_size, emscripten::val pos, ImU32 col, std::string text_begin, float wrap_width, emscripten::val cpu_fine_clip_rect), {\r\n            ImFont* _font = font.as<ImFont*>(emscripten::allow_raw_pointers());\r\n            that.AddText(_font, font_size, import_ImVec2(pos), col, text_begin.c_str(), NULL, wrap_width, import_maybe_null_value<ImVec4>(cpu_fine_clip_rect));\r\n        }))\r\n        // IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);\r\n        .function(\"AddImage\", FUNCTION(void, (ImDrawList& that, emscripten::val user_texture_id, emscripten::val a, emscripten::val b, emscripten::val uv_a, emscripten::val uv_b, ImU32 col), {\r\n            that.AddImage((ImTextureID) user_texture_id.as<int>(), import_ImVec2(a), import_ImVec2(b), import_ImVec2(uv_a), import_ImVec2(uv_b), col);\r\n        }))\r\n        // IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);\r\n        .function(\"AddImageQuad\", FUNCTION(void, (ImDrawList& that, emscripten::val user_texture_id, emscripten::val a, emscripten::val b, emscripten::val c, emscripten::val d, emscripten::val uv_a, emscripten::val uv_b, emscripten::val uv_c, emscripten::val uv_d, ImU32 col), {\r\n            that.AddImageQuad((ImTextureID) user_texture_id.as<int>(), import_ImVec2(a), import_ImVec2(b), import_ImVec2(c), import_ImVec2(d), import_ImVec2(uv_a), import_ImVec2(uv_b), import_ImVec2(uv_c), import_ImVec2(uv_d), col);\r\n        }))\r\n        // IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);\r\n        .function(\"AddImageRounded\", FUNCTION(void, (ImDrawList& that, emscripten::val user_texture_id, emscripten::val a, emscripten::val b, emscripten::val uv_a, emscripten::val uv_b, ImU32 col, float rounding, int rounding_corners), {\r\n            that.AddImageRounded((ImTextureID) user_texture_id.as<int>(), import_ImVec2(a), import_ImVec2(b), import_ImVec2(uv_a), import_ImVec2(uv_b), col, rounding, rounding_corners);\r\n        }))\r\n        // IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);\r\n        .function(\"AddPolyline\", FUNCTION(void, (ImDrawList& that, emscripten::val points, const int num_points, ImU32 col, bool closed, float thickness), {\r\n            ImVec2 _points[num_points];\r\n            for (int i = 0; i < num_points; ++i) {\r\n                _points[i] = import_ImVec2(points[i]);\r\n            }\r\n            that.AddPolyline(_points, num_points, col, closed, thickness);\r\n        }))\r\n        // IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);\r\n        .function(\"AddConvexPolyFilled\", FUNCTION(void, (ImDrawList& that, emscripten::val points, const int num_points, ImU32 col), {\r\n            ImVec2 _points[num_points];\r\n            for (int i = 0; i < num_points; ++i) {\r\n                _points[i] = import_ImVec2(points[i]);\r\n            }\r\n            that.AddConvexPolyFilled(_points, num_points, col);\r\n        }))\r\n        // IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);\r\n        .function(\"AddBezierCurve\", FUNCTION(void, (ImDrawList& that, emscripten::val pos0, emscripten::val cp0, emscripten::val cp1, emscripten::val pos1, ImU32 col, float thickness, int num_segments), {\r\n            that.AddBezierCurve(import_ImVec2(pos0), import_ImVec2(cp0), import_ImVec2(cp1), import_ImVec2(pos1), col, thickness, num_segments);\r\n        }))\r\n\r\n        // Stateful path API, add points then finish with PathFill() or PathStroke()\r\n        // inline    void  PathClear()                                                 { _Path.resize(0); }\r\n        CLASS_METHOD(ImDrawList, PathClear)\r\n        // inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }\r\n        .function(\"PathLineTo\", FUNCTION(void, (ImDrawList& that, emscripten::val pos), {\r\n            that.PathLineTo(import_ImVec2(pos));\r\n        }))\r\n        // inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }\r\n        .function(\"PathLineToMergeDuplicate\", FUNCTION(void, (ImDrawList& that, emscripten::val pos), {\r\n            that.PathLineToMergeDuplicate(import_ImVec2(pos));\r\n        }))\r\n        // inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }\r\n        .function(\"PathFillConvex\", FUNCTION(void, (ImDrawList& that, ImU32 col), {\r\n            that.PathFillConvex(col);\r\n        }))\r\n        // inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }\r\n        .function(\"PathStroke\", FUNCTION(void, (ImDrawList& that, ImU32 col, bool closed, float thickness), {\r\n            that.PathStroke(col, closed, thickness);\r\n        }))\r\n        // IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);\r\n        .function(\"PathArcTo\", FUNCTION(void, (ImDrawList& that, emscripten::val centre, float radius, float a_min, float a_max, int num_segments), {\r\n            that.PathArcTo(import_ImVec2(centre), radius, a_min, a_max, num_segments);\r\n        }))\r\n        // IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle\r\n        .function(\"PathArcToFast\", FUNCTION(void, (ImDrawList& that, emscripten::val centre, float radius, int a_min_of_12, int a_max_of_12), {\r\n            that.PathArcToFast(import_ImVec2(centre), radius, a_min_of_12, a_max_of_12);\r\n        }))\r\n        // IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);\r\n        .function(\"PathBezierCurveTo\", FUNCTION(void, (ImDrawList& that, emscripten::val p1, emscripten::val p2, emscripten::val p3, int num_segments), {\r\n            that.PathBezierCurveTo(import_ImVec2(p1), import_ImVec2(p2), import_ImVec2(p3), num_segments);\r\n        }))\r\n        // IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);\r\n        .function(\"PathRect\", FUNCTION(void, (ImDrawList& that, emscripten::val rect_min, emscripten::val rect_max, float rounding, int rounding_corners_flags), {\r\n            that.PathRect(import_ImVec2(rect_min), import_ImVec2(rect_max), rounding, rounding_corners_flags);\r\n        }))\r\n\r\n        // Channels\r\n        // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)\r\n        // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)\r\n        // IMGUI_API void  ChannelsSplit(int channels_count);\r\n        CLASS_METHOD(ImDrawList, ChannelsSplit)\r\n        // IMGUI_API void  ChannelsMerge();\r\n        CLASS_METHOD(ImDrawList, ChannelsMerge)\r\n        // IMGUI_API void  ChannelsSetCurrent(int channel_index);\r\n        CLASS_METHOD(ImDrawList, ChannelsSetCurrent)\r\n\r\n        // Advanced\r\n        // IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.\r\n        .function(\"AddCallback\", FUNCTION(void, (ImDrawList& that, emscripten::val callback, emscripten::val callback_data), {\r\n            // TODO\r\n        }))\r\n        // IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible\r\n        CLASS_METHOD(ImDrawList, AddDrawCmd)\r\n        // IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.\r\n\r\n        // Internal helpers\r\n        // NB: all primitives needs to be reserved via PrimReserve() beforehand!\r\n        // IMGUI_API void  Clear();\r\n        CLASS_METHOD(ImDrawList, Clear)\r\n        // IMGUI_API void  ClearFreeMemory();\r\n        CLASS_METHOD(ImDrawList, ClearFreeMemory)\r\n        // IMGUI_API void  PrimReserve(int idx_count, int vtx_count);\r\n        CLASS_METHOD(ImDrawList, PrimReserve)\r\n        // IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)\r\n        .function(\"PrimRect\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, ImU32 col), {\r\n            that.PrimRect(import_ImVec2(a), import_ImVec2(b), col);\r\n        }))\r\n        // IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);\r\n        .function(\"PrimRectUV\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, emscripten::val uv_a, emscripten::val uv_b, ImU32 col), {\r\n            that.PrimRectUV(import_ImVec2(a), import_ImVec2(b), import_ImVec2(uv_a), import_ImVec2(uv_b), col);\r\n        }))\r\n        // IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);\r\n        .function(\"PrimQuadUV\", FUNCTION(void, (ImDrawList& that, emscripten::val a, emscripten::val b, emscripten::val c, emscripten::val d, emscripten::val uv_a, emscripten::val uv_b, emscripten::val uv_c, emscripten::val uv_d, ImU32 col), {\r\n            that.PrimQuadUV(import_ImVec2(a), import_ImVec2(b), import_ImVec2(c), import_ImVec2(d), import_ImVec2(uv_a), import_ImVec2(uv_b), import_ImVec2(uv_c), import_ImVec2(uv_d), col);\r\n        }))\r\n        // inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }\r\n        .function(\"PrimWriteVtx\", FUNCTION(void, (ImDrawList& that, emscripten::val pos, emscripten::val uv, ImU32 col), {\r\n            that.PrimWriteVtx(import_ImVec2(pos), import_ImVec2(uv), col);\r\n        }))\r\n        // inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }\r\n        .function(\"PrimWriteIdx\", FUNCTION(void, (ImDrawList& that, ImDrawIdx idx), {\r\n            that.PrimWriteIdx(idx);\r\n        }))\r\n        // inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }\r\n        .function(\"PrimVtx\", FUNCTION(void, (ImDrawList& that, emscripten::val pos, emscripten::val uv, ImU32 col), {\r\n            that.PrimVtx(import_ImVec2(pos), import_ImVec2(uv), col);\r\n        }))\r\n        // IMGUI_API void  UpdateClipRect();\r\n        CLASS_METHOD(ImDrawList, UpdateClipRect)\r\n        // IMGUI_API void  UpdateTextureID();\r\n        CLASS_METHOD(ImDrawList, UpdateTextureID)\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImDrawData) {\r\n    emscripten::class_<ImDrawData>(\"ImDrawData\")\r\n        .function(\"IterateDrawLists\", FUNCTION(void, (const ImDrawData* that, emscripten::val callback), {\r\n            for (int n = 0; n < that->CmdListsCount; n++) {\r\n                const ImDrawList* cmd_list = that->CmdLists[n];\r\n                callback(emscripten::val(cmd_list));\r\n            }\r\n        }), emscripten::allow_raw_pointers())\r\n\r\n        // bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.\r\n        CLASS_MEMBER(ImDrawData, Valid)\r\n        // ImDrawList**    CmdLists;\r\n        // int             CmdListsCount;\r\n        CLASS_MEMBER(ImDrawData, CmdListsCount)\r\n        // int             TotalIdxCount;          // For convenience, sum of all cmd_lists idx_buffer.Size\r\n        CLASS_MEMBER(ImDrawData, TotalIdxCount)\r\n        // int             TotalVtxCount;          // For convenience, sum of all cmd_lists vtx_buffer.Size\r\n        CLASS_MEMBER(ImDrawData, TotalVtxCount)\r\n        // ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImDrawData, DisplayPos)\r\n        // ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImDrawData, DisplaySize)\r\n\r\n        // Functions\r\n        // ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }\r\n        // IMGUI_API void DeIndexAllBuffers();               // For backward compatibility or convenience: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\r\n        CLASS_METHOD(ImDrawData, DeIndexAllBuffers)\r\n        // IMGUI_API void ScaleClipRects(const ImVec2& sc);  // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\r\n        .function(\"ScaleClipRects\", FUNCTION(void, (ImDrawData& that, emscripten::val sc), {\r\n            that.ScaleClipRects(import_ImVec2(sc));\r\n        }))\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImFontGlyph) {\r\n    emscripten::class_<ImFontGlyph>(\"ImFontGlyph\")\r\n        // ImWchar         Codepoint;          // 0x0000..0xFFFF\r\n        CLASS_MEMBER(ImFontGlyph, Codepoint)\r\n        // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)\r\n        CLASS_MEMBER(ImFontGlyph, AdvanceX)\r\n        // float           X0, Y0, X1, Y1;     // Glyph corners\r\n        CLASS_MEMBER(ImFontGlyph, X0)\r\n        CLASS_MEMBER(ImFontGlyph, Y0)\r\n        CLASS_MEMBER(ImFontGlyph, X1)\r\n        CLASS_MEMBER(ImFontGlyph, Y1)\r\n        // float           U0, V0, U1, V1;     // Texture coordinates\r\n        CLASS_MEMBER(ImFontGlyph, U0)\r\n        CLASS_MEMBER(ImFontGlyph, V0)\r\n        CLASS_MEMBER(ImFontGlyph, U1)\r\n        CLASS_MEMBER(ImFontGlyph, V1)\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImFontConfig) {\r\n    emscripten::class_<ImFontConfig>(\"ImFontConfig\")\r\n        // void*           FontData;                   //          // TTF/OTF data\r\n        // int             FontDataSize;               //          // TTF/OTF data size\r\n        // FontData: DataView | null;\r\n        CLASS_MEMBER_GET_SET(ImFontConfig, FontData, \r\n            { TODO(); return emscripten::val::null(); }, \r\n            { TODO(); }\r\n        )\r\n        // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).\r\n        CLASS_MEMBER(ImFontConfig, FontDataOwnedByAtlas)\r\n        // int             FontNo;                     // 0        // Index of font within TTF/OTF file\r\n        CLASS_MEMBER(ImFontConfig, FontNo)\r\n        // float           SizePixels;                 //          // Size in pixels for rasterizer.\r\n        CLASS_MEMBER(ImFontConfig, SizePixels)\r\n        // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n        CLASS_MEMBER(ImFontConfig, OversampleH)\r\n        CLASS_MEMBER(ImFontConfig, OversampleV)\r\n        // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.\r\n        CLASS_MEMBER(ImFontConfig, PixelSnapH)\r\n        // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImFontConfig, GlyphExtraSpacing)\r\n        // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImFontConfig, GlyphOffset)\r\n        // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.\r\n        CLASS_MEMBER_GET(ImFontConfig, GlyphRanges, {\r\n            return that.GlyphRanges == NULL ? emscripten::val::null() : emscripten::val((intptr_t) that.GlyphRanges);\r\n        })\r\n        // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font\r\n        CLASS_MEMBER(ImFontConfig, GlyphMinAdvanceX)\r\n        // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs\r\n        CLASS_MEMBER(ImFontConfig, GlyphMaxAdvanceX)\r\n        // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.\r\n        CLASS_MEMBER(ImFontConfig, MergeMode)\r\n        // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.\r\n        CLASS_MEMBER(ImFontConfig, RasterizerFlags)\r\n        // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.\r\n        CLASS_MEMBER(ImFontConfig, RasterizerMultiply)\r\n\r\n        // [Internal]\r\n        // char            Name[32];                               // Name (strictly to ease debugging)\r\n        CLASS_MEMBER_GET_SET(ImFontConfig, Name, \r\n            { return emscripten::val(std::string(that.Name)); }, \r\n            { strncpy(that.Name, value.as<std::string>().c_str(), sizeof(that.Name) - 1); }\r\n        )\r\n        // ImFont*         DstFont;\r\n        CLASS_MEMBER_GET_RAW_POINTER(ImFontConfig, DstFont)\r\n\r\n        // IMGUI_API ImFontConfig();\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImFont) {\r\n    emscripten::class_<ImFont>(\"ImFont\")\r\n        // Members: Hot ~62/78 bytes\r\n        // float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)\r\n        CLASS_MEMBER(ImFont, FontSize)\r\n        // float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()\r\n        CLASS_MEMBER(ImFont, Scale)\r\n        // ImVec2                      DisplayOffset;      // = (0.f,1.f)  // Offset font rendering by xx pixels\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImFont, DisplayOffset)\r\n        // ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.\r\n        // CLASS_MEMBER(ImFont, Glyphs)\r\n        .function(\"IterateGlyphs\", FUNCTION(void, (ImFont* that, emscripten::val callback), {\r\n            for (int n = 0; n < that->Glyphs.Size; n++) {\r\n                auto glyph = &that->Glyphs[n];\r\n                callback(emscripten::val(glyph));\r\n            }\r\n        }), emscripten::allow_raw_pointers())\r\n        // ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).\r\n        // CLASS_MEMBER(ImFont, IndexAdvanceX)\r\n        // ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.\r\n        // CLASS_MEMBER(ImFont, IndexLookup)\r\n        // const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)\r\n        // CLASS_MEMBER(ImFont, FallbackGlyph)\r\n        CLASS_MEMBER_GET_SET_RAW_POINTER(ImFont, FallbackGlyph)\r\n        // float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX\r\n        CLASS_MEMBER(ImFont, FallbackAdvanceX)\r\n        // ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()\r\n        CLASS_MEMBER(ImFont, FallbackChar)\r\n\r\n        // Members: Cold ~18/26 bytes\r\n        // short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.\r\n        CLASS_MEMBER(ImFont, ConfigDataCount)\r\n        // ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData\r\n        // CLASS_MEMBER(ImFont, ConfigData)\r\n        .function(\"IterateConfigData\", FUNCTION(void, (ImFont* that, emscripten::val callback), {\r\n            for (int n = 0; n < that->ConfigDataCount; n++) {\r\n                auto cfg = &that->ConfigData[n];\r\n                callback(emscripten::val(cfg));\r\n            }\r\n        }), emscripten::allow_raw_pointers())\r\n        // ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into\r\n        // CLASS_MEMBER(ImFont, ContainerAtlas)\r\n        // float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]\r\n        CLASS_MEMBER(ImFont, Ascent)\r\n        CLASS_MEMBER(ImFont, Descent)\r\n        // int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)\r\n        CLASS_MEMBER(ImFont, MetricsTotalSurface)\r\n\r\n        // Methods\r\n        // IMGUI_API ImFont();\r\n        // IMGUI_API ~ImFont();\r\n        // IMGUI_API void              ClearOutputData();\r\n        CLASS_METHOD(ImFont, ClearOutputData)\r\n        // IMGUI_API void              BuildLookupTable();\r\n        CLASS_METHOD(ImFont, BuildLookupTable)\r\n        // IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;\r\n        .function(\"FindGlyph\", FUNCTION(emscripten::val, (const ImFont& that, ImWchar c), {\r\n            const ImFontGlyph* glyph = that.FindGlyph(c);\r\n            return glyph == NULL ? emscripten::val::null() : emscripten::val(glyph);\r\n        }), emscripten::allow_raw_pointers())\r\n        // IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;\r\n        .function(\"FindGlyphNoFallback\", FUNCTION(emscripten::val, (const ImFont& that, ImWchar c), {\r\n            const ImFontGlyph* glyph = that.FindGlyphNoFallback(c);\r\n            return glyph == NULL ? emscripten::val::null() : emscripten::val(glyph);\r\n        }), emscripten::allow_raw_pointers())\r\n        // IMGUI_API void              SetFallbackChar(ImWchar c);\r\n        CLASS_METHOD(ImFont, SetFallbackChar)\r\n        // float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }\r\n        CLASS_METHOD(ImFont, GetCharAdvance)\r\n        // bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }\r\n        CLASS_METHOD(ImFont, IsLoaded)\r\n        // const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : \"<unknown>\"; }\r\n        .function(\"GetDebugName\", FUNCTION(std::string, (const ImFont& that), { return that.GetDebugName(); }))\r\n\r\n        // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.\r\n        // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.\r\n        // IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8\r\n        .function(\"CalcTextSizeA\", FUNCTION(emscripten::val, (const ImFont& that, float size, float max_width, float wrap_width, std::string text_begin, emscripten::val remaining, emscripten::val out), {\r\n            const char* _text_begin = text_begin.c_str();\r\n            const char* _remaining = NULL;\r\n            const ImVec2 text_size = that.CalcTextSizeA(size, max_width, wrap_width, _text_begin, NULL, &_remaining);\r\n            if (!remaining.isNull()) {\r\n                remaining.set(0, (int)(_remaining - _text_begin));\r\n            }\r\n            return export_ImVec2(text_size, out);\r\n        }))\r\n        // IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;\r\n        .function(\"CalcWordWrapPositionA\", FUNCTION(int, (const ImFont& that, float scale, std::string text, float wrap_width), {\r\n            const char* _text = text.c_str();\r\n            const char* pos = that.CalcWordWrapPositionA(scale, _text, NULL, wrap_width);\r\n            return (int)(pos - _text);\r\n        }))\r\n        // IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;\r\n        .function(\"RenderChar\", FUNCTION(void, (const ImFont& that, emscripten::val draw_list, float size, emscripten::val pos, ImU32 col, unsigned short c), {\r\n            that.RenderChar(draw_list.as<ImDrawList*>(emscripten::allow_raw_pointers()), size, import_ImVec2(pos), col, c);\r\n        }))\r\n        // IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;\r\n\r\n        // [Internal]\r\n        // IMGUI_API void              GrowIndex(int new_size);\r\n        // IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);\r\n        // IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.\r\n\r\n        // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n        // typedef ImFontGlyph Glyph; // OBSOLETE 1.52+\r\n        // #endif\r\n    ;\r\n}\r\n\r\nImFontConfig import_ImFontConfig(emscripten::val value) {\r\n    ImFontConfig font_cfg;\r\n    // void*           FontData;                   //          // TTF/OTF data\r\n    // int             FontDataSize;               //          // TTF/OTF data size\r\n    const emscripten::val FontData = value[\"FontData\"];\r\n    if (FontData.isNull()) {\r\n        font_cfg.FontData = NULL;\r\n        font_cfg.FontDataSize = 0;\r\n    } else {\r\n        const emscripten::val buffer = FontData[\"buffer\"];\r\n        const size_t byteOffset = FontData[\"byteOffset\"].as<size_t>();\r\n        const size_t byteLength = FontData[\"byteLength\"].as<size_t>();\r\n        font_cfg.FontData = NULL; // TODO\r\n        font_cfg.FontDataSize = 0; // TODO\r\n        printf(\"TODO: FontData %zu %zu\\n\", byteOffset, byteLength);\r\n    }\r\n    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).\r\n    font_cfg.FontDataOwnedByAtlas = value[\"FontDataOwnedByAtlas\"].as<bool>();\r\n    // int             FontNo;                     // 0        // Index of font within TTF/OTF file\r\n    font_cfg.FontNo = value[\"FontNo\"].as<int>();\r\n    // float           SizePixels;                 //          // Size in pixels for rasterizer.\r\n    font_cfg.SizePixels = import_value<float>(value[\"SizePixels\"]);\r\n    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n    font_cfg.OversampleH = value[\"OversampleH\"].as<int>();\r\n    font_cfg.OversampleV = value[\"OversampleV\"].as<int>();\r\n    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.\r\n    font_cfg.PixelSnapH = value[\"PixelSnapH\"].as<bool>();\r\n    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.\r\n    font_cfg.GlyphExtraSpacing = import_ImVec2(value[\"GlyphExtraSpacing\"]);\r\n    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.\r\n    font_cfg.GlyphOffset = import_ImVec2(value[\"GlyphOffset\"]);\r\n    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.\r\n    const emscripten::val GlyphRanges = value[\"GlyphRanges\"];\r\n    font_cfg.GlyphRanges = GlyphRanges.isNull() ? NULL : (const ImWchar*) GlyphRanges.as<intptr_t>();\r\n    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font\r\n    font_cfg.GlyphMinAdvanceX = import_value<float>(value[\"GlyphMinAdvanceX\"]);\r\n    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs\r\n    font_cfg.GlyphMaxAdvanceX = import_value<float>(value[\"GlyphMaxAdvanceX\"]);\r\n    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.\r\n    font_cfg.MergeMode = value[\"MergeMode\"].as<bool>();\r\n    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.\r\n    font_cfg.RasterizerFlags = value[\"RasterizerFlags\"].as<unsigned int>();\r\n    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.\r\n    font_cfg.RasterizerMultiply = import_value<float>(value[\"RasterizerMultiply\"]);\r\n\r\n    // [Internal]\r\n    // char            Name[32];                               // Name (strictly to ease debugging)\r\n    strncpy(font_cfg.Name, value[\"Name\"].as<std::string>().c_str(), sizeof(font_cfg.Name) - 1);\r\n    // ImFont*         DstFont;\r\n    return font_cfg;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImFontAtlas) {\r\n    emscripten::class_<ImFontAtlas>(\"ImFontAtlas\")\r\n        // IMGUI_API ImFontAtlas();\r\n        // IMGUI_API ~ImFontAtlas();\r\n        // IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);\r\n        // IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);\r\n        .function(\"AddFontDefault\", FUNCTION(emscripten::val, (ImFontAtlas& that, emscripten::val font_cfg), {\r\n            ImFontConfig _font_cfg = font_cfg.isNull() ? ImFontConfig() : import_ImFontConfig(font_cfg);\r\n            ImFont* font = that.AddFontDefault(font_cfg.isNull() ? NULL : &_font_cfg);\r\n            return emscripten::val(font);\r\n        }), emscripten::allow_raw_pointers())\r\n        // IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);\r\n        // IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.\r\n        .function(\"AddFontFromMemoryTTF\", FUNCTION(emscripten::val, (ImFontAtlas& that, emscripten::val data, float size_pixels, emscripten::val font_cfg, emscripten::val glyph_ranges), {\r\n            std::vector<unsigned char> _data;\r\n            _data.resize(data[\"length\"].as<size_t>());\r\n            emscripten::val(emscripten::typed_memory_view<unsigned char>(_data.size(), _data.data())).call<void>(\"set\", data);\r\n            size_t _data_size = _data.size();\r\n            void* _data_copy = ImGui::MemAlloc(_data_size);\r\n            memcpy(_data_copy, _data.data(), _data_size);\r\n            ImFontConfig _font_cfg = font_cfg.isNull() ? ImFontConfig() : import_ImFontConfig(font_cfg);\r\n            ImWchar* _glyph_ranges = glyph_ranges.isNull() ? NULL : (ImWchar*) glyph_ranges.as<intptr_t>();\r\n            ImFont* font = that.AddFontFromMemoryTTF(_data_copy, _data_size, size_pixels, font_cfg.isNull() ? NULL : &_font_cfg, _glyph_ranges);\r\n            return emscripten::val(font);\r\n        }), emscripten::allow_raw_pointers())\r\n        // IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.\r\n        // IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.\r\n        // IMGUI_API void              ClearTexData();             // Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.\r\n        CLASS_METHOD(ImFontAtlas, ClearTexData)\r\n        // IMGUI_API void              ClearInputData();           // Clear the input TTF data (inc sizes, glyph ranges)\r\n        CLASS_METHOD(ImFontAtlas, ClearInputData)\r\n        // IMGUI_API void              ClearFonts();               // Clear the ImGui-side font data (glyphs storage, UV coordinates)\r\n        CLASS_METHOD(ImFontAtlas, ClearFonts)\r\n        // IMGUI_API void              Clear();                    // Clear all\r\n        CLASS_METHOD(ImFontAtlas, Clear)\r\n        \r\n        // Build atlas, retrieve pixel data.\r\n        // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().\r\n        // RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste). \r\n        // Pitch = Width * BytesPerPixels\r\n        // IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.\r\n        CLASS_METHOD(ImFontAtlas, Build)\r\n        // IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }\r\n        CLASS_METHOD(ImFontAtlas, IsBuilt)\r\n        // IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel\r\n        .function(\"GetTexDataAsAlpha8\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            unsigned char* pixels = NULL;\r\n            int width = -1;\r\n            int height = -1;\r\n            int bytes_per_pixel = -1;\r\n            that.GetTexDataAsAlpha8(&pixels, &width, &height, &bytes_per_pixel);\r\n            emscripten::val tex_data = emscripten::val::object();\r\n            tex_data.set(emscripten::val(\"pixels\"), emscripten::val(emscripten::typed_memory_view(width * height * bytes_per_pixel, pixels)));\r\n            tex_data.set(emscripten::val(\"width\"), emscripten::val(width));\r\n            tex_data.set(emscripten::val(\"height\"), emscripten::val(height));\r\n            tex_data.set(emscripten::val(\"bytes_per_pixel\"), emscripten::val(bytes_per_pixel));\r\n            return tex_data;\r\n        }))\r\n        // IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel\r\n        .function(\"GetTexDataAsRGBA32\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            unsigned char* pixels = NULL;\r\n            int width = -1;\r\n            int height = -1;\r\n            int bytes_per_pixel = -1;\r\n            that.GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);\r\n            emscripten::val tex_data = emscripten::val::object();\r\n            tex_data.set(emscripten::val(\"pixels\"), emscripten::val(emscripten::typed_memory_view(width * height * bytes_per_pixel, pixels)));\r\n            tex_data.set(emscripten::val(\"width\"), emscripten::val(width));\r\n            tex_data.set(emscripten::val(\"height\"), emscripten::val(height));\r\n            tex_data.set(emscripten::val(\"bytes_per_pixel\"), emscripten::val(bytes_per_pixel));\r\n            return tex_data;\r\n        }))\r\n        // void                        SetTexID(ImTextureID id)    { TexID = id; }\r\n\r\n        //-------------------------------------------\r\n        // Glyph Ranges\r\n        //-------------------------------------------\r\n\r\n        // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)\r\n        // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8\"Hello world\" syntax. See FAQ for details.\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesDefault();    // Basic Latin, Extended Latin\r\n        .function(\"GetGlyphRangesDefault\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesDefault());\r\n        }))\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesKorean();     // Default + Korean characters\r\n        .function(\"GetGlyphRangesKorean\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesKorean());\r\n        }))\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs\r\n        .function(\"GetGlyphRangesJapanese\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesJapanese());\r\n        }))\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs\r\n        .function(\"GetGlyphRangesChineseFull\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesChineseFull());\r\n        }))\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese\r\n        .function(\"GetGlyphRangesChineseSimplifiedCommon\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesChineseSimplifiedCommon());\r\n        }))\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters\r\n        .function(\"GetGlyphRangesCyrillic\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesCyrillic());\r\n        }))\r\n        // IMGUI_API const ImWchar*    GetGlyphRangesThai();       // Default + Thai characters\r\n        .function(\"GetGlyphRangesThai\", FUNCTION(emscripten::val, (ImFontAtlas& that), {\r\n            return emscripten::val((intptr_t) that.GetGlyphRangesThai());\r\n        }))\r\n\r\n        // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().\r\n        // struct GlyphRangesBuilder\r\n        // {\r\n        //     ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)\r\n        //     GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }\r\n        //     bool           GetBit(int n)        { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }\r\n        //     void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array\r\n        //     void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character\r\n        //     IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)\r\n        //     IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext\r\n        //     IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges\r\n        // };\r\n\r\n        //-------------------------------------------\r\n        // Custom Rectangles/Glyphs API\r\n        //-------------------------------------------\r\n\r\n        // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.\r\n        // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.\r\n        // struct CustomRect\r\n        // {\r\n        //     unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.\r\n        //     unsigned short  Width, Height;  // Input    // Desired rectangle dimension\r\n        //     unsigned short  X, Y;           // Output   // Packed position in Atlas\r\n        //     float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance\r\n        //     ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset\r\n        //     ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font\r\n        //     CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }\r\n        //     bool IsPacked() const   { return X != 0xFFFF; }\r\n        // };\r\n\r\n        // IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList\r\n        // IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.\r\n        // IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);\r\n        // const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }\r\n\r\n        //-------------------------------------------\r\n        // Members\r\n        //-------------------------------------------\r\n\r\n        // bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.\r\n        CLASS_MEMBER(ImFontAtlas, Locked)\r\n        // ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)\r\n        CLASS_MEMBER(ImFontAtlas, Flags)\r\n        // ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.\r\n        CLASS_MEMBER_GET_SET(ImFontAtlas, TexID, \r\n            { return emscripten::val((int) that.TexID); }, \r\n            { that.TexID = (ImTextureID) value.as<int>(); }\r\n        )\r\n        // int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.\r\n        CLASS_MEMBER(ImFontAtlas, TexDesiredWidth)\r\n        // int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.\r\n        CLASS_MEMBER(ImFontAtlas, TexGlyphPadding)\r\n\r\n        // [Internal]\r\n        // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.\r\n        // unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight\r\n        // unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4\r\n        // int                         TexWidth;           // Texture width calculated during Build().\r\n        CLASS_MEMBER(ImFontAtlas, TexWidth)\r\n        // int                         TexHeight;          // Texture height calculated during Build().\r\n        CLASS_MEMBER(ImFontAtlas, TexHeight)\r\n        // ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImFontAtlas, TexUvScale)\r\n        // ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImFontAtlas, TexUvWhitePixel)\r\n        // ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.\r\n        .function(\"IterateFonts\", FUNCTION(void, (ImFontAtlas* that, emscripten::val callback), {\r\n            for (int n = 0; n < that->Fonts.Size; n++) {\r\n                ImFont* font = that->Fonts.Data[n];\r\n                callback(emscripten::val(font));\r\n            }\r\n        }), emscripten::allow_raw_pointers())\r\n        // ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.\r\n        // ImVector<ImFontConfig>      ConfigData;         // Internal data\r\n        // int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImGuiIO) {\r\n    emscripten::class_<ImGuiIO>(\"ImGuiIO\")\r\n        //------------------------------------------------------------------\r\n        // Settings (fill once)                 // Default value:\r\n        //------------------------------------------------------------------\r\n\r\n        // ImGuiConfigFlags ConfigFlags;           // = 0                  // See ImGuiConfigFlags_. Gamepad/keyboard navigation options.\r\n        CLASS_MEMBER(ImGuiIO, ConfigFlags)\r\n        // ImGuiConfigFlags BackendFlags;          // = 0                  // Set ImGuiBackendFlags_ enum. Set by imgui_impl_xxx files or custom back-end.\r\n        CLASS_MEMBER(ImGuiIO, BackendFlags)\r\n        // ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiIO, DisplaySize)\r\n        // float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.\r\n        CLASS_MEMBER(ImGuiIO, DeltaTime)\r\n        // float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.\r\n        CLASS_MEMBER(ImGuiIO, IniSavingRate)\r\n        // const char*   IniFilename;              // = \"imgui.ini\"        // Path to .ini file. NULL to disable .ini saving.\r\n        CLASS_MEMBER_GET_SET(ImGuiIO, IniFilename, \r\n            {\r\n                return that.IniFilename == NULL ? emscripten::val::null() : emscripten::val(that.IniFilename);\r\n            },\r\n            {\r\n                WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n                ctx->_ImGuiIO_IniFilename = value.as<std::string>(); that.IniFilename = value.isNull() ? NULL : ctx->_ImGuiIO_IniFilename.c_str();\r\n            }\r\n        )\r\n        // const char*   LogFilename;              // = \"imgui_log.txt\"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).\r\n        CLASS_MEMBER_GET_SET(ImGuiIO, LogFilename, \r\n            {\r\n                return that.LogFilename == NULL ? emscripten::val::null() : emscripten::val(that.LogFilename);\r\n            },\r\n            {\r\n                WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n                ctx->_ImGuiIO_LogFilename = value.as<std::string>(); that.LogFilename = value.isNull() ? NULL : ctx->_ImGuiIO_LogFilename.c_str();\r\n            }\r\n        )\r\n        // float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.\r\n        CLASS_MEMBER(ImGuiIO, MouseDoubleClickTime)\r\n        // float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.\r\n        CLASS_MEMBER(ImGuiIO, MouseDoubleClickMaxDist)\r\n        // float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging\r\n        CLASS_MEMBER(ImGuiIO, MouseDragThreshold)\r\n        // int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array\r\n        .function(\"_getAt_KeyMap\", FUNCTION(int, (const ImGuiIO& that, ImGuiKey index), {\r\n            return (0 <= index && index < ImGuiKey_COUNT) ? that.KeyMap[index] : -1;\r\n        }))\r\n        .function(\"_setAt_KeyMap\", FUNCTION(bool, (ImGuiIO& that, ImGuiKey index, int value), {\r\n            if (0 <= index && index < ImGuiKey_COUNT) { that.KeyMap[index] = value; return true; } return false;\r\n        }))\r\n        // float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).\r\n        CLASS_MEMBER(ImGuiIO, KeyRepeatDelay)\r\n        // float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.\r\n        CLASS_MEMBER(ImGuiIO, KeyRepeatRate)\r\n        // void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.\r\n        CLASS_MEMBER_GET_SET(ImGuiIO, UserData, \r\n            { return WrapImGuiContext::GetCurrentContext()->_ImGuiIO_UserData; }, \r\n            { WrapImGuiContext::GetCurrentContext()->_ImGuiIO_UserData = value; })\r\n\r\n        // ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.\r\n        CLASS_MEMBER_GET_RAW_POINTER(ImGuiIO, Fonts)\r\n        // float         FontGlobalScale;          // = 1.0f               // Global scale all fonts\r\n        CLASS_MEMBER(ImGuiIO, FontGlobalScale)\r\n        // bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.\r\n        CLASS_MEMBER(ImGuiIO, FontAllowUserScaling)\r\n        // ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].\r\n        CLASS_MEMBER_GET_SET_RAW_POINTER(ImGuiIO, FontDefault)\r\n        // ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiIO, DisplayFramebufferScale)\r\n        // ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiIO, DisplayVisibleMin)\r\n        // ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiIO, DisplayVisibleMax)\r\n\r\n        // Advanced/subtle behaviors\r\n        // bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).\r\n        CLASS_MEMBER(ImGuiIO, MouseDrawCursor)\r\n        // bool          ConfigMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl\r\n        CLASS_MEMBER(ImGuiIO, ConfigMacOSXBehaviors)\r\n        // bool          ConfigInputTextCursorBlink;  // = true               // Enable blinking cursor, for users who consider it annoying.\r\n        CLASS_MEMBER(ImGuiIO, ConfigInputTextCursorBlink)\r\n        // bool          ConfigResizeWindowsFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)\r\n        CLASS_MEMBER(ImGuiIO, ConfigResizeWindowsFromEdges)\r\n\r\n        //------------------------------------------------------------------\r\n        // Settings (User Functions)\r\n        //------------------------------------------------------------------\r\n\r\n        // Optional: access OS clipboard\r\n        // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)\r\n        // const char* (*GetClipboardTextFn)(void* user_data);\r\n        CLASS_MEMBER_GET_SET(ImGuiIO, GetClipboardTextFn, \r\n            { return WrapImGuiContext::GetCurrentContext()->_ImGuiIO_GetClipboardTextFn; },\r\n            { WrapImGuiContext::GetCurrentContext()->_ImGuiIO_GetClipboardTextFn = value; }\r\n        )\r\n        // void        (*SetClipboardTextFn)(void* user_data, const char* text);\r\n        CLASS_MEMBER_GET_SET(ImGuiIO, SetClipboardTextFn, \r\n            { return WrapImGuiContext::GetCurrentContext()->_ImGuiIO_SetClipboardTextFn; },\r\n            { WrapImGuiContext::GetCurrentContext()->_ImGuiIO_SetClipboardTextFn = value; }\r\n        )\r\n        // void*       ClipboardUserData;\r\n        CLASS_MEMBER_GET_SET(ImGuiIO, ClipboardUserData, \r\n            { return WrapImGuiContext::GetCurrentContext()->_ImGuiIO_ClipboardUserData; },\r\n            { WrapImGuiContext::GetCurrentContext()->_ImGuiIO_ClipboardUserData = value; }\r\n        )\r\n\r\n        // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.\r\n        // (default to posix malloc/free)\r\n        // void*       (*MemAllocFn)(size_t sz);\r\n        // void        (*MemFreeFn)(void* ptr);\r\n\r\n        // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)\r\n        // (default to use native imm32 api on Windows)\r\n        // void        (*ImeSetInputScreenPosFn)(int x, int y);\r\n        // void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.\r\n\r\n        //------------------------------------------------------------------\r\n        // Input - Fill before calling NewFrame()\r\n        //------------------------------------------------------------------\r\n\r\n        // ImVec2      MousePos;                   // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiIO, MousePos)\r\n        // bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.\r\n        .function(\"_getAt_MouseDown\", FUNCTION(bool, (const ImGuiIO& that, int index), {\r\n            return (0 <= index && index < IM_ARRAYSIZE(that.MouseDown)) ? that.MouseDown[index] : false;\r\n        }), emscripten::allow_raw_pointers())\r\n        .function(\"_setAt_MouseDown\", FUNCTION(bool, (ImGuiIO& that, int index, bool value), {\r\n            if (0 <= index && index < IM_ARRAYSIZE(that.MouseDown)) { that.MouseDown[index] = value; return true; } return false;\r\n        }), emscripten::allow_raw_pointers())\r\n        // float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.\r\n        CLASS_MEMBER(ImGuiIO, MouseWheel)\r\n        // bool        KeyCtrl;                    // Keyboard modifier pressed: Control\r\n        CLASS_MEMBER(ImGuiIO, KeyCtrl)\r\n        // bool        KeyShift;                   // Keyboard modifier pressed: Shift\r\n        CLASS_MEMBER(ImGuiIO, KeyShift)\r\n        // bool        KeyAlt;                     // Keyboard modifier pressed: Alt\r\n        CLASS_MEMBER(ImGuiIO, KeyAlt)\r\n        // bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows\r\n        CLASS_MEMBER(ImGuiIO, KeySuper)\r\n        // bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)\r\n        .function(\"_getAt_KeysDown\", FUNCTION(bool, (const ImGuiIO& that, int index), {\r\n            return (0 <= index && index < IM_ARRAYSIZE(that.KeysDown)) ? that.KeysDown[index] : false;\r\n        }), emscripten::allow_raw_pointers())\r\n        .function(\"_setAt_KeysDown\", FUNCTION(bool, (ImGuiIO& that, int index, bool value), {\r\n            if (0 <= index && index < IM_ARRAYSIZE(that.KeysDown)) { that.KeysDown[index] = value; return true; } return false;\r\n        }), emscripten::allow_raw_pointers())\r\n        // ImWchar     InputCharacters[16+1];      // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.\r\n        CLASS_MEMBER_GET(ImGuiIO, InputCharacters, {\r\n            return emscripten::val(emscripten::typed_memory_view<ImWchar>(sizeof(that.InputCharacters), that.InputCharacters));\r\n        })\r\n        // float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame)\r\n        .function(\"_getAt_NavInputs\", FUNCTION(float, (const ImGuiIO& that, ImGuiNavInput index), {\r\n            return (0 <= index && index < ImGuiNavInput_COUNT) ? that.NavInputs[index] : 0.0f;\r\n        }), emscripten::allow_raw_pointers())\r\n        .function(\"_setAt_NavInputs\", FUNCTION(bool, (ImGuiIO& that, ImGuiNavInput index, float value), {\r\n            if (0 <= index && index < ImGuiNavInput_COUNT) { that.NavInputs[index] = value; return true; } return false;\r\n        }), emscripten::allow_raw_pointers())\r\n\r\n        // Functions\r\n        // IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]\r\n        CLASS_METHOD(ImGuiIO, AddInputCharacter)\r\n        // IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string\r\n        .function(\"AddInputCharactersUTF8\", FUNCTION(void, (ImGuiIO& that, std::string utf8_chars), {\r\n            that.AddInputCharactersUTF8(utf8_chars.c_str());\r\n        }), emscripten::allow_raw_pointers())\r\n        // inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually\r\n        CLASS_METHOD(ImGuiIO, ClearInputCharacters)\r\n\r\n        //------------------------------------------------------------------\r\n        // Output - Retrieve after calling NewFrame()\r\n        //------------------------------------------------------------------\r\n\r\n        // bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application. This is set by ImGui when it wants to use your mouse (e.g. unclicked mouse is hovering a window, or a widget is active). \r\n        CLASS_MEMBER(ImGuiIO, WantCaptureMouse)\r\n        // bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application. This is set by ImGui when it wants to use your keyboard inputs.\r\n        CLASS_MEMBER(ImGuiIO, WantCaptureKeyboard)\r\n        // bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).\r\n        CLASS_MEMBER(ImGuiIO, WantTextInput)\r\n        // bool        WantSetMousePos;            // [BETA-NAV] MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.\r\n        CLASS_MEMBER(ImGuiIO, WantSetMousePos)\r\n        // bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.\r\n        CLASS_MEMBER(ImGuiIO, WantSaveIniSettings)\r\n        // bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.\r\n        CLASS_MEMBER(ImGuiIO, NavActive)\r\n        // bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).\r\n        CLASS_MEMBER(ImGuiIO, NavVisible)\r\n        // float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames\r\n        CLASS_MEMBER(ImGuiIO, Framerate)\r\n        // int         MetricsRenderVertices;      // Vertices output during last call to Render()\r\n        CLASS_MEMBER(ImGuiIO, MetricsRenderVertices)\r\n        // int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3\r\n        CLASS_MEMBER(ImGuiIO, MetricsRenderIndices)\r\n        // int         MetricsRenderWindows;       // Number of visible windows\r\n        CLASS_MEMBER(ImGuiIO, MetricsRenderWindows)\r\n        // int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)\r\n        CLASS_MEMBER(ImGuiIO, MetricsActiveWindows)\r\n        // int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.\r\n        CLASS_MEMBER(ImGuiIO, MetricsActiveAllocations)\r\n        // ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiIO, MouseDelta)\r\n\r\n        //------------------------------------------------------------------\r\n        // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!\r\n        //------------------------------------------------------------------\r\n\r\n        // ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())\r\n        // ImVec2      MouseClickedPos[5];         // Position at time of clicking\r\n        .function(\"_getAt_MouseClickedPos\", FUNCTION(emscripten::val, (const ImGuiIO* that, int index), {\r\n            if (0 <= index && index < IM_ARRAYSIZE(that->MouseClickedPos)) {\r\n                const auto p = &that->MouseClickedPos[index]; return emscripten::val(p);\r\n            }\r\n            return emscripten::val::undefined();\r\n        }), emscripten::allow_raw_pointers())\r\n        // float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)\r\n        // bool        MouseClicked[5];            // Mouse button went from !Down to Down\r\n        // bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?\r\n        // bool        MouseReleased[5];           // Mouse button went from Down to !Down\r\n        // bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.\r\n        // float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)\r\n        .function(\"_getAt_MouseDownDuration\", FUNCTION(float, (const ImGuiIO& that, int index), {\r\n            return (0 <= index && index < IM_ARRAYSIZE(that.MouseDownDuration)) ? that.MouseDownDuration[index] : -1.0f;\r\n        }))\r\n        // float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down\r\n        // ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point\r\n        // float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point\r\n        // float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)\r\n        .function(\"_getAt_KeysDownDuration\", FUNCTION(float, (const ImGuiIO& that, int index), {\r\n            return (0 <= index && index < IM_ARRAYSIZE(that.KeysDownDuration)) ? that.KeysDownDuration[index] : -1.0f;\r\n        }))\r\n        // float       KeysDownDurationPrev[512];  // Previous duration the key has been down\r\n        // float       NavInputsDownDuration[ImGuiNavInput_COUNT];\r\n        .function(\"_getAt_NavInputsDownDuration\", FUNCTION(float, (const ImGuiIO& that, ImGuiNavInput index), {\r\n            return (0 <= index && index < ImGuiNavInput_COUNT) ? that.NavInputsDownDuration[index] : -1.0f;\r\n        }))\r\n        // float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];\r\n\r\n        // IMGUI_API   ImGuiIO();\r\n    ;\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(ImGuiStyle) {\r\n    emscripten::class_<ImGuiStyle>(\"ImGuiStyle\")\r\n        .constructor()\r\n        // float       Alpha;                      // Global alpha applies to everything in ImGui\r\n        CLASS_MEMBER(ImGuiStyle, Alpha)\r\n        // ImVec2      WindowPadding;              // Padding within a window\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, WindowPadding)\r\n        // float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows\r\n        CLASS_MEMBER(ImGuiStyle, WindowRounding)\r\n        // float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n        CLASS_MEMBER(ImGuiStyle, WindowBorderSize)\r\n        // ImVec2      WindowMinSize;              // Minimum window size\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, WindowMinSize)\r\n        // ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, WindowTitleAlign)\r\n        // float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.\r\n        CLASS_MEMBER(ImGuiStyle, ChildRounding)\r\n        // float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n        CLASS_MEMBER(ImGuiStyle, ChildBorderSize)\r\n        // float       PopupRounding;              // Radius of popup window corners rounding.\r\n        CLASS_MEMBER(ImGuiStyle, PopupRounding)\r\n        // float       PopupBorderSize;            // Thickness of border around popup windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n        CLASS_MEMBER(ImGuiStyle, PopupBorderSize)\r\n        // ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, FramePadding)\r\n        // float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).\r\n        CLASS_MEMBER(ImGuiStyle, FrameRounding)\r\n        // float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n        CLASS_MEMBER(ImGuiStyle, FrameBorderSize)\r\n        // ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, ItemSpacing)\r\n        // ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, ItemInnerSpacing)\r\n        // ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, TouchExtraPadding)\r\n        // float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\r\n        CLASS_MEMBER(ImGuiStyle, IndentSpacing)\r\n        // float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns\r\n        CLASS_MEMBER(ImGuiStyle, ColumnsMinSpacing)\r\n        // float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar\r\n        CLASS_MEMBER(ImGuiStyle, ScrollbarSize)\r\n        // float       ScrollbarRounding;          // Radius of grab corners for scrollbar\r\n        CLASS_MEMBER(ImGuiStyle, ScrollbarRounding)\r\n        // float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.\r\n        CLASS_MEMBER(ImGuiStyle, GrabMinSize)\r\n        // float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\r\n        CLASS_MEMBER(ImGuiStyle, GrabRounding)\r\n        // ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, ButtonTextAlign)\r\n        // ImVec2      DisplayWindowPadding;       // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, DisplayWindowPadding)\r\n        // ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.\r\n        CLASS_MEMBER_GET_RAW_REFERENCE(ImGuiStyle, DisplaySafeAreaPadding)\r\n        // float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.\r\n        CLASS_MEMBER(ImGuiStyle, MouseCursorScale)\r\n        // bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.\r\n        CLASS_MEMBER(ImGuiStyle, AntiAliasedLines)\r\n        // bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)\r\n        CLASS_MEMBER(ImGuiStyle, AntiAliasedFill)\r\n        // float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\r\n        CLASS_MEMBER(ImGuiStyle, CurveTessellationTol)\r\n        // ImVec4      Colors[ImGuiCol_COUNT];\r\n        .function(\"_getAt_Colors\", FUNCTION(emscripten::val, (ImGuiStyle* that, ImGuiCol index), {\r\n            if (0 <= index && index < ImGuiCol_COUNT) {\r\n                auto p = &that->Colors[index]; return emscripten::val(p);\r\n            }\r\n            return emscripten::val::undefined();\r\n        }), emscripten::allow_raw_pointers())\r\n        .function(\"_setAt_Colors\", FUNCTION(bool, (ImGuiStyle* that, ImGuiCol index, emscripten::val value), {\r\n            if (0 <= index && index < ImGuiCol_COUNT) { that->Colors[index] = import_ImVec4(value); return true; } return false;    \r\n        }), emscripten::allow_raw_pointers())\r\n\r\n        // IMGUI_API ImGuiStyle();\r\n        // IMGUI_API void ScaleAllSizes(float scale_factor);\r\n        CLASS_METHOD(ImGuiStyle, ScaleAllSizes)\r\n    ;\r\n}\r\n\r\nnamespace ImGui {\r\n\r\ntemplate <typename T>\r\nbool DragScalarV(const char* label, ImGuiDataType data_type, std::vector<T>& v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f) {\r\n    return ImGui::DragScalarN(label, data_type, v.data(), v.size(), v_speed, v_min, v_max, format, power);\r\n}\r\n\r\ntemplate <typename T>\r\nbool InputScalarV(const char* label, ImGuiDataType data_type, std::vector<T>& v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0) {\r\n    return ImGui::InputScalarN(label, data_type, v.data(), v.size(), step, step_fast, format, extra_flags);\r\n}\r\n\r\ntemplate <typename T>\r\nbool SliderScalarV(const char* label, ImGuiDataType data_type, std::vector<T>& v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f) {\r\n    return ImGui::SliderScalarN(label, data_type, v.data(), v.size(), v_min, v_max, format, power);\r\n}\r\n\r\n\r\n} // namespace ImGui\r\n\r\nEMSCRIPTEN_BINDINGS(ImGui) {\r\n    emscripten::constant(\"IMGUI_VERSION\", std::string(IMGUI_VERSION));\r\n\r\n    emscripten::function(\"IMGUI_CHECKVERSION\", FUNCTION(bool, (), { return IMGUI_CHECKVERSION(); }));\r\n\r\n    emscripten::constant(\"ImGuiIOSize\", sizeof(ImGuiIO));\r\n    emscripten::constant(\"ImGuiStyleSize\", sizeof(ImGuiStyle));\r\n    emscripten::constant(\"ImVec2Size\", sizeof(ImVec2));\r\n    emscripten::constant(\"ImVec4Size\", sizeof(ImVec4));\r\n\r\n    emscripten::constant(\"ImDrawVertSize\", sizeof(ImDrawVert));\r\n    emscripten::constant(\"ImDrawIdxSize\", sizeof(ImDrawIdx));\r\n    emscripten::constant(\"ImDrawVertPosOffset\", IM_OFFSETOF(ImDrawVert, pos));\r\n    emscripten::constant(\"ImDrawVertUVOffset\", IM_OFFSETOF(ImDrawVert, uv));\r\n    emscripten::constant(\"ImDrawVertColOffset\", IM_OFFSETOF(ImDrawVert, col));\r\n\r\n    // Context creation and access, if you want to use multiple context, share context between modules (e.g. DLL). \r\n    // All contexts share a same ImFontAtlas by default. If you want different font atlas, you can new() them and overwrite the GetIO().Fonts variable of an ImGui context.\r\n    // All those functions are not reliant on the current context.\r\n    // IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);\r\n    emscripten::function(\"CreateContext\", FUNCTION(WrapImGuiContext*, (), {\r\n        return WrapImGuiContext::CreateContext(); // TODO: shared font atlas\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = Destroy current context\r\n    emscripten::function(\"DestroyContext\", FUNCTION(void, (WrapImGuiContext* wrap), {\r\n        WrapImGuiContext::DestroyContext(wrap);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API ImGuiContext* GetCurrentContext();\r\n    emscripten::function(\"GetCurrentContext\", FUNCTION(WrapImGuiContext*, (), {\r\n        return WrapImGuiContext::GetCurrentContext();\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);\r\n    emscripten::function(\"SetCurrentContext\", FUNCTION(void, (WrapImGuiContext* wrap), {\r\n        WrapImGuiContext::SetCurrentContext(wrap);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);\r\n    emscripten::function(\"DebugCheckVersionAndDataLayout\", FUNCTION(bool, (std::string version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert), {\r\n        return ImGui::DebugCheckVersionAndDataLayout(version_str.c_str(), sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert);\r\n    }));\r\n\r\n    // Main\r\n    // IMGUI_API ImGuiIO&      GetIO();\r\n    emscripten::function(\"GetIO\", FUNCTION(emscripten::val, (), {\r\n        ImGuiIO* p = &ImGui::GetIO(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API ImGuiStyle&   GetStyle();\r\n    emscripten::function(\"GetStyle\", FUNCTION(emscripten::val, (), {\r\n        ImGuiStyle* p = &ImGui::GetStyle(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API ImDrawData*   GetDrawData();                              // same value as passed to your io.RenderDrawListsFn() function. valid after Render() and until the next call to NewFrame()\r\n    emscripten::function(\"GetDrawData\", FUNCTION(emscripten::val, (), {\r\n        ImDrawData* p = ImGui::GetDrawData(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().\r\n    emscripten::function(\"NewFrame\", &ImGui::NewFrame);\r\n    // IMGUI_API void          Render();                                   // ends the ImGui frame, finalize the draw data, then call your io.RenderDrawListsFn() function if set.\r\n    emscripten::function(\"Render\", &ImGui::Render);\r\n    // IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), so most likely don't need to ever call that yourself directly. If you don't need to render you may call EndFrame() but you'll have wasted CPU already. If you don't need to render, better to not create any imgui windows instead!\r\n    emscripten::function(\"EndFrame\", &ImGui::EndFrame);\r\n\r\n    // Demo, Debug, Informations\r\n    // IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!\r\n    emscripten::function(\"ShowDemoWindow\", FUNCTION(void, (emscripten::val p_open), {\r\n        ImGui::ShowDemoWindow(access_maybe_null_value<bool>(p_open));\r\n    }));\r\n    // IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.\r\n    emscripten::function(\"ShowMetricsWindow\", FUNCTION(void, (emscripten::val p_open), {\r\n        ImGui::ShowMetricsWindow(access_maybe_null_value<bool>(p_open));\r\n    }));\r\n    // IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)\r\n    emscripten::function(\"ShowStyleEditor\", FUNCTION(void, (emscripten::val ref), {\r\n        ImGui::ShowStyleEditor(ref.isNull() ? NULL : ref.as<ImGuiStyle*>(emscripten::allow_raw_pointers()));\r\n    }));\r\n    // IMGUI_API bool          ShowStyleSelector(const char* label);\r\n    emscripten::function(\"ShowStyleSelector\", FUNCTION(void, (std::string label), {\r\n        ImGui::ShowStyleSelector(label.c_str());\r\n    }));\r\n    // IMGUI_API void          ShowFontSelector(const char* label);\r\n    emscripten::function(\"ShowFontSelector\", FUNCTION(void, (std::string label), {\r\n        ImGui::ShowFontSelector(label.c_str());\r\n    }));\r\n    // IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).\r\n    emscripten::function(\"ShowUserGuide\", &ImGui::ShowUserGuide);\r\n    // IMGUI_API const char*   GetVersion();\r\n    emscripten::function(\"GetVersion\", FUNCTION(std::string, (), {\r\n        return ImGui::GetVersion();\r\n    }));\r\n\r\n    // Styles\r\n    // IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // New, recommended style\r\n    emscripten::function(\"StyleColorsDark\", FUNCTION(void, (ImGuiStyle* dst), { ImGui::StyleColorsDark(dst); }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // Classic imgui style (default)\r\n    emscripten::function(\"StyleColorsClassic\", FUNCTION(void, (ImGuiStyle* dst), { ImGui::StyleColorsClassic(dst); }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // Best used with borders and a custom, thicker font\r\n    emscripten::function(\"StyleColorsLight\", FUNCTION(void, (ImGuiStyle* dst), { ImGui::StyleColorsLight(dst); }), emscripten::allow_raw_pointers());\r\n\r\n    // Window\r\n    // IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                                                   // push window to the stack and start appending to it. see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_open' creates a widget on the upper-right to close the window (which sets your bool to false).\r\n    emscripten::function(\"Begin\", FUNCTION(bool, (std::string label, emscripten::val p_open, ImGuiWindowFlags flags), {\r\n        return ImGui::Begin(label.c_str(), access_maybe_null_value<bool>(p_open), flags);\r\n    }));\r\n    // IMGUI_API void          End();                                                                                                                      // finish appending to current window, pop it off the window stack.\r\n    emscripten::function(\"End\", &ImGui::End);\r\n    // IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);    // begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).\r\n    // IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);            // \"\r\n    emscripten::function(\"BeginChild\", FUNCTION(bool, (emscripten::val id, emscripten::val size, bool border, ImGuiWindowFlags extra_flags), {\r\n        if (id.typeOf().strictlyEquals(emscripten::val(\"string\"))) {\r\n            return ImGui::BeginChild(id.as<std::string>().c_str(), import_ImVec2(size), border, extra_flags);\r\n        } else {\r\n            return ImGui::BeginChild(id.as<ImGuiID>(), import_ImVec2(size), border, extra_flags);\r\n        }\r\n    }));\r\n    // IMGUI_API void          EndChild();\r\n    emscripten::function(\"EndChild\", &ImGui::EndChild);\r\n    // IMGUI_API ImVec2        GetContentRegionMax();                                              // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates\r\n    emscripten::function(\"GetContentRegionMax\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetContentRegionMax(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetContentRegionAvail();                                            // == GetContentRegionMax() - GetCursorPos()\r\n    emscripten::function(\"GetContentRegionAvail\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetContentRegionAvail(), out);\r\n    }));\r\n    // IMGUI_API float         GetContentRegionAvailWidth();                                       //\r\n    emscripten::function(\"GetContentRegionAvailWidth\", &ImGui::GetContentRegionAvailWidth);\r\n    // IMGUI_API ImVec2        GetWindowContentRegionMin();                                        // content boundaries min (roughly (0,0)-Scroll), in window coordinates\r\n    emscripten::function(\"GetWindowContentRegionMin\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetWindowContentRegionMin(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetWindowContentRegionMax();                                        // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates\r\n    emscripten::function(\"GetWindowContentRegionMax\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetWindowContentRegionMax(), out);\r\n    }));\r\n    // IMGUI_API float         GetWindowContentRegionWidth();                                      //\r\n    emscripten::function(\"GetWindowContentRegionWidth\", &ImGui::GetWindowContentRegionWidth);\r\n    // IMGUI_API ImDrawList*   GetWindowDrawList();                                                // get rendering command-list if you want to append your own draw primitives\r\n    emscripten::function(\"GetWindowDrawList\", FUNCTION(emscripten::val, (), {\r\n        ImDrawList* p = ImGui::GetWindowDrawList(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API ImVec2        GetWindowPos();                                                     // get current window position in screen space (useful if you want to do your own drawing via the DrawList api)\r\n    emscripten::function(\"GetWindowPos\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetWindowPos(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetWindowSize();                                                    // get current window size\r\n    emscripten::function(\"GetWindowSize\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetWindowSize(), out);\r\n    }));\r\n    // IMGUI_API float         GetWindowWidth();\r\n    emscripten::function(\"GetWindowWidth\", &ImGui::GetWindowWidth);\r\n    // IMGUI_API float         GetWindowHeight();\r\n    emscripten::function(\"GetWindowHeight\", &ImGui::GetWindowHeight);\r\n    // IMGUI_API bool          IsWindowCollapsed();\r\n    emscripten::function(\"IsWindowCollapsed\", &ImGui::IsWindowCollapsed);\r\n    // IMGUI_API bool          IsWindowAppearing();\r\n    emscripten::function(\"IsWindowAppearing\", &ImGui::IsWindowAppearing);\r\n    // IMGUI_API void          SetWindowFontScale(float scale);                                    // per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows\r\n    emscripten::function(\"SetWindowFontScale\", &ImGui::SetWindowFontScale);\r\n\r\n    // IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.\r\n    emscripten::function(\"SetNextWindowPos\", FUNCTION(void, (emscripten::val pos, ImGuiCond cond, emscripten::val pivot), {\r\n        ImGui::SetNextWindowPos(import_ImVec2(pos), cond, import_ImVec2(pivot));\r\n    }));\r\n    // IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);          // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()\r\n    emscripten::function(\"SetNextWindowSize\", FUNCTION(void, (emscripten::val size, ImGuiCond cond), {\r\n        ImGui::SetNextWindowSize(import_ImVec2(size), cond);\r\n    }));\r\n    // IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.\r\n    emscripten::function(\"SetNextWindowSizeConstraints\", FUNCTION(void, (emscripten::val size_min, emscripten::val size_max, emscripten::val custom_callback, emscripten::val custom_callback_data), {\r\n        if (!custom_callback.isNull()) {\r\n            WrapImGuiContext::GetCurrentContext()->_ImGui_SetNextWindowSizeConstraints_custom_callback = custom_callback;\r\n            ImGui::SetNextWindowSizeConstraints(import_ImVec2(size_min), import_ImVec2(size_max), FUNCTION(void, (ImGuiSizeCallbackData* data), {\r\n                WrapImGuiContext::GetCurrentContext()->_ImGui_SetNextWindowSizeConstraints_custom_callback(emscripten::val(data));\r\n            }), NULL);\r\n        } else {\r\n            ImGui::SetNextWindowSizeConstraints(import_ImVec2(size_min), import_ImVec2(size_max));\r\n        }\r\n    }));\r\n    // IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                       // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()\r\n    emscripten::function(\"SetNextWindowContentSize\", FUNCTION(void, (emscripten::val size), {\r\n        ImGui::SetNextWindowContentSize(import_ImVec2(size));\r\n    }));\r\n    // IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);         // set next window collapsed state. call before Begin()\r\n    emscripten::function(\"SetNextWindowCollapsed\", &ImGui::SetNextWindowCollapsed);\r\n    // IMGUI_API void          SetNextWindowFocus();                                               // set next window to be focused / front-most. call before Begin()\r\n    emscripten::function(\"SetNextWindowFocus\", &ImGui::SetNextWindowFocus);\r\n    // IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                  // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg.\r\n    emscripten::function(\"SetNextWindowBgAlpha\", &ImGui::SetNextWindowBgAlpha);\r\n    // IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.\r\n    emscripten::function(\"SetWindowPos\", FUNCTION(void, (emscripten::val pos, ImGuiCond cond), {\r\n        ImGui::SetWindowPos(import_ImVec2(pos), cond);\r\n    }));\r\n    // IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);              // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.    \r\n    emscripten::function(\"SetWindowSize\", FUNCTION(void, (emscripten::val pos, ImGuiCond cond), {\r\n        ImGui::SetWindowSize(import_ImVec2(pos), cond);\r\n    }));\r\n    // IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);             // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().\r\n    emscripten::function(\"SetWindowCollapsed\", FUNCTION(void, (bool collapsed, ImGuiCond cond), {\r\n        ImGui::SetWindowCollapsed(collapsed, cond);\r\n    }));\r\n    // IMGUI_API void          SetWindowFocus();                                                   // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().\r\n    emscripten::function(\"SetWindowFocus\", FUNCTION(void, (), {\r\n        ImGui::SetWindowFocus();\r\n    }));\r\n    // IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.\r\n    emscripten::function(\"SetWindowNamePos\", FUNCTION(void, (std::string name, emscripten::val pos, ImGuiCond cond), {\r\n        ImGui::SetWindowPos(name.c_str(), import_ImVec2(pos), cond);\r\n    }));\r\n    // IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.\r\n    emscripten::function(\"SetWindowNameSize\", FUNCTION(void, (std::string name, emscripten::val size, ImGuiCond cond), {\r\n        ImGui::SetWindowSize(name.c_str(), import_ImVec2(size), cond);\r\n    }));\r\n    // IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state\r\n    emscripten::function(\"SetWindowNameCollapsed\", FUNCTION(void, (std::string name, bool collapsed, ImGuiCond cond), {\r\n        ImGui::SetWindowCollapsed(name.c_str(), collapsed, cond);\r\n    }));\r\n    // IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.\r\n    emscripten::function(\"SetWindowNameFocus\", FUNCTION(void, (std::string name), {\r\n        ImGui::SetWindowFocus(name.c_str());\r\n    }));\r\n\r\n    // IMGUI_API float         GetScrollX();                                                       // get scrolling amount [0..GetScrollMaxX()]\r\n    emscripten::function(\"GetScrollX\", &ImGui::GetScrollX);\r\n    // IMGUI_API float         GetScrollY();                                                       // get scrolling amount [0..GetScrollMaxY()]\r\n    emscripten::function(\"GetScrollY\", &ImGui::GetScrollY);\r\n    // IMGUI_API float         GetScrollMaxX();                                                    // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X\r\n    emscripten::function(\"GetScrollMaxX\", &ImGui::GetScrollMaxX);\r\n    // IMGUI_API float         GetScrollMaxY();                                                    // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y\r\n    emscripten::function(\"GetScrollMaxY\", &ImGui::GetScrollMaxY);\r\n    // IMGUI_API void          SetScrollX(float scroll_x);                                         // set scrolling amount [0..GetScrollMaxX()]\r\n    emscripten::function(\"SetScrollX\", &ImGui::SetScrollX);\r\n    // IMGUI_API void          SetScrollY(float scroll_y);                                         // set scrolling amount [0..GetScrollMaxY()]\r\n    emscripten::function(\"SetScrollY\", &ImGui::SetScrollY);\r\n    // IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                         // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead.\r\n    emscripten::function(\"SetScrollHereY\", &ImGui::SetScrollHereY);\r\n    // IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.\r\n    emscripten::function(\"SetScrollFromPosY\", &ImGui::SetScrollFromPosY);\r\n    // IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                // replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)\r\n    emscripten::function(\"SetStateStorage\", FUNCTION(void, (emscripten::val tree), {\r\n        TODO();\r\n    }));\r\n    // IMGUI_API ImGuiStorage* GetStateStorage();\r\n    emscripten::function(\"GetStateStorage\", FUNCTION(emscripten::val, (), {\r\n        TODO();\r\n        return emscripten::val::null();\r\n    }));\r\n\r\n    // Parameters stacks (shared)\r\n    // IMGUI_API void          PushFont(ImFont* font);                                             // use NULL as a shortcut to push default font\r\n    emscripten::function(\"PushFont\", FUNCTION(void, (emscripten::val font), {\r\n        ImFont* _font = font.isNull() ? NULL : font.as<ImFont*>(emscripten::allow_raw_pointers());\r\n        ImGui::PushFont(_font);\r\n    }));\r\n    // IMGUI_API void          PopFont();\r\n    emscripten::function(\"PopFont\", FUNCTION(void, (), {\r\n        ImGui::PopFont();\r\n    }));\r\n    // IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);\r\n    // IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);\r\n    emscripten::function(\"PushStyleColor\", FUNCTION(void, (ImGuiCol idx, emscripten::val col), {\r\n        if (col.typeOf().strictlyEquals(emscripten::val(\"number\"))) {\r\n            ImGui::PushStyleColor(idx, col.as<ImU32>());\r\n        } else {\r\n            ImGui::PushStyleColor(idx, import_ImVec4(col));\r\n        }\r\n    }));\r\n    // IMGUI_API void          PopStyleColor(int count = 1);\r\n    emscripten::function(\"PopStyleColor\", &ImGui::PopStyleColor);\r\n    // IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float emscripten::val);\r\n    // IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& emscripten::val);\r\n    emscripten::function(\"PushStyleVar\", FUNCTION(void, (ImGuiStyleVar idx, emscripten::val var), {\r\n        if (var.typeOf().strictlyEquals(emscripten::val(\"number\"))) {\r\n            ImGui::PushStyleVar(idx, import_value<float>(var));\r\n        } else {\r\n            ImGui::PushStyleVar(idx, import_ImVec2(var));\r\n        }\r\n    }));\r\n    // IMGUI_API void          PopStyleVar(int count = 1);\r\n    emscripten::function(\"PopStyleVar\", &ImGui::PopStyleVar);\r\n    // IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                    // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwhise use GetColorU32() to get style color + style alpha.\r\n    emscripten::function(\"GetStyleColorVec4\", FUNCTION(emscripten::val, (ImGuiCol idx), {\r\n        const ImVec4* p = &ImGui::GetStyleColorVec4(idx); return emscripten::val(p);\r\n    }));\r\n    // IMGUI_API ImFont*       GetFont();                                                          // get current font\r\n    emscripten::function(\"GetFont\", FUNCTION(emscripten::val, (), {\r\n        ImFont* p = ImGui::GetFont(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API float         GetFontSize();                                                      // get current font size (= height in pixels) of current font with current scale applied\r\n    emscripten::function(\"GetFontSize\", &ImGui::GetFontSize);\r\n    // IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                           // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API\r\n    emscripten::function(\"GetFontTexUvWhitePixel\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetFontTexUvWhitePixel(), out);\r\n    }));\r\n    // IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  // retrieve given style color with style alpha applied and optional extra alpha multiplier\r\n    // IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     // retrieve given color with style alpha applied\r\n    // IMGUI_API ImU32         GetColorU32(ImU32 col);                                             // retrieve given color with style alpha applied\r\n    emscripten::function(\"GetColorU32_A\", FUNCTION(ImU32, (ImGuiCol idx, emscripten::val alpha_mul), {\r\n        return ImGui::GetColorU32(idx, import_value<float>(alpha_mul));\r\n    }));\r\n    emscripten::function(\"GetColorU32_B\", FUNCTION(ImU32, (emscripten::val col), {\r\n        return ImGui::GetColorU32(import_ImVec4(col));\r\n    }));\r\n    emscripten::function(\"GetColorU32_C\", FUNCTION(ImU32, (ImU32 col), {\r\n        return ImGui::GetColorU32(col);\r\n    }));\r\n\r\n    // Parameters stacks (current window)\r\n    // IMGUI_API void          PushItemWidth(float item_width);                                    // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)\r\n    emscripten::function(\"PushItemWidth\", &ImGui::PushItemWidth);\r\n    // IMGUI_API void          PopItemWidth();\r\n    emscripten::function(\"PopItemWidth\", &ImGui::PopItemWidth);\r\n    // IMGUI_API float         CalcItemWidth();                                                    // width of item given pushed settings and current cursor position\r\n    emscripten::function(\"CalcItemWidth\", &ImGui::CalcItemWidth);\r\n    // IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space\r\n    emscripten::function(\"PushTextWrapPos\", &ImGui::PushTextWrapPos);\r\n    // IMGUI_API void          PopTextWrapPos();\r\n    emscripten::function(\"PopTextWrapPos\", &ImGui::PopTextWrapPos);\r\n    // IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);                  // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets\r\n    emscripten::function(\"PushAllowKeyboardFocus\", &ImGui::PushAllowKeyboardFocus);\r\n    // IMGUI_API void          PopAllowKeyboardFocus();\r\n    emscripten::function(\"PopAllowKeyboardFocus\", &ImGui::PopAllowKeyboardFocus);\r\n    // IMGUI_API void          PushButtonRepeat(bool repeat);                                      // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.\r\n    emscripten::function(\"PushButtonRepeat\", &ImGui::PushButtonRepeat);\r\n    // IMGUI_API void          PopButtonRepeat();\r\n    emscripten::function(\"PopButtonRepeat\", &ImGui::PopButtonRepeat);\r\n\r\n    // Cursor / Layout\r\n    // IMGUI_API void          Separator();                                                        // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.\r\n    emscripten::function(\"Separator\", &ImGui::Separator);\r\n    // IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              // call between widgets or groups to layout them horizontally\r\n    emscripten::function(\"SameLine\", &ImGui::SameLine);\r\n    // IMGUI_API void          NewLine();                                                          // undo a SameLine()\r\n    emscripten::function(\"NewLine\", &ImGui::NewLine);\r\n    // IMGUI_API void          Spacing();                                                          // add vertical spacing\r\n    emscripten::function(\"Spacing\", &ImGui::Spacing);\r\n    // IMGUI_API void          Dummy(const ImVec2& size);                                          // add a dummy item of given size\r\n    emscripten::function(\"Dummy\", FUNCTION(void, (emscripten::val size), {\r\n        ImGui::Dummy(import_ImVec2(size));\r\n    }));\r\n    // IMGUI_API void          Indent(float indent_w = 0.0f);                                      // move content position toward the right, by style.IndentSpacing or indent_w if != 0\r\n    emscripten::function(\"Indent\", &ImGui::Indent);\r\n    // IMGUI_API void          Unindent(float indent_w = 0.0f);                                    // move content position back to the left, by style.IndentSpacing or indent_w if != 0\r\n    emscripten::function(\"Unindent\", &ImGui::Unindent);\r\n    // IMGUI_API void          BeginGroup();                                                       // lock horizontal starting position + capture group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\r\n    emscripten::function(\"BeginGroup\", &ImGui::BeginGroup);\r\n    // IMGUI_API void          EndGroup();\r\n    emscripten::function(\"EndGroup\", &ImGui::EndGroup);\r\n    // IMGUI_API ImVec2        GetCursorPos();                                                     // cursor position is relative to window position\r\n    emscripten::function(\"GetCursorPos\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetCursorPos(), out);\r\n    }));\r\n    // IMGUI_API float         GetCursorPosX();                                                    // \"\r\n    emscripten::function(\"GetCursorPosX\", &ImGui::GetCursorPosX);\r\n    // IMGUI_API float         GetCursorPosY();                                                    // \"\r\n    emscripten::function(\"GetCursorPosY\", &ImGui::GetCursorPosY);\r\n    // IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                              // \"\r\n    emscripten::function(\"SetCursorPos\", FUNCTION(void, (emscripten::val local_pos), {\r\n        ImGui::SetCursorPos(import_ImVec2(local_pos));\r\n    }));\r\n    // IMGUI_API void          SetCursorPosX(float x);                                             // \"\r\n    emscripten::function(\"SetCursorPosX\", &ImGui::SetCursorPosX);\r\n    // IMGUI_API void          SetCursorPosY(float y);                                             // \"\r\n    emscripten::function(\"SetCursorPosY\", &ImGui::SetCursorPosY);\r\n    // IMGUI_API ImVec2        GetCursorStartPos();                                                // initial cursor position\r\n    emscripten::function(\"GetCursorStartPos\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetCursorStartPos(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetCursorScreenPos();                                               // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)\r\n    emscripten::function(\"GetCursorScreenPos\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetCursorScreenPos(), out);\r\n    }));\r\n    // IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              // cursor position in absolute screen coordinates [0..io.DisplaySize]\r\n    emscripten::function(\"SetCursorScreenPos\", FUNCTION(void, (emscripten::val pos), {\r\n        ImGui::SetCursorScreenPos(import_ImVec2(pos));\r\n    }));\r\n    // IMGUI_API void          AlignTextToFramePadding();                                          // vertically align/lower upcoming text to FramePadding.y so that it will aligns to upcoming widgets (call if you have text on a line before regular widgets)\r\n    emscripten::function(\"AlignTextToFramePadding\", &ImGui::AlignTextToFramePadding);\r\n    // IMGUI_API float         GetTextLineHeight();                                                // ~ FontSize\r\n    emscripten::function(\"GetTextLineHeight\", &ImGui::GetTextLineHeight);\r\n    // IMGUI_API float         GetTextLineHeightWithSpacing();                                     // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)\r\n    emscripten::function(\"GetTextLineHeightWithSpacing\", &ImGui::GetTextLineHeightWithSpacing);\r\n    // IMGUI_API float         GetFrameHeight();                                                   // ~ FontSize + style.FramePadding.y * 2\r\n    emscripten::function(\"GetFrameHeight\", &ImGui::GetFrameHeight);\r\n    // IMGUI_API float         GetFrameHeightWithSpacing();                                        // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)\r\n    emscripten::function(\"GetFrameHeightWithSpacing\", &ImGui::GetFrameHeightWithSpacing);\r\n\r\n    // Columns\r\n    // You can also use SameLine(pos_x) for simplified columns. The columns API is still work-in-progress and rather lacking.\r\n    // IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);\r\n    emscripten::function(\"Columns\", FUNCTION(void, (int count, emscripten::val id, bool border), {\r\n        ImGui::Columns(count, import_maybe_null_string(id), border);\r\n    }));\r\n    // IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished\r\n    emscripten::function(\"NextColumn\", &ImGui::NextColumn);\r\n    // IMGUI_API int           GetColumnIndex();                                                   // get current column index\r\n    emscripten::function(\"GetColumnIndex\", &ImGui::GetColumnIndex);\r\n    // IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column\r\n    emscripten::function(\"GetColumnWidth\", &ImGui::GetColumnWidth);\r\n    // IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column\r\n    emscripten::function(\"SetColumnWidth\", &ImGui::SetColumnWidth);\r\n    // IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f\r\n    emscripten::function(\"GetColumnOffset\", &ImGui::GetColumnOffset);\r\n    // IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column\r\n    emscripten::function(\"SetColumnOffset\", &ImGui::SetColumnOffset);\r\n    // IMGUI_API int           GetColumnsCount();\r\n    emscripten::function(\"GetColumnsCount\", &ImGui::GetColumnsCount);\r\n\r\n    // ID scopes\r\n    // If you are creating widgets in a loop you most likely want to push a unique identifier (e.g. object pointer, loop index) so ImGui can differentiate them.\r\n    // You can also use the \"##foobar\" syntax within widget label to distinguish them from each others. Read \"A primer on the use of labels/IDs\" in the FAQ for more details.\r\n    // IMGUI_API void          PushID(const char* str_id);                                         // push identifier into the ID stack. IDs are hash of the entire stack!\r\n    // IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);\r\n    // IMGUI_API void          PushID(const void* ptr_id);\r\n    // IMGUI_API void          PushID(int int_id);\r\n    emscripten::function(\"PushID\", FUNCTION(void, (emscripten::val id), {\r\n        if (id.typeOf().strictlyEquals(emscripten::val(\"number\"))) {\r\n            return ImGui::PushID(id.as<int>());\r\n        } else {\r\n            return ImGui::PushID(id.as<std::string>().c_str());\r\n        }\r\n    }));\r\n    // IMGUI_API void          PopID();\r\n    emscripten::function(\"PopID\", &ImGui::PopID);\r\n    // IMGUI_API ImGuiID       GetID(const char* str_id);                                          // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself\r\n    // IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);\r\n    // IMGUI_API ImGuiID       GetID(const void* ptr_id);\r\n    emscripten::function(\"GetID\", FUNCTION(ImGuiID, (emscripten::val id), {\r\n        if (id.typeOf().strictlyEquals(emscripten::val(\"number\"))) {\r\n            return ImGui::GetID((const void*) id.as<int>());\r\n        } else {\r\n            return ImGui::GetID(id.as<std::string>().c_str());\r\n        }\r\n    }));\r\n\r\n    // Widgets: Text\r\n    // IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);               // raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.\r\n    emscripten::function(\"TextUnformatted\", FUNCTION(void, (std::string text), { ImGui::TextUnformatted(text.c_str(), NULL); }));\r\n    // IMGUI_API void          Text(const char* fmt, ...)                                     IM_FMTARGS(1); // simple formatted text\r\n    emscripten::function(\"Text\", FUNCTION(void, (std::string fmt), { ImGui::Text(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextV(const char* fmt, va_list args)                           IM_FMTLIST(1);\r\n    emscripten::function(\"TextV\", FUNCTION(void, (std::string fmt), { ImGui::Text(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)           IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();\r\n    emscripten::function(\"TextColored\", FUNCTION(void, (emscripten::val col, std::string fmt), { ImGui::TextColored(import_ImVec4(col), \"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    emscripten::function(\"TextColoredV\", FUNCTION(void, (emscripten::val col, std::string fmt), { ImGui::TextColored(import_ImVec4(col), \"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextDisabled(const char* fmt, ...)                             IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();\r\n    emscripten::function(\"TextDisabled\", FUNCTION(void, (std::string fmt), { ImGui::TextDisabled(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                   IM_FMTLIST(1);\r\n    emscripten::function(\"TextDisabledV\", FUNCTION(void, (std::string fmt), { ImGui::TextDisabled(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextWrapped(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().\r\n    emscripten::function(\"TextWrapped\", FUNCTION(void, (std::string fmt), { ImGui::TextWrapped(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                    IM_FMTLIST(1);\r\n    emscripten::function(\"TextWrappedV\", FUNCTION(void, (std::string fmt), { ImGui::TextWrapped(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          LabelText(const char* label, const char* fmt, ...)             IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets\r\n    emscripten::function(\"LabelText\", FUNCTION(void, (std::string label, std::string fmt), { ImGui::LabelText(label.c_str(), \"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)   IM_FMTLIST(2);\r\n    emscripten::function(\"LabelTextV\", FUNCTION(void, (std::string label, std::string fmt), { ImGui::LabelText(label.c_str(), \"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          BulletText(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for Bullet()+Text()\r\n    emscripten::function(\"BulletText\", FUNCTION(void, (std::string fmt), { ImGui::BulletText(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          BulletTextV(const char* fmt, va_list args)                     IM_FMTLIST(1);\r\n    emscripten::function(\"BulletTextV\", FUNCTION(void, (std::string fmt), { ImGui::BulletText(\"%s\", fmt.c_str()); }));\r\n    // IMGUI_API void          Bullet();                                                                     // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses\r\n    emscripten::function(\"Bullet\", &ImGui::Bullet);\r\n\r\n    // Widgets: Main\r\n    // IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));            // button\r\n    emscripten::function(\"Button\", FUNCTION(bool, (std::string label, emscripten::val size), {\r\n        return ImGui::Button(label.c_str(), import_ImVec2(size));\r\n    }));\r\n    // IMGUI_API bool          SmallButton(const char* label);                                         // button with FramePadding=(0,0) to easily embed within text\r\n    emscripten::function(\"SmallButton\", FUNCTION(bool, (std::string label), { return ImGui::SmallButton(label.c_str()); }));\r\n    // IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape\r\n    emscripten::function(\"ArrowButton\", FUNCTION(bool, (std::string label, int dir), { return ImGui::ArrowButton(label.c_str(), dir); }));\r\n    // IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);                // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)\r\n    emscripten::function(\"InvisibleButton\", FUNCTION(bool, (std::string str_id, emscripten::val size), { return ImGui::InvisibleButton(str_id.c_str(), import_ImVec2(size)); }));\r\n    // IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));\r\n    emscripten::function(\"Image\", FUNCTION(void, (emscripten::val user_texture_id, emscripten::val size, emscripten::val uv0, emscripten::val uv1, emscripten::val tint_col, emscripten::val border_col), {\r\n        ImGui::Image((ImTextureID) user_texture_id.as<int>(), import_ImVec2(size), import_ImVec2(uv0), import_ImVec2(uv1), import_ImVec4(tint_col), import_ImVec4(border_col));\r\n    }));\r\n    // IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding\r\n    emscripten::function(\"ImageButton\", FUNCTION(bool, (emscripten::val user_texture_id, emscripten::val size, emscripten::val uv0, emscripten::val uv1, int frame_padding, emscripten::val bg_col, emscripten::val tint_col), {\r\n        return ImGui::ImageButton((ImTextureID) user_texture_id.as<int>(), import_ImVec2(size), import_ImVec2(uv0), import_ImVec2(uv1), frame_padding, import_ImVec4(bg_col), import_ImVec4(tint_col));\r\n    }));\r\n    // IMGUI_API bool          Checkbox(const char* label, bool* v);\r\n    emscripten::function(\"Checkbox\", FUNCTION(bool, (std::string label, emscripten::val v), {\r\n        return ImGui::Checkbox(label.c_str(), access_value<bool>(v));\r\n    }));\r\n    // IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);\r\n    emscripten::function(\"CheckboxFlags\", FUNCTION(bool, (std::string label, emscripten::val flags, unsigned int flags_value), {\r\n        return ImGui::CheckboxFlags(label.c_str(), access_value<unsigned int>(flags), flags_value);\r\n    }));\r\n    // IMGUI_API bool          RadioButton(const char* label, bool active);\r\n    // IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);\r\n    emscripten::function(\"RadioButton_A\", FUNCTION(bool, (std::string label, bool active), {\r\n        return ImGui::RadioButton(label.c_str(), active);\r\n    }));\r\n    emscripten::function(\"RadioButton_B\", FUNCTION(bool, (std::string label, emscripten::val v, int v_button), {\r\n        return ImGui::RadioButton(label.c_str(), access_value<int>(v), v_button);\r\n    }));\r\n    // IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));\r\n    // IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));\r\n    emscripten::function(\"PlotLines\", FUNCTION(void, (std::string label, emscripten::val values_getter, emscripten::val data, int values_count, int values_offset, emscripten::val overlay_text, emscripten::val scale_min, emscripten::val scale_max, emscripten::val graph_size), {\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        ctx->_ImGui_PlotLines_values_getter = values_getter;\r\n        ctx->_ImGui_PlotLines_data = data;\r\n        ImGui::PlotLines(label.c_str(), FUNCTION(float, (void* data, int idx), {\r\n            WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n            return import_value<float>(ctx->_ImGui_PlotLines_values_getter(ctx->_ImGui_PlotLines_data, emscripten::val(idx)));\r\n        }), NULL, values_count, values_offset, import_maybe_null_string(overlay_text), import_value<float>(scale_min), import_value<float>(scale_max), import_ImVec2(graph_size));\r\n    }));\r\n    // IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));\r\n    // IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));\r\n    emscripten::function(\"PlotHistogram\", FUNCTION(void, (std::string label, emscripten::val values_getter, emscripten::val data, int values_count, int values_offset, emscripten::val overlay_text, emscripten::val scale_min, emscripten::val scale_max, emscripten::val graph_size), {\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        ctx->_ImGui_PlotHistogram_values_getter = values_getter;\r\n        ctx->_ImGui_PlotHistogram_data = data;\r\n        ImGui::PlotHistogram(label.c_str(), FUNCTION(float, (void* data, int idx), {\r\n            WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n            return import_value<float>(ctx->_ImGui_PlotHistogram_values_getter(ctx->_ImGui_PlotHistogram_data, emscripten::val(idx)));\r\n        }), NULL, values_count, values_offset, import_maybe_null_string(overlay_text), import_value<float>(scale_min), import_value<float>(scale_max), import_ImVec2(graph_size));\r\n    }));\r\n    // IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);\r\n    emscripten::function(\"ProgressBar\", FUNCTION(void, (float fraction, emscripten::val size_arg, emscripten::val overlay), {\r\n        ImGui::ProgressBar(fraction, import_ImVec2(size_arg), import_maybe_null_string(overlay));\r\n    }));\r\n\r\n    // Widgets: Combo Box\r\n    // The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it. \r\n    // The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.\r\n    // IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);\r\n    emscripten::function(\"BeginCombo\", FUNCTION(bool, (std::string label, emscripten::val preview_value, ImGuiComboFlags flags), {\r\n        return ImGui::BeginCombo(label.c_str(), import_maybe_null_string(preview_value), flags);\r\n    }));\r\n    // IMGUI_API void          EndCombo();\r\n    emscripten::function(\"EndCombo\", &ImGui::EndCombo);\r\n    // IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);\r\n    // IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\"\r\n    // IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);\r\n    emscripten::function(\"Combo\", FUNCTION(bool, (std::string label, emscripten::val current_item, emscripten::val items_getter, emscripten::val data, int items_count, int popup_max_height_in_items), {\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        ctx->_ImGui_Combo_items_getter = items_getter;\r\n        ctx->_ImGui_Combo_data = data;\r\n        ctx->_ImGui_Combo_items_count = items_count;\r\n        return ImGui::Combo(label.c_str(), access_value<int>(current_item), FUNCTION(bool, (void* data, int idx, const char** out_text), {\r\n            WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n            if (0 <= idx && idx < ctx->_ImGui_Combo_items_count) {\r\n                ctx->_ImGui_Combo_text = \"\";\r\n                emscripten::val _out_text = emscripten::val::array();\r\n                _out_text[0] = emscripten::val(ctx->_ImGui_Combo_text);\r\n                emscripten::val ret = ctx->_ImGui_Combo_items_getter(ctx->_ImGui_Combo_data, emscripten::val(idx), _out_text);\r\n                ctx->_ImGui_Combo_text = _out_text[0].as<std::string>();\r\n                *out_text = ctx->_ImGui_Combo_text.c_str();\r\n                return ret.as<bool>();\r\n            } else {\r\n                return false;\r\n            }\r\n        }), NULL, items_count, popup_max_height_in_items);\r\n    }));\r\n\r\n    // Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x\r\n    // IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);     // If v_min >= v_max we have no bound\r\n    emscripten::function(\"DragFloat\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::DragFloat(label.c_str(), access_value<float>(v), import_value<float>(v_speed), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"DragFloat2\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::DragFloat2(label.c_str(), access_value<float, 2>(v), import_value<float>(v_speed), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"DragFloat3\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::DragFloat3(label.c_str(), access_value<float, 3>(v), import_value<float>(v_speed), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"DragFloat4\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::DragFloat4(label.c_str(), access_value<float, 4>(v), import_value<float>(v_speed), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", const char* display_format_max = NULL, float power = 1.0f);\r\n    emscripten::function(\"DragFloatRange2\", FUNCTION(bool, (std::string label, emscripten::val v_current_min, emscripten::val v_current_max, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val display_format_max, emscripten::val power), {\r\n        return ImGui::DragFloatRange2(label.c_str(), access_value<float>(v_current_min), access_value<float>(v_current_max), import_value<float>(v_speed), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_maybe_null_string(display_format_max), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%.0f\");                                       // If v_min >= v_max we have no bound\r\n    emscripten::function(\"DragInt\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::DragInt(label.c_str(), access_value<int>(v), import_value<float>(v_speed), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%.0f\");\r\n    emscripten::function(\"DragInt2\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::DragInt2(label.c_str(), access_value<int, 2>(v), import_value<float>(v_speed), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%.0f\");\r\n    emscripten::function(\"DragInt3\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::DragInt3(label.c_str(), access_value<int, 3>(v), import_value<float>(v_speed), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%.0f\");\r\n    emscripten::function(\"DragInt4\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_speed, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::DragInt4(label.c_str(), access_value<int, 4>(v), import_value<float>(v_speed), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%.0f\", const char* display_format_max = NULL);\r\n    emscripten::function(\"DragIntRange2\", FUNCTION(bool, (std::string label, emscripten::val v_current_min, emscripten::val v_current_max, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val display_format_max), {\r\n        return ImGui::DragIntRange2(label.c_str(), access_value<int>(v_current_min), access_value<int>(v_current_max), import_value<float>(v_speed), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_maybe_null_string(display_format_max));\r\n    }));\r\n    // IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);\r\n    // IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);\r\n    emscripten::function(\"DragScalar\", FUNCTION(bool, (std::string label, ImGuiDataType data_type, emscripten::val v, emscripten::val v_speed, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        switch (data_type) {\r\n            case ImGuiDataType_S32:\r\n                return ImGui::DragScalarV<ImS32>(label.c_str(), data_type, access_typed_array<ImS32>(v), import_value<float>(v_speed), import_maybe_null_value<ImS32>(v_min), import_maybe_null_value<ImS32>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_U32:\r\n                return ImGui::DragScalarV<ImU32>(label.c_str(), data_type, access_typed_array<ImU32>(v), import_value<float>(v_speed), import_maybe_null_value<ImU32>(v_min), import_maybe_null_value<ImU32>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            // case ImGuiDataType_S64:\r\n            //     return ImGui::DragScalarV<ImS64>(label.c_str(), data_type, access_typed_array<ImS64>(v), import_value<float>(v_speed), import_maybe_null_value<ImS64>(v_min), import_maybe_null_value<ImS64>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            // case ImGuiDataType_U64:\r\n            //     return ImGui::DragScalarV<ImU64>(label.c_str(), data_type, access_typed_array<ImU64>(v), import_value<float>(v_speed), import_maybe_null_value<ImU64>(v_min), import_maybe_null_value<ImU64>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_Float:\r\n                return ImGui::DragScalarV<float>(label.c_str(), data_type, access_typed_array<float>(v), import_value<float>(v_speed), import_maybe_null_value<float>(v_min), import_maybe_null_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_Double:\r\n                return ImGui::DragScalarV<double>(label.c_str(), data_type, access_typed_array<double>(v), import_value<float>(v_speed), import_maybe_null_value<double>(v_min), import_maybe_null_value<double>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n        }\r\n        return false;\r\n    }));\r\n\r\n    // Widgets: Input with Keyboard\r\n    // IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    emscripten::function(\"InputText\", FUNCTION(bool, (std::string label, emscripten::val buf, size_t buf_size, ImGuiInputTextFlags flags, emscripten::val callback, emscripten::val user_data), {\r\n        std::string _buf = buf[0].as<std::string>();\r\n        _buf.reserve(buf_size);\r\n        bool ret = false;\r\n        if (!callback.isNull()) {\r\n            WrapImGuiContext::GetCurrentContext()->_ImGui_InputText_callback = callback;\r\n            ret = ImGui::InputText(label.c_str(), (char*) _buf.data(), buf_size, flags, FUNCTION(int, (ImGuiInputTextCallbackData* data), {\r\n                return WrapImGuiContext::GetCurrentContext()->_ImGui_InputText_callback(emscripten::val(data)).as<int>();\r\n            }), NULL);\r\n        } else {\r\n            ret = ImGui::InputText(label.c_str(), (char*) _buf.data(), buf_size, flags);\r\n        }\r\n        std::string out_buf (_buf.c_str());\r\n        buf.set(0, out_buf);\r\n        return ret;\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    emscripten::function(\"InputTextMultiline\", FUNCTION(bool, (std::string label, emscripten::val buf, size_t buf_size, emscripten::val size, ImGuiInputTextFlags flags, emscripten::val callback, emscripten::val user_data), {\r\n        std::string _buf = buf[0].as<std::string>();\r\n        _buf.reserve(buf_size);\r\n        bool ret = false;\r\n        if (!callback.isNull()) {\r\n            WrapImGuiContext::GetCurrentContext()->_ImGui_InputTextMultiline_callback = callback;\r\n            ret = ImGui::InputTextMultiline(label.c_str(), (char*) _buf.data(), buf_size, import_ImVec2(size), flags, FUNCTION(int, (ImGuiInputTextCallbackData* data), {\r\n                return WrapImGuiContext::GetCurrentContext()->_ImGui_InputTextMultiline_callback(emscripten::val(data)).as<int>();\r\n            }), NULL);\r\n        } else {\r\n            ret = ImGui::InputTextMultiline(label.c_str(), (char*) _buf.data(), buf_size, import_ImVec2(size), flags);\r\n        }\r\n        std::string out_buf (_buf.c_str());\r\n        buf.set(0, out_buf);\r\n        return ret;\r\n    }));\r\n    // IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputFloat\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val step, emscripten::val step_fast, emscripten::val format, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputFloat(label.c_str(), access_value<float>(v), import_value<float>(step), import_value<float>(step_fast), import_maybe_null_string(format), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputFloat2\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val format, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputFloat2(label.c_str(), access_value<float, 2>(v), import_maybe_null_string(format), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputFloat3\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val format, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputFloat3(label.c_str(), access_value<float, 3>(v), import_maybe_null_string(format), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputFloat4\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val format, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputFloat4(label.c_str(), access_value<float, 4>(v), import_maybe_null_string(format), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputInt\", FUNCTION(bool, (std::string label, emscripten::val v, int step, int step_fast, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputInt(label.c_str(), access_value<int>(v), step, step_fast, extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputInt2\", FUNCTION(bool, (std::string label, emscripten::val v, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputInt2(label.c_str(), access_value<int, 2>(v), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputInt3\", FUNCTION(bool, (std::string label, emscripten::val v, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputInt3(label.c_str(), access_value<int, 3>(v), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputInt4\", FUNCTION(bool, (std::string label, emscripten::val v, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputInt4(label.c_str(), access_value<int, 4>(v), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0f, double step_fast = 0.0f, const char* format = \"%.6f\", ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputDouble\", FUNCTION(bool, (std::string label, emscripten::val v, double step, double step_fast, emscripten::val format, ImGuiInputTextFlags extra_flags), {\r\n        return ImGui::InputDouble(label.c_str(), access_value<double>(v), step, step_fast, import_maybe_null_string(format), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);\r\n    // IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);\r\n    emscripten::function(\"InputScalar\", FUNCTION(bool, (std::string label, ImGuiDataType data_type, emscripten::val v, emscripten::val step, emscripten::val step_fast, emscripten::val format, ImGuiInputTextFlags extra_flags), {\r\n        switch (data_type) {\r\n            case ImGuiDataType_S32:\r\n                return ImGui::InputScalarV<ImS32>(label.c_str(), data_type, access_typed_array<ImS32>(v), import_maybe_null_value<ImS32>(step), import_maybe_null_value<ImS32>(step_fast), import_maybe_null_string(format), extra_flags);\r\n            case ImGuiDataType_U32:\r\n                return ImGui::InputScalarV<ImU32>(label.c_str(), data_type, access_typed_array<ImU32>(v), import_maybe_null_value<ImU32>(step), import_maybe_null_value<ImU32>(step_fast), import_maybe_null_string(format), extra_flags);\r\n            // case ImGuiDataType_S64:\r\n            //     return ImGui::InputScalarV<ImS64>(label.c_str(), data_type, access_typed_array<ImS64>(v), import_maybe_null_value<ImS64>(step), import_maybe_null_value<ImS64>(step_fast), import_maybe_null_string(format), extra_flags);\r\n            // case ImGuiDataType_U64:\r\n            //     return ImGui::InputScalarV<ImU64>(label.c_str(), data_type, access_typed_array<ImU64>(v), import_maybe_null_value<ImU64>(step), import_maybe_null_value<ImU64>(step_fast), import_maybe_null_string(format), extra_flags);\r\n            case ImGuiDataType_Float:\r\n                return ImGui::InputScalarV<float>(label.c_str(), data_type, access_typed_array<float>(v), import_maybe_null_value<float>(step), import_maybe_null_value<float>(step_fast), import_maybe_null_string(format), extra_flags);\r\n            case ImGuiDataType_Double:\r\n                return ImGui::InputScalarV<double>(label.c_str(), data_type, access_typed_array<double>(v), import_maybe_null_value<double>(step), import_maybe_null_value<double>(step_fast), import_maybe_null_string(format), extra_flags);\r\n        }\r\n        return false;\r\n    }));\r\n\r\n    // Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for logarithmic sliders\r\n    emscripten::function(\"SliderFloat\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::SliderFloat(label.c_str(), access_value<float>(v), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"SliderFloat2\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::SliderFloat2(label.c_str(), access_value<float, 2>(v), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"SliderFloat3\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::SliderFloat3(label.c_str(), access_value<float, 3>(v), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"SliderFloat4\", FUNCTION(bool, (std::string label, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::SliderFloat4(label.c_str(), access_value<float, 4>(v), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);\r\n    emscripten::function(\"SliderAngle\", FUNCTION(bool, (std::string label, emscripten::val v_rad, emscripten::val v_degrees_min, emscripten::val v_degrees_max), {\r\n        return ImGui::SliderAngle(label.c_str(), access_value<float>(v_rad), import_value<float>(v_degrees_min), import_value<float>(v_degrees_max));\r\n    }));\r\n    // IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = \"%.0f\");\r\n    emscripten::function(\"SliderInt\", FUNCTION(bool, (std::string label, emscripten::val v, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::SliderInt(label.c_str(), access_value<int>(v), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = \"%.0f\");\r\n    emscripten::function(\"SliderInt2\", FUNCTION(bool, (std::string label, emscripten::val v, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::SliderInt2(label.c_str(), access_value<int, 2>(v), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = \"%.0f\");\r\n    emscripten::function(\"SliderInt3\", FUNCTION(bool, (std::string label, emscripten::val v, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::SliderInt3(label.c_str(), access_value<int, 3>(v), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = \"%.0f\");\r\n    emscripten::function(\"SliderInt4\", FUNCTION(bool, (std::string label, emscripten::val v, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::SliderInt4(label.c_str(), access_value<int, 4>(v), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    // IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    emscripten::function(\"SliderScalar\", FUNCTION(bool, (std::string label, ImGuiDataType data_type, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        switch (data_type) {\r\n            case ImGuiDataType_S32:\r\n                return ImGui::SliderScalarV<ImS32>(label.c_str(), data_type, access_typed_array<ImS32>(v), import_maybe_null_value<ImS32>(v_min), import_maybe_null_value<ImS32>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_U32:\r\n                return ImGui::SliderScalarV<ImU32>(label.c_str(), data_type, access_typed_array<ImU32>(v), import_maybe_null_value<ImU32>(v_min), import_maybe_null_value<ImU32>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            // case ImGuiDataType_S64:\r\n            //     return ImGui::SliderScalarV<ImS64>(label.c_str(), data_type, access_typed_array<ImS64>(v), import_maybe_null_value<ImS64>(v_min), import_maybe_null_value<ImS64>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            // case ImGuiDataType_U64:\r\n            //     return ImGui::SliderScalarV<ImU64>(label.c_str(), data_type, access_typed_array<ImU64>(v), import_maybe_null_value<ImU64>(v_min), import_maybe_null_value<ImU64>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_Float:\r\n                return ImGui::SliderScalarV<float>(label.c_str(), data_type, access_typed_array<float>(v), import_maybe_null_value<float>(v_min), import_maybe_null_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_Double:\r\n                return ImGui::SliderScalarV<double>(label.c_str(), data_type, access_typed_array<double>(v), import_maybe_null_value<double>(v_min), import_maybe_null_value<double>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n        }\r\n        return false;\r\n    }));\r\n    // IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    emscripten::function(\"VSliderFloat\", FUNCTION(bool, (std::string label, emscripten::val size, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        return ImGui::VSliderFloat(label.c_str(), import_ImVec2(size), access_value<float>(v), import_value<float>(v_min), import_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n    }));\r\n    // IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = \"%.0f\");\r\n    emscripten::function(\"VSliderInt\", FUNCTION(bool, (std::string label, emscripten::val size, emscripten::val v, int v_min, int v_max, emscripten::val format), {\r\n        return ImGui::VSliderInt(label.c_str(), import_ImVec2(size), access_value<int>(v), v_min, v_max, import_maybe_null_string(format));\r\n    }));\r\n    // IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    emscripten::function(\"VSliderScalar\", FUNCTION(bool, (std::string label, emscripten::val size, ImGuiDataType data_type, emscripten::val v, emscripten::val v_min, emscripten::val v_max, emscripten::val format, emscripten::val power), {\r\n        switch (data_type) {\r\n            case ImGuiDataType_S32:\r\n                return ImGui::VSliderScalar(label.c_str(), import_ImVec2(size), data_type, access_typed_array<ImS32>(v).data(), import_maybe_null_value<ImS32>(v_min), import_maybe_null_value<ImS32>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_U32:\r\n                return ImGui::VSliderScalar(label.c_str(), import_ImVec2(size), data_type, access_typed_array<ImU32>(v).data(), import_maybe_null_value<ImU32>(v_min), import_maybe_null_value<ImU32>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            // case ImGuiDataType_S64:\r\n            //     return ImGui::VSliderScalar(label.c_str(), import_ImVec2(size), data_type, access_typed_array<ImS64>(v).data(), import_maybe_null_value<ImS64>(v_min), import_maybe_null_value<ImS64>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            // case ImGuiDataType_U64:\r\n            //     return ImGui::VSliderScalar(label.c_str(), import_ImVec2(size), data_type, access_typed_array<ImU64>(v).data(), import_maybe_null_value<ImU64>(v_min), import_maybe_null_value<ImU64>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_Float:\r\n                return ImGui::VSliderScalar(label.c_str(), import_ImVec2(size), data_type, access_typed_array<float>(v).data(), import_maybe_null_value<float>(v_min), import_maybe_null_value<float>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n            case ImGuiDataType_Double:\r\n                return ImGui::VSliderScalar(label.c_str(), import_ImVec2(size), data_type, access_typed_array<double>(v).data(), import_maybe_null_value<double>(v_min), import_maybe_null_value<double>(v_max), import_maybe_null_string(format), import_value<float>(power));\r\n        }\r\n        return false;\r\n    }));\r\n\r\n    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)\r\n    // Note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x\r\n    // IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    emscripten::function(\"ColorEdit3\", FUNCTION(bool, (std::string label, emscripten::val col, ImGuiColorEditFlags flags), {\r\n        return ImGui::ColorEdit3(label.c_str(), access_value<float, 3>(col), flags);\r\n    }));\r\n    // IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);\r\n    emscripten::function(\"ColorEdit4\", FUNCTION(bool, (std::string label, emscripten::val col, ImGuiColorEditFlags flags), {\r\n        return ImGui::ColorEdit4(label.c_str(), access_value<float, 4>(col), flags);\r\n    }));\r\n    // IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    emscripten::function(\"ColorPicker3\", FUNCTION(bool, (std::string label, emscripten::val col, ImGuiColorEditFlags flags), {\r\n        return ImGui::ColorPicker3(label.c_str(), access_value<float, 3>(col), flags);\r\n    }));\r\n    // IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);\r\n    emscripten::function(\"ColorPicker4\", FUNCTION(bool, (std::string label, emscripten::val col, ImGuiColorEditFlags flags, emscripten::val ref_col), {\r\n        return ImGui::ColorPicker4(label.c_str(), access_value<float, 4>(col), flags, access_maybe_null_value<float, 4>(ref_col));\r\n    }));\r\n    // IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.\r\n    emscripten::function(\"ColorButton\", FUNCTION(bool, (std::string label, emscripten::val col, ImGuiColorEditFlags flags, emscripten::val size), {\r\n        return ImGui::ColorButton(label.c_str(), import_ImVec4(col), flags, import_ImVec2(size));\r\n    }));\r\n    // IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                         // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.\r\n    emscripten::function(\"SetColorEditOptions\", &ImGui::SetColorEditOptions);\r\n\r\n    // Widgets: Trees\r\n    // IMGUI_API bool          TreeNode(const char* label);                                            // if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().\r\n    // IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);       // read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().\r\n    // IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);       // \"\r\n    // IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    // IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    emscripten::function(\"TreeNode_A\", FUNCTION(bool, (std::string label), {\r\n        return ImGui::TreeNode(label.c_str());\r\n    }));\r\n    emscripten::function(\"TreeNode_B\", FUNCTION(bool, (std::string str_id, std::string fmt), {\r\n        return ImGui::TreeNode(str_id.c_str(), \"%s\", fmt.c_str());\r\n    }));\r\n    emscripten::function(\"TreeNode_C\", FUNCTION(bool, (int ptr_id, std::string fmt), {\r\n        return ImGui::TreeNode((const void*) ptr_id, \"%s\", fmt.c_str());\r\n    }));\r\n    // IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);\r\n    // IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    // IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    // IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    // IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    emscripten::function(\"TreeNodeEx_A\", FUNCTION(bool, (std::string label, ImGuiTreeNodeFlags flags), {\r\n        return ImGui::TreeNodeEx(label.c_str(), flags);\r\n    }));\r\n    emscripten::function(\"TreeNodeEx_B\", FUNCTION(bool, (std::string str_id, ImGuiTreeNodeFlags flags, std::string fmt), {\r\n        return ImGui::TreeNodeEx(str_id.c_str(), flags, \"%s\", fmt.c_str());\r\n    }));\r\n    emscripten::function(\"TreeNodeEx_C\", FUNCTION(bool, (int ptr_id, ImGuiTreeNodeFlags flags, std::string fmt), {\r\n        return ImGui::TreeNodeEx((const void*) ptr_id, flags, \"%s\", fmt.c_str());    \r\n    }));\r\n    // IMGUI_API void          TreePush(const char* str_id);                                           // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call Push/Pop yourself for layout purpose\r\n    // IMGUI_API void          TreePush(const void* ptr_id = NULL);                                    // \"\r\n    emscripten::function(\"TreePush_A\", FUNCTION(void, (std::string str_id), {\r\n        ImGui::TreePush(str_id.c_str());\r\n    }));\r\n    emscripten::function(\"TreePush_B\", FUNCTION(void, (int ptr_id), {\r\n        ImGui::TreePush((const void*) ptr_id);\r\n    }));\r\n    // IMGUI_API void          TreePop();                                                              // ~ Unindent()+PopId()\r\n    emscripten::function(\"TreePop\", &ImGui::TreePop);\r\n    // IMGUI_API void          TreeAdvanceToLabelPos();                                                // advance cursor x position by GetTreeNodeToLabelSpacing()\r\n    emscripten::function(\"TreeAdvanceToLabelPos\", &ImGui::TreeAdvanceToLabelPos);\r\n    // IMGUI_API float         GetTreeNodeToLabelSpacing();                                            // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode\r\n    emscripten::function(\"GetTreeNodeToLabelSpacing\", &ImGui::GetTreeNodeToLabelSpacing);\r\n    // IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);                  // set next TreeNode/CollapsingHeader open state.\r\n    emscripten::function(\"SetNextTreeNodeOpen\", &ImGui::SetNextTreeNodeOpen);\r\n    // IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);      // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().\r\n    // IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header\r\n    emscripten::function(\"CollapsingHeader_A\", FUNCTION(bool, (std::string label, ImGuiTreeNodeFlags flags), {\r\n        return ImGui::CollapsingHeader(label.c_str(), flags);\r\n    }));\r\n    emscripten::function(\"CollapsingHeader_B\", FUNCTION(bool, (std::string label, emscripten::val p_open, ImGuiTreeNodeFlags flags), {\r\n        return ImGui::CollapsingHeader(label.c_str(), access_maybe_null_value<bool>(p_open), flags);\r\n    }));\r\n\r\n    // Widgets: Selectable / Lists\r\n    // IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height\r\n    // IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));\r\n    emscripten::function(\"Selectable_A\", FUNCTION(bool, (std::string label, bool selected, ImGuiSelectableFlags flags, emscripten::val size), {\r\n        return ImGui::Selectable(label.c_str(), selected, flags, import_ImVec2(size));    \r\n    }));\r\n    emscripten::function(\"Selectable_B\", FUNCTION(bool, (std::string label, emscripten::val p_selected, ImGuiSelectableFlags flags, emscripten::val size), {\r\n        return ImGui::Selectable(label.c_str(), access_maybe_null_value<bool>(p_selected), flags, import_ImVec2(size));\r\n    }));\r\n    // IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);\r\n    // IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);\r\n    emscripten::function(\"ListBox_A\", FUNCTION(bool, (std::string label, emscripten::val current_item, emscripten::val items, int items_count, int height_in_items), {\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        ctx->_ImGui_ListBox_A_items = items;\r\n        ctx->_ImGui_ListBox_A_items_count = items_count;\r\n        return ImGui::ListBox(label.c_str(), access_value<int>(current_item), FUNCTION(bool, (void* data, int idx, const char** out_text), {\r\n            WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n            if (0 <= idx && idx <= ctx->_ImGui_ListBox_A_items_count) {\r\n                ctx->_ImGui_ListBox_A_text = ctx->_ImGui_ListBox_A_items[idx].as<std::string>();\r\n                *out_text = ctx->_ImGui_ListBox_A_text.c_str();\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }), NULL, items_count, height_in_items);\r\n    }));\r\n    emscripten::function(\"ListBox_B\", FUNCTION(bool, (std::string label, emscripten::val current_item, emscripten::val items_getter, emscripten::val data, int items_count, int height_in_items), {\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        ctx->_ImGui_ListBox_B_items_getter = items_getter;\r\n        ctx->_ImGui_ListBox_B_data = data;\r\n        ctx->_ImGui_ListBox_B_items_count = items_count;\r\n        return ImGui::ListBox(label.c_str(), access_value<int>(current_item), FUNCTION(bool, (void* data, int idx, const char** out_text), {\r\n            WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n            if (0 <= idx && idx <= ctx->_ImGui_ListBox_B_items_count) {\r\n                ctx->_ImGui_ListBox_B_text = \"\";\r\n                emscripten::val _out_text = emscripten::val::array();\r\n                _out_text[0] = emscripten::val(ctx->_ImGui_ListBox_B_text);\r\n                emscripten::val ret = ctx->_ImGui_ListBox_B_items_getter(ctx->_ImGui_ListBox_B_data, emscripten::val(idx), _out_text);\r\n                ctx->_ImGui_ListBox_B_text = _out_text[0].as<std::string>();\r\n                *out_text = ctx->_ImGui_ListBox_B_text.c_str();\r\n                return ret.as<bool>();\r\n            } else {\r\n                return false;\r\n            }\r\n        }), NULL, items_count, height_in_items);\r\n    }));\r\n    // IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0));     // use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.\r\n    // IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // \"\r\n    emscripten::function(\"ListBoxHeader_A\", FUNCTION(bool, (std::string label, emscripten::val size), {\r\n        return ImGui::ListBoxHeader(label.c_str(), import_ImVec2(size));\r\n    }));\r\n    emscripten::function(\"ListBoxHeader_B\", FUNCTION(bool, (std::string label, int items_count, int height_in_items), {\r\n        return ImGui::ListBoxHeader(label.c_str(), items_count, height_in_items);\r\n    }));\r\n    // IMGUI_API void          ListBoxFooter();                                                        // terminate the scrolling region\r\n    emscripten::function(\"ListBoxFooter\", &ImGui::ListBoxFooter);\r\n\r\n    // Widgets: Value() Helpers. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)\r\n    // IMGUI_API void          Value(const char* prefix, bool b);\r\n    // IMGUI_API void          Value(const char* prefix, int v);\r\n    // IMGUI_API void          Value(const char* prefix, unsigned int v);\r\n    // IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);\r\n    emscripten::function(\"Value_A\", FUNCTION(void, (std::string prefix, bool b), {\r\n        ImGui::Value(prefix.c_str(), b);\r\n    }));\r\n    emscripten::function(\"Value_B\", FUNCTION(void, (std::string prefix, int v), {\r\n        ImGui::Value(prefix.c_str(), v);\r\n    }));\r\n    emscripten::function(\"Value_C\", FUNCTION(void, (std::string prefix, unsigned int v), {\r\n        ImGui::Value(prefix.c_str(), v);\r\n    }));\r\n    emscripten::function(\"Value_D\", FUNCTION(void, (std::string prefix, float v, emscripten::val float_format), {\r\n        ImGui::Value(prefix.c_str(), v, import_maybe_null_string(float_format));\r\n    }));\r\n\r\n    // Tooltips\r\n    // IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set text tooltip under mouse-cursor, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().\r\n    // IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);\r\n    emscripten::function(\"SetTooltip\", FUNCTION(void, (std::string fmt), {\r\n        ImGui::SetTooltip(\"%s\", fmt.c_str());\r\n    }));\r\n    // IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of contents).\r\n    emscripten::function(\"BeginTooltip\", &ImGui::BeginTooltip);\r\n    // IMGUI_API void          EndTooltip();\r\n    emscripten::function(\"EndTooltip\", &ImGui::EndTooltip);\r\n\r\n    // Menus\r\n    // IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!\r\n    emscripten::function(\"BeginMainMenuBar\", &ImGui::BeginMainMenuBar);\r\n    // IMGUI_API void          EndMainMenuBar();\r\n    emscripten::function(\"EndMainMenuBar\", &ImGui::EndMainMenuBar);\r\n    // IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window). only call EndMenuBar() if this returns true!\r\n    emscripten::function(\"BeginMenuBar\", &ImGui::BeginMenuBar);\r\n    // IMGUI_API void          EndMenuBar();\r\n    emscripten::function(\"EndMenuBar\", &ImGui::EndMenuBar);\r\n    // IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!\r\n    emscripten::function(\"BeginMenu\", FUNCTION(bool, (std::string label, bool enabled), {\r\n        return ImGui::BeginMenu(label.c_str(), enabled);\r\n    }));\r\n    // IMGUI_API void          EndMenu();\r\n    emscripten::function(\"EndMenu\", &ImGui::EndMenu);\r\n    // IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment\r\n    // IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL\r\n    emscripten::function(\"MenuItem_A\", FUNCTION(bool, (std::string label, emscripten::val shortcut, bool selected, bool enabled), {\r\n        return ImGui::MenuItem(label.c_str(), import_maybe_null_string(shortcut), selected, enabled);\r\n    }));\r\n    emscripten::function(\"MenuItem_B\", FUNCTION(bool, (std::string label, emscripten::val shortcut, emscripten::val p_selected, bool enabled), {\r\n        return ImGui::MenuItem(label.c_str(), import_maybe_null_string(shortcut), access_maybe_null_value<bool>(p_selected), enabled);\r\n    }));\r\n\r\n    // Popups\r\n    // IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).\r\n    emscripten::function(\"OpenPopup\", FUNCTION(void, (std::string str_id), { ImGui::OpenPopup(str_id.c_str()); }));\r\n    // IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item. return true when just opened.\r\n    emscripten::function(\"OpenPopupOnItemClick\", FUNCTION(bool, (emscripten::val str_id, int mouse_button), { return ImGui::OpenPopupOnItemClick(import_maybe_null_string(str_id), mouse_button); }));\r\n    // IMGUI_API bool          BeginPopup(const char* str_id);                                     // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returned true!\r\n    emscripten::function(\"BeginPopup\", FUNCTION(bool, (std::string str_id), { return ImGui::BeginPopup(str_id.c_str()); }));\r\n    // IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0);               // modal dialog (block interactions behind the modal window, can't close the modal window by clicking outside)\r\n    emscripten::function(\"BeginPopupModal\", FUNCTION(bool, (std::string name, emscripten::val p_open, ImGuiWindowFlags extra_flags), {\r\n        return ImGui::BeginPopupModal(name.c_str(), access_maybe_null_value<bool>(p_open), extra_flags);\r\n    }));\r\n    // IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!\r\n    emscripten::function(\"BeginPopupContextItem\", FUNCTION(bool, (emscripten::val str_id, int mouse_button), { return ImGui::BeginPopupContextItem(import_maybe_null_string(str_id), mouse_button); }));\r\n    // IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.\r\n    emscripten::function(\"BeginPopupContextWindow\", FUNCTION(bool, (emscripten::val str_id, int mouse_button, bool also_over_items), { return ImGui::BeginPopupContextWindow(import_maybe_null_string(str_id), mouse_button, also_over_items); }));\r\n    // IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).\r\n    emscripten::function(\"BeginPopupContextVoid\", FUNCTION(bool, (emscripten::val str_id, int mouse_button), { return ImGui::BeginPopupContextVoid(import_maybe_null_string(str_id), mouse_button); }));\r\n    // IMGUI_API void          EndPopup();\r\n    emscripten::function(\"EndPopup\", &ImGui::EndPopup);\r\n    // IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open\r\n    emscripten::function(\"IsPopupOpen\", FUNCTION(bool, (std::string str_id), { return ImGui::IsPopupOpen(str_id.c_str()); }));\r\n    // IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.\r\n    emscripten::function(\"CloseCurrentPopup\", &ImGui::CloseCurrentPopup);\r\n\r\n    // Logging/Capture: all text output from interface is captured to tty/file/clipboard. By default, tree nodes are automatically opened during logging.\r\n    // IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty\r\n    emscripten::function(\"LogToTTY\", &ImGui::LogToTTY);\r\n    // IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file\r\n    emscripten::function(\"LogToFile\", FUNCTION(void, (int max_depth, emscripten::val filename), {\r\n        ImGui::LogToFile(max_depth, import_maybe_null_string(filename));\r\n    }));\r\n    // IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard\r\n    emscripten::function(\"LogToClipboard\", &ImGui::LogToClipboard);\r\n    // IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)\r\n    emscripten::function(\"LogFinish\", &ImGui::LogFinish);\r\n    // IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard\r\n    emscripten::function(\"LogButtons\", &ImGui::LogButtons);\r\n    // IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)\r\n    emscripten::function(\"LogText\", FUNCTION(void, (std::string fmt), {\r\n        ImGui::LogText(\"%s\", fmt.c_str());\r\n    }));\r\n\r\n    // Drag and Drop\r\n    // [BETA API] Missing Demo code. API may evolve.\r\n    // IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0, int mouse_button = 0);                // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()\r\n    emscripten::function(\"BeginDragDropSource\", &ImGui::BeginDragDropSource);\r\n    // IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 8 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.\r\n    emscripten::function(\"SetDragDropPayload\", FUNCTION(bool, (std::string type, emscripten::val data, size_t size, ImGuiCond cond), {\r\n        WrapImGuiContext::GetCurrentContext()->_ImGui_DragDropPayload_data.set(type, data);\r\n        return ImGui::SetDragDropPayload(type.c_str(), NULL, 0, cond);\r\n    }));\r\n    // IMGUI_API void          EndDragDropSource();\r\n    emscripten::function(\"EndDragDropSource\", &ImGui::EndDragDropSource);\r\n    // IMGUI_API bool          BeginDragDropTarget();                                                                  // call after submitting an item that may receive an item. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()\r\n    emscripten::function(\"BeginDragDropTarget\", &ImGui::BeginDragDropTarget);\r\n    // IMGUI_API const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);            // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.\r\n    emscripten::function(\"AcceptDragDropPayload\", FUNCTION(emscripten::val, (std::string type, ImGuiDragDropFlags flags), {\r\n        const ImGuiPayload* _payload = ImGui::AcceptDragDropPayload(type.c_str(), flags);\r\n        if (_payload == NULL) { return emscripten::val::null(); }\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        emscripten::val data = ctx->_ImGui_DragDropPayload_data[type];\r\n        ctx->_ImGui_DragDropPayload_data.delete_(type);\r\n        emscripten::val payload = emscripten::val::object();\r\n        payload.set(\"Data\", data);\r\n        return payload;\r\n    }));\r\n    // IMGUI_API void          EndDragDropTarget();\r\n    emscripten::function(\"EndDragDropTarget\", &ImGui::EndDragDropTarget);\r\n    // IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.\r\n    emscripten::function(\"GetDragDropPayload\", FUNCTION(emscripten::val, (), {\r\n        return emscripten::val::null(); // TODO\r\n    }));\r\n\r\n    // Clipping\r\n    // IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);\r\n    emscripten::function(\"PushClipRect\", FUNCTION(void, (emscripten::val clip_rect_min, emscripten::val clip_rect_max, bool intersect_with_current_clip_rect), {\r\n        return ImGui::PushClipRect(import_ImVec2(clip_rect_min), import_ImVec2(clip_rect_max), intersect_with_current_clip_rect);\r\n    }));\r\n    // IMGUI_API void          PopClipRect();\r\n    emscripten::function(\"PopClipRect\", &ImGui::PopClipRect);\r\n\r\n    // Focus\r\n    // (FIXME: Those functions will be reworked after we merge the navigation branch + have a pass at focusing/tabbing features.)\r\n    // (Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHere()\" when applicable, to make your code more forward compatible when navigation branch is merged)\r\n    // IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window (WIP navigation branch only). Pleaase use instead of SetScrollHere().\r\n    emscripten::function(\"SetItemDefaultFocus\", &ImGui::SetItemDefaultFocus);\r\n    // IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.\r\n    emscripten::function(\"SetKeyboardFocusHere\", &ImGui::SetKeyboardFocusHere);\r\n\r\n    // Utilities\r\n    // IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.\r\n    emscripten::function(\"IsItemHovered\", &ImGui::IsItemHovered);\r\n    // IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)\r\n    emscripten::function(\"IsItemActive\", &ImGui::IsItemActive);\r\n    // IMGUI_API bool          IsItemEdited();\r\n    emscripten::function(\"IsItemEdited\", &ImGui::IsItemEdited);\r\n    // IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?\r\n    emscripten::function(\"IsItemFocused\", &ImGui::IsItemFocused);\r\n    // IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on)\r\n    emscripten::function(\"IsItemClicked\", &ImGui::IsItemClicked);\r\n    // IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (aka not out of sight due to clipping/scrolling.)\r\n    emscripten::function(\"IsItemVisible\", &ImGui::IsItemVisible);\r\n    // IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.\r\n    emscripten::function(\"IsItemDeactivated\", &ImGui::IsItemDeactivated);\r\n    // IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).\r\n    emscripten::function(\"IsItemDeactivatedAfterEdit\", &ImGui::IsItemDeactivatedAfterEdit);\r\n    // IMGUI_API bool          IsAnyItemHovered();\r\n    emscripten::function(\"IsAnyItemHovered\", &ImGui::IsAnyItemHovered);\r\n    // IMGUI_API bool          IsAnyItemActive();\r\n    emscripten::function(\"IsAnyItemActive\", &ImGui::IsAnyItemActive);\r\n    // IMGUI_API bool          IsAnyItemFocused();\r\n    emscripten::function(\"IsAnyItemFocused\", &ImGui::IsAnyItemFocused);\r\n    // IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rectangle of last item, in screen space\r\n    emscripten::function(\"GetItemRectMin\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetItemRectMin(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetItemRectMax();                                                   // \"\r\n    emscripten::function(\"GetItemRectMax\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetItemRectMax(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item, in screen space\r\n    emscripten::function(\"GetItemRectSize\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetItemRectSize(), out);\r\n    }));\r\n    // IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.\r\n    emscripten::function(\"SetItemAllowOverlap\", &ImGui::SetItemAllowOverlap);\r\n    // IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags = 0);                       // is current window focused? or its root/child, depending on flags. see flags for options.\r\n    emscripten::function(\"IsWindowFocused\", &ImGui::IsWindowFocused);\r\n    // IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags = 0);                       // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options.\r\n    emscripten::function(\"IsWindowHovered\", &ImGui::IsWindowHovered);\r\n    // IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.\r\n    // IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.\r\n    emscripten::function(\"IsRectVisible_A\", FUNCTION(bool, (emscripten::val size), {\r\n        return ImGui::IsRectVisible(import_ImVec2(size));\r\n    }));\r\n    emscripten::function(\"IsRectVisible_B\", FUNCTION(bool, (emscripten::val rect_min, emscripten::val rect_max), {\r\n        return ImGui::IsRectVisible(import_ImVec2(rect_min), import_ImVec2(rect_max));\r\n    }));\r\n    // IMGUI_API float         GetTime();\r\n    emscripten::function(\"GetTime\", &ImGui::GetTime);\r\n    // IMGUI_API int           GetFrameCount();\r\n    emscripten::function(\"GetFrameCount\", &ImGui::GetFrameCount);\r\n    // IMGUI_API ImDrawList*   GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text\r\n    emscripten::function(\"GetOverlayDrawList\", FUNCTION(emscripten::val, (), {\r\n        ImDrawList* p = ImGui::GetOverlayDrawList(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API ImDrawListSharedData* GetDrawListSharedData();\r\n    emscripten::function(\"GetDrawListSharedData\", FUNCTION(emscripten::val, (), {\r\n        ImDrawListSharedData* p = ImGui::GetDrawListSharedData(); return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);\r\n    emscripten::function(\"GetStyleColorName\", FUNCTION(std::string, (ImGuiCol idx), { return std::string(ImGui::GetStyleColorName(idx)); }));\r\n    // IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);\r\n    emscripten::function(\"CalcTextSize\", FUNCTION(emscripten::val, (std::string text, bool hide_text_after_double_hash, float wrap_width, emscripten::val out), {\r\n        return export_ImVec2(ImGui::CalcTextSize(text.c_str(), NULL, hide_text_after_double_hash, wrap_width), out);\r\n    }));\r\n    // IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.\r\n    emscripten::function(\"CalcListClipping\", FUNCTION(void, (int items_count, float items_height, emscripten::val out_items_display_start, emscripten::val out_items_display_end), {\r\n        ImGui::CalcListClipping(items_count, items_height, access_value<int>(out_items_display_start), access_value<int>(out_items_display_end));\r\n    }));\r\n\r\n    // IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0);    // helper to create a child window / scrolling region that looks like a normal widget frame\r\n    emscripten::function(\"BeginChildFrame\", &ImGui::BeginChildFrame);\r\n    // IMGUI_API void          EndChildFrame();\r\n    emscripten::function(\"EndChildFrame\", &ImGui::EndChildFrame);\r\n\r\n    // IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);\r\n    emscripten::function(\"ColorConvertU32ToFloat4\", FUNCTION(emscripten::val, (ImU32 in, emscripten::val out), {\r\n        return export_ImVec4(ImGui::ColorConvertU32ToFloat4(in), out);\r\n    }));\r\n    // IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);\r\n    emscripten::function(\"ColorConvertFloat4ToU32\", FUNCTION(ImU32, (emscripten::val in), {\r\n        return ImGui::ColorConvertFloat4ToU32(import_ImVec4(in));\r\n    }));\r\n    // IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);\r\n    emscripten::function(\"ColorConvertRGBtoHSV\", FUNCTION(void, (float r, float g, float b, emscripten::val out_h, emscripten::val out_s, emscripten::val out_v), {\r\n        ImGui::ColorConvertRGBtoHSV(r, g, b, access_value<float>(out_h), access_value<float>(out_s), access_value<float>(out_v));\r\n    }));\r\n    // IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);\r\n    emscripten::function(\"ColorConvertHSVtoRGB\", FUNCTION(void, (float h, float s, float v, emscripten::val out_r, emscripten::val out_g, emscripten::val out_b), {\r\n        ImGui::ColorConvertHSVtoRGB(h, s, v, access_value<float>(out_r), access_value<float>(out_g), access_value<float>(out_b));\r\n    }));\r\n\r\n    // Inputs\r\n    // IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]\r\n    emscripten::function(\"GetKeyIndex\", &ImGui::GetKeyIndex);\r\n    // IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices/enums according to how your backend/engine stored them into KeyDown[]!\r\n    emscripten::function(\"IsKeyDown\", &ImGui::IsKeyDown);\r\n    // IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate\r\n    emscripten::function(\"IsKeyPressed\", &ImGui::IsKeyPressed);\r\n    // IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..\r\n    emscripten::function(\"IsKeyReleased\", &ImGui::IsKeyReleased);\r\n    // IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate\r\n    emscripten::function(\"GetKeyPressedAmount\", &ImGui::GetKeyPressedAmount);\r\n    // IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held\r\n    emscripten::function(\"IsMouseDown\", &ImGui::IsMouseDown);\r\n    // IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held\r\n    emscripten::function(\"IsAnyMouseDown\", &ImGui::IsAnyMouseDown);\r\n    // IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down)\r\n    emscripten::function(\"IsMouseClicked\", &ImGui::IsMouseClicked);\r\n    // IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.\r\n    emscripten::function(\"IsMouseDoubleClicked\", &ImGui::IsMouseDoubleClicked);\r\n    // IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)\r\n    emscripten::function(\"IsMouseReleased\", &ImGui::IsMouseReleased);\r\n    // IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    emscripten::function(\"IsMouseDragging\", &ImGui::IsMouseDragging);\r\n    // IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings. disregarding of consideration of focus/window ordering/blocked by a popup.\r\n    emscripten::function(\"IsMouseHoveringRect\", FUNCTION(bool, (emscripten::val r_min, emscripten::val r_max, bool clip), {\r\n        return ImGui::IsMouseHoveringRect(import_ImVec2(r_min), import_ImVec2(r_max), clip);\r\n    }));\r\n    // IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //\r\n    emscripten::function(\"IsMousePosValid\", FUNCTION(bool, (emscripten::val mouse_pos), {\r\n        return ImGui::IsMousePosValid(import_maybe_null_value<ImVec2>(mouse_pos));\r\n    }));\r\n    // IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls\r\n    emscripten::function(\"GetMousePos\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetMousePos(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse positioning at the time of opening popup we have BeginPopup() into\r\n    emscripten::function(\"GetMousePosOnOpeningCurrentPopup\", FUNCTION(emscripten::val, (emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetMousePosOnOpeningCurrentPopup(), out);\r\n    }));\r\n    // IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    emscripten::function(\"GetMouseDragDelta\", FUNCTION(emscripten::val, (int button, float lock_threshold, emscripten::val out), {\r\n        return export_ImVec2(ImGui::GetMouseDragDelta(button, lock_threshold), out);\r\n    }));\r\n    // IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //\r\n    emscripten::function(\"ResetMouseDragDelta\", &ImGui::ResetMouseDragDelta);\r\n    // IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you\r\n    emscripten::function(\"GetMouseCursor\", &ImGui::GetMouseCursor);\r\n    // IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type\r\n    emscripten::function(\"SetMouseCursor\", &ImGui::SetMouseCursor);\r\n    // IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        // manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application handle). e.g. force capture keyboard when your widget is being hovered.\r\n    emscripten::function(\"CaptureKeyboardFromApp\", &ImGui::CaptureKeyboardFromApp);\r\n    // IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           // manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application handle).\r\n    emscripten::function(\"CaptureMouseFromApp\", &ImGui::CaptureMouseFromApp);\r\n\r\n    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)\r\n    // IMGUI_API const char*   GetClipboardText();\r\n    emscripten::function(\"GetClipboardText\", FUNCTION(std::string, (), {\r\n        const char* text = ImGui::GetClipboardText();\r\n        return (text != NULL) ? text : \"\";\r\n    }));\r\n    // IMGUI_API void          SetClipboardText(const char* text);\r\n    emscripten::function(\"SetClipboardText\", FUNCTION(void, (emscripten::val text), {\r\n        ImGui::SetClipboardText(text.as<std::string>().c_str());\r\n    }));\r\n\r\n    // Settings/.Ini Utilities\r\n    // The disk functions are automatically called if io.IniFilename != NULL (default is \"imgui.ini\").\r\n    // Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.\r\n    // IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).\r\n    // IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.\r\n    emscripten::function(\"LoadIniSettingsFromMemory\", FUNCTION(void, (std::string ini_data), {\r\n        ImGui::LoadIniSettingsFromMemory(ini_data.c_str());\r\n    }));\r\n    // IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);\r\n    // IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.\r\n    emscripten::function(\"SaveIniSettingsToMemory\", FUNCTION(std::string, (), {\r\n        return ImGui::SaveIniSettingsToMemory();\r\n    }));\r\n\r\n    // Memory Utilities\r\n    // All those functions are not reliant on the current context.\r\n    // If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again.\r\n    // IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data = NULL);\r\n    emscripten::function(\"SetAllocatorFunctions\", FUNCTION(void, (emscripten::val alloc_func, emscripten::val free_func, emscripten::val user_data), {\r\n        WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n        ctx->_ImGui_SetAllocatorFunctions_alloc_func = alloc_func;\r\n        ctx->_ImGui_SetAllocatorFunctions_free_func = free_func;\r\n        ctx->_ImGui_SetAllocatorFunctions_user_data = user_data;\r\n        if (alloc_func.isNull() || free_func.isNull()) {\r\n            ImGui::SetAllocatorFunctions(NULL, NULL, NULL);\r\n        } else {\r\n            ImGui::SetAllocatorFunctions(\r\n                FUNCTION(void*, (size_t sz, void* user_data), {\r\n                    WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n                    return ctx->_ImGui_SetAllocatorFunctions_alloc_func(emscripten::val(sz), ctx->_ImGui_SetAllocatorFunctions_user_data).as<void*>(emscripten::allow_raw_pointers());\r\n                }), \r\n                FUNCTION(void, (void* ptr, void* user_data), {\r\n                    WrapImGuiContext* ctx = WrapImGuiContext::GetCurrentContext();\r\n                    ctx->_ImGui_SetAllocatorFunctions_free_func(emscripten::val(ptr), ctx->_ImGui_SetAllocatorFunctions_user_data);\r\n                }), \r\n                NULL);\r\n        }\r\n    }));\r\n    // IMGUI_API void*         MemAlloc(size_t sz);\r\n    emscripten::function(\"MemAlloc\", FUNCTION(emscripten::val, (size_t sz), {\r\n        void* p = ImGui::MemAlloc(sz);\r\n        return emscripten::val(p);\r\n    }), emscripten::allow_raw_pointers());\r\n    // IMGUI_API void          MemFree(void* ptr);\r\n    emscripten::function(\"MemFree\", FUNCTION(void, (emscripten::val ptr), {\r\n        void* _ptr = ptr.as<void*>(emscripten::allow_raw_pointers());\r\n        ImGui::MemFree(_ptr);\r\n    }));\r\n}\r\n","/*\n * Copyright 2012 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n */\n\n#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/val.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stdint.h> // uintptr_t\n#include <emscripten/wire.h>\n#include <array>\n#include <vector>\n\n\nnamespace emscripten {\n\n    class val;\n\n    namespace internal {\n\n        template<typename WrapperType>\n        val wrapped_extend(const std::string&, const val&);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _emval_register_symbol(const char*);\n\n            enum {\n                _EMVAL_UNDEFINED = 1,\n                _EMVAL_NULL = 2,\n                _EMVAL_TRUE = 3,\n                _EMVAL_FALSE = 4\n            };\n\n            typedef struct _EM_VAL* EM_VAL;\n            typedef struct _EM_DESTRUCTORS* EM_DESTRUCTORS;\n            typedef struct _EM_METHOD_CALLER* EM_METHOD_CALLER;\n            typedef double EM_GENERIC_WIRE_TYPE;\n            typedef const void* EM_VAR_ARGS;\n\n            void _emval_incref(EM_VAL value);\n            void _emval_decref(EM_VAL value);\n\n            void _emval_run_destructors(EM_DESTRUCTORS handle);\n\n            EM_VAL _emval_new_array();\n            EM_VAL _emval_new_object();\n            EM_VAL _emval_new_cstring(const char*);\n\n            EM_VAL _emval_take_value(TYPEID type, EM_VAR_ARGS argv);\n\n            EM_VAL _emval_new(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            EM_VAL _emval_get_global(const char* name);\n            EM_VAL _emval_get_module_property(const char* name);\n            EM_VAL _emval_get_property(EM_VAL object, EM_VAL key);\n            void _emval_set_property(EM_VAL object, EM_VAL key, EM_VAL value);\n            EM_GENERIC_WIRE_TYPE _emval_as(EM_VAL value, TYPEID returnType, EM_DESTRUCTORS* destructors);\n\n            bool _emval_equals(EM_VAL first, EM_VAL second);\n            bool _emval_strictly_equals(EM_VAL first, EM_VAL second);\n            bool _emval_greater_than(EM_VAL first, EM_VAL second);\n            bool _emval_less_than(EM_VAL first, EM_VAL second);\n            bool _emval_not(EM_VAL object);\n\n            EM_VAL _emval_call(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            // DO NOT call this more than once per signature. It will\n            // leak generated function objects!\n            EM_METHOD_CALLER _emval_get_method_caller(\n                unsigned argCount, // including return value\n                const TYPEID argTypes[]);\n            EM_GENERIC_WIRE_TYPE _emval_call_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                EM_VAR_ARGS argv);\n            void _emval_call_void_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_VAR_ARGS argv);\n            EM_VAL _emval_typeof(EM_VAL value);\n            bool _emval_instanceof(EM_VAL object, EM_VAL constructor);\n            bool _emval_in(EM_VAL item, EM_VAL object);\n            bool _emval_delete(EM_VAL object, EM_VAL property);\n            bool _emval_throw(EM_VAL object);\n        }\n\n        template<const char* address>\n        struct symbol_registrar {\n            symbol_registrar() {\n                internal::_emval_register_symbol(address);\n            }\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct Signature {\n            /*\n            typedef typename BindingType<ReturnType>::WireType (*MethodCaller)(\n                EM_VAL value,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                typename BindingType<Args>::WireType...);\n            */\n\n            static EM_METHOD_CALLER get_method_caller() {\n                static EM_METHOD_CALLER mc = init_method_caller();\n                return mc;\n            }\n\n        private:\n            static EM_METHOD_CALLER init_method_caller() {\n                WithPolicies<>::ArgTypeList<ReturnType, Args...> args;\n                return _emval_get_method_caller(args.getCount(), args.getTypes());\n            }\n        };\n\n        struct DestructorsRunner {\n        public:\n            explicit DestructorsRunner(EM_DESTRUCTORS d)\n                : destructors(d)\n            {}\n            ~DestructorsRunner() {\n                _emval_run_destructors(destructors);\n            }\n\n            DestructorsRunner(const DestructorsRunner&) = delete;\n            void operator=(const DestructorsRunner&) = delete;\n\n        private:\n            EM_DESTRUCTORS destructors;\n        };\n\n        template<typename WireType>\n        struct GenericWireTypeConverter {\n            static WireType from(double wt) {\n                return static_cast<WireType>(wt);\n            }\n        };\n\n        template<typename Pointee>\n        struct GenericWireTypeConverter<Pointee*> {\n            static Pointee* from(double wt) {\n                return reinterpret_cast<Pointee*>(static_cast<uintptr_t>(wt));\n            }\n        };\n\n        template<typename T>\n        T fromGenericWireType(double g) {\n            typedef typename BindingType<T>::WireType WireType;\n            WireType wt = GenericWireTypeConverter<WireType>::from(g);\n            return BindingType<T>::fromWireType(wt);\n        }\n\n        template<typename... Args>\n        struct PackSize;\n\n        template<>\n        struct PackSize<> {\n            static constexpr size_t value = 0;\n        };\n\n        template<typename Arg, typename... Args>\n        struct PackSize<Arg, Args...> {\n            static constexpr size_t value = (sizeof(typename BindingType<Arg>::WireType) + 7) / 8 + PackSize<Args...>::value;\n        };\n\n        union GenericWireType {\n            union {\n                unsigned u;\n                float f;\n                const void* p;\n            } w[2];\n            double d;\n        };\n        static_assert(sizeof(GenericWireType) == 8, \"GenericWireType must be 8 bytes\");\n        static_assert(alignof(GenericWireType) == 8, \"GenericWireType must be 8-byte-aligned\");\n\n        inline void writeGenericWireType(GenericWireType*& cursor, float wt) {\n            cursor->w[0].f = wt;\n            ++cursor;\n        }\n\n        inline void writeGenericWireType(GenericWireType*& cursor, double wt) {\n            cursor->d = wt;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T* wt) {\n            cursor->w[0].p = wt;\n            ++cursor;\n        }\n\n        template<typename ElementType>\n        inline void writeGenericWireType(GenericWireType*& cursor, const memory_view<ElementType>& wt) {\n            cursor->w[0].u = wt.size;\n            cursor->w[1].p = wt.data;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T wt) {\n            cursor->w[0].u = static_cast<unsigned>(wt);\n            ++cursor;\n        }\n\n        inline void writeGenericWireTypes(GenericWireType*&) {\n        }\n\n        template<typename First, typename... Rest>\n        EMSCRIPTEN_ALWAYS_INLINE void writeGenericWireTypes(GenericWireType*& cursor, First&& first, Rest&&... rest) {\n            writeGenericWireType(cursor, BindingType<First>::toWireType(std::forward<First>(first)));\n            writeGenericWireTypes(cursor, std::forward<Rest>(rest)...);\n        }\n\n        template<typename... Args>\n        struct WireTypePack {\n            WireTypePack(Args&&... args) {\n                GenericWireType* cursor = elements.data();\n                writeGenericWireTypes(cursor, std::forward<Args>(args)...);\n            }\n\n            operator EM_VAR_ARGS() const {\n                return elements.data();\n            }\n\n        private:\n            std::array<GenericWireType, PackSize<Args...>::value> elements;\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct MethodCaller {\n            static ReturnType call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<ReturnType, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                EM_DESTRUCTORS destructors;\n                EM_GENERIC_WIRE_TYPE result = _emval_call_method(\n                    caller,\n                    handle,\n                    methodName,\n                    &destructors,\n                    argv);\n                DestructorsRunner rd(destructors);\n                return fromGenericWireType<ReturnType>(result);\n            }\n        };\n\n        template<typename... Args>\n        struct MethodCaller<void, Args...> {\n            static void call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<void, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                _emval_call_void_method(\n                    caller,\n                    handle,\n                    methodName,\n                    argv);\n            }\n        };\n    }\n\n#define EMSCRIPTEN_SYMBOL(name)                                         \\\n    static const char name##_symbol[] = #name;                          \\\n    static const ::emscripten::internal::symbol_registrar<name##_symbol> name##_registrar\n\n    class val {\n    public:\n        // missing operators:\n        // * ~ - + ++ --\n        // * * / %\n        // * + -\n        // * << >> >>>\n        // * & ^ | && || ?:\n        //\n        // exposing void, comma, and conditional is unnecessary\n        // same with: = += -= *= /= %= <<= >>= >>>= &= ^= |=\n\n        static val array() {\n            return val(internal::_emval_new_array());\n        }\n\n        template<typename T>\n        static val array(const std::vector<T> vec) {\n            val new_array = array();\n            for(auto it = vec.begin(); it != vec.end(); it++)\n                new_array.call<void>(\"push\", *it);\n            return new_array;\n        }\n\n        static val object() {\n            return val(internal::_emval_new_object());\n        }\n\n        static val undefined() {\n            return val(internal::EM_VAL(internal::_EMVAL_UNDEFINED));\n        }\n\n        static val null() {\n            return val(internal::EM_VAL(internal::_EMVAL_NULL));\n        }\n\n        static val take_ownership(internal::EM_VAL e) {\n            return val(e);\n        }\n\n        static val global(const char* name = 0) {\n            return val(internal::_emval_get_global(name));\n        }\n\n        static val module_property(const char* name) {\n            return val(internal::_emval_get_module_property(name));\n        }\n\n        template<typename T>\n        explicit val(T&& value) {\n            using namespace internal;\n\n            typedef internal::BindingType<T> BT;\n            WireTypePack<T> argv(std::forward<T>(value));\n            handle = _emval_take_value(\n                internal::TypeID<T>::get(),\n                argv);\n        }\n\n        val() = delete;\n\n        explicit val(const char* v)\n            : handle(internal::_emval_new_cstring(v))\n        {}\n\n        val(val&& v)\n            : handle(v.handle)\n        {\n            v.handle = 0;\n        }\n\n        val(const val& v)\n            : handle(v.handle)\n        {\n            internal::_emval_incref(handle);\n        }\n\n        ~val() {\n            internal::_emval_decref(handle);\n        }\n\n        val& operator=(val&& v) {\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            v.handle = 0;\n            return *this;\n        }\n\n        val& operator=(const val& v) {\n            internal::_emval_incref(v.handle);\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            return *this;\n        }\n\n        bool hasOwnProperty(const char* key) const {\n            return val::global(\"Object\")[\"prototype\"][\"hasOwnProperty\"].call<bool>(\"call\", *this, val(key));\n        }\n\n        bool isNull() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_NULL);\n        }\n\n        bool isUndefined() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_UNDEFINED);\n        }\n\n        bool isTrue() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_TRUE);\n        }\n\n        bool isFalse() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_FALSE);\n        }\n\n        bool isNumber() const {\n            return typeOf().as<std::string>() == \"number\";\n        }\n\n        bool isString() const {\n            return typeOf().as<std::string>() == \"string\";\n        }\n\n        bool isArray() const {\n            return instanceof(global(\"Array\"));\n        }\n\n        bool equals(const val& v) const {\n            return internal::_emval_equals(handle, v.handle);\n        }\n\n        bool operator==(const val& v) const {\n            return internal::_emval_equals(handle, v.handle);\n        }\n\n        bool operator!=(const val& v) const {\n            return !(*this == v);\n        }\n\n        bool strictlyEquals(const val& v) const {\n            return internal::_emval_strictly_equals(handle, v.handle);\n        }\n\n        bool operator>(const val& v) const {\n            return internal::_emval_greater_than(handle, v.handle);\n        }\n\n        bool operator>=(const val& v) const {\n            return (*this > v) || (*this == v);\n        }\n\n        bool operator<(const val& v) const {\n            return internal::_emval_less_than(handle, v.handle);\n        }\n\n        bool operator<=(const val& v) const {\n            return (*this < v) || (*this == v);\n        }\n\n        bool operator!() const {\n            return internal::_emval_not(handle);\n        }\n\n        template<typename... Args>\n        val new_(Args&&... args) const {\n            return internalCall(internal::_emval_new,std::forward<Args>(args)...);\n        }\n\n        template<typename T>\n        val operator[](const T& key) const {\n            return val(internal::_emval_get_property(handle, val(key).handle));\n        }\n\n        template<typename K>\n        void set(const K& key, const val& v) {\n            internal::_emval_set_property(handle, val(key).handle, v.handle);\n        }\n\n        template<typename K, typename V>\n        void set(const K& key, const V& value) {\n            internal::_emval_set_property(handle, val(key).handle, val(value).handle);\n        }\n\n        template<typename... Args>\n        val operator()(Args&&... args) const {\n            return internalCall(internal::_emval_call, std::forward<Args>(args)...);\n        }\n\n        template<typename ReturnValue, typename... Args>\n        ReturnValue call(const char* name, Args&&... args) const {\n            using namespace internal;\n\n            return MethodCaller<ReturnValue, Args...>::call(handle, name, std::forward<Args>(args)...);\n        }\n\n        template<typename T, typename ...Policies>\n        T as(Policies...) const {\n            using namespace internal;\n\n            typedef BindingType<T> BT;\n            typename WithPolicies<Policies...>::template ArgTypeList<T> targetType;\n\n            EM_DESTRUCTORS destructors;\n            EM_GENERIC_WIRE_TYPE result = _emval_as(\n                handle,\n                targetType.getTypes()[0],\n                &destructors);\n            DestructorsRunner dr(destructors);\n            return fromGenericWireType<T>(result);\n        }\n\n// If code is not being compiled with GNU extensions enabled, typeof() is not a reserved keyword, so support that as a member function.\n#if __STRICT_ANSI__\n        val typeof() const {\n            return val(_emval_typeof(handle));\n        }\n#endif\n\n// Prefer calling val::typeOf() over val::typeof(), since this form works in both C++11 and GNU++11 build modes. \"typeof\" is a reserved word in GNU++11 extensions.\n        val typeOf() const {\n            return val(_emval_typeof(handle));\n        }\n\n        bool instanceof(const val& v) const {\n            return internal::_emval_instanceof(handle, v.handle);\n        }\n\n        bool in(const val& v) const {\n            return internal::_emval_in(handle, v.handle);\n        }\n\n        template<typename T>\n        bool delete_(const T& property) const {\n            return internal::_emval_delete(handle, val(property).handle);\n        }\n\n        void throw_() const {\n            internal::_emval_throw(handle);\n        }\n\n    private:\n        // takes ownership, assumes handle already incref'd\n        explicit val(internal::EM_VAL handle)\n            : handle(handle)\n        {}\n\n        template<typename WrapperType>\n        friend val internal::wrapped_extend(const std::string& , const val& );\n\n        internal::EM_VAL __get_handle() const {\n            return handle;\n        }\n\n        template<typename Implementation, typename... Args>\n        val internalCall(Implementation impl, Args&&... args) const {\n            using namespace internal;\n\n            WithPolicies<>::ArgTypeList<Args...> argList;\n            WireTypePack<Args...> argv(std::forward<Args>(args)...);\n            return val(\n                impl(\n                    handle,\n                    argList.getCount(),\n                    argList.getTypes(),\n                    argv));\n        }\n\n        internal::EM_VAL handle;\n\n        friend struct internal::BindingType<val>;\n    };\n\n    namespace internal {\n        template<>\n        struct BindingType<val> {\n            typedef internal::EM_VAL WireType;\n            static WireType toWireType(const val& v) {\n                _emval_incref(v.handle);\n                return v.handle;\n            }\n            static val fromWireType(WireType v) {\n                return val::take_ownership(v);\n            }\n        };\n    }\n\n    template<typename T>\n    std::vector<T> vecFromJSArray(val v) {\n        auto l = v[\"length\"].as<unsigned>();\n\n        std::vector<T> rv;\n        for(unsigned i = 0; i < l; ++i) {\n            rv.push_back(v[i].as<T>());\n        }\n\n        return rv;\n    };\n}\n\n#endif // ~C++11 version check\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n    template <class T> struct is_aggregate; // C++17\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    template<class T> struct has_unique_object_representations;         // C++17\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class Fn, class... ArgTypes> struct is_invocable;\n    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;\n\n    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;\n    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n    template <class T> struct remove_cvref; // C++20\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class T>\n      using result_of_t       = typename result_of<T>::type;  // C++14\n    template <class Fn, class... ArgTypes>\n      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> inline constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> inline constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> inline constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> inline constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> inline constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> inline constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> inline constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> inline constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> inline constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> inline constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> inline constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> inline constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> inline constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> inline constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> inline constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> inline constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> inline constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> inline constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> inline constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_aggregate_v\n        = is_aggregate<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> inline constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> inline constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> inline constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> inline constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> inline constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> inline constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> inline constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> inline constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> inline constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> inline constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> inline constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> inline constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> inline constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> inline constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> inline constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> inline constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> inline constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> inline constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> inline constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> inline constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> inline constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> inline constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> inline constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n      template<class T> inline constexpr bool has_unique_object_representations_v // C++17\n        = has_unique_object_representations<T>::value;\n\n      // See C++14 20.10.5, type property queries\n      template <class T> inline constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> inline constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> inline constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> inline constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> inline constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> inline constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v\n        = is_invocable<Fn, ArgTypes...>::value;                          // C++17\n      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v\n        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17\n      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v\n        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17\n      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v\n        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        inline constexpr bool negation_v = negation<B>::value;           // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\n#if _LIBCPP_STD_VER > 17\n// aligned_union - same as __uncvref\ntemplate <class _Tp>\nstruct remove_cvref {\n    using type = remove_cv_t<remove_reference_t<_Tp>>;\n};\n\ntemplate <class _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;\n#endif\n\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Up, bool>\nstruct __decay {\n    typedef typename remove_cv<_Up>::type type;\n};\n\ntemplate <class _Up>\nstruct __decay<_Up, true> {\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_aggregate\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};\n\n#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_aggregate_v\n    = is_aggregate<_Tp>::value;\n#endif\n\n#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// has_unique_object_representations\n\n#if _LIBCPP_STD_VER > 14 && defined(_LIBCPP_HAS_UNIQUE_OBJECT_REPRESENTATIONS)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_unique_object_representations\n    : public integral_constant<bool, \n       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};\n\n#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_unique_object_representations_v\n    = has_unique_object_representations<_Tp>::value;\n#endif\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS common_type<void, void, void>\n{\npublic:\n    typedef void type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename common_type<_Tp, _Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n    : public common_type<_Tp, _Tp> {};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>(), _VSTD::declval<_A2>()), true_type()))\n__is_constructible3_test(_Tp&, _A0&, _A1&, _A2&);\n\ntemplate <class _A0, class _A1, class _A2>\nfalse_type\n__is_constructible3_test(__any, _A0&, _A1&, _A2&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible3_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>(), declval<_A2>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<true, _Tp, _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_void_check\n    : public __is_constructible3_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1, _A2>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_void_check<true, _Tp, _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat,\n                     class _A2 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible3_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value\n                                        || is_void<_A2>::value,\n                                           _Tp, _A0, _A1, _A2>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, _A1, __is_construct::__nat>\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<false, _Ap[_Np], _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<false, _Ap[], _A0, _A1, _A2>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    using type =\n        typename conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type;\n    static const bool value = type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nusing __nothrow_invokable =\n    __nothrow_invokable_r_imp<\n            __invokable<_Fp, _Args...>::value,\n            true, void, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// invoke_result\n\ntemplate <class _Fn, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS invoke_result\n    : __invoke_of<_Fn, _Args...>\n{\n};\n\ntemplate <class _Fn, class... _Args>\nusing invoke_result_t = typename invoke_result<_Fn, _Args...>::type;\n\n// is_invocable\n\ntemplate <class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_invocable\n    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};\n\ntemplate <class _Ret, class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_invocable_r\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_invocable_v\n    = is_invocable<_Fn, _Args...>::value;\n\ntemplate <class _Ret, class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_invocable_r_v\n    = is_invocable_r<_Ret, _Fn, _Args...>::value;\n\n// is_nothrow_invocable\n\ntemplate <class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable\n    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};\n\ntemplate <class _Ret, class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable_r\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_v\n    = is_nothrow_invocable<_Fn, _Args...>::value;\n\ntemplate <class _Ret, class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_r_v\n    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR constexpr bool is_swappable_with_v\n    = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_swappable_v\n    = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_with_v\n    = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_v\n    = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\ntemplate<typename _Fp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_floating_point<_Fp>::value, long long>::type\n __convert_to_integral(_Fp __val) { return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args>\n_LIBCPP_INLINE_VAR constexpr bool conjunction_v\n    = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args>\n_LIBCPP_INLINE_VAR constexpr bool disjunction_v\n    = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool negation_v\n    = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 14\n// std::byte\nnamespace std  // purposefully not versioned\n{\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &\n  operator<<=(byte& __lhs, _Integer __shift) noexcept\n  { return __lhs = __lhs << __shift; }\n  \ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type\n  operator<< (byte  __lhs, _Integer __shift) noexcept\n  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &\n  operator>>=(byte& __lhs, _Integer __shift) noexcept\n  { return __lhs = __lhs >> __shift; }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type\n  operator>> (byte  __lhs, _Integer __shift) noexcept\n  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }\n  \ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type\n  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }\n\n}\n#endif\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","/*\n * Copyright 2012 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n */\n\n#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/bind.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void* GenericFunction;\n        typedef void (*VoidFunctionPtr)(void);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                double value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename InstanceType, typename ElementType, int N>\n        value_object& field(const char* fieldName, ElementType (InstanceType::*field)[N]) {\n            using namespace internal;\n\n            typedef std::array<ElementType, N> FieldType;\n            static_assert(sizeof(FieldType) == sizeof(ElementType[N]));\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast   = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n\n            static std::vector<typename MapType::key_type> keys(\n                const MapType& m\n            ) {\n              std::vector<typename MapType::key_type> keys;\n              keys.reserve(m.size());\n              for (const auto& pair : m) {\n                keys.push_back(pair.first);\n              }\n              return keys;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            .function(\"keys\", internal::MapAccess<MapType>::keys)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        double asGenericValue(T t) {\n            return static_cast<double>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            static_cast<double>(asGenericValue(BT::toWireType(v))));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n\n#endif // ~C++11 version check\n","// dear imgui, v1.67 WIP\r\n// (headers)\r\n\r\n// See imgui.cpp file for documentation.\r\n// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.\r\n// Read 'Programmer guide' in imgui.cpp for notes on how to setup ImGui in your codebase.\r\n// Get latest version at https://github.com/ocornut/imgui\r\n\r\n/*\r\n\r\nIndex of this file:\r\n// Header mess\r\n// Forward declarations and basic types\r\n// ImGui API (Dear ImGui end-user API)\r\n// Flags & Enumerations\r\n// ImGuiStyle\r\n// ImGuiIO\r\n// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)\r\n// Obsolete functions\r\n// Helpers (ImVector, ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)\r\n// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)\r\n// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFont)\r\n\r\n*/\r\n\r\n#pragma once\r\n\r\n// Configuration file (edit imconfig.h or define IMGUI_USER_CONFIG to your own filename)\r\n#ifdef IMGUI_USER_CONFIG\r\n#include IMGUI_USER_CONFIG\r\n#endif\r\n#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)\r\n#include \"imconfig.h\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Header mess\r\n//-----------------------------------------------------------------------------\r\n\r\n#include <float.h>                  // FLT_MAX\r\n#include <stdarg.h>                 // va_list\r\n#include <stddef.h>                 // ptrdiff_t, NULL\r\n#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp\r\n\r\n// Version\r\n// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY00 then bounced up to XYY01 when release tagging happens)\r\n#define IMGUI_VERSION               \"1.66b\"\r\n#define IMGUI_VERSION_NUM           16602\r\n#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert))\r\n\r\n// Define attributes of all API symbols declarations (e.g. for DLL under Windows)\r\n// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)\r\n#ifndef IMGUI_API\r\n#define IMGUI_API\r\n#endif\r\n#ifndef IMGUI_IMPL_API\r\n#define IMGUI_IMPL_API              IMGUI_API\r\n#endif\r\n\r\n// Helper Macros\r\n#ifndef IM_ASSERT\r\n#include <assert.h>\r\n#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h\r\n#endif\r\n#if defined(__clang__) || defined(__GNUC__)\r\n#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.\r\n#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))\r\n#else\r\n#define IM_FMTARGS(FMT)\r\n#define IM_FMTLIST(FMT)\r\n#endif\r\n#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers!\r\n#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.\r\n\r\n// Warnings\r\n#if defined(__clang__)\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\r\n#elif defined(__GNUC__) && __GNUC__ >= 8\r\n#pragma GCC diagnostic push\r\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Forward declarations and basic types\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImDrawChannel;               // Temporary storage for outputting drawing commands out of order, used by ImDrawList::ChannelsSplit()\r\nstruct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call)\r\nstruct ImDrawData;                  // All draw command lists required to render the frame\r\nstruct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic \"mesh\" builder)\r\nstruct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)\r\nstruct ImDrawVert;                  // A single vertex (20 bytes by default, override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)\r\nstruct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas\r\nstruct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader\r\nstruct ImFontConfig;                // Configuration data when adding a font or merging fonts\r\nstruct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*obsolete* please avoid using)\r\n#ifndef ImTextureID\r\ntypedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)\r\n#endif\r\nstruct ImGuiContext;                // ImGui context (opaque)\r\nstruct ImGuiIO;                     // Main configuration and I/O between your application and ImGui\r\nstruct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)\r\nstruct ImGuiListClipper;            // Helper to manually clip large list of items\r\nstruct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro\r\nstruct ImGuiPayload;                // User data payload for drag and drop operations\r\nstruct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)\r\nstruct ImGuiStorage;                // Helper for key->value storage\r\nstruct ImGuiStyle;                  // Runtime data for styling/colors\r\nstruct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. \"aaaaa[,bbbb][,ccccc]\")\r\nstruct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)\r\n\r\n// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)\r\n// Use your programming IDE \"Go to definition\" facility on the names of the center columns to find the actual flags/enum lists.\r\ntypedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)\r\ntypedef unsigned short ImWchar;     // Character for keyboard input/display\r\ntypedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling\r\ntypedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for Set*()\r\ntypedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type\r\ntypedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction\r\ntypedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)\r\ntypedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation\r\ntypedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier\r\ntypedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling\r\ntypedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect*() etc.\r\ntypedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList\r\ntypedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas\r\ntypedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags\r\ntypedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit*(), ColorPicker*()\r\ntypedef int ImGuiColumnsFlags;      // -> enum ImGuiColumnsFlags_    // Flags: for Columns(), BeginColumns()\r\ntypedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags\r\ntypedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()\r\ntypedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for *DragDrop*()\r\ntypedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()\r\ntypedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.\r\ntypedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText*()\r\ntypedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()\r\ntypedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode*(),CollapsingHeader()\r\ntypedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin*()\r\ntypedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);\r\ntypedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);\r\n\r\n// Scalar data types\r\ntypedef signed int          ImS32;  // 32-bit signed integer == int\r\ntypedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)\r\n#if defined(_MSC_VER) && !defined(__clang__)\r\ntypedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)\r\ntypedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)\r\n#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)\r\n#include <stdint.h>\r\ntypedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)\r\ntypedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)\r\n#else\r\ntypedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)\r\ntypedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)\r\n#endif\r\n\r\n// 2D vector (often used to store positions, sizes, etc.)\r\nstruct ImVec2\r\n{\r\n    float     x, y;\r\n    ImVec2()  { x = y = 0.0f; }\r\n    ImVec2(float _x, float _y) { x = _x; y = _y; }\r\n    float operator[] (size_t i) const { IM_ASSERT(i <= 1); return (&x)[i]; }    // We very rarely use this [] operator, the assert overhead is fine.\r\n#ifdef IM_VEC2_CLASS_EXTRA\r\n    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.\r\n#endif\r\n};\r\n\r\n// 4D vector (often used to store floating-point colors)\r\nstruct ImVec4\r\n{\r\n    float     x, y, z, w;\r\n    ImVec4()  { x = y = z = w = 0.0f; }\r\n    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }\r\n#ifdef IM_VEC4_CLASS_EXTRA\r\n    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.\r\n#endif\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGui: Dear ImGui end-user API\r\n// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui.cpp/.h!)\r\n//-----------------------------------------------------------------------------\r\n\r\nnamespace ImGui\r\n{\r\n    // Context creation and access\r\n    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.\r\n    // All those functions are not reliant on the current context.\r\n    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);\r\n    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context\r\n    IMGUI_API ImGuiContext* GetCurrentContext();\r\n    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);\r\n    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);\r\n\r\n    // Main\r\n    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)\r\n    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.\r\n    IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().\r\n    IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all!\r\n    IMGUI_API void          Render();                                   // ends the ImGui frame, finalize the draw data. (Obsolete: optionally call io.RenderDrawListsFn if set. Nowadays, prefer calling your render function yourself.)\r\n    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render. (Obsolete: this used to be passed to your io.RenderDrawListsFn() function.)\r\n\r\n    // Demo, Debug, Information\r\n    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!\r\n    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create about window. display Dear ImGui version, credits and build/system information.\r\n    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.\r\n    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)\r\n    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.\r\n    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.\r\n    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).\r\n    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. \"1.23\"\r\n\r\n    // Styles\r\n    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)\r\n    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style\r\n    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font\r\n\r\n    // Windows\r\n    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.\r\n    // - You may append multiple times to the same window during the same frame.\r\n    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window, which clicking will set the boolean to false when clicked.\r\n    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.\r\n    //   Always call a matching End() for each Begin() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]\r\n    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);\r\n    IMGUI_API void          End();\r\n\r\n    // Child Windows\r\n    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.\r\n    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).\r\n    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.\r\n    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]\r\n    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);\r\n    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);\r\n    IMGUI_API void          EndChild();\r\n\r\n    // Windows Utilities\r\n    IMGUI_API bool          IsWindowAppearing();\r\n    IMGUI_API bool          IsWindowCollapsed();\r\n    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.\r\n    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!\r\n    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the window, to append your own drawing primitives\r\n    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)\r\n    IMGUI_API ImVec2        GetWindowSize();                            // get current window size\r\n    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)\r\n    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)\r\n    IMGUI_API ImVec2        GetContentRegionMax();                      // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates\r\n    IMGUI_API ImVec2        GetContentRegionAvail();                    // == GetContentRegionMax() - GetCursorPos()\r\n    IMGUI_API float         GetContentRegionAvailWidth();               //\r\n    IMGUI_API ImVec2        GetWindowContentRegionMin();                // content boundaries min (roughly (0,0)-Scroll), in window coordinates\r\n    IMGUI_API ImVec2        GetWindowContentRegionMax();                // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates\r\n    IMGUI_API float         GetWindowContentRegionWidth();              //\r\n\r\n    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.\r\n    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()\r\n    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.\r\n    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()\r\n    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()\r\n    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()\r\n    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.\r\n    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.\r\n    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.\r\n    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().\r\n    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().\r\n    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows\r\n    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.\r\n    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.\r\n    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state\r\n    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.\r\n\r\n    // Windows Scrolling\r\n    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]\r\n    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]\r\n    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X\r\n    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y\r\n    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]\r\n    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]\r\n    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                     // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead.\r\n    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);    // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.\r\n\r\n    // Parameters stacks (shared)\r\n    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font\r\n    IMGUI_API void          PopFont();\r\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);\r\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);\r\n    IMGUI_API void          PopStyleColor(int count = 1);\r\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);\r\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);\r\n    IMGUI_API void          PopStyleVar(int count = 1);\r\n    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.\r\n    IMGUI_API ImFont*       GetFont();                                                      // get current font\r\n    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied\r\n    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API\r\n    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier\r\n    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied\r\n    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied\r\n\r\n    // Parameters stacks (current window)\r\n    IMGUI_API void          PushItemWidth(float item_width);                                // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)\r\n    IMGUI_API void          PopItemWidth();\r\n    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position\r\n    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                       // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space\r\n    IMGUI_API void          PopTextWrapPos();\r\n    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets\r\n    IMGUI_API void          PopAllowKeyboardFocus();\r\n    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.\r\n    IMGUI_API void          PopButtonRepeat();\r\n\r\n    // Cursor / Layout\r\n    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.\r\n    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);          // call between widgets or groups to layout them horizontally\r\n    IMGUI_API void          NewLine();                                                      // undo a SameLine()\r\n    IMGUI_API void          Spacing();                                                      // add vertical spacing\r\n    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size\r\n    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0\r\n    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0\r\n    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position + capture group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\r\n    IMGUI_API void          EndGroup();\r\n    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position is relative to window position\r\n    IMGUI_API float         GetCursorPosX();                                                // \"\r\n    IMGUI_API float         GetCursorPosY();                                                // \"\r\n    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          // \"\r\n    IMGUI_API void          SetCursorPosX(float x);                                         // \"\r\n    IMGUI_API void          SetCursorPosY(float y);                                         // \"\r\n    IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position\r\n    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)\r\n    IMGUI_API void          SetCursorScreenPos(const ImVec2& screen_pos);                   // cursor position in absolute screen coordinates [0..io.DisplaySize]\r\n    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)\r\n    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize\r\n    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)\r\n    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2\r\n    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)\r\n\r\n    // ID stack/scopes\r\n    // Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most\r\n    // likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.\r\n    // You can also use the \"##foobar\" syntax within widget label to distinguish them from each others.\r\n    // In this header file we use the \"label\"/\"name\" terminology to denote a string that will be displayed and used as an ID,\r\n    // whereas \"str_id\" denote a string that is only used as an ID and not aimed to be displayed.\r\n    IMGUI_API void          PushID(const char* str_id);                                     // push identifier into the ID stack. IDs are hash of the entire stack!\r\n    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);\r\n    IMGUI_API void          PushID(const void* ptr_id);\r\n    IMGUI_API void          PushID(int int_id);\r\n    IMGUI_API void          PopID();\r\n    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself\r\n    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);\r\n    IMGUI_API ImGuiID       GetID(const void* ptr_id);\r\n\r\n    // Widgets: Text\r\n    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.\r\n    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text\r\n    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);\r\n    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();\r\n    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);\r\n    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();\r\n    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);\r\n    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().\r\n    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);\r\n    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets\r\n    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);\r\n    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()\r\n    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);\r\n\r\n    // Widgets: Main\r\n    // Most widgets return true when the value has been changed or when pressed/selected\r\n    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button\r\n    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text\r\n    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)\r\n    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape\r\n    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));\r\n    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding\r\n    IMGUI_API bool          Checkbox(const char* label, bool* v);\r\n    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);\r\n    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton(\"one\", my_value==1)) { my_value = 1; }\r\n    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer\r\n    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);\r\n    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses\r\n\r\n    // Widgets: Combo Box\r\n    // The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.\r\n    // The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.\r\n    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);\r\n    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\"\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);\r\n\r\n    // Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x\r\n    // Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc.\r\n    // Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).\r\n    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);     // If v_min >= v_max we have no bound\r\n    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", const char* format_max = NULL, float power = 1.0f);\r\n    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");                                       // If v_min >= v_max we have no bound\r\n    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");\r\n    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");\r\n    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");\r\n    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", const char* format_max = NULL);\r\n    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);\r\n    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);\r\n\r\n    // Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc.\r\n    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders\r\n    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = \"%.0f deg\");\r\n    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n\r\n    // Widgets: Input with Keyboard\r\n    // If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h\r\n    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0f, double step_fast = 0.0f, const char* format = \"%.6f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);\r\n\r\n    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)\r\n    // Note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x\r\n    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);\r\n    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.\r\n    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.\r\n\r\n    // Widgets: Trees\r\n    // TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.\r\n    IMGUI_API bool          TreeNode(const char* label);\r\n    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to completely decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().\r\n    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // \"\r\n    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);\r\n    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.\r\n    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // \"\r\n    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()\r\n    IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()\r\n    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode\r\n    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.\r\n    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().\r\n    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header\r\n\r\n    // Widgets: Selectables\r\n    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // \"bool selected\" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height\r\n    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // \"bool* p_selected\" point to the selection state (read-write), as a convenient helper.\r\n\r\n    // Widgets: List Boxes\r\n    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);\r\n    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);\r\n    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.\r\n    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // \"\r\n    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!\r\n\r\n    // Widgets: Data Plotting\r\n    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));\r\n    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));\r\n    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));\r\n    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));\r\n\r\n    // Widgets: Value() Helpers. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)\r\n    IMGUI_API void          Value(const char* prefix, bool b);\r\n    IMGUI_API void          Value(const char* prefix, int v);\r\n    IMGUI_API void          Value(const char* prefix, unsigned int v);\r\n    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);\r\n\r\n    // Widgets: Menus\r\n    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.\r\n    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!\r\n    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).\r\n    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!\r\n    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!\r\n    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!\r\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment\r\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL\r\n\r\n    // Tooltips\r\n    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).\r\n    IMGUI_API void          EndTooltip();\r\n    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().\r\n    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);\r\n\r\n    // Popups\r\n    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).\r\n    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!\r\n    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!\r\n    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.\r\n    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).\r\n    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)\r\n    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!\r\n    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.\r\n    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open\r\n    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.\r\n\r\n    // Columns\r\n    // You can also use SameLine(pos_x) for simplified columns. The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)\r\n    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);\r\n    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished\r\n    IMGUI_API int           GetColumnIndex();                                                   // get current column index\r\n    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column\r\n    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column\r\n    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f\r\n    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column\r\n    IMGUI_API int           GetColumnsCount();\r\n\r\n    // Logging/Capture: all text output from interface is captured to tty/file/clipboard. By default, tree nodes are automatically opened during logging.\r\n    IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty\r\n    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file\r\n    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard\r\n    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)\r\n    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard\r\n    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)\r\n\r\n    // Drag and Drop\r\n    // [BETA API] Missing Demo code. API may evolve.\r\n    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()\r\n    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.\r\n    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!\r\n    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()\r\n    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.\r\n    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!\r\n    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.\r\n    \r\n    // Clipping\r\n    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);\r\n    IMGUI_API void          PopClipRect();\r\n\r\n    // Focus, Activation\r\n    // (Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHereY()\" when applicable to signify \"this is the default item\")\r\n    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.\r\n    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.\r\n\r\n    // Item/Widgets Utilities\r\n    // See Demo Window under \"Widgets->Querying Status\" for an interactive visualization of many of those functions.\r\n    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.\r\n    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)\r\n    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?\r\n    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()\r\n    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)\r\n    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the \"bool\" return value of many widgets.\r\n    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.\r\n    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).\r\n    IMGUI_API bool          IsAnyItemHovered();\r\n    IMGUI_API bool          IsAnyItemActive();\r\n    IMGUI_API bool          IsAnyItemFocused();\r\n    IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rectangle of last item, in screen space\r\n    IMGUI_API ImVec2        GetItemRectMax();                                                   // \"\r\n    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item, in screen space\r\n    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.\r\n\r\n    // Miscellaneous Utilities\r\n    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.\r\n    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.\r\n    IMGUI_API double        GetTime();\r\n    IMGUI_API int           GetFrameCount();\r\n    IMGUI_API ImDrawList*   GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text\r\n    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances\r\n    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);\r\n    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)\r\n    IMGUI_API ImGuiStorage* GetStateStorage();\r\n    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);\r\n    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.\r\n    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame\r\n    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)\r\n\r\n    // Color Utilities\r\n    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);\r\n    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);\r\n    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);\r\n    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);\r\n\r\n    // Inputs Utilities\r\n    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]\r\n    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]!\r\n    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate\r\n    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..\r\n    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate\r\n    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held (0=left, 1=right, 2=middle)\r\n    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held\r\n    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down) (0=left, 1=right, 2=middle)\r\n    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.\r\n    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)\r\n    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but  disregarding of other consideration of focus/window ordering/popup-block.\r\n    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //\r\n    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls\r\n    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into\r\n    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //\r\n    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you\r\n    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type\r\n    IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        // manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered.\r\n    IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           // manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle).\r\n\r\n    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)\r\n    IMGUI_API const char*   GetClipboardText();\r\n    IMGUI_API void          SetClipboardText(const char* text);\r\n\r\n    // Settings/.Ini Utilities\r\n    // The disk functions are automatically called if io.IniFilename != NULL (default is \"imgui.ini\").\r\n    // Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.\r\n    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).\r\n    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.\r\n    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);\r\n    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.\r\n\r\n    // Memory Utilities\r\n    // All those functions are not reliant on the current context.\r\n    // If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again.\r\n    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data = NULL);\r\n    IMGUI_API void*         MemAlloc(size_t size);\r\n    IMGUI_API void          MemFree(void* ptr);\r\n\r\n} // namespace ImGui\r\n\r\n//-----------------------------------------------------------------------------\r\n// Flags & Enumerations\r\n//-----------------------------------------------------------------------------\r\n\r\n// Flags for ImGui::Begin()\r\nenum ImGuiWindowFlags_\r\n{\r\n    ImGuiWindowFlags_None                   = 0,\r\n    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar\r\n    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip\r\n    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window\r\n    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)\r\n    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.\r\n    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it\r\n    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame\r\n    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).\r\n    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file\r\n    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.\r\n    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar\r\n    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section.\r\n    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state\r\n    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)\r\n    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)\r\n    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)\r\n    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)\r\n    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window\r\n    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)\r\n    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,\r\n    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,\r\n    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,\r\n\r\n    // [Internal]\r\n    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)\r\n    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()\r\n    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()\r\n    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()\r\n    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()\r\n    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()\r\n\r\n    // [Obsolete]\r\n    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f / style.WindowBorderSize=1.0f to enable borders around windows and items\r\n    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigResizeWindowsFromEdges and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)\r\n};\r\n\r\n// Flags for ImGui::InputText()\r\nenum ImGuiInputTextFlags_\r\n{\r\n    ImGuiInputTextFlags_None                = 0,\r\n    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/\r\n    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef\r\n    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z\r\n    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs\r\n    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus\r\n    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)\r\n    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)\r\n    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)\r\n    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.\r\n    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\r\n    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\\t' character into the text field\r\n    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).\r\n    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally\r\n    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode\r\n    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode\r\n    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'\r\n    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().\r\n    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)\r\n    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)\r\n    // [Internal]\r\n    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()\r\n};\r\n\r\n// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()\r\nenum ImGuiTreeNodeFlags_\r\n{\r\n    ImGuiTreeNodeFlags_None                 = 0,\r\n    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected\r\n    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)\r\n    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one\r\n    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack\r\n    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)\r\n    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open\r\n    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node\r\n    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.\r\n    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).\r\n    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow\r\n    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().\r\n    //ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed\r\n    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible\r\n    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)\r\n    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap\r\n#endif\r\n};\r\n\r\n// Flags for ImGui::Selectable()\r\nenum ImGuiSelectableFlags_\r\n{\r\n    ImGuiSelectableFlags_None               = 0,\r\n    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window\r\n    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)\r\n    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too\r\n    ImGuiSelectableFlags_Disabled           = 1 << 3    // Cannot be selected, display greyed out text\r\n};\r\n\r\n// Flags for ImGui::BeginCombo()\r\nenum ImGuiComboFlags_\r\n{\r\n    ImGuiComboFlags_None                    = 0,\r\n    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default\r\n    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()\r\n    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)\r\n    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible\r\n    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible\r\n    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button\r\n    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button\r\n    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest\r\n};\r\n\r\n// Flags for ImGui::IsWindowFocused()\r\nenum ImGuiFocusedFlags_\r\n{\r\n    ImGuiFocusedFlags_None                          = 0,\r\n    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused\r\n    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)\r\n    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.\r\n    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows\r\n};\r\n\r\n// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()\r\n// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!\r\n// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.\r\nenum ImGuiHoveredFlags_\r\n{\r\n    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.\r\n    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered\r\n    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)\r\n    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered\r\n    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window\r\n    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.\r\n    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.\r\n    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window\r\n    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled\r\n    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,\r\n    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows\r\n};\r\n\r\n// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()\r\nenum ImGuiDragDropFlags_\r\n{\r\n    ImGuiDragDropFlags_None                         = 0,\r\n    // BeginDragDropSource() flags\r\n    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.\r\n    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.\r\n    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.\r\n    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.\r\n    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.\r\n    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)\r\n    // AcceptDragDropPayload() flags\r\n    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.\r\n    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.\r\n    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.\r\n    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.\r\n};\r\n\r\n// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.\r\n#define IMGUI_PAYLOAD_TYPE_COLOR_3F     \"_COL3F\"    // float[3]: Standard type for colors, without alpha. User code may use this type.\r\n#define IMGUI_PAYLOAD_TYPE_COLOR_4F     \"_COL4F\"    // float[4]: Standard type for colors. User code may use this type.\r\n\r\n// A primary data type\r\nenum ImGuiDataType_\r\n{\r\n    ImGuiDataType_S32,      // int\r\n    ImGuiDataType_U32,      // unsigned int\r\n    ImGuiDataType_S64,      // long long, __int64\r\n    ImGuiDataType_U64,      // unsigned long long, unsigned __int64\r\n    ImGuiDataType_Float,    // float\r\n    ImGuiDataType_Double,   // double\r\n    ImGuiDataType_COUNT\r\n};\r\n\r\n// A cardinal direction\r\nenum ImGuiDir_\r\n{\r\n    ImGuiDir_None    = -1,\r\n    ImGuiDir_Left    = 0,\r\n    ImGuiDir_Right   = 1,\r\n    ImGuiDir_Up      = 2,\r\n    ImGuiDir_Down    = 3,\r\n    ImGuiDir_COUNT\r\n};\r\n\r\n// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array\r\nenum ImGuiKey_\r\n{\r\n    ImGuiKey_Tab,\r\n    ImGuiKey_LeftArrow,\r\n    ImGuiKey_RightArrow,\r\n    ImGuiKey_UpArrow,\r\n    ImGuiKey_DownArrow,\r\n    ImGuiKey_PageUp,\r\n    ImGuiKey_PageDown,\r\n    ImGuiKey_Home,\r\n    ImGuiKey_End,\r\n    ImGuiKey_Insert,\r\n    ImGuiKey_Delete,\r\n    ImGuiKey_Backspace,\r\n    ImGuiKey_Space,\r\n    ImGuiKey_Enter,\r\n    ImGuiKey_Escape,\r\n    ImGuiKey_A,         // for text edit CTRL+A: select all\r\n    ImGuiKey_C,         // for text edit CTRL+C: copy\r\n    ImGuiKey_V,         // for text edit CTRL+V: paste\r\n    ImGuiKey_X,         // for text edit CTRL+X: cut\r\n    ImGuiKey_Y,         // for text edit CTRL+Y: redo\r\n    ImGuiKey_Z,         // for text edit CTRL+Z: undo\r\n    ImGuiKey_COUNT\r\n};\r\n\r\n// Gamepad/Keyboard directional navigation\r\n// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.\r\n// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().\r\n// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.\r\nenum ImGuiNavInput_\r\n{\r\n    // Gamepad Mapping\r\n    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)\r\n    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)\r\n    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)\r\n    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)\r\n    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)\r\n    ImGuiNavInput_DpadRight,     //\r\n    ImGuiNavInput_DpadUp,        //\r\n    ImGuiNavInput_DpadDown,      //\r\n    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down\r\n    ImGuiNavInput_LStickRight,   //\r\n    ImGuiNavInput_LStickUp,      //\r\n    ImGuiNavInput_LStickDown,    //\r\n    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)\r\n    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)\r\n    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)\r\n    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)\r\n\r\n    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.\r\n    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].\r\n    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt\r\n    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys\r\n    ImGuiNavInput_KeyRight_,     // move right\r\n    ImGuiNavInput_KeyUp_,        // move up\r\n    ImGuiNavInput_KeyDown_,      // move down\r\n    ImGuiNavInput_COUNT,\r\n    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_\r\n};\r\n\r\n// Configuration flags stored in io.ConfigFlags. Set by user/application.\r\nenum ImGuiConfigFlags_\r\n{\r\n    ImGuiConfigFlags_None                   = 0,\r\n    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].\r\n    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.\r\n    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.\r\n    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.\r\n    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.\r\n    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.\r\n\r\n    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)\r\n    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.\r\n    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.\r\n};\r\n\r\n// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.\r\nenum ImGuiBackendFlags_\r\n{\r\n    ImGuiBackendFlags_None                  = 0,\r\n    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end supports gamepad and currently has one connected.\r\n    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end supports honoring GetMouseCursor() value to change the OS cursor shape.\r\n    ImGuiBackendFlags_HasSetMousePos        = 1 << 2    // Back-end supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).\r\n};\r\n\r\n// Enumeration for PushStyleColor() / PopStyleColor()\r\nenum ImGuiCol_\r\n{\r\n    ImGuiCol_Text,\r\n    ImGuiCol_TextDisabled,\r\n    ImGuiCol_WindowBg,              // Background of normal windows\r\n    ImGuiCol_ChildBg,               // Background of child windows\r\n    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows\r\n    ImGuiCol_Border,\r\n    ImGuiCol_BorderShadow,\r\n    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input\r\n    ImGuiCol_FrameBgHovered,\r\n    ImGuiCol_FrameBgActive,\r\n    ImGuiCol_TitleBg,\r\n    ImGuiCol_TitleBgActive,\r\n    ImGuiCol_TitleBgCollapsed,\r\n    ImGuiCol_MenuBarBg,\r\n    ImGuiCol_ScrollbarBg,\r\n    ImGuiCol_ScrollbarGrab,\r\n    ImGuiCol_ScrollbarGrabHovered,\r\n    ImGuiCol_ScrollbarGrabActive,\r\n    ImGuiCol_CheckMark,\r\n    ImGuiCol_SliderGrab,\r\n    ImGuiCol_SliderGrabActive,\r\n    ImGuiCol_Button,\r\n    ImGuiCol_ButtonHovered,\r\n    ImGuiCol_ButtonActive,\r\n    ImGuiCol_Header,\r\n    ImGuiCol_HeaderHovered,\r\n    ImGuiCol_HeaderActive,\r\n    ImGuiCol_Separator,\r\n    ImGuiCol_SeparatorHovered,\r\n    ImGuiCol_SeparatorActive,\r\n    ImGuiCol_ResizeGrip,\r\n    ImGuiCol_ResizeGripHovered,\r\n    ImGuiCol_ResizeGripActive,\r\n    ImGuiCol_PlotLines,\r\n    ImGuiCol_PlotLinesHovered,\r\n    ImGuiCol_PlotHistogram,\r\n    ImGuiCol_PlotHistogramHovered,\r\n    ImGuiCol_TextSelectedBg,\r\n    ImGuiCol_DragDropTarget,\r\n    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item\r\n    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB\r\n    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active\r\n    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active\r\n    ImGuiCol_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg, ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive\r\n    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg\r\n    //ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.\r\n    //ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.\r\n#endif\r\n};\r\n\r\n// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.\r\n// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.\r\n// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.\r\nenum ImGuiStyleVar_\r\n{\r\n    // Enum name ......................// Member in ImGuiStyle structure (see ImGuiStyle for descriptions)\r\n    ImGuiStyleVar_Alpha,               // float     Alpha\r\n    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding\r\n    ImGuiStyleVar_WindowRounding,      // float     WindowRounding\r\n    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize\r\n    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize\r\n    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign\r\n    ImGuiStyleVar_ChildRounding,       // float     ChildRounding\r\n    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize\r\n    ImGuiStyleVar_PopupRounding,       // float     PopupRounding\r\n    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize\r\n    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding\r\n    ImGuiStyleVar_FrameRounding,       // float     FrameRounding\r\n    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize\r\n    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing\r\n    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing\r\n    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing\r\n    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize\r\n    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding\r\n    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize\r\n    ImGuiStyleVar_GrabRounding,        // float     GrabRounding\r\n    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign\r\n    ImGuiStyleVar_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding\r\n#endif\r\n};\r\n\r\n// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()\r\nenum ImGuiColorEditFlags_\r\n{\r\n    ImGuiColorEditFlags_None            = 0,\r\n    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).\r\n    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.\r\n    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.\r\n    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)\r\n    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).\r\n    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.\r\n    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).\r\n    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.\r\n    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.\r\n\r\n    // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.\r\n    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.\r\n    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.\r\n    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.\r\n    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).\r\n    ImGuiColorEditFlags_RGB             = 1 << 20,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.\r\n    ImGuiColorEditFlags_HSV             = 1 << 21,  // [Inputs]     // \"\r\n    ImGuiColorEditFlags_HEX             = 1 << 22,  // [Inputs]     // \"\r\n    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.\r\n    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.\r\n    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.\r\n    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.\r\n\r\n    // [Internal] Masks\r\n    ImGuiColorEditFlags__InputsMask     = ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_HSV|ImGuiColorEditFlags_HEX,\r\n    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,\r\n    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,\r\n    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_PickerHueBar    // Change application default using SetColorEditOptions()\r\n};\r\n\r\n// Enumeration for GetMouseCursor()\r\n// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here\r\nenum ImGuiMouseCursor_\r\n{\r\n    ImGuiMouseCursor_None = -1,\r\n    ImGuiMouseCursor_Arrow = 0,\r\n    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.\r\n    ImGuiMouseCursor_ResizeAll,         // (Unused by imgui functions)\r\n    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border\r\n    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column\r\n    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window\r\n    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window\r\n    ImGuiMouseCursor_Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)\r\n    ImGuiMouseCursor_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT\r\n#endif\r\n};\r\n\r\n// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions\r\n// Represent a condition.\r\n// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.\r\nenum ImGuiCond_\r\n{\r\n    ImGuiCond_Always        = 1 << 0,   // Set the variable\r\n    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)\r\n    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)\r\n    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing\r\n#endif\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiStyle\r\n// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().\r\n// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values, \r\n// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImGuiStyle\r\n{\r\n    float       Alpha;                      // Global alpha applies to everything in ImGui.\r\n    ImVec2      WindowPadding;              // Padding within a window.\r\n    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.\r\n    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().\r\n    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\r\n    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.\r\n    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)\r\n    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).\r\n    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).\r\n    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.\r\n    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).\r\n    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\r\n    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\r\n    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.\r\n    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.\r\n    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.\r\n    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.\r\n    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\r\n    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.\r\n    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.\r\n    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!\r\n    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.\r\n    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.\r\n    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)\r\n    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\r\n    ImVec4      Colors[ImGuiCol_COUNT];\r\n\r\n    IMGUI_API ImGuiStyle();\r\n    IMGUI_API void ScaleAllSizes(float scale_factor);\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiIO\r\n// Communicate most settings and inputs/outputs to Dear ImGui using this structure. \r\n// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImGuiIO\r\n{\r\n    //------------------------------------------------------------------\r\n    // Configuration (fill once)            // Default value:\r\n    //------------------------------------------------------------------\r\n\r\n    ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.\r\n    ImGuiBackendFlags  BackendFlags;        // = 0                  // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.\r\n    ImVec2        DisplaySize;              // <unset>              // Main display size, in pixels. For clamping windows positions.\r\n    float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.\r\n    float         IniSavingRate;            // = 5.0f               // Minimum time between saving positions/sizes to .ini file, in seconds.\r\n    const char*   IniFilename;              // = \"imgui.ini\"        // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.\r\n    const char*   LogFilename;              // = \"imgui_log.txt\"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).\r\n    float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.\r\n    float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.\r\n    float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging.\r\n    int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array which represent your \"native\" keyboard state.\r\n    float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).\r\n    float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.\r\n    void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.\r\n\r\n    ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.\r\n    float         FontGlobalScale;          // = 1.0f               // Global scale all fonts\r\n    bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.\r\n    ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].\r\n    ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.\r\n    ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // [OBSOLETE] If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.\r\n    ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // [OBSOLETE: just use io.DisplaySize!] If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize\r\n\r\n    // Miscellaneous configuration options\r\n    bool          MouseDrawCursor;              // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.\r\n    bool          ConfigMacOSXBehaviors;        // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)\r\n    bool          ConfigInputTextCursorBlink;   // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)\r\n    bool          ConfigResizeWindowsFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)\r\n\r\n    //------------------------------------------------------------------\r\n    // Platform Functions\r\n    // (the imgui_impl_xxxx back-end files are setting those up for you)\r\n    //------------------------------------------------------------------\r\n\r\n    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window)\r\n    const char* BackendPlatformName;\r\n    const char* BackendRendererName;\r\n\r\n    // Optional: Access OS clipboard\r\n    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)\r\n    const char* (*GetClipboardTextFn)(void* user_data);\r\n    void        (*SetClipboardTextFn)(void* user_data, const char* text);\r\n    void*       ClipboardUserData;\r\n\r\n    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)\r\n    // (default to use native imm32 api on Windows)\r\n    void        (*ImeSetInputScreenPosFn)(int x, int y);\r\n    void*       ImeWindowHandle;                // (Windows) Set this to your HWND to get automatic IME cursor positioning.\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!\r\n    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.\r\n    void        (*RenderDrawListsFn)(ImDrawData* data);\r\n#else\r\n    // This is only here to keep ImGuiIO the same size, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.\r\n    void*       RenderDrawListsFnUnused;\r\n#endif\r\n\r\n    //------------------------------------------------------------------\r\n    // Input - Fill before calling NewFrame()\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)\r\n    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.\r\n    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.\r\n    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.\r\n    bool        KeyCtrl;                        // Keyboard modifier pressed: Control\r\n    bool        KeyShift;                       // Keyboard modifier pressed: Shift\r\n    bool        KeyAlt;                         // Keyboard modifier pressed: Alt\r\n    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows\r\n    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the \"native\" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).\r\n    ImWchar     InputCharacters[16+1];          // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.\r\n    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame, all values will be cleared back to zero in ImGui::EndFrame)\r\n\r\n    // Functions\r\n    IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]\r\n    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string\r\n    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually\r\n\r\n    //------------------------------------------------------------------\r\n    // Output - Retrieve after calling NewFrame()\r\n    //------------------------------------------------------------------\r\n\r\n    bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).\r\n    bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).\r\n    bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).\r\n    bool        WantSetMousePos;            // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.\r\n    bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.\r\n    bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.\r\n    bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).\r\n    float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames\r\n    int         MetricsRenderVertices;      // Vertices output during last call to Render()\r\n    int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3\r\n    int         MetricsRenderWindows;       // Number of visible windows\r\n    int         MetricsActiveWindows;       // Number of active windows\r\n    int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.\r\n    ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.\r\n\r\n    //------------------------------------------------------------------\r\n    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2      MousePosPrev;               // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)\r\n    ImVec2      MouseClickedPos[5];         // Position at time of clicking\r\n    double      MouseClickedTime[5];        // Time of last click (used to figure out double-click)\r\n    bool        MouseClicked[5];            // Mouse button went from !Down to Down\r\n    bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?\r\n    bool        MouseReleased[5];           // Mouse button went from Down to !Down\r\n    bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.\r\n    float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)\r\n    float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down\r\n    ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point\r\n    float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point\r\n    float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)\r\n    float       KeysDownDurationPrev[512];  // Previous duration the key has been down\r\n    float       NavInputsDownDuration[ImGuiNavInput_COUNT];\r\n    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];\r\n\r\n    IMGUI_API   ImGuiIO();\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Misc data structures\r\n//-----------------------------------------------------------------------------\r\n\r\n// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.\r\n// The callback function should return 0 by default.\r\n// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)\r\n// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB\r\n// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows\r\n// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration\r\n// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\r\n// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. \r\nstruct ImGuiInputTextCallbackData\r\n{\r\n    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only\r\n    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only\r\n    void*               UserData;       // What user passed to InputText()      // Read-only\r\n\r\n    // Arguments for the different callback events\r\n    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.\r\n    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.\r\n    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;\r\n    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]\r\n    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!\r\n    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()\r\n    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1\r\n    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]\r\n    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]\r\n    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)\r\n    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]\r\n\r\n    // Helper functions for text manipulation.\r\n    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.\r\n    IMGUI_API ImGuiInputTextCallbackData();\r\n    IMGUI_API void      DeleteChars(int pos, int bytes_count);\r\n    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);\r\n    bool                HasSelection() const { return SelectionStart != SelectionEnd; }\r\n};\r\n\r\n// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\r\n// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.\r\nstruct ImGuiSizeCallbackData\r\n{\r\n    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()\r\n    ImVec2  Pos;            // Read-only.   Window position, for reference.\r\n    ImVec2  CurrentSize;    // Read-only.   Current window size.\r\n    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.\r\n};\r\n\r\n// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()\r\nstruct ImGuiPayload\r\n{\r\n    // Members\r\n    void*           Data;               // Data (copied and owned by dear imgui)\r\n    int             DataSize;           // Data size\r\n\r\n    // [Internal]\r\n    ImGuiID         SourceId;           // Source item id\r\n    ImGuiID         SourceParentId;     // Source parent id (if available)\r\n    int             DataFrameCount;     // Data timestamp\r\n    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)\r\n    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)\r\n    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.\r\n\r\n    ImGuiPayload()  { Clear(); }\r\n    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }\r\n    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }\r\n    bool IsPreview() const                  { return Preview; }\r\n    bool IsDelivery() const                 { return Delivery; }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)\r\n//-----------------------------------------------------------------------------\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\nnamespace ImGui\r\n{\r\n    // OBSOLETED in 1.66 (from Sep 2018)\r\n    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }\r\n    // OBSOLETED in 1.63 (from Aug 2018)\r\n    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }\r\n    // OBSOLETED in 1.61 (from Apr 2018)\r\n    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'!\r\n    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);\r\n    // OBSOLETED in 1.60 (from Dec 2017)\r\n    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }\r\n    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }\r\n    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { (void)on_edge; (void)outward; IM_ASSERT(0); return pos; }\r\n    // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\r\n    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }\r\n    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }\r\n    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }\r\n    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }\r\n    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }\r\n    // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)\r\n    IMGUI_API bool      Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.\r\n    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }\r\n    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }\r\n    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }\r\n    // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)\r\n    static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }\r\n    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.\r\n    static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }\r\n    static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }\r\n}\r\ntypedef ImGuiInputTextCallback      ImGuiTextEditCallback;      // OBSOLETE in 1.63 (from Aug 2018): made the names consistent\r\ntypedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n// Helper: Lightweight std::vector<> like class to avoid dragging dependencies (also: Windows implementation of STL with debug enabled is absurdly slow, so let's bypass it so our code runs fast in debug).\r\n// *Important* Our implementation does NOT call C++ constructors/destructors. This is intentional, we do not require it but you have to be mindful of that. Do _not_ use this class as a std::vector replacement in your code!\r\ntemplate<typename T>\r\nclass ImVector\r\n{\r\npublic:\r\n    int                         Size;\r\n    int                         Capacity;\r\n    T*                          Data;\r\n\r\n    typedef T                   value_type;\r\n    typedef value_type*         iterator;\r\n    typedef const value_type*   const_iterator;\r\n\r\n    inline ImVector()           { Size = Capacity = 0; Data = NULL; }\r\n    inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }\r\n    inline ImVector(const ImVector<T>& src)                     { Size = Capacity = 0; Data = NULL; operator=(src); }\r\n    inline ImVector<T>& operator=(const ImVector<T>& src)       { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(value_type)); return *this; }\r\n\r\n    inline bool                 empty() const                   { return Size == 0; }\r\n    inline int                  size() const                    { return Size; }\r\n    inline int                  capacity() const                { return Capacity; }\r\n    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }\r\n    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }\r\n\r\n    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }\r\n    inline iterator             begin()                         { return Data; }\r\n    inline const_iterator       begin() const                   { return Data; }\r\n    inline iterator             end()                           { return Data + Size; }\r\n    inline const_iterator       end() const                     { return Data + Size; }\r\n    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }\r\n    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }\r\n    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size - 1]; }\r\n    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size - 1]; }\r\n    inline void                 swap(ImVector<value_type>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }\r\n\r\n    inline int          _grow_capacity(int sz) const            { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }\r\n    inline void         resize(int new_size)                    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }\r\n    inline void         resize(int new_size,const value_type& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }\r\n    inline void         reserve(int new_capacity)\r\n    {\r\n        if (new_capacity <= Capacity)\r\n            return;\r\n        value_type* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));\r\n        if (Data)\r\n        {\r\n            memcpy(new_data, Data, (size_t)Size * sizeof(value_type));\r\n            ImGui::MemFree(Data);\r\n        }\r\n        Data = new_data;\r\n        Capacity = new_capacity;\r\n    }\r\n\r\n    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.\r\n    inline void         push_back(const value_type& v)                  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }\r\n    inline void         pop_back()                                      { IM_ASSERT(Size > 0); Size--; }\r\n    inline void         push_front(const value_type& v)                 { if (Size == 0) push_back(v); else insert(Data, v); }\r\n    inline iterator     erase(const_iterator it)                        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }\r\n    inline iterator     erase(const_iterator it, const_iterator it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(value_type)); Size -= (int)count; return Data + off; }\r\n    inline iterator     erase_unsorted(const_iterator it)               { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(value_type)); Size--; return Data + off; }\r\n    inline iterator     insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }\r\n    inline bool         contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }\r\n    inline int          index_from_pointer(const_iterator it) const     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }\r\n};\r\n\r\n// Helper: IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() macros to call MemAlloc + Placement New, Placement Delete + MemFree\r\n// We call C++ constructor on own allocated memory via the placement \"new(ptr) Type()\" syntax.\r\n// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.\r\nstruct ImNewDummy {};\r\ninline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }\r\ninline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symetrical new()\r\n#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)\r\n#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE\r\ntemplate<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }\r\n\r\n// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.\r\n// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\");\r\nstruct ImGuiOnceUponAFrame\r\n{\r\n    ImGuiOnceUponAFrame() { RefFrame = -1; }\r\n    mutable int RefFrame;\r\n    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }\r\n};\r\n\r\n// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS    // Will obsolete\r\n#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)\r\n#endif\r\n\r\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\r\nstruct ImGuiTextFilter\r\n{\r\n    IMGUI_API           ImGuiTextFilter(const char* default_filter = \"\");\r\n    IMGUI_API bool      Draw(const char* label = \"Filter (inc,-exc)\", float width = 0.0f);    // Helper calling InputText+Build\r\n    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;\r\n    IMGUI_API void      Build();\r\n    void                Clear()          { InputBuf[0] = 0; Build(); }\r\n    bool                IsActive() const { return !Filters.empty(); }\r\n\r\n    // [Internal]\r\n    struct TextRange\r\n    {\r\n        const char* b;\r\n        const char* e;\r\n\r\n        TextRange() { b = e = NULL; }\r\n        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }\r\n        const char*     begin() const   { return b; }\r\n        const char*     end () const    { return e; }\r\n        bool            empty() const   { return b == e; }\r\n        IMGUI_API void  split(char separator, ImVector<TextRange>* out) const;\r\n    };\r\n    char                InputBuf[256];\r\n    ImVector<TextRange> Filters;\r\n    int                 CountGrep;\r\n};\r\n\r\n// Helper: Growable text buffer for logging/accumulating text\r\n// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')\r\nstruct ImGuiTextBuffer\r\n{\r\n    ImVector<char>      Buf;\r\n    static char         EmptyString[1];\r\n\r\n    ImGuiTextBuffer()   { }\r\n    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }\r\n    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }\r\n    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator\r\n    int                 size() const            { return Buf.Data ? Buf.Size - 1 : 0; }\r\n    bool                empty()                 { return Buf.Size <= 1; }\r\n    void                clear()                 { Buf.clear(); }\r\n    void                reserve(int capacity)   { Buf.reserve(capacity); }\r\n    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }\r\n    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);\r\n    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);\r\n};\r\n\r\n// Helper: Key->Value storage\r\n// Typically you don't have to worry about this since a storage is held within each Window.\r\n// We use it to e.g. store collapse state for a tree (Int 0/1)\r\n// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)\r\n// You can use it as custom user storage for temporary values. Declare your own storage if, for example:\r\n// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).\r\n// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)\r\n// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.\r\nstruct ImGuiStorage\r\n{\r\n    struct Pair\r\n    {\r\n        ImGuiID key;\r\n        union { int val_i; float val_f; void* val_p; };\r\n        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }\r\n        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }\r\n        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }\r\n    };\r\n    ImVector<Pair>      Data;\r\n\r\n    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)\r\n    // - Set***() functions find pair, insertion on demand if missing.\r\n    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.\r\n    void                Clear() { Data.clear(); }\r\n    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;\r\n    IMGUI_API void      SetInt(ImGuiID key, int val);\r\n    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;\r\n    IMGUI_API void      SetBool(ImGuiID key, bool val);\r\n    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;\r\n    IMGUI_API void      SetFloat(ImGuiID key, float val);\r\n    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL\r\n    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);\r\n\r\n    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.\r\n    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\r\n    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)\r\n    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat(\"var\", pvar, 0, 100.0f); some_var += *pvar;\r\n    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);\r\n    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);\r\n    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);\r\n    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);\r\n\r\n    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)\r\n    IMGUI_API void      SetAllInt(int val);\r\n\r\n    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\r\n    IMGUI_API void      BuildSortByKey();\r\n};\r\n\r\n// Helper: Manually clip large list of items.\r\n// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.\r\n// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.\r\n// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.\r\n// Usage:\r\n//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.\r\n//     while (clipper.Step())\r\n//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n//             ImGui::Text(\"line number %d\", i);\r\n// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).\r\n// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.\r\n// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)\r\n// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.\r\nstruct ImGuiListClipper\r\n{\r\n    float   StartPosY;\r\n    float   ItemsHeight;\r\n    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;\r\n\r\n    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).\r\n    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().\r\n    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().\r\n    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).\r\n    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.\r\n\r\n    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.\r\n    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.\r\n    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.\r\n};\r\n\r\n// Helpers macros to generate 32-bits encoded colors\r\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\r\n#define IM_COL32_R_SHIFT    16\r\n#define IM_COL32_G_SHIFT    8\r\n#define IM_COL32_B_SHIFT    0\r\n#define IM_COL32_A_SHIFT    24\r\n#define IM_COL32_A_MASK     0xFF000000\r\n#else\r\n#define IM_COL32_R_SHIFT    0\r\n#define IM_COL32_G_SHIFT    8\r\n#define IM_COL32_B_SHIFT    16\r\n#define IM_COL32_A_SHIFT    24\r\n#define IM_COL32_A_MASK     0xFF000000\r\n#endif\r\n#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))\r\n#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF\r\n#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black\r\n#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000\r\n\r\n// Helper: ImColor() implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)\r\n// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.\r\n// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.\r\n// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.\r\nstruct ImColor\r\n{\r\n    ImVec4              Value;\r\n\r\n    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }\r\n    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }\r\n    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }\r\n    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }\r\n    ImColor(const ImVec4& col)                                      { Value = col; }\r\n    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }\r\n    inline operator ImVec4() const                                  { return Value; }\r\n\r\n    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.\r\n    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }\r\n    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)\r\n// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.\r\n//-----------------------------------------------------------------------------\r\n\r\n// Draw callbacks for advanced uses.\r\n// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,\r\n// you can poke into the draw list for that! Draw callback may be useful for example to: A) Change your GPU render state, \r\n// B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.\r\n// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'\r\ntypedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);\r\n\r\n// Typically, 1 command = 1 GPU draw call (unless command is a callback)\r\nstruct ImDrawCmd\r\n{\r\n    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].\r\n    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in \"viewport\" coordinates\r\n    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.\r\n    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.\r\n    void*           UserCallbackData;       // The draw callback code can access this.\r\n\r\n    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }\r\n};\r\n\r\n// Vertex index (override with '#define ImDrawIdx unsigned int' in imconfig.h)\r\n#ifndef ImDrawIdx\r\ntypedef unsigned short ImDrawIdx;\r\n#endif\r\n\r\n// Vertex layout\r\n#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT\r\nstruct ImDrawVert\r\n{\r\n    ImVec2  pos;\r\n    ImVec2  uv;\r\n    ImU32   col;\r\n};\r\n#else\r\n// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h\r\n// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.\r\n// The type has to be described within the macro (you can either declare the struct or use a typedef)\r\n// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.\r\nIMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;\r\n#endif\r\n\r\n// Draw channels are used by the Columns API to \"split\" the render list into different channels while building, so items of each column can be batched together.\r\n// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.\r\nstruct ImDrawChannel\r\n{\r\n    ImVector<ImDrawCmd>     CmdBuffer;\r\n    ImVector<ImDrawIdx>     IdxBuffer;\r\n};\r\n\r\nenum ImDrawCornerFlags_\r\n{\r\n    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1\r\n    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2\r\n    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4\r\n    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8\r\n    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3\r\n    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC\r\n    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5\r\n    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA\r\n    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience\r\n};\r\n\r\nenum ImDrawListFlags_\r\n{\r\n    ImDrawListFlags_None             = 0,\r\n    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)\r\n    ImDrawListFlags_AntiAliasedFill  = 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)\r\n};\r\n\r\n// Draw command list\r\n// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.\r\n// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.\r\n// You can interleave normal ImGui:: calls and adding primitives to the current draw list.\r\n// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)\r\n// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.\r\nstruct ImDrawList\r\n{\r\n    // This is what you have to render\r\n    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.\r\n    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those\r\n    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.\r\n    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.\r\n\r\n    // [Internal, used while building lists]\r\n    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)\r\n    const char*             _OwnerName;         // Pointer to owner window's name for debugging\r\n    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size\r\n    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n    ImVector<ImVec4>        _ClipRectStack;     // [Internal]\r\n    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]\r\n    ImVector<ImVec2>        _Path;              // [Internal] current path building\r\n    int                     _ChannelsCurrent;   // [Internal] current channel number (0)\r\n    int                     _ChannelsCount;     // [Internal] number of active channels (1+)\r\n    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)\r\n\r\n    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)\r\n    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }\r\n    ~ImDrawList() { ClearFreeMemory(); }\r\n    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\r\n    IMGUI_API void  PushClipRectFullScreen();\r\n    IMGUI_API void  PopClipRect();\r\n    IMGUI_API void  PushTextureID(ImTextureID texture_id);\r\n    IMGUI_API void  PopTextureID();\r\n    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }\r\n    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }\r\n\r\n    // Primitives\r\n    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round\r\n    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right\r\n    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);\r\n    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);\r\n    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);\r\n    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);\r\n    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);\r\n    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);\r\n    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);\r\n    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);\r\n    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);\r\n    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);\r\n    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);\r\n    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.\r\n    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);\r\n\r\n    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()\r\n    inline    void  PathClear()                                                 { _Path.resize(0); }\r\n    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }\r\n    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }\r\n    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }  // Note: Anti-aliased filling requires points to be in clockwise order.\r\n    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }\r\n    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);\r\n    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle\r\n    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);\r\n    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);\r\n\r\n    // Channels\r\n    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)\r\n    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)\r\n    IMGUI_API void  ChannelsSplit(int channels_count);\r\n    IMGUI_API void  ChannelsMerge();\r\n    IMGUI_API void  ChannelsSetCurrent(int channel_index);\r\n\r\n    // Advanced\r\n    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.\r\n    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible\r\n    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.\r\n\r\n    // Internal helpers\r\n    // NB: all primitives needs to be reserved via PrimReserve() beforehand!\r\n    IMGUI_API void  Clear();\r\n    IMGUI_API void  ClearFreeMemory();\r\n    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);\r\n    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)\r\n    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);\r\n    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);\r\n    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }\r\n    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }\r\n    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }\r\n    IMGUI_API void  UpdateClipRect();\r\n    IMGUI_API void  UpdateTextureID();\r\n};\r\n\r\n// All draw data to render an ImGui frame\r\n// (NB: the style and the naming convention here is a little inconsistent but we preserve them for backward compatibility purpose)\r\nstruct ImDrawData\r\n{\r\n    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.\r\n    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.\r\n    int             CmdListsCount;          // Number of ImDrawList* to render\r\n    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size\r\n    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size\r\n    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)\r\n    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)\r\n\r\n    // Functions\r\n    ImDrawData()    { Valid = false; Clear(); }\r\n    ~ImDrawData()   { Clear(); }\r\n    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!\r\n    IMGUI_API void  DeIndexAllBuffers();                // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\r\n    IMGUI_API void  ScaleClipRects(const ImVec2& sc);   // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFont)\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImFontConfig\r\n{\r\n    void*           FontData;               //          // TTF/OTF data\r\n    int             FontDataSize;           //          // TTF/OTF data size\r\n    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).\r\n    int             FontNo;                 // 0        // Index of font within TTF/OTF file\r\n    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).\r\n    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.\r\n    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.\r\n    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.\r\n    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.\r\n    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font\r\n    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs\r\n    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.\r\n    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.\r\n    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.\r\n\r\n    // [Internal]\r\n    char            Name[40];               // Name (strictly to ease debugging)\r\n    ImFont*         DstFont;\r\n\r\n    IMGUI_API ImFontConfig();\r\n};\r\n\r\nstruct ImFontGlyph\r\n{\r\n    ImWchar         Codepoint;          // 0x0000..0xFFFF\r\n    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)\r\n    float           X0, Y0, X1, Y1;     // Glyph corners\r\n    float           U0, V0, U1, V1;     // Texture coordinates\r\n};\r\n\r\nenum ImFontAtlasFlags_\r\n{\r\n    ImFontAtlasFlags_None               = 0,\r\n    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two\r\n    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas\r\n};\r\n\r\n// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:\r\n//  - One or more fonts.\r\n//  - Custom graphics data needed to render the shapes needed by Dear ImGui.\r\n//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).\r\n// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.\r\n//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.\r\n//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\r\n//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)\r\n//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API. \r\n//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.\r\n// Common pitfalls:\r\n// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the \r\n//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.\r\n// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.\r\n//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed, \r\n// - Even though many functions are suffixed with \"TTF\", OTF data is supported just as well.\r\n// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!\r\nstruct ImFontAtlas\r\n{\r\n    IMGUI_API ImFontAtlas();\r\n    IMGUI_API ~ImFontAtlas();\r\n    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);\r\n    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);\r\n    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);\r\n    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.\r\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.\r\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.\r\n    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.\r\n    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.\r\n    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).\r\n    IMGUI_API void              Clear();                    // Clear all input and output.\r\n\r\n    // Build atlas, retrieve pixel data.\r\n    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().\r\n    // The pitch is always = Width * BytesPerPixels (1 or 4)\r\n    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into \r\n    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.\r\n    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.\r\n    IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }\r\n    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel\r\n    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel\r\n    void                        SetTexID(ImTextureID id)    { TexID = id; }\r\n\r\n    //-------------------------------------------\r\n    // Glyph Ranges\r\n    //-------------------------------------------\r\n\r\n    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)\r\n    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8\"Hello world\" syntax. See FAQ for details.\r\n    // NB: Consider using GlyphRangesBuilder to build glyph ranges from textual data.\r\n    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin\r\n    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters\r\n    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs\r\n    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs\r\n    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese\r\n    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters\r\n    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters\r\n\r\n    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().\r\n    struct GlyphRangesBuilder\r\n    {\r\n        ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)\r\n        GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }\r\n        bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }\r\n        void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array\r\n        void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character\r\n        IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)\r\n        IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext\r\n        IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges\r\n    };\r\n\r\n    //-------------------------------------------\r\n    // Custom Rectangles/Glyphs API\r\n    //-------------------------------------------\r\n\r\n    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.\r\n    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.\r\n    struct CustomRect\r\n    {\r\n        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.\r\n        unsigned short  Width, Height;  // Input    // Desired rectangle dimension\r\n        unsigned short  X, Y;           // Output   // Packed position in Atlas\r\n        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance\r\n        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset\r\n        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font\r\n        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }\r\n        bool IsPacked() const   { return X != 0xFFFF; }\r\n    };\r\n\r\n    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList\r\n    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.\r\n    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }\r\n\r\n    // [Internal]\r\n    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);\r\n    IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);\r\n\r\n    //-------------------------------------------\r\n    // Members\r\n    //-------------------------------------------\r\n\r\n    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.\r\n    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)\r\n    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.\r\n    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.\r\n    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.\r\n\r\n    // [Internal]\r\n    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.\r\n    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight\r\n    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4\r\n    int                         TexWidth;           // Texture width calculated during Build().\r\n    int                         TexHeight;          // Texture height calculated during Build().\r\n    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)\r\n    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel\r\n    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.\r\n    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.\r\n    ImVector<ImFontConfig>      ConfigData;         // Internal data\r\n    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList\r\n};\r\n\r\n// Font runtime data and rendering\r\n// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().\r\nstruct ImFont\r\n{\r\n    // Members: Hot ~62/78 bytes\r\n    float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)\r\n    float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()\r\n    ImVec2                      DisplayOffset;      // = (0.f,0.f)  // Offset font rendering by xx pixels\r\n    ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.\r\n    ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).\r\n    ImVector<ImWchar>           IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.\r\n    const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)\r\n    float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX\r\n    ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()\r\n\r\n    // Members: Cold ~18/26 bytes\r\n    short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.\r\n    ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData\r\n    ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into\r\n    float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]\r\n    bool                        DirtyLookupTables;\r\n    int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)\r\n\r\n    // Methods\r\n    IMGUI_API ImFont();\r\n    IMGUI_API ~ImFont();\r\n    IMGUI_API void              ClearOutputData();\r\n    IMGUI_API void              BuildLookupTable();\r\n    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;\r\n    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;\r\n    IMGUI_API void              SetFallbackChar(ImWchar c);\r\n    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }\r\n    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }\r\n    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : \"<unknown>\"; }\r\n\r\n    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.\r\n    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.\r\n    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8\r\n    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;\r\n    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;\r\n    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;\r\n\r\n    // [Internal]\r\n    IMGUI_API void              GrowIndex(int new_size);\r\n    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);\r\n    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+\r\n#endif\r\n};\r\n\r\n#if defined(__clang__)\r\n#pragma clang diagnostic pop\r\n#elif defined(__GNUC__) && __GNUC__ >= 8\r\n#pragma GCC diagnostic pop\r\n#endif\r\n\r\n// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)\r\n#ifdef IMGUI_INCLUDE_IMGUI_USER_H\r\n#include \"imgui_user.h\"\r\n#endif\r\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool starts_with(basic_string_view<charT, traits> sv) const noexcept; // C++2a\n    bool starts_with(charT c) const noexcept;                             // C++2a\n    bool starts_with(const charT* s) const;                               // C++2a\n    bool ends_with(basic_string_view<charT, traits> sv) const noexcept;   // C++2a\n    bool ends_with(charT c) const noexcept;                               // C++2a\n    bool ends_with(const charT* s) const;                                 // C++2a\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n    ( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef _CharT                                       value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, typename traits_type::char_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#ifdef _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x01;\n    static const size_type __long_mask  = 0x1ul;\n#else  // _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x80;\n    static const size_type __long_mask  = ~(size_type(~0) >> 1);\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#ifdef _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x80;\n    static const size_type __long_mask  = ~(size_type(~0) >> 1);\n#else  // _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x01;\n    static const size_type __long_mask  = 0x1ul;\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY basic_string(const _CharT* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, const _Allocator& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, _CharT __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, _CharT __c, const _Allocator& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const _Allocator& __a = _Allocator());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const _Allocator& __a = _Allocator());\n    template<class _Tp>\n        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n        basic_string(const _Tp& __t, size_type __pos, size_type __n,\n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const _Allocator& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<_CharT> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);\n#endif  // _LIBCPP_CXX03_LANG\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n     _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type __res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(__str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14 || defined(_LIBCPP_BUILDING_LIBRARY)\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n#if _LIBCPP_STD_VER > 17\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(__self_view __sv) const _NOEXCEPT\n    { return __self_view(data(), size()).starts_with(__sv); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(front(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(const value_type* __s) const _NOEXCEPT\n    { return starts_with(__self_view(__s)); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(__self_view __sv) const _NOEXCEPT\n    { return __self_view(data(), size()).ends_with( __sv); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(back(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(const value_type* __s) const _NOEXCEPT\n    { return ends_with(__self_view(__s)); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline\n    void __init(const value_type* __s, size_type __sz);\n    inline\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() == __str.__alloc())\n                __alloc() = __str.__alloc();\n            else\n            {\n                if (!__str.__is_long())\n                {\n                    clear();\n                    shrink_to_fit();\n                    __alloc() = __str.__alloc();\n                }\n                else\n                {\n                    allocator_type __a = __str.__alloc();\n                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());\n                    clear();\n                    shrink_to_fit();\n                    __alloc() = _VSTD::move(__a);\n                    __set_long_pointer(__p);\n                    __set_long_cap(__str.__get_long_cap());\n                    __set_long_size(__str.size());\n                }\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__second_tag(), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__second_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    const basic_string& __str, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,\n                                                        size_type __pos, size_type __n,\n                                                        const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n             typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__second_tag(), __a)\n{\n    __self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    initializer_list<_CharT> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    initializer_list<_CharT> __il, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n// __sz += __n2 - __n1; in this and the below function below can cause unsigned integer overflow,\n// but this is a safe operation, so we disable the check.\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#ifdef _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    int\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\ninline constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class T> constexpr T* to_address(T* p) noexcept; // C++20\ntemplate <class Ptr> auto to_address(const Ptr& p) noexcept; // C++20\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);                          // [[nodiscard]] in C++20\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint); // [[nodiscard]] in C++20\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};      // removed in C++17\n\ntemplate<class X>\nclass auto_ptr                                  // removed in C++17\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;       // removed in C++17\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class E, class T, class Y, class D>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, unique_ptr<Y, D> const& p);\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);          // removed in C++17\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r); // removed in C++17\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n};\n\ntemplate <>  // Added in C++14\nstruct owner_less<void>\n{\n    template <class _Tp, class _Up>\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;\n\n    typedef void is_transparent;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\ntemplate <class T, class Alloc>\n  inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n#include <cassert>\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp, class = void>\nstruct __has_element_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_element_type<_Tp,\n              typename __void_t<typename _Tp::element_type>::type> : true_type {};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class = void>\nstruct __has_difference_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_difference_type<_Tp,\n            typename __void_t<typename _Tp::difference_type>::type> : true_type {};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\ntemplate <class _Tp, class = void>\nstruct __has_pointer_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_pointer_type<_Tp,\n          typename __void_t<typename _Tp::pointer>::type> : true_type {};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_const_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_const_pointer<_Tp,\n            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_void_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_void_pointer<_Tp,\n               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_const_void_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer<_Tp,\n            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\n#if _LIBCPP_STD_VER <= 17\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n#else\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__to_raw_pointer(const _Pointer& __p) _NOEXCEPT\n-> decltype(pointer_traits<_Pointer>::to_address(__p))\n{\n    return pointer_traits<_Pointer>::to_address(__p);\n}\n\ntemplate <class _Pointer, class... _None>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__to_raw_pointer(const _Pointer& __p, _None...) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY constexpr\n_Tp*\nto_address(_Tp* __p) _NOEXCEPT\n{\n    static_assert(!is_function_v<_Tp>, \"_Tp is a function type\");\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nto_address(const _Pointer& __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p);\n}\n#endif\n\ntemplate <class _Tp, class = void>\nstruct __has_size_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_size_type<_Tp,\n               typename __void_t<typename _Tp::size_type>::type> : true_type {};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_copy_assignment : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment<_Tp,\n    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>\n        : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_move_assignment : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment<_Tp,\n           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_swap : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap<_Tp,\n           typename __void_t<typename _Tp::propagate_on_container_swap>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_is_always_equal : false_type {};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal<_Tp,\n           typename __void_t<typename _Tp::is_always_equal>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype((void)__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return __allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return __select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer __allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer __allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a) _NOEXCEPT\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&) _NOEXCEPT\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        __select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        __select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY \n    pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*) const_cast<_Tp *>(__p));}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; }\n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n#endif\n\ntemplate <class _Tp, int _Idx,\n          bool _CanBeEmptyBase =\n              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>\nstruct __compressed_pair_elem {\n  typedef _Tp _ParamT;\n  typedef _Tp& reference;\n  typedef const _Tp& const_reference;\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() : __value_() {}\n\n  template <class _Up, class = typename enable_if<\n      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value\n  >::type>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr explicit\n  __compressed_pair_elem(_Up&& __u)\n      : __value_(_VSTD::forward<_Up>(__u)){};\n\n  template <class... _Args, size_t... _Indexes>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,\n                         __tuple_indices<_Indexes...>)\n      : __value_(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}\n#else\n  _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_() {}\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return __value_; }\n  _LIBCPP_INLINE_VISIBILITY\n  const_reference __get() const _NOEXCEPT { return __value_; }\n\nprivate:\n  _Tp __value_;\n};\n\ntemplate <class _Tp, int _Idx>\nstruct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {\n  typedef _Tp _ParamT;\n  typedef _Tp& reference;\n  typedef const _Tp& const_reference;\n  typedef _Tp __value_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() = default;\n\n  template <class _Up, class = typename enable_if<\n        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value\n  >::type>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr explicit\n  __compressed_pair_elem(_Up&& __u)\n      : __value_type(_VSTD::forward<_Up>(__u)){};\n\n  template <class... _Args, size_t... _Indexes>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,\n                         __tuple_indices<_Indexes...>)\n      : __value_type(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}\n#else\n  _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_type() {}\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair_elem(_ParamT __p)\n      : __value_type(std::forward<_ParamT>(__p)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return *this; }\n  _LIBCPP_INLINE_VISIBILITY\n  const_reference __get() const _NOEXCEPT { return *this; }\n};\n\n// Tag used to construct the second element of the compressed pair.\nstruct __second_tag {};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair : private __compressed_pair_elem<_T1, 0>,\n                          private __compressed_pair_elem<_T2, 1> {\n  typedef __compressed_pair_elem<_T1, 0> _Base1;\n  typedef __compressed_pair_elem<_T2, 1> _Base2;\n\n  // NOTE: This static assert should never fire because __compressed_pair\n  // is *almost never* used in a scenario where it's possible for T1 == T2.\n  // (The exception is std::function where it is possible that the function\n  //  object and the allocator have the same type).\n  static_assert((!is_same<_T1, _T2>::value),\n    \"__compressed_pair cannot be instantated when T1 and T2 are the same type; \"\n    \"The current implementation is NOT ABI-compatible with the previous \"\n    \"implementation for this configuration\");\n\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n  template <bool _Dummy = true,\n      class = typename enable_if<\n          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&\n          __dependent_type<is_default_constructible<_T2>, _Dummy>::value\n      >::type\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr __compressed_pair() {}\n\n  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,\n                                                   __compressed_pair>::value,\n                                          bool>::type = true>\n  _LIBCPP_INLINE_VISIBILITY constexpr explicit\n  __compressed_pair(_Tp&& __t)\n      : _Base1(std::forward<_Tp>(__t)), _Base2() {}\n\n  template <class _Tp>\n  _LIBCPP_INLINE_VISIBILITY constexpr\n  __compressed_pair(__second_tag, _Tp&& __t)\n      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}\n\n  template <class _U1, class _U2>\n  _LIBCPP_INLINE_VISIBILITY constexpr\n  __compressed_pair(_U1&& __t1, _U2&& __t2)\n      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}\n\n  template <class... _Args1, class... _Args2>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                    tuple<_Args2...> __second_args)\n      : _Base1(__pc, _VSTD::move(__first_args),\n               typename __make_tuple_indices<sizeof...(_Args1)>::type()),\n        _Base2(__pc, _VSTD::move(__second_args),\n               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}\n\n#else\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair() {}\n\n  _LIBCPP_INLINE_VISIBILITY explicit\n  __compressed_pair(_T1 __t1) : _Base1(_VSTD::forward<_T1>(__t1)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair(__second_tag, _T2 __t2)\n      : _Base1(), _Base2(_VSTD::forward<_T2>(__t2)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair(_T1 __t1, _T2 __t2)\n      : _Base1(_VSTD::forward<_T1>(__t1)), _Base2(_VSTD::forward<_T2>(__t2)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base1::reference first() _NOEXCEPT {\n    return static_cast<_Base1&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base1::const_reference first() const _NOEXCEPT {\n    return static_cast<_Base1 const&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base2::reference second() _NOEXCEPT {\n    return static_cast<_Base2&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base2::const_reference second() const _NOEXCEPT {\n    return static_cast<_Base2 const&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(__compressed_pair& __x)\n    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n               __is_nothrow_swappable<_T2>::value)\n  {\n    using std::swap;\n    swap(first(), __x.first());\n    swap(second(), __x.second());\n  }\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n               __is_nothrow_swappable<_T2>::value) {\n  __x.swap(__y);\n}\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete {\n    static_assert(!is_function<_Tp>::value,\n                  \"default_delete cannot be instantiated for function types\");\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;\n#else\n  _LIBCPP_INLINE_VISIBILITY default_delete() {}\n#endif\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  default_delete(const default_delete<_Up>&,\n                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =\n                     0) _NOEXCEPT {}\n\n  _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __ptr) const _NOEXCEPT {\n    static_assert(sizeof(_Tp) > 0,\n                  \"default_delete can not delete incomplete type\");\n    static_assert(!is_void<_Tp>::value,\n                  \"default_delete can not delete incomplete type\");\n    delete __ptr;\n  }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]> {\nprivate:\n  template <class _Up>\n  struct _EnableIfConvertible\n      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};\n\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;\n#else\n  _LIBCPP_INLINE_VISIBILITY default_delete() {}\n#endif\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  default_delete(const default_delete<_Up[]>&,\n                 typename _EnableIfConvertible<_Up>::type* = 0) _NOEXCEPT {}\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  typename _EnableIfConvertible<_Up>::type\n  operator()(_Up* __ptr) const _NOEXCEPT {\n    static_assert(sizeof(_Tp) > 0,\n                  \"default_delete can not delete incomplete type\");\n    static_assert(!is_void<_Tp>::value,\n                  \"default_delete can not delete void type\");\n    delete[] __ptr;\n  }\n};\n\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae {\n  static_assert(!is_reference<_Deleter>::value, \"incorrect specialization\");\n  typedef const _Deleter& __lval_ref_type;\n  typedef _Deleter&& __good_rval_ref_type;\n  typedef true_type __enable_rval_overload;\n};\n\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae<_Deleter const&> {\n  typedef const _Deleter& __lval_ref_type;\n  typedef const _Deleter&& __bad_rval_ref_type;\n  typedef false_type __enable_rval_overload;\n};\n\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae<_Deleter&> {\n  typedef _Deleter& __lval_ref_type;\n  typedef _Deleter&& __bad_rval_ref_type;\n  typedef false_type __enable_rval_overload;\n};\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr {\npublic:\n  typedef _Tp element_type;\n  typedef _Dp deleter_type;\n  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\n\n  static_assert(!is_rvalue_reference<deleter_type>::value,\n                \"the specified deleter type cannot be an rvalue reference\");\n\nprivate:\n  __compressed_pair<pointer, deleter_type> __ptr_;\n\n  struct __nat { int __for_bool_; };\n\n#ifndef _LIBCPP_CXX03_LANG\n  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;\n\n  template <bool _Dummy>\n  using _LValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;\n\n  template <bool _Dummy>\n  using _GoodRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;\n\n  template <bool _Dummy>\n  using _BadRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;\n\n  template <bool _Dummy, class _Deleter = typename __dependent_type<\n                             __identity<deleter_type>, _Dummy>::type>\n  using _EnableIfDeleterDefaultConstructible =\n      typename enable_if<is_default_constructible<_Deleter>::value &&\n                         !is_pointer<_Deleter>::value>::type;\n\n  template <class _ArgType>\n  using _EnableIfDeleterConstructible =\n      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;\n\n  template <class _UPtr, class _Up>\n  using _EnableIfMoveConvertible = typename enable_if<\n      is_convertible<typename _UPtr::pointer, pointer>::value &&\n      !is_array<_Up>::value\n  >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterConvertible = typename enable_if<\n      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||\n      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterAssignable = typename enable_if<\n      is_assignable<_Dp&, _UDel&&>::value\n    >::type;\n\npublic:\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, __d) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterConvertible<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(auto_ptr<_Up>&& __p,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value &&\n                                    is_same<_Dp, default_delete<_Tp>>::value,\n                                __nat>::type = __nat()) _NOEXCEPT\n      : __ptr_(__p.release()) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n    return *this;\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterAssignable<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n#else  // _LIBCPP_CXX03_LANG\nprivate:\n  unique_ptr(unique_ptr&);\n  template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep>&);\n\n  unique_ptr& operator=(unique_ptr&);\n  template <class _Up, class _Ep> unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr() : __ptr_(pointer())\n  {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n    static_assert(is_default_constructible<deleter_type>::value,\n                  \"unique_ptr::deleter_type is not default constructible\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t) : __ptr_(pointer())\n  {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p)\n      : __ptr_(_VSTD::move(__p)) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator __rv<unique_ptr>() {\n    return __rv<unique_ptr>(*this);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(__rv<unique_ptr> __u)\n      : __ptr_(__u->release(),\n               _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n  template <class _Up, class _Ep>\n  _LIBCPP_INLINE_VISIBILITY\n  typename enable_if<\n      !is_array<_Up>::value &&\n          is_convertible<typename unique_ptr<_Up, _Ep>::pointer,\n                         pointer>::value &&\n          is_assignable<deleter_type&, _Ep&>::value,\n      unique_ptr&>::type\n  operator=(unique_ptr<_Up, _Ep> __u) {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, deleter_type __d)\n      : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n#endif // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n      typename enable_if<is_convertible<_Up*, _Tp*>::value &&\n                             is_same<_Dp, default_delete<_Tp> >::value,\n                         unique_ptr&>::type\n      operator=(auto_ptr<_Up> __p) {\n    reset(__p.release());\n    return *this;\n  }\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~unique_ptr() { reset(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(nullptr_t) _NOEXCEPT {\n    reset();\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename add_lvalue_reference<_Tp>::type\n  operator*() const {\n    return *__ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer operator->() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer get() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  deleter_type& get_deleter() _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  const deleter_type& get_deleter() const _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n    return __ptr_.first() != nullptr;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer release() _NOEXCEPT {\n    pointer __t = __ptr_.first();\n    __ptr_.first() = pointer();\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void reset(pointer __p = pointer()) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(unique_ptr& __u) _NOEXCEPT {\n    __ptr_.swap(__u.__ptr_);\n  }\n};\n\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp> {\npublic:\n  typedef _Tp element_type;\n  typedef _Dp deleter_type;\n  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\n\nprivate:\n  __compressed_pair<pointer, deleter_type> __ptr_;\n\n  template <class _From>\n  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};\n\n  template <class _FromElem>\n  struct _CheckArrayPointerConversion<_FromElem*>\n      : integral_constant<bool,\n          is_same<_FromElem*, pointer>::value ||\n            (is_same<pointer, element_type*>::value &&\n             is_convertible<_FromElem(*)[], element_type(*)[]>::value)\n      >\n  {};\n\n#ifndef _LIBCPP_CXX03_LANG\n  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;\n\n  template <bool _Dummy>\n  using _LValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;\n\n  template <bool _Dummy>\n  using _GoodRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;\n\n  template <bool _Dummy>\n  using _BadRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;\n\n  template <bool _Dummy, class _Deleter = typename __dependent_type<\n                             __identity<deleter_type>, _Dummy>::type>\n  using _EnableIfDeleterDefaultConstructible =\n      typename enable_if<is_default_constructible<_Deleter>::value &&\n                         !is_pointer<_Deleter>::value>::type;\n\n  template <class _ArgType>\n  using _EnableIfDeleterConstructible =\n      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;\n\n  template <class _Pp>\n  using _EnableIfPointerConvertible = typename enable_if<\n      _CheckArrayPointerConversion<_Pp>::value\n  >::type;\n\n  template <class _UPtr, class _Up,\n        class _ElemT = typename _UPtr::element_type>\n  using _EnableIfMoveConvertible = typename enable_if<\n      is_array<_Up>::value &&\n      is_same<pointer, element_type*>::value &&\n      is_same<typename _UPtr::pointer, _ElemT*>::value &&\n      is_convertible<_ElemT(*)[], element_type(*)[]>::value\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterConvertible = typename enable_if<\n      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||\n      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterAssignable = typename enable_if<\n      is_assignable<_Dp&, _UDel&&>::value\n    >::type;\n\npublic:\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(_Pp __p) noexcept\n      : __ptr_(__p) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, __d) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(nullptr, __d) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(nullptr, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr&& __u) noexcept {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n    return *this;\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterConvertible<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterAssignable<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr&\n  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n#else // _LIBCPP_CXX03_LANG\nprivate:\n  template <class _Up> explicit unique_ptr(_Up);\n\n  unique_ptr(unique_ptr&);\n  template <class _Up> unique_ptr(unique_ptr<_Up>&);\n\n  unique_ptr& operator=(unique_ptr&);\n  template <class _Up> unique_ptr& operator=(unique_ptr<_Up>&);\n\n  template <class _Up>\n  unique_ptr(_Up __u,\n             typename conditional<\n                 is_reference<deleter_type>::value, deleter_type,\n                 typename add_lvalue_reference<const deleter_type>::type>::type,\n             typename enable_if<is_convertible<_Up, pointer>::value,\n                                __nat>::type = __nat());\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr() : __ptr_(pointer()) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t) : __ptr_(pointer()) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p) : __ptr_(__p) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, deleter_type __d)\n      : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, deleter_type __d)\n      : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator __rv<unique_ptr>() {\n    return __rv<unique_ptr>(*this);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(__rv<unique_ptr> __u)\n      : __ptr_(__u->release(),\n               _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(__rv<unique_ptr> __u) {\n    reset(__u->release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n    return *this;\n  }\n\n#endif // _LIBCPP_CXX03_LANG\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  ~unique_ptr() { reset(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(nullptr_t) _NOEXCEPT {\n    reset();\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename add_lvalue_reference<_Tp>::type\n  operator[](size_t __i) const {\n    return __ptr_.first()[__i];\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer get() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  deleter_type& get_deleter() _NOEXCEPT {\n    return __ptr_.second();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const deleter_type& get_deleter() const _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n    return __ptr_.first() != nullptr;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer release() _NOEXCEPT {\n    pointer __t = __ptr_.first();\n    __ptr_.first() = pointer();\n    return __t;\n  }\n\n  template <class _Pp>\n  _LIBCPP_INLINE_VISIBILITY\n  typename enable_if<\n      _CheckArrayPointerConversion<_Pp>::value\n  >::type\n  reset(_Pp __p) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void reset(nullptr_t = nullptr) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = nullptr;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(unique_ptr& __u) _NOEXCEPT {\n    __ptr_.swap(__u.__ptr_);\n  }\n\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, class _Dp>\n#ifdef _LIBCPP_CXX03_LANG\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n#else\nstruct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<\n    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>\n#endif\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t __size_;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++__size_;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : __size_(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\n// NOTE: Relaxed and acq/rel atomics (for increment and decrement respectively)\n// should be sufficient for thread safety.\n// See https://bugs.llvm.org/show_bug.cgi?id=22803\n#if defined(__clang__) && __has_builtin(__atomic_add_fetch)          \\\n                       && defined(__ATOMIC_RELAXED)                  \\\n                       && defined(__ATOMIC_ACQ_REL)\n#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT\n#elif !defined(__clang__) && defined(_GNUC_VER) && _GNUC_VER >= 407\n#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _Tp\n__libcpp_atomic_refcount_increment(_Tp& __t) _NOEXCEPT\n{\n#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)\n    return __atomic_add_fetch(&__t, 1, __ATOMIC_RELAXED);\n#else\n    return __t += 1;\n#endif\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _Tp\n__libcpp_atomic_refcount_decrement(_Tp& __t) _NOEXCEPT\n{\n#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)\n    return __atomic_add_fetch(&__t, -1, __ATOMIC_ACQ_REL);\n#else\n    return __t -= 1;\n#endif\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n#if defined(_LIBCPP_BUILDING_MEMORY) && \\\n    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_shared() _NOEXCEPT {\n      __libcpp_atomic_refcount_increment(__shared_owners_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    bool __release_shared() _NOEXCEPT {\n      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {\n        __on_zero_shared();\n        return true;\n      }\n      return false;\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n#if defined(_LIBCPP_BUILDING_MEMORY) && \\\n    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_shared() _NOEXCEPT {\n      __shared_count::__add_shared();\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_weak() _NOEXCEPT {\n      __libcpp_atomic_refcount_increment(__shared_weak_owners_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    void __release_shared() _NOEXCEPT {\n      if (__shared_count::__release_shared())\n        __release_weak();\n    }\n#endif\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : nullptr;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\nstruct __shared_ptr_dummy_rebind_allocator_type;\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<__shared_ptr_dummy_rebind_allocator_type>\n{\npublic:\n    template <class _Other>\n    struct rebind\n    {\n        typedef allocator<_Other> other;\n    };\n};\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#endif\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const _NOEXCEPT\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const _NOEXCEPT\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return static_cast<_Dp*>(__cntrl_\n                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))\n                      : nullptr);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    template <class _Yp, bool = is_function<_Yp>::value>\n        struct __shared_ptr_default_allocator\n        {\n            typedef allocator<_Yp> type;\n        };\n\n    template <class _Yp>\n        struct __shared_ptr_default_allocator<_Yp, true>\n        {\n            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;\n        };\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if<is_convertible<_OrigPtr*,\n                                          const enable_shared_from_this<_Yp>*\n        >::value,\n            void>::type\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    static_assert( is_constructible<_Tp, _Args...>::value, \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    static_assert( is_constructible<_Tp, _Args...>::value, \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    static_assert((is_constructible<_Tp>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    static_assert((is_constructible<_Tp, _A0>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1, _A2>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    static_assert((is_constructible<_Tp>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    static_assert((is_constructible<_Tp, _A0>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1, _A2>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,\n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,\n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const _NOEXCEPT\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const _NOEXCEPT\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\n__sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2,\n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool,\n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n\n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n\n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n\n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_MEMORY\n","/*\n * Copyright 2012 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n */\n\n#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/wire.h> requires building with -std=c++11 or newer!\n#else\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                    return &typeid(T);\n#else\n                    static_assert(!has_unbound_type_names,\n                        \"Unbound type names are illegal with RTTI disabled. \"\n                        \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                        \"from the compiler arguments\");\n                    static_assert(!std::is_polymorphic<C>::value,\n                        \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n                }\n\n                return CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            if(has_unbound_type_names || std::is_polymorphic<C>::value) {\n#if __has_feature(cxx_rtti)\n                return &typeid(value);\n#else\n                static_assert(!has_unbound_type_names,\n                    \"Unbound type names are illegal with RTTI disabled. \"\n                    \"Either add -DEMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES=0 to or remove -fno-rtti \"\n                    \"from the compiler arguments\");\n                static_assert(!std::is_polymorphic<C>::value,\n                    \"Canonicalized<T>::type being polymorphic is illegal with RTTI disabled\");\n#endif\n            }\n            return LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n\n        template<typename T>\n        constexpr bool typeSupportsMemoryView() {\n            return (std::is_floating_point<T>::value &&\n                        (sizeof(T) == 4 || sizeof(T) == 8)) ||\n                    (std::is_integral<T>::value &&\n                        (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type of typed_memory_view is invalid\");\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n\n#endif // ~C++11 version check\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP___STRING\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    pointer __soon_to_be_end = __end_;\n    while (__new_last != __soon_to_be_end)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__soon_to_be_end));\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void __emplace_back(const value_type& __x) { push_back(__x); }\n#else\n    template <class _Arg>\n    _LIBCPP_INLINE_VISIBILITY\n    void __emplace_back(_Arg&& __arg) {\n      emplace_back(_VSTD::forward<_Arg>(__arg));\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif // !_LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    iterator insert(const_iterator __position, value_type&& __x);\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // !_LIBCPP_CXX03_LANG\n\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> void __push_back_slow_path(_Up&& __x);\n\n    template <class... _Args>\n    void __emplace_back_slow_path(_Args&&... __args);\n#else\n    template <class _Up> void __push_back_slow_path(_Up& __x);\n#endif\n\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        __emplace_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        __emplace_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        __emplace_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_CXX03_LANG\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(),\n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(),\n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate<class InputIterator, class Size, class Function>\n    InputIterator for_each_n(InputIterator first, Size n, Function f); // C++17\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14, removed in C++17\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14, removed in C++17\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_COMPILER_MSVC)\n#include <intrin.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __invert // invert the sense of a comparison\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __invert() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __invert(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __ctz(unsigned __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n    return static_cast<unsigned>(__builtin_ctz(__x));\n#else\n  static_assert(sizeof(unsigned) == sizeof(unsigned long), \"\");\n  static_assert(sizeof(unsigned long) == 4, \"\");\n  unsigned long where;\n  // Search from LSB to MSB for first set bit.\n  // Returns zero if no set bit is found.\n  if (_BitScanForward(&where, __x))\n    return where;\n  return 32;\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __ctz(unsigned long __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n#else\n    static_assert(sizeof(unsigned long) == sizeof(unsigned), \"\");\n    return __ctz(static_cast<unsigned>(__x));\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __ctz(unsigned long long __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n#else\n    unsigned long where;\n// Search from LSB to MSB for first set bit.\n// Returns zero if no set bit is found.\n#if defined(_LIBCPP_HAS_BITSCAN64)\n    (defined(_M_AMD64) || defined(__x86_64__))\n  if (_BitScanForward64(&where, __x))\n    return static_cast<int>(where);\n#else\n  // Win32 doesn't have _BitScanForward64 so emulate it with two 32 bit calls.\n  // Scan the Low Word.\n  if (_BitScanForward(&where, static_cast<unsigned long>(__x)))\n    return where;\n  // Scan the High Word.\n  if (_BitScanForward(&where, static_cast<unsigned long>(__x >> 32)))\n    return where + 32; // Create a bit offset from the LSB.\n#endif\n  return 64;\n#endif // _LIBCPP_COMPILER_MSVC\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __clz(unsigned __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n    return static_cast<unsigned>(__builtin_clz(__x));\n#else\n  static_assert(sizeof(unsigned) == sizeof(unsigned long), \"\");\n  static_assert(sizeof(unsigned long) == 4, \"\");\n  unsigned long where;\n  // Search from LSB to MSB for first set bit.\n  // Returns zero if no set bit is found.\n  if (_BitScanReverse(&where, __x))\n    return 31 - where;\n  return 32; // Undefined Behavior.\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __clz(unsigned long __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n#else\n    static_assert(sizeof(unsigned) == sizeof(unsigned long), \"\");\n    return __clz(static_cast<unsigned>(__x));\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __clz(unsigned long long __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n#else\n  unsigned long where;\n// BitScanReverse scans from MSB to LSB for first set bit.\n// Returns 0 if no set bit is found.\n#if defined(_LIBCPP_HAS_BITSCAN64)\n  if (_BitScanReverse64(&where, __x))\n    return static_cast<int>(63 - where);\n#else\n  // Scan the high 32 bits.\n  if (_BitScanReverse(&where, static_cast<unsigned long>(__x >> 32)))\n    return 63 - (where + 32); // Create a bit offset from the MSB.\n  // Scan the low 32 bits.\n  if (_BitScanReverse(&where, static_cast<unsigned long>(__x)))\n    return 63 - where;\n#endif\n  return 64; // Undefined Behavior.\n#endif // _LIBCPP_COMPILER_MSVC\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n  return __builtin_popcount  (__x);\n#else\n  static_assert(sizeof(unsigned) == 4, \"\");\n  return __popcnt(__x);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n  return __builtin_popcountl (__x);\n#else\n  static_assert(sizeof(unsigned long) == 4, \"\");\n  return __popcnt(__x);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {\n#ifndef _LIBCPP_COMPILER_MSVC\n  return __builtin_popcountll(__x);\n#else\n  static_assert(sizeof(unsigned long long) == 8, \"\");\n  return __popcnt64(__x);\n#endif\n}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n// for_each_n\n\ntemplate <class _InputIterator, class _Size, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfor_each_n(_InputIterator __first, _Size __orig_n, _Function __f)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    while (__n > 0)\n    {\n         __f(*__first);\n         ++__first;\n         --__n;\n    }\n    return __first;\n}\n#endif\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UIntType, _UIntType _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UIntType) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_CXX03_LANG\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    const size_t _WRt = numeric_limits<result_type>::digits;\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WRt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WRt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE) \\\n  || defined(_LIBCPP_BUILDING_LIBRARY)\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_CXX03_LANG\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n#endif\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output_iter,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output_iter[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output_iter[__r] = *__first;\n  }\n  return __output_iter + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output_iter,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output_iter++ = *__first;\n      --__n;\n    }\n  }\n  return __output_iter;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output_iter,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output_iter, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output_iter,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output_iter, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_CXX03_LANG\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __invert<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_CXX03_LANG\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_CXX03_LANG\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__second_tag(), __a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n// 21.6.4, pointer optimization barrier\ntemplate <class T> constexpr T* launder(T* p) noexcept; // C++17\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable, nodiscard in C++2a\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17, nodiscard in C++2a\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable, nodiscard in C++2a\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17, nodiscard in C++2a\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable, nodiscard in C++2a\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17, nodiscard in C++2a\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable, nodiscard in C++2a\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17, nodiscard in C++2a\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;             // nodiscard in C++2a\nvoid* operator new[](std::size_t size, void* ptr) noexcept;             // nodiscard in C++2a\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)\n#include <new.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\n#if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n#endif // !_LIBCPP_ABI_MICROSOFT || _LIBCPP_NO_VCRUNTIME\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_LIBRARY) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH\n    bad_array_length : public bad_alloc {\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n#if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)\n\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n#endif // !_LIBCPP_ABI_MICROSOFT || _LIBCPP_NO_VCRUNTIME\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\n#ifndef _LIBCPP_NO_EXCEPTIONS\n_LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH\n#endif\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\ntemplate <class _Tp>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline \n_LIBCPP_CONSTEXPR _Tp* __launder(_Tp* __p) _NOEXCEPT\n{\n    static_assert (!(is_function<_Tp>::value), \"can't launder functions\" );\n    static_assert (!(is_same<void, typename remove_cv<_Tp>::type>::value), \"can't launder cv-void\" );\n#ifdef _LIBCPP_COMPILER_HAS_BUILTIN_LAUNDER\n    return __builtin_launder(__p);\n#else\n    return __p;\n#endif\n}\n\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp* launder(_Tp* __p) noexcept\n{\n    return _VSTD::__launder(__p);\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* __msg);\n    __libcpp_refstring(const __libcpp_refstring& __s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& __s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// dear imgui, v1.67 WIP\r\n// (main code and documentation)\r\n\r\n// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.\r\n// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\r\n// Get latest version at https://github.com/ocornut/imgui\r\n// Releases change-log at https://github.com/ocornut/imgui/releases\r\n// Technical Support for Getting Started https://discourse.dearimgui.org/c/getting-started\r\n// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269\r\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\r\n// This library is free but I need your support to sustain development and maintenance.\r\n// If you work for a company, please consider financial support, see README. For individuals: https://www.patreon.com/imgui\r\n\r\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\r\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\r\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\r\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\r\n// to a better solution or official support for them.\r\n\r\n/*\r\n\r\nIndex of this file:\r\n\r\nDOCUMENTATION\r\n\r\n- MISSION STATEMENT\r\n- END-USER GUIDE\r\n- PROGRAMMER GUIDE (read me!)\r\n  - Read first\r\n  - How to update to a newer version of Dear ImGui\r\n  - Getting started with integrating Dear ImGui in your code/engine\r\n  - This is how a simple application may look like (2 variations)\r\n  - This is how a simple rendering function may look like\r\n  - Using gamepad/keyboard navigation controls\r\n- API BREAKING CHANGES (read me when you update!)\r\n- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS\r\n  - How can I tell whether to dispatch mouse/keyboard to imgui or to my application?\r\n  - How can I display an image? What is ImTextureID, how does it works?\r\n  - How can I have multiple widgets with the same label or without a label? A primer on labels and the ID Stack.\r\n  - How can I use my own math types instead of ImVec2/ImVec4? \r\n  - How can I load a different font than the default?\r\n  - How can I easily use icons in my application?\r\n  - How can I load multiple fonts?\r\n  - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?\r\n  - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)\r\n  - I integrated Dear ImGui in my engine and the text or lines are blurry..\r\n  - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..\r\n  - How can I help?\r\n\r\nCODE \r\n(search for \"[SECTION]\" in the code to find them)\r\n\r\n// [SECTION] FORWARD DECLARATIONS\r\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\r\n// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\r\n// [SECTION] MISC HELPER/UTILITIES (Maths, String, Format, Hash, File functions)\r\n// [SECTION] MISC HELPER/UTILITIES (ImText* functions)\r\n// [SECTION] MISC HELPER/UTILITIES (Color functions)\r\n// [SECTION] ImGuiStorage\r\n// [SECTION] ImGuiTextFilter\r\n// [SECTION] ImGuiTextBuffer\r\n// [SECTION] ImGuiListClipper\r\n// [SECTION] RENDER HELPERS\r\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\r\n// [SECTION] TOOLTIPS\r\n// [SECTION] POPUPS\r\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\r\n// [SECTION] COLUMNS\r\n// [SECTION] DRAG AND DROP\r\n// [SECTION] LOGGING/CAPTURING\r\n// [SECTION] SETTINGS\r\n// [SECTION] PLATFORM DEPENDENT HELPERS\r\n// [SECTION] METRICS/DEBUG WINDOW\r\n\r\n*/\r\n\r\n//-----------------------------------------------------------------------------\r\n// DOCUMENTATION\r\n//-----------------------------------------------------------------------------\r\n\r\n/*\r\n\r\n MISSION STATEMENT\r\n =================\r\n\r\n - Easy to use to create code-driven and data-driven tools\r\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools\r\n - Easy to hack and improve\r\n - Minimize screen real-estate usage\r\n - Minimize setup and maintenance\r\n - Minimize state storage on user side\r\n - Portable, minimize dependencies, run on target (consoles, phones, etc.)\r\n - Efficient runtime and memory consumption (NB- we do allocate when \"growing\" content e.g. creating a window,\r\n   opening a tree node for the first time, etc. but a typical frame should not allocate anything)\r\n\r\n Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:\r\n - Doesn't look fancy, doesn't animate\r\n - Limited layout features, intricate layouts are typically crafted in code\r\n\r\n\r\n END-USER GUIDE\r\n ==============\r\n\r\n - Double-click on title bar to collapse window.\r\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\r\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\r\n - Click and drag on any empty space to move window.\r\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\r\n - CTRL+Click on a slider or drag box to input value as text.\r\n - Use mouse wheel to scroll.\r\n - Text editor:\r\n   - Hold SHIFT or use mouse to select text.\r\n   - CTRL+Left/Right to word jump.\r\n   - CTRL+Shift+Left/Right to select words.\r\n   - CTRL+A our Double-Click to select all.\r\n   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/\r\n   - CTRL+Z,CTRL+Y to undo/redo.\r\n   - ESCAPE to revert text to its original value.\r\n   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)\r\n   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.\r\n - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.\r\n - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW\r\n\r\n\r\n PROGRAMMER GUIDE\r\n ================\r\n\r\n READ FIRST\r\n\r\n - Read the FAQ below this section!\r\n - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction\r\n   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.\r\n - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.\r\n - You can learn about immediate-mode GUI principles at http://www.johno.se/book/imgui.html or watch http://mollyrocket.com/861\r\n   See README.md for more links describing the IMGUI paradigm. Dear ImGui is an implementation of the IMGUI paradigm.\r\n\r\n HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\r\n\r\n - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)\r\n - Or maintain your own branch where you have imconfig.h modified.\r\n - Read the \"API BREAKING CHANGES\" section (below). This is where we list occasional API breaking changes.\r\n   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed\r\n   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will\r\n   likely be a comment about it. Please report any issue to the GitHub page!\r\n - Try to keep your copy of dear imgui reasonably up to date.\r\n\r\n GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\r\n\r\n - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.\r\n - Add the Dear ImGui source files to your projects or using your preferred build system.\r\n   It is recommended you build and statically link the .cpp files as part of your project and not as shared library (DLL).\r\n - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating imgui types with your own maths types.\r\n - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.\r\n - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.\r\n   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in \"update\" vs \"render\"\r\n   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling ImGui::Render().\r\n - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.\r\n - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.\r\n\r\n HOW A SIMPLE APPLICATION MAY LOOK LIKE\r\n EXHIBIT 1: USING THE EXAMPLE BINDINGS (imgui_impl_XXX.cpp files from the examples/ folder)\r\n\r\n     // Application init: create a dear imgui context, setup some options, load fonts\r\n     ImGui::CreateContext();\r\n     ImGuiIO& io = ImGui::GetIO();\r\n     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.\r\n     // TODO: Fill optional fields of the io structure later.\r\n     // TODO: Load TTF/OTF fonts if you don't want to use the default font.\r\n\r\n     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32 and imgui_impl_dx11)\r\n     ImGui_ImplWin32_Init(hwnd);\r\n     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);\r\n\r\n     // Application main loop\r\n     while (true)\r\n     {\r\n         // Feed inputs to dear imgui, start new frame\r\n         ImGui_ImplDX11_NewFrame();\r\n         ImGui_ImplWin32_NewFrame();\r\n         ImGui::NewFrame();\r\n\r\n         // Any application code here\r\n         ImGui::Text(\"Hello, world!\");\r\n\r\n         // Render dear imgui into screen\r\n         ImGui::Render();\r\n         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());\r\n         g_pSwapChain->Present(1, 0);\r\n     }\r\n     \r\n     // Shutdown\r\n     ImGui_ImplDX11_Shutdown();\r\n     ImGui_ImplWin32_Shutdown();\r\n     ImGui::DestroyContext();\r\n\r\n HOW A SIMPLE APPLICATION MAY LOOK LIKE\r\n EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE\r\n\r\n     // Application init: create a dear imgui context, setup some options, load fonts\r\n     ImGui::CreateContext();\r\n     ImGuiIO& io = ImGui::GetIO();\r\n     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.\r\n     // TODO: Fill optional fields of the io structure later.\r\n     // TODO: Load TTF/OTF fonts if you don't want to use the default font.\r\n\r\n     // Build and load the texture atlas into a texture\r\n     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)\r\n     int width, height;\r\n     unsigned char* pixels = NULL;\r\n     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);\r\n\r\n     // At this point you've got the texture data and you need to upload that your your graphic system:\r\n     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.\r\n     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.\r\n     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)\r\n     io.Fonts->TexID = (void*)texture;\r\n\r\n     // Application main loop\r\n     while (true)\r\n     {\r\n        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.\r\n        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)\r\n        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)\r\n        io.DisplaySize.x = 1920.0f;             // set the current display width\r\n        io.DisplaySize.y = 1280.0f;             // set the current display height here\r\n        io.MousePos = my_mouse_pos;             // set the mouse position\r\n        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states\r\n        io.MouseDown[1] = my_mouse_buttons[1];\r\n\r\n        // Call NewFrame(), after this point you can use ImGui::* functions anytime\r\n        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use imgui everywhere)\r\n        ImGui::NewFrame();\r\n\r\n        // Most of your application code here\r\n        ImGui::Text(\"Hello, world!\");\r\n        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin(\"My window\"); ImGui::Text(\"Hello, world!\"); ImGui::End();\r\n        MyGameRender(); // may use any ImGui functions as well!\r\n\r\n        // Render imgui, swap buffers\r\n        // (You want to try calling EndFrame/Render as late as you can, to be able to use imgui in your own game rendering code)\r\n        ImGui::EndFrame();\r\n        ImGui::Render();\r\n        ImDrawData* draw_data = ImGui::GetDrawData();\r\n        MyImGuiRenderFunction(draw_data);\r\n        SwapBuffers();\r\n     }\r\n\r\n     // Shutdown\r\n     ImGui::DestroyContext();\r\n\r\n HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\r\n\r\n    void void MyImGuiRenderFunction(ImDrawData* draw_data)\r\n    {\r\n       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled\r\n       // TODO: Setup viewport using draw_data->DisplaySize\r\n       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize\r\n       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.\r\n       for (int n = 0; n < draw_data->CmdListsCount; n++)\r\n       {\r\n          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui\r\n          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui\r\n          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)\r\n          {\r\n             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];\r\n             if (pcmd->UserCallback)\r\n             {\r\n                 pcmd->UserCallback(cmd_list, pcmd);\r\n             }\r\n             else\r\n             {\r\n                 // The texture for the draw call is specified by pcmd->TextureId.\r\n                 // The vast majority of draw calls will use the imgui texture atlas, which value you have set yourself during initialization.\r\n                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);\r\n\r\n                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.\r\n                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches\r\n                 //   (some elements visible outside their bounds) but you can fix that once everything else works!\r\n                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)\r\n                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.\r\n                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github), \r\n                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.\r\n                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)\r\n                 ImVec2 pos = draw_data->DisplayPos;\r\n                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));\r\n\r\n                 // Render 'pcmd->ElemCount/3' indexed triangles.\r\n                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits in imconfig.h if your engine doesn't support 16-bits indices.\r\n                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);\r\n             }\r\n             idx_buffer += pcmd->ElemCount;\r\n          }\r\n       }\r\n    }\r\n\r\n - The examples/ folders contains many actual implementation of the pseudo-codes above.\r\n - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.\r\n   They tell you if Dear ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs \r\n   from the rest of your application. In every cases you need to pass on the inputs to imgui. Refer to the FAQ for more information.\r\n - Please read the FAQ below!. Amusingly, it is called a FAQ because people frequently run into the same issues!\r\n\r\n USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\r\n\r\n - The gamepad/keyboard navigation is fairly functional and keeps being improved. \r\n - Gamepad support is particularly useful to use dear imgui on a console system (e.g. PS4, Switch, XB1) without a mouse!\r\n - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787\r\n - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.\r\n - Gamepad:\r\n    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.\r\n    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().\r\n      Note that io.NavInputs[] is cleared by EndFrame().\r\n    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:\r\n         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.\r\n    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.\r\n      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).\r\n    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.\r\n    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo\r\n      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.\r\n - Keyboard:\r\n    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.\r\n      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.\r\n    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag\r\n      will be set. For more advanced uses, you may want to read from:\r\n       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.\r\n       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).\r\n       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.\r\n      Please reach out if you think the game vs navigation input sharing could be improved.\r\n - Mouse:\r\n    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.\r\n    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.\r\n    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.\r\n      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.\r\n      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.\r\n      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.\r\n      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)\r\n      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want\r\n       to set a boolean to ignore your other external mouse positions until the external source is moved again.)\r\n\r\n\r\n API BREAKING CHANGES\r\n ====================\r\n\r\n Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.\r\n Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.\r\n When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.\r\n You can read releases logs https://github.com/ocornut/imgui/releases for more details.\r\n\r\n - 2018/10/12 (1.66) - Renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.\r\n - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).\r\n - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h. \r\n                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.\r\n - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)\r\n - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.\r\n                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.\r\n                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.\r\n - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).\r\n - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).\r\n - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).\r\n - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges to enable the feature.\r\n - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.\r\n - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.\r\n - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).\r\n - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.\r\n - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details. \r\n - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from \"%.0f\" to \"%d\", as we are not using integers internally any more.\r\n                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.\r\n                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.\r\n                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. \"DragInt.*%f\" to help you find them.\r\n - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional \"int decimal_precision\" in favor of an equivalent and more flexible \"const char* format\",\r\n                       consistent with other functions. Kept redirection functions (will obsolete).\r\n - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.\r\n - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).\r\n - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.\r\n - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.\r\n - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.\r\n - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.\r\n - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.\r\n - 2018/02/07 (1.60) - reorganized context handling to be more explicit,\r\n                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.\r\n                       - removed Shutdown() function, as DestroyContext() serve this purpose.\r\n                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.\r\n                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.\r\n                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.\r\n - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.\r\n - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).\r\n - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).\r\n - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.\r\n - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.\r\n - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).\r\n - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags\r\n - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.\r\n - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.\r\n - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).\r\n - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).\r\n                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).\r\n - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).\r\n - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).\r\n - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.\r\n - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.\r\n                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.\r\n - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.\r\n - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.\r\n - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.\r\n - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);\r\n - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.\r\n - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.\r\n - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.\r\n                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.\r\n - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!\r\n - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).\r\n - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).\r\n - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace \"io.MousePos = ImVec2(-1,-1)\" with \"io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)\".\r\n - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!\r\n                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).\r\n                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).\r\n - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.\r\n - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an \"ambiguous call\" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.\r\n - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.\r\n - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.\r\n - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).\r\n - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).\r\n - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().\r\n - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.\r\n                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under \"Color/Picker Widgets\", to understand the various new options.\r\n                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'\r\n - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse\r\n - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.\r\n - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.\r\n - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().\r\n - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.\r\n - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.\r\n - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.\r\n - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.\r\n                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.\r\n                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.\r\n                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.\r\n                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)\r\n                           {\r\n                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;\r\n                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);\r\n                           }\r\n                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.\r\n - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().\r\n - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.\r\n - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the \"default_open = true\" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).\r\n - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.\r\n - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).\r\n - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)\r\n - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).\r\n - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.\r\n - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.\r\n - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.\r\n - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.\r\n - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.\r\n                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.\r\n                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!\r\n - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize\r\n - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.\r\n - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason\r\n - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.\r\n                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.\r\n - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.\r\n                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(\r\n                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.\r\n                     - the signature of the io.RenderDrawListsFn handler has changed!\r\n                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)\r\n                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).\r\n                         argument:   'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'\r\n                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.\r\n                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.\r\n                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.\r\n                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!\r\n                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!\r\n - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.\r\n - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).\r\n - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.\r\n - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence\r\n - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!\r\n - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).\r\n - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).\r\n - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.\r\n - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the \"open\" state of a popup. BeginPopup() returns true if the popup is opened.\r\n - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).\r\n - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.\r\n - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API\r\n - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.\r\n - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.\r\n - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.\r\n - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing\r\n - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.\r\n - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)\r\n - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.\r\n - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.\r\n - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.\r\n - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior\r\n - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()\r\n - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)\r\n - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.\r\n - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.\r\n              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.\r\n                       font init:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>\r\n                       became:     unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier;\r\n                       you now more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.\r\n                       it is now recommended that you sample the font texture with bilinear interpolation.\r\n              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.\r\n              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)\r\n              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets\r\n - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)\r\n - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)\r\n - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility\r\n - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()\r\n - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)\r\n - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)\r\n - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()\r\n - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn\r\n - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)\r\n - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite\r\n - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes\r\n\r\n\r\n FREQUENTLY ASKED QUESTIONS (FAQ), TIPS\r\n ======================================\r\n\r\n Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?\r\n A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure (e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } )\r\n    - When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.\r\n    - When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.\r\n    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).\r\n    Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.\r\n     This is because imgui needs to detect that you clicked in the void to unfocus its own windows.\r\n    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to \"check if the mouse is hovering a window\" (don't do that!).\r\n     It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.\r\n     Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also\r\n     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().\r\n    Note: Text input widget releases focus on \"Return KeyDown\", so the subsequent \"Return KeyUp\" event that your application receive will typically\r\n     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs\r\n     were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)\r\n\r\n Q: How can I display an image? What is ImTextureID, how does it works?\r\n A: Short explanation:\r\n    - You may use functions such as ImGui::Image(), ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.\r\n    - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value.\r\n    - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason). \r\n      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.\r\n\r\n    Long explanation:\r\n    - Dear ImGui's job is to create \"meshes\", defined in a renderer-agnostic format made of draw commands and vertices.\r\n      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code\r\n      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).\r\n    - Each rendering function decides on a data type to represent \"textures\". The concept of what is a \"texture\" is entirely tied to your underlying engine/graphics API.\r\n      We carry the information to identify a \"texture\" in the ImTextureID type. \r\n      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.\r\n      Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.\r\n    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying \r\n      an image from the end-user perspective. This is what the _examples_ rendering functions are using:\r\n\r\n         OpenGL:     ImTextureID = GLuint                       (see ImGui_ImplGlfwGL3_RenderDrawData() function in imgui_impl_glfw_gl3.cpp)\r\n         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see ImGui_ImplDX9_RenderDrawData()     function in imgui_impl_dx9.cpp)\r\n         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see ImGui_ImplDX11_RenderDrawData()    function in imgui_impl_dx11.cpp)\r\n         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see ImGui_ImplDX12_RenderDrawData()    function in imgui_impl_dx12.cpp)\r\n\r\n      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID. \r\n      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure \r\n      tying together both the texture and information about its format and how to read it.\r\n    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about\r\n      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase\r\n      is designed. If your engine has high-level data types for \"textures\" and \"material\" then you may want to use them.\r\n      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID \r\n      representation suggested by the example bindings is probably the best choice.\r\n      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)\r\n\r\n    User code may do:\r\n\r\n        // Cast our texture type to ImTextureID / void*\r\n        MyTexture* texture = g_CoffeeTableTexture;\r\n        ImGui::Image((void*)texture, ImVec2(texture->Width, texture->Height)); \r\n\r\n    The renderer function called after ImGui::Render() will receive that same value that the user code passed:\r\n\r\n        // Cast ImTextureID / void* stored in the draw command as our texture type\r\n        MyTexture* texture = (MyTexture*)pcmd->TextureId;\r\n        MyEngineBindTexture2D(texture);\r\n\r\n    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui.\r\n    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.\r\n    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.\r\n\r\n    Here's a simplified OpenGL example using stb_image.h:\r\n\r\n        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:\r\n        #define STB_IMAGE_IMPLEMENTATION\r\n        #include <stb_image.h>\r\n        [...]\r\n        int my_image_width, my_image_height;\r\n        unsigned char* my_image_data = stbi_load(\"my_image.png\", &my_image_width, &my_image_height, NULL, 4);\r\n\r\n        // Turn the RGBA pixel data into an OpenGL texture:\r\n        GLuint my_opengl_texture;\r\n        glGenTextures(1, &my_opengl_texture);\r\n        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);\r\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);\r\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);\r\n\r\n        // Now that we have an OpenGL texture, assuming our imgui rendering function (imgui_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:\r\n        ImGui::Image((void*)(intptr_t)my_opengl_texture, ImVec2(my_image_width, my_image_height));\r\n\r\n    C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTexture / void*, and vice-versa. \r\n    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTexture / void*.\r\n    Examples:\r\n\r\n        GLuint my_tex = XXX;\r\n        void* my_void_ptr;\r\n        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)\r\n        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint\r\n\r\n        ID3D11ShaderResourceView* my_dx11_srv = XXX;\r\n        void* my_void_ptr;\r\n        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*\r\n        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*\r\n\r\n    Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.\r\n\r\n Q: How can I have multiple widgets with the same label or without a label?\r\n Q: I have multiple widgets with the same label, and only the first one works. Why is that?\r\n A: A primer on labels and the ID Stack...\r\n\r\n    Dear ImGui internally need to uniquely identify UI elements.\r\n    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.\r\n    Interactive widgets (such as calls to Button buttons) need a unique ID. \r\n    Unique ID are used internally to track active widgets and occasionally associate state to widgets.\r\n    Unique ID are implicitly built from the hash of multiple elements that identify the \"path\" to the UI element.\r\n\r\n   - Unique ID are often derived from a string label:\r\n\r\n       Button(\"OK\");          // Label = \"OK\",     ID = hash of (..., \"OK\")\r\n       Button(\"Cancel\");      // Label = \"Cancel\", ID = hash of (..., \"Cancel\")\r\n\r\n   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having\r\n     two buttons labeled \"OK\" in different windows or different tree locations is fine.\r\n     We used \"...\" above to signify whatever was already pushed to the ID stack previously:\r\n\r\n       Begin(\"MyWindow\");\r\n       Button(\"OK\");          // Label = \"OK\",     ID = hash of (\"MyWindow\", \"OK\")\r\n       End();\r\n\r\n   - If you have a same ID twice in the same location, you'll have a conflict:\r\n\r\n       Button(\"OK\");\r\n       Button(\"OK\");          // ID collision! Interacting with either button will trigger the first one.\r\n\r\n     Fear not! this is easy to solve and there are many ways to solve it!\r\n\r\n   - Solving ID conflict in a simple/local context:\r\n     When passing a label you can optionally specify extra ID information within string itself.\r\n     Use \"##\" to pass a complement to the ID that won't be visible to the end-user.\r\n     This helps solving the simple collision cases when you know e.g. at compilation time which items\r\n     are going to be created:\r\n\r\n       Begin(\"MyWindow\");\r\n       Button(\"Play\");        // Label = \"Play\",   ID = hash of (\"MyWindow\", \"Play\")\r\n       Button(\"Play##foo1\");  // Label = \"Play\",   ID = hash of (\"MyWindow\", \"Play##foo1\")  // Different from above\r\n       Button(\"Play##foo2\");  // Label = \"Play\",   ID = hash of (\"MyWindow\", \"Play##foo2\")  // Different from above\r\n       End();\r\n\r\n   - If you want to completely hide the label, but still need an ID:\r\n\r\n       Checkbox(\"##On\", &b);  // Label = \"\",       ID = hash of (..., \"##On\")   // No visible label, just a checkbox!\r\n\r\n   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows\r\n     you to animate labels. For example you may want to include varying information in a window title bar,\r\n     but windows are uniquely identified by their ID. Use \"###\" to pass a label that isn't part of ID:\r\n\r\n       Button(\"Hello###ID\");  // Label = \"Hello\",  ID = hash of (..., \"ID\")\r\n       Button(\"World###ID\");  // Label = \"World\",  ID = hash of (..., \"ID\")     // Same as above, even though the label looks different\r\n\r\n       sprintf(buf, \"My game (%f FPS)###MyGame\", fps);\r\n       Begin(buf);            // Variable title,   ID = hash of \"MyGame\"\r\n\r\n   - Solving ID conflict in a more general manner:\r\n     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts\r\n     within the same window. This is the most convenient way of distinguishing ID when iterating and\r\n     creating many UI elements programmatically.\r\n     You can push a pointer, a string or an integer value into the ID stack.\r\n     Remember that ID are formed from the concatenation of _everything_ in the ID stack!\r\n\r\n       Begin(\"Window\");\r\n       for (int i = 0; i < 100; i++)\r\n       {\r\n         PushID(i);         // Push i to the id tack\r\n         Button(\"Click\");   // Label = \"Click\",  ID = Hash of (\"Window\", i, \"Click\")\r\n         PopID();\r\n       }\r\n       for (int i = 0; i < 100; i++)\r\n       {\r\n         MyObject* obj = Objects[i];\r\n         PushID(obj);\r\n         Button(\"Click\");   // Label = \"Click\",  ID = Hash of (\"Window\", obj pointer, \"Click\")\r\n         PopID();\r\n       }\r\n       for (int i = 0; i < 100; i++)\r\n       {\r\n         MyObject* obj = Objects[i];\r\n         PushID(obj->Name);\r\n         Button(\"Click\");   // Label = \"Click\",  ID = Hash of (\"Window\", obj->Name, \"Click\")\r\n         PopID();\r\n       }\r\n       End();\r\n\r\n   - More example showing that you can stack multiple prefixes into the ID stack:\r\n\r\n       Button(\"Click\");     // Label = \"Click\",  ID = hash of (..., \"Click\")\r\n       PushID(\"node\");\r\n       Button(\"Click\");     // Label = \"Click\",  ID = hash of (..., \"node\", \"Click\")\r\n         PushID(my_ptr);\r\n           Button(\"Click\"); // Label = \"Click\",  ID = hash of (..., \"node\", my_ptr, \"Click\")\r\n         PopID();\r\n       PopID();\r\n\r\n   - Tree nodes implicitly creates a scope for you by calling PushID().\r\n\r\n       Button(\"Click\");     // Label = \"Click\",  ID = hash of (..., \"Click\")\r\n       if (TreeNode(\"node\"))\r\n       {\r\n         Button(\"Click\");   // Label = \"Click\",  ID = hash of (..., \"node\", \"Click\")\r\n         TreePop();\r\n       }\r\n\r\n   - When working with trees, ID are used to preserve the open/close state of each tree node.\r\n     Depending on your use cases you may want to use strings, indices or pointers as ID.\r\n      e.g. when following a single pointer that may change over time, using a static string as ID\r\n       will preserve your node open/closed state when the targeted object change.\r\n      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the\r\n       node open/closed state differently. See what makes more sense in your situation!\r\n\r\n Q: How can I use my own math types instead of ImVec2/ImVec4? \r\n A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.\r\n    This way you'll be able to use your own types everywhere, e.g. passsing glm::vec2 to ImGui functions instead of ImVec2.\r\n\r\n Q: How can I load a different font than the default?\r\n A: Use the font atlas to load the TTF/OTF file you want:\r\n      ImGuiIO& io = ImGui::GetIO();\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels);\r\n      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()\r\n    Default is ProggyClean.ttf, rendered at size 13, embedded in dear imgui's source code.\r\n    (Read the 'misc/fonts/README.txt' file for more details about font loading.)\r\n\r\n    New programmers: remember that in C/C++ and most programming languages if you want to use a\r\n    backslash \\ within a string literal, you need to write it double backslash \"\\\\\":\r\n      io.Fonts->AddFontFromFileTTF(\"MyDataFolder\\MyFontFile.ttf\", size_in_pixels);   // WRONG (you are escape the M here!)\r\n      io.Fonts->AddFontFromFileTTF(\"MyDataFolder\\\\MyFontFile.ttf\", size_in_pixels);  // CORRECT\r\n      io.Fonts->AddFontFromFileTTF(\"MyDataFolder/MyFontFile.ttf\", size_in_pixels);   // ALSO CORRECT\r\n\r\n Q: How can I easily use icons in my application?\r\n A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you\r\n    main font. Then you can refer to icons within your strings. \r\n    (Read the 'misc/fonts/README.txt' file for more details about icons font loading.)\r\n\r\n Q: How can I load multiple fonts?\r\n A: Use the font atlas to pack them into a single texture:\r\n    (Read the 'misc/fonts/README.txt' file and the code in ImFontAtlas for more details.)\r\n\r\n      ImGuiIO& io = ImGui::GetIO();\r\n      ImFont* font0 = io.Fonts->AddFontDefault();\r\n      ImFont* font1 = io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels);\r\n      ImFont* font2 = io.Fonts->AddFontFromFileTTF(\"myfontfile2.ttf\", size_in_pixels);\r\n      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()\r\n      // the first loaded font gets used by default\r\n      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime\r\n\r\n      // Options\r\n      ImFontConfig config;\r\n      config.OversampleH = 3;\r\n      config.OversampleV = 1;\r\n      config.GlyphOffset.y -= 2.0f;      // Move everything by 2 pixels up\r\n      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_pixels, &config);\r\n\r\n      // Combine multiple fonts into one (e.g. for icon fonts)\r\n      static ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };\r\n      ImFontConfig config;\r\n      config.MergeMode = true;\r\n      io.Fonts->AddFontDefault();\r\n      io.Fonts->AddFontFromFileTTF(\"fontawesome-webfont.ttf\", 16.0f, &config, ranges); // Merge icon font\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs\r\n\r\n Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?\r\n A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.\r\n\r\n      // Add default Japanese ranges\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());\r\n\r\n      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)\r\n      ImVector<ImWchar> ranges;\r\n      ImFontAtlas::GlyphRangesBuilder builder;\r\n      builder.AddText(\"Hello world\");                        // Add a string (here \"Hello world\" contains 7 unique characters)\r\n      builder.AddChar(0x7262);                               // Add a specific character\r\n      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges\r\n      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels, NULL, ranges.Data);\r\n\r\n    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8\r\n    by using the u8\"hello\" syntax. Specifying literal in your source code using a local code page\r\n    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!\r\n    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.\r\n\r\n    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter(). \r\n    The applications in examples/ are doing that. \r\n    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).\r\n    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.\r\n    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for \r\n    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.\r\n\r\n Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)\r\n A: - You can create a dummy window. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags.\r\n      (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse)\r\n      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.\r\n    - You can call ImGui::GetOverlayDrawList() and use this draw list to display contents over every other imgui windows.\r\n    - You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create your own ImDrawListSharedData,\r\n      and then call your rendered code with your own ImDrawList or ImDrawData data.\r\n\r\n Q: I integrated Dear ImGui in my engine and the text or lines are blurry..\r\n A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).\r\n    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.\r\n\r\n Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..\r\n A: You are probably mishandling the clipping rectangles in your render function.\r\n    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).\r\n\r\n Q: How can I help?\r\n A: - If you are experienced with Dear ImGui and C++, look at the github issues, or docs/TODO.txt and see how you want/can help!\r\n    - Convince your company to sponsor/fund development! Individual users: you can also become a Patron (patreon.com/imgui) or donate on PayPal! See README.\r\n    - Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.\r\n      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1269). Visuals are ideal as they inspire other programmers.\r\n      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.\r\n    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).\r\n\r\n - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.\r\n        this is also useful to set yourself in the context of another window (to get/set other settings)\r\n - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called \"Debug\".\r\n - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle\r\n        of a deep nested inner loop in your code.\r\n - tip: you can call Render() multiple times (e.g for VR renders).\r\n - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!\r\n\r\n*/\r\n\r\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include \"imgui.h\"\r\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\r\n#define IMGUI_DEFINE_MATH_OPERATORS\r\n#endif\r\n#include \"imgui_internal.h\"\r\n\r\n#include <ctype.h>      // toupper, isprint\r\n#include <stdio.h>      // vsnprintf, sscanf, printf\r\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\r\n#include <stddef.h>     // intptr_t\r\n#else\r\n#include <stdint.h>     // intptr_t\r\n#endif\r\n\r\n// Debug options\r\n#define IMGUI_DEBUG_NAV_SCORING     0\r\n#define IMGUI_DEBUG_NAV_RECTS       0\r\n\r\n// Visual Studio warnings\r\n#ifdef _MSC_VER\r\n#pragma warning (disable: 4127)     // condition expression is constant\r\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\r\n#endif\r\n\r\n// Clang/GCC warnings with -Weverything\r\n#ifdef __clang__\r\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\r\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.\r\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\r\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.\r\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.\r\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\r\n#pragma clang diagnostic ignored \"-Wformat-pedantic\"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.\r\n#pragma clang diagnostic ignored \"-Wint-to-void-pointer-cast\" // warning : cast to 'void *' from smaller integer type 'int'\r\n#elif defined(__GNUC__)\r\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\r\n#pragma GCC diagnostic ignored \"-Wint-to-pointer-cast\"      // warning: cast to pointer from integer of different size\r\n#pragma GCC diagnostic ignored \"-Wformat\"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'\r\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\r\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"        // warning: format not a string literal, format string not checked\r\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false\r\n#if __GNUC__ >= 8\r\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\r\n#endif\r\n#endif\r\n\r\n// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.\r\nstatic const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in\r\nstatic const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear\r\n\r\n// Window resizing from edges (when io.ConfigResizeWindowsFromEdges = true)\r\nstatic const float RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().\r\nstatic const float RESIZE_WINDOWS_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] FORWARD DECLARATIONS\r\n//-------------------------------------------------------------------------\r\n\r\nstatic void             SetCurrentWindow(ImGuiWindow* window);\r\nstatic void             SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);\r\nstatic void             SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);\r\nstatic void             SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);\r\nstatic void             FindHoveredWindow();\r\nstatic ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);\r\nstatic void             CheckStacksSize(ImGuiWindow* window, bool write);\r\nstatic ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges);\r\n\r\nstatic void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);\r\nstatic void             AddWindowToDrawData(ImVector<ImDrawList*>* out_list, ImGuiWindow* window);\r\nstatic void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);\r\n\r\nstatic ImRect           GetViewportRect();\r\n\r\n// Settings\r\nstatic void*            SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);\r\nstatic void             SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);\r\nstatic void             SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);\r\n\r\n// Platform Dependents default implementation for IO functions\r\nstatic const char*      GetClipboardTextFn_DefaultImpl(void* user_data);\r\nstatic void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);\r\nstatic void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);\r\n\r\nnamespace ImGui\r\n{\r\nstatic bool             BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);\r\n\r\n// Navigation\r\nstatic void             NavUpdate();\r\nstatic void             NavUpdateWindowing();\r\nstatic void             NavUpdateWindowingList();\r\nstatic void             NavUpdateMoveResult();\r\nstatic float            NavUpdatePageUpPageDown(int allowed_dir_flags);\r\nstatic inline void      NavUpdateAnyRequestFlag();\r\nstatic void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id);\r\nstatic ImVec2           NavCalcPreferredRefPos();\r\nstatic void             NavSaveLastChildNavWindow(ImGuiWindow* nav_window);\r\nstatic ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);\r\n\r\n// Misc\r\nstatic void             UpdateMouseInputs();\r\nstatic void             UpdateMouseWheel();\r\nstatic void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);\r\n}\r\n\r\n// Test engine hooks (imgui-test)\r\n//#define IMGUI_ENABLE_TEST_ENGINE_HOOKS\r\n#ifdef IMGUI_ENABLE_TEST_ENGINE_HOOKS\r\nextern void             ImGuiTestEngineHook_PreNewFrame();\r\nextern void             ImGuiTestEngineHook_PostNewFrame();\r\nextern void             ImGuiTestEngineHook_ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg);\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\r\n//-----------------------------------------------------------------------------\r\n\r\n// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.\r\n// CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().\r\n// If you use DLL hotreloading you might need to call SetCurrentContext() after reloading code from this file.\r\n// ImGui functions are not thread-safe because of this pointer. If you want thread-safety to allow N threads to access N different contexts, you can:\r\n// - Change this variable to use thread local storage. You may #define GImGui in imconfig.h for that purpose. Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586\r\n// - Having multiple instances of the ImGui code compiled inside different namespace (easiest/safest, if you have a finite number of contexts)\r\n#ifndef GImGui\r\nImGuiContext*   GImGui = NULL;\r\n#endif\r\n\r\n// Memory Allocator functions. Use SetAllocatorFunctions() to change them.\r\n// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.\r\n// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.\r\n#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS\r\nstatic void*   MallocWrapper(size_t size, void* user_data)    { (void)user_data; return malloc(size); }\r\nstatic void    FreeWrapper(void* ptr, void* user_data)        { (void)user_data; free(ptr); }\r\n#else\r\nstatic void*   MallocWrapper(size_t size, void* user_data)    { (void)user_data; (void)size; IM_ASSERT(0); return NULL; }\r\nstatic void    FreeWrapper(void* ptr, void* user_data)        { (void)user_data; (void)ptr; IM_ASSERT(0); }\r\n#endif\r\n\r\nstatic void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;\r\nstatic void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;\r\nstatic void*    GImAllocatorUserData = NULL;\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\r\n//-----------------------------------------------------------------------------\r\n\r\nImGuiStyle::ImGuiStyle()\r\n{\r\n    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui\r\n    WindowPadding           = ImVec2(8,8);      // Padding within a window\r\n    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows\r\n    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    WindowMinSize           = ImVec2(32,32);    // Minimum window size\r\n    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text\r\n    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows\r\n    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows\r\n    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)\r\n    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).\r\n    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines\r\n    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)\r\n    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\r\n    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\r\n    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns\r\n    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar\r\n    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar\r\n    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar\r\n    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\r\n    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.\r\n    DisplayWindowPadding    = ImVec2(20,20);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.\r\n    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.\r\n    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.\r\n    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.\r\n    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)\r\n    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\r\n\r\n    // Default theme\r\n    ImGui::StyleColorsDark(this);\r\n}\r\n\r\n// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.\r\n// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.\r\nvoid ImGuiStyle::ScaleAllSizes(float scale_factor)\r\n{\r\n    WindowPadding = ImFloor(WindowPadding * scale_factor);\r\n    WindowRounding = ImFloor(WindowRounding * scale_factor);\r\n    WindowMinSize = ImFloor(WindowMinSize * scale_factor);\r\n    ChildRounding = ImFloor(ChildRounding * scale_factor);\r\n    PopupRounding = ImFloor(PopupRounding * scale_factor);\r\n    FramePadding = ImFloor(FramePadding * scale_factor);\r\n    FrameRounding = ImFloor(FrameRounding * scale_factor);\r\n    ItemSpacing = ImFloor(ItemSpacing * scale_factor);\r\n    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);\r\n    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);\r\n    IndentSpacing = ImFloor(IndentSpacing * scale_factor);\r\n    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);\r\n    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);\r\n    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);\r\n    GrabMinSize = ImFloor(GrabMinSize * scale_factor);\r\n    GrabRounding = ImFloor(GrabRounding * scale_factor);\r\n    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);\r\n    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);\r\n    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);\r\n}\r\n\r\nImGuiIO::ImGuiIO()\r\n{\r\n    // Most fields are initialized with zero\r\n    memset(this, 0, sizeof(*this));\r\n\r\n    // Settings\r\n    ConfigFlags = ImGuiConfigFlags_None;\r\n    BackendFlags = ImGuiBackendFlags_None;\r\n    DisplaySize = ImVec2(-1.0f, -1.0f);\r\n    DeltaTime = 1.0f/60.0f;\r\n    IniSavingRate = 5.0f;\r\n    IniFilename = \"imgui.ini\";\r\n    LogFilename = \"imgui_log.txt\";\r\n    MouseDoubleClickTime = 0.30f;\r\n    MouseDoubleClickMaxDist = 6.0f;\r\n    for (int i = 0; i < ImGuiKey_COUNT; i++)\r\n        KeyMap[i] = -1;\r\n    KeyRepeatDelay = 0.250f;\r\n    KeyRepeatRate = 0.050f;\r\n    UserData = NULL;\r\n\r\n    Fonts = NULL;\r\n    FontGlobalScale = 1.0f;\r\n    FontDefault = NULL;\r\n    FontAllowUserScaling = false;\r\n    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);\r\n    DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);\r\n\r\n    // Miscellaneous configuration options\r\n#ifdef __APPLE__\r\n    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag\r\n#else\r\n    ConfigMacOSXBehaviors = false;\r\n#endif\r\n    ConfigInputTextCursorBlink = true;\r\n    ConfigResizeWindowsFromEdges = false;\r\n\r\n    // Platform Functions\r\n    BackendPlatformName = BackendRendererName = NULL;\r\n    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations\r\n    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;\r\n    ClipboardUserData = NULL;\r\n    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;\r\n    ImeWindowHandle = NULL;\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    RenderDrawListsFn = NULL;\r\n#endif\r\n\r\n    // Input (NB: we already have memset zero the entire structure!)\r\n    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);\r\n    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);\r\n    MouseDragThreshold = 6.0f;\r\n    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;\r\n    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;\r\n    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;\r\n}\r\n\r\n// Pass in translated ASCII characters for text input.\r\n// - with glfw you can get those from the callback set in glfwSetCharCallback()\r\n// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message\r\nvoid ImGuiIO::AddInputCharacter(ImWchar c)\r\n{\r\n    const int n = ImStrlenW(InputCharacters);\r\n    if (n + 1 < IM_ARRAYSIZE(InputCharacters))\r\n    {\r\n        InputCharacters[n] = c;\r\n        InputCharacters[n+1] = '\\0';\r\n    }\r\n}\r\n\r\nvoid ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)\r\n{\r\n    // We can't pass more wchars than ImGuiIO::InputCharacters[] can hold so don't convert more\r\n    const int wchars_buf_len = sizeof(ImGuiIO::InputCharacters) / sizeof(ImWchar);\r\n    ImWchar wchars[wchars_buf_len];\r\n    ImTextStrFromUtf8(wchars, wchars_buf_len, utf8_chars, NULL);\r\n    for (int i = 0; i < wchars_buf_len && wchars[i] != 0; i++)\r\n        AddInputCharacter(wchars[i]);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] MISC HELPER/UTILITIES (Maths, String, Format, Hash, File functions)\r\n//-----------------------------------------------------------------------------\r\n\r\nImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)\r\n{\r\n    ImVec2 ap = p - a;\r\n    ImVec2 ab_dir = b - a;\r\n    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;\r\n    if (dot < 0.0f)\r\n        return a;\r\n    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;\r\n    if (dot > ab_len_sqr)\r\n        return b;\r\n    return a + ab_dir * dot / ab_len_sqr;\r\n}\r\n\r\nbool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)\r\n{\r\n    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;\r\n    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;\r\n    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;\r\n    return ((b1 == b2) && (b2 == b3));\r\n}\r\n\r\nvoid ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)\r\n{\r\n    ImVec2 v0 = b - a;\r\n    ImVec2 v1 = c - a;\r\n    ImVec2 v2 = p - a;\r\n    const float denom = v0.x * v1.y - v1.x * v0.y;\r\n    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;\r\n    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;\r\n    out_u = 1.0f - out_v - out_w;\r\n}\r\n\r\nImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)\r\n{\r\n    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);\r\n    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);\r\n    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);\r\n    float dist2_ab = ImLengthSqr(p - proj_ab);\r\n    float dist2_bc = ImLengthSqr(p - proj_bc);\r\n    float dist2_ca = ImLengthSqr(p - proj_ca);\r\n    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));\r\n    if (m == dist2_ab)\r\n        return proj_ab;\r\n    if (m == dist2_bc)\r\n        return proj_bc;\r\n    return proj_ca;\r\n}\r\n\r\nint ImStricmp(const char* str1, const char* str2)\r\n{\r\n    int d;\r\n    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }\r\n    return d;\r\n}\r\n\r\nint ImStrnicmp(const char* str1, const char* str2, size_t count)\r\n{\r\n    int d = 0;\r\n    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }\r\n    return d;\r\n}\r\n\r\nvoid ImStrncpy(char* dst, const char* src, size_t count)\r\n{\r\n    if (count < 1) return;\r\n    strncpy(dst, src, count);\r\n    dst[count-1] = 0;\r\n}\r\n\r\nchar* ImStrdup(const char *str)\r\n{\r\n    size_t len = strlen(str) + 1;\r\n    void* buf = ImGui::MemAlloc(len);\r\n    return (char*)memcpy(buf, (const void*)str, len);\r\n}\r\n\r\nconst char* ImStrchrRange(const char* str, const char* str_end, char c)\r\n{\r\n    const char* p = (const char*)memchr(str, (int)c, str_end - str);\r\n    return p;\r\n}\r\n\r\nint ImStrlenW(const ImWchar* str)\r\n{\r\n    //return (int)wcslen((const wchar_t*)str);\t// FIXME-OPT: Could use this when wchar_t are 16-bits\r\n    int n = 0;\r\n    while (*str++) n++;\r\n    return n;\r\n}\r\n\r\n// Find end-of-line. Return pointer will point to either first \\n, either str_end.\r\nconst char* ImStreolRange(const char* str, const char* str_end)\r\n{\r\n    const char* p = (const char*)memchr(str, '\\n', str_end - str);\r\n    return p ? p : str_end;\r\n}\r\n\r\nconst ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line\r\n{\r\n    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\\n')\r\n        buf_mid_line--;\r\n    return buf_mid_line;\r\n}\r\n\r\nconst char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)\r\n{\r\n    if (!needle_end)\r\n        needle_end = needle + strlen(needle);\r\n\r\n    const char un0 = (char)toupper(*needle);\r\n    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))\r\n    {\r\n        if (toupper(*haystack) == un0)\r\n        {\r\n            const char* b = needle + 1;\r\n            for (const char* a = haystack + 1; b < needle_end; a++, b++)\r\n                if (toupper(*a) != toupper(*b))\r\n                    break;\r\n            if (b == needle_end)\r\n                return haystack;\r\n        }\r\n        haystack++;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Trim str by offsetting contents when there's leading data + writing a \\0 at the trailing position. We use this in situation where the cost is negligible.\r\nvoid ImStrTrimBlanks(char* buf)\r\n{\r\n    char* p = buf;\r\n    while (p[0] == ' ' || p[0] == '\\t')     // Leading blanks\r\n        p++;\r\n    char* p_start = p;\r\n    while (*p != 0)                         // Find end of string\r\n        p++;\r\n    while (p > p_start && (p[-1] == ' ' || p[-1] == '\\t'))  // Trailing blanks\r\n        p--;\r\n    if (p_start != buf)                     // Copy memory if we had leading blanks\r\n        memmove(buf, p_start, p - p_start);\r\n    buf[p - p_start] = 0;                   // Zero terminate\r\n}\r\n\r\n// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).\r\n// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.\r\n// B) When buf==NULL vsnprintf() will return the output size.\r\n#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS\r\n\r\n#if defined(_MSC_VER) && !defined(vsnprintf)\r\n#define vsnprintf _vsnprintf\r\n#endif\r\n\r\nint ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    int w = vsnprintf(buf, buf_size, fmt, args);\r\n    va_end(args);\r\n    if (buf == NULL)\r\n        return w;\r\n    if (w == -1 || w >= (int)buf_size)\r\n        w = (int)buf_size - 1;\r\n    buf[w] = 0;\r\n    return w;\r\n}\r\n\r\nint ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)\r\n{\r\n    int w = vsnprintf(buf, buf_size, fmt, args);\r\n    if (buf == NULL)\r\n        return w;\r\n    if (w == -1 || w >= (int)buf_size)\r\n        w = (int)buf_size - 1;\r\n    buf[w] = 0;\r\n    return w;\r\n}\r\n#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS\r\n\r\n// Pass data_size==0 for zero-terminated strings\r\n// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.\r\nImU32 ImHash(const void* data, int data_size, ImU32 seed)\r\n{\r\n    static ImU32 crc32_lut[256] = { 0 };\r\n    if (!crc32_lut[1])\r\n    {\r\n        const ImU32 polynomial = 0xEDB88320;\r\n        for (ImU32 i = 0; i < 256; i++)\r\n        {\r\n            ImU32 crc = i;\r\n            for (ImU32 j = 0; j < 8; j++)\r\n                crc = (crc >> 1) ^ (ImU32(-int(crc & 1)) & polynomial);\r\n            crc32_lut[i] = crc;\r\n        }\r\n    }\r\n\r\n    seed = ~seed;\r\n    ImU32 crc = seed;\r\n    const unsigned char* current = (const unsigned char*)data;\r\n\r\n    if (data_size > 0)\r\n    {\r\n        // Known size\r\n        while (data_size--)\r\n            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *current++];\r\n    }\r\n    else\r\n    {\r\n        // Zero-terminated string\r\n        while (unsigned char c = *current++)\r\n        {\r\n            // We support a syntax of \"label###id\" where only \"###id\" is included in the hash, and only \"label\" gets displayed.\r\n            // Because this syntax is rarely used we are optimizing for the common case.\r\n            // - If we reach ### in the string we discard the hash so far and reset to the seed.\r\n            // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller.\r\n            if (c == '#' && current[0] == '#' && current[1] == '#')\r\n                crc = seed;\r\n            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];\r\n        }\r\n    }\r\n    return ~crc;\r\n}\r\n\r\nFILE* ImFileOpen(const char* filename, const char* mode)\r\n{\r\n#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)\r\n    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)\r\n    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;\r\n    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;\r\n    ImVector<ImWchar> buf;\r\n    buf.resize(filename_wsize + mode_wsize);\r\n    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);\r\n    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);\r\n    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);\r\n#else\r\n    return fopen(filename, mode);\r\n#endif\r\n}\r\n\r\n// Load file content into memory\r\n// Memory allocated with ImGui::MemAlloc(), must be freed by user using ImGui::MemFree()\r\nvoid* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)\r\n{\r\n    IM_ASSERT(filename && file_open_mode);\r\n    if (out_file_size)\r\n        *out_file_size = 0;\r\n\r\n    FILE* f;\r\n    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)\r\n        return NULL;\r\n\r\n    long file_size_signed;\r\n    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))\r\n    {\r\n        fclose(f);\r\n        return NULL;\r\n    }\r\n\r\n    size_t file_size = (size_t)file_size_signed;\r\n    void* file_data = ImGui::MemAlloc(file_size + padding_bytes);\r\n    if (file_data == NULL)\r\n    {\r\n        fclose(f);\r\n        return NULL;\r\n    }\r\n    if (fread(file_data, 1, file_size, f) != file_size)\r\n    {\r\n        fclose(f);\r\n        ImGui::MemFree(file_data);\r\n        return NULL;\r\n    }\r\n    if (padding_bytes > 0)\r\n        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);\r\n\r\n    fclose(f);\r\n    if (out_file_size)\r\n        *out_file_size = file_size;\r\n\r\n    return file_data;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\r\n//-----------------------------------------------------------------------------\r\n\r\n// Convert UTF-8 to 32-bits character, process single character input.\r\n// Based on stb_from_utf8() from github.com/nothings/stb/\r\n// We handle UTF-8 decoding error by skipping forward.\r\nint ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)\r\n{\r\n    unsigned int c = (unsigned int)-1;\r\n    const unsigned char* str = (const unsigned char*)in_text;\r\n    if (!(*str & 0x80))\r\n    {\r\n        c = (unsigned int)(*str++);\r\n        *out_char = c;\r\n        return 1;\r\n    }\r\n    if ((*str & 0xe0) == 0xc0)\r\n    {\r\n        *out_char = 0xFFFD; // will be invalid but not end of string\r\n        if (in_text_end && in_text_end - (const char*)str < 2) return 1;\r\n        if (*str < 0xc2) return 2;\r\n        c = (unsigned int)((*str++ & 0x1f) << 6);\r\n        if ((*str & 0xc0) != 0x80) return 2;\r\n        c += (*str++ & 0x3f);\r\n        *out_char = c;\r\n        return 2;\r\n    }\r\n    if ((*str & 0xf0) == 0xe0)\r\n    {\r\n        *out_char = 0xFFFD; // will be invalid but not end of string\r\n        if (in_text_end && in_text_end - (const char*)str < 3) return 1;\r\n        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;\r\n        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below\r\n        c = (unsigned int)((*str++ & 0x0f) << 12);\r\n        if ((*str & 0xc0) != 0x80) return 3;\r\n        c += (unsigned int)((*str++ & 0x3f) << 6);\r\n        if ((*str & 0xc0) != 0x80) return 3;\r\n        c += (*str++ & 0x3f);\r\n        *out_char = c;\r\n        return 3;\r\n    }\r\n    if ((*str & 0xf8) == 0xf0)\r\n    {\r\n        *out_char = 0xFFFD; // will be invalid but not end of string\r\n        if (in_text_end && in_text_end - (const char*)str < 4) return 1;\r\n        if (*str > 0xf4) return 4;\r\n        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;\r\n        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below\r\n        c = (unsigned int)((*str++ & 0x07) << 18);\r\n        if ((*str & 0xc0) != 0x80) return 4;\r\n        c += (unsigned int)((*str++ & 0x3f) << 12);\r\n        if ((*str & 0xc0) != 0x80) return 4;\r\n        c += (unsigned int)((*str++ & 0x3f) << 6);\r\n        if ((*str & 0xc0) != 0x80) return 4;\r\n        c += (*str++ & 0x3f);\r\n        // utf-8 encodings of values used in surrogate pairs are invalid\r\n        if ((c & 0xFFFFF800) == 0xD800) return 4;\r\n        *out_char = c;\r\n        return 4;\r\n    }\r\n    *out_char = 0;\r\n    return 0;\r\n}\r\n\r\nint ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)\r\n{\r\n    ImWchar* buf_out = buf;\r\n    ImWchar* buf_end = buf + buf_size;\r\n    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c;\r\n        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);\r\n        if (c == 0)\r\n            break;\r\n        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes\r\n            *buf_out++ = (ImWchar)c;\r\n    }\r\n    *buf_out = 0;\r\n    if (in_text_remaining)\r\n        *in_text_remaining = in_text;\r\n    return (int)(buf_out - buf);\r\n}\r\n\r\nint ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)\r\n{\r\n    int char_count = 0;\r\n    while ((!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c;\r\n        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);\r\n        if (c == 0)\r\n            break;\r\n        if (c < 0x10000)\r\n            char_count++;\r\n    }\r\n    return char_count;\r\n}\r\n\r\n// Based on stb_to_utf8() from github.com/nothings/stb/\r\nstatic inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)\r\n{\r\n    if (c < 0x80)\r\n    {\r\n        buf[0] = (char)c;\r\n        return 1;\r\n    }\r\n    if (c < 0x800)\r\n    {\r\n        if (buf_size < 2) return 0;\r\n        buf[0] = (char)(0xc0 + (c >> 6));\r\n        buf[1] = (char)(0x80 + (c & 0x3f));\r\n        return 2;\r\n    }\r\n    if (c >= 0xdc00 && c < 0xe000)\r\n    {\r\n        return 0;\r\n    }\r\n    if (c >= 0xd800 && c < 0xdc00)\r\n    {\r\n        if (buf_size < 4) return 0;\r\n        buf[0] = (char)(0xf0 + (c >> 18));\r\n        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));\r\n        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));\r\n        buf[3] = (char)(0x80 + ((c ) & 0x3f));\r\n        return 4;\r\n    }\r\n    //else if (c < 0x10000)\r\n    {\r\n        if (buf_size < 3) return 0;\r\n        buf[0] = (char)(0xe0 + (c >> 12));\r\n        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));\r\n        buf[2] = (char)(0x80 + ((c ) & 0x3f));\r\n        return 3;\r\n    }\r\n}\r\n\r\n// Not optimal but we very rarely use this function.\r\nint ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)\r\n{\r\n    unsigned int dummy = 0;\r\n    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);\r\n}\r\n\r\nstatic inline int ImTextCountUtf8BytesFromChar(unsigned int c)\r\n{\r\n    if (c < 0x80) return 1;\r\n    if (c < 0x800) return 2;\r\n    if (c >= 0xdc00 && c < 0xe000) return 0;\r\n    if (c >= 0xd800 && c < 0xdc00) return 4;\r\n    return 3;\r\n}\r\n\r\nint ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)\r\n{\r\n    char* buf_out = buf;\r\n    const char* buf_end = buf + buf_size;\r\n    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c = (unsigned int)(*in_text++);\r\n        if (c < 0x80)\r\n            *buf_out++ = (char)c;\r\n        else\r\n            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);\r\n    }\r\n    *buf_out = 0;\r\n    return (int)(buf_out - buf);\r\n}\r\n\r\nint ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)\r\n{\r\n    int bytes_count = 0;\r\n    while ((!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c = (unsigned int)(*in_text++);\r\n        if (c < 0x80)\r\n            bytes_count++;\r\n        else\r\n            bytes_count += ImTextCountUtf8BytesFromChar(c);\r\n    }\r\n    return bytes_count;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] MISC HELPER/UTILTIES (Color functions)\r\n// Note: The Convert functions are early design which are not consistent with other API.\r\n//-----------------------------------------------------------------------------\r\n\r\nImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)\r\n{\r\n    float s = 1.0f/255.0f;\r\n    return ImVec4(\r\n        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,\r\n        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,\r\n        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,\r\n        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);\r\n}\r\n\r\nImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)\r\n{\r\n    ImU32 out;\r\n    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;\r\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;\r\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;\r\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;\r\n    return out;\r\n}\r\n\r\n// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592\r\n// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\r\nvoid ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)\r\n{\r\n    float K = 0.f;\r\n    if (g < b)\r\n    {\r\n        ImSwap(g, b);\r\n        K = -1.f;\r\n    }\r\n    if (r < g)\r\n    {\r\n        ImSwap(r, g);\r\n        K = -2.f / 6.f - K;\r\n    }\r\n\r\n    const float chroma = r - (g < b ? g : b);\r\n    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));\r\n    out_s = chroma / (r + 1e-20f);\r\n    out_v = r;\r\n}\r\n\r\n// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593\r\n// also http://en.wikipedia.org/wiki/HSL_and_HSV\r\nvoid ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)\r\n{\r\n    if (s == 0.0f)\r\n    {\r\n        // gray\r\n        out_r = out_g = out_b = v;\r\n        return;\r\n    }\r\n\r\n    h = ImFmod(h, 1.0f) / (60.0f/360.0f);\r\n    int   i = (int)h;\r\n    float f = h - (float)i;\r\n    float p = v * (1.0f - s);\r\n    float q = v * (1.0f - s * f);\r\n    float t = v * (1.0f - s * (1.0f - f));\r\n\r\n    switch (i)\r\n    {\r\n    case 0: out_r = v; out_g = t; out_b = p; break;\r\n    case 1: out_r = q; out_g = v; out_b = p; break;\r\n    case 2: out_r = p; out_g = v; out_b = t; break;\r\n    case 3: out_r = p; out_g = q; out_b = v; break;\r\n    case 4: out_r = t; out_g = p; out_b = v; break;\r\n    case 5: default: out_r = v; out_g = p; out_b = q; break;\r\n    }\r\n}\r\n\r\nImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)\r\n{\r\n    ImGuiStyle& style = GImGui->Style;\r\n    ImVec4 c = style.Colors[idx];\r\n    c.w *= style.Alpha * alpha_mul;\r\n    return ColorConvertFloat4ToU32(c);\r\n}\r\n\r\nImU32 ImGui::GetColorU32(const ImVec4& col)\r\n{\r\n    ImGuiStyle& style = GImGui->Style;\r\n    ImVec4 c = col;\r\n    c.w *= style.Alpha;\r\n    return ColorConvertFloat4ToU32(c);\r\n}\r\n\r\nconst ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)\r\n{\r\n    ImGuiStyle& style = GImGui->Style;\r\n    return style.Colors[idx];\r\n}\r\n\r\nImU32 ImGui::GetColorU32(ImU32 col)\r\n{\r\n    float style_alpha = GImGui->Style.Alpha;\r\n    if (style_alpha >= 1.0f)\r\n        return col;\r\n    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;\r\n    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.\r\n    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImGuiStorage\r\n// Helper: Key->value storage\r\n//-----------------------------------------------------------------------------\r\n\r\n// std::lower_bound but without the bullshit\r\nstatic ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)\r\n{\r\n    ImVector<ImGuiStorage::Pair>::iterator first = data.begin();\r\n    ImVector<ImGuiStorage::Pair>::iterator last = data.end();\r\n    size_t count = (size_t)(last - first);\r\n    while (count > 0)\r\n    {\r\n        size_t count2 = count >> 1;\r\n        ImVector<ImGuiStorage::Pair>::iterator mid = first + count2;\r\n        if (mid->key < key)\r\n        {\r\n            first = ++mid;\r\n            count -= count2 + 1;\r\n        }\r\n        else\r\n        {\r\n            count = count2;\r\n        }\r\n    }\r\n    return first;\r\n}\r\n\r\n// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\r\nvoid ImGuiStorage::BuildSortByKey()\r\n{\r\n    struct StaticFunc\r\n    {\r\n        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)\r\n        {\r\n            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.\r\n            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;\r\n            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;\r\n            return 0;\r\n        }\r\n    };\r\n    if (Data.Size > 1)\r\n        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);\r\n}\r\n\r\nint ImGuiStorage::GetInt(ImGuiID key, int default_val) const\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);\r\n    if (it == Data.end() || it->key != key)\r\n        return default_val;\r\n    return it->val_i;\r\n}\r\n\r\nbool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const\r\n{\r\n    return GetInt(key, default_val ? 1 : 0) != 0;\r\n}\r\n\r\nfloat ImGuiStorage::GetFloat(ImGuiID key, float default_val) const\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);\r\n    if (it == Data.end() || it->key != key)\r\n        return default_val;\r\n    return it->val_f;\r\n}\r\n\r\nvoid* ImGuiStorage::GetVoidPtr(ImGuiID key) const\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);\r\n    if (it == Data.end() || it->key != key)\r\n        return NULL;\r\n    return it->val_p;\r\n}\r\n\r\n// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\r\nint* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n        it = Data.insert(it, Pair(key, default_val));\r\n    return &it->val_i;\r\n}\r\n\r\nbool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)\r\n{\r\n    return (bool*)GetIntRef(key, default_val ? 1 : 0);\r\n}\r\n\r\nfloat* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n        it = Data.insert(it, Pair(key, default_val));\r\n    return &it->val_f;\r\n}\r\n\r\nvoid** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n        it = Data.insert(it, Pair(key, default_val));\r\n    return &it->val_p;\r\n}\r\n\r\n// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)\r\nvoid ImGuiStorage::SetInt(ImGuiID key, int val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n    {\r\n        Data.insert(it, Pair(key, val));\r\n        return;\r\n    }\r\n    it->val_i = val;\r\n}\r\n\r\nvoid ImGuiStorage::SetBool(ImGuiID key, bool val)\r\n{\r\n    SetInt(key, val ? 1 : 0);\r\n}\r\n\r\nvoid ImGuiStorage::SetFloat(ImGuiID key, float val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n    {\r\n        Data.insert(it, Pair(key, val));\r\n        return;\r\n    }\r\n    it->val_f = val;\r\n}\r\n\r\nvoid ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n    {\r\n        Data.insert(it, Pair(key, val));\r\n        return;\r\n    }\r\n    it->val_p = val;\r\n}\r\n\r\nvoid ImGuiStorage::SetAllInt(int v)\r\n{\r\n    for (int i = 0; i < Data.Size; i++)\r\n        Data[i].val_i = v;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImGuiTextFilter\r\n//-----------------------------------------------------------------------------\r\n\r\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\r\nImGuiTextFilter::ImGuiTextFilter(const char* default_filter)\r\n{\r\n    if (default_filter)\r\n    {\r\n        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));\r\n        Build();\r\n    }\r\n    else\r\n    {\r\n        InputBuf[0] = 0;\r\n        CountGrep = 0;\r\n    }\r\n}\r\n\r\nbool ImGuiTextFilter::Draw(const char* label, float width)\r\n{\r\n    if (width != 0.0f)\r\n        ImGui::PushItemWidth(width);\r\n    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));\r\n    if (width != 0.0f)\r\n        ImGui::PopItemWidth();\r\n    if (value_changed)\r\n        Build();\r\n    return value_changed;\r\n}\r\n\r\nvoid ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>* out) const\r\n{\r\n    out->resize(0);\r\n    const char* wb = b;\r\n    const char* we = wb;\r\n    while (we < e)\r\n    {\r\n        if (*we == separator)\r\n        {\r\n            out->push_back(TextRange(wb, we));\r\n            wb = we + 1;\r\n        }\r\n        we++;\r\n    }\r\n    if (wb != we)\r\n        out->push_back(TextRange(wb, we));\r\n}\r\n\r\nvoid ImGuiTextFilter::Build()\r\n{\r\n    Filters.resize(0);\r\n    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));\r\n    input_range.split(',', &Filters);\r\n\r\n    CountGrep = 0;\r\n    for (int i = 0; i != Filters.Size; i++)\r\n    {\r\n        TextRange& f = Filters[i];\r\n        while (f.b < f.e && ImCharIsBlankA(f.b[0]))\r\n            f.b++;\r\n        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))\r\n            f.e--;\r\n        if (f.empty())\r\n            continue;\r\n        if (Filters[i].b[0] != '-')\r\n            CountGrep += 1;\r\n    }\r\n}\r\n\r\nbool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const\r\n{\r\n    if (Filters.empty())\r\n        return true;\r\n\r\n    if (text == NULL)\r\n        text = \"\";\r\n\r\n    for (int i = 0; i != Filters.Size; i++)\r\n    {\r\n        const TextRange& f = Filters[i];\r\n        if (f.empty())\r\n            continue;\r\n        if (f.b[0] == '-')\r\n        {\r\n            // Subtract\r\n            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)\r\n                return false;\r\n        }\r\n        else\r\n        {\r\n            // Grep\r\n            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    // Implicit * grep\r\n    if (CountGrep == 0)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImGuiTextBuffer\r\n//-----------------------------------------------------------------------------\r\n\r\n// On some platform vsnprintf() takes va_list by reference and modifies it.\r\n// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.\r\n#ifndef va_copy\r\n#if defined(__GNUC__) || defined(__clang__)\r\n#define va_copy(dest, src) __builtin_va_copy(dest, src)\r\n#else\r\n#define va_copy(dest, src) (dest = src)\r\n#endif\r\n#endif\r\n\r\nchar ImGuiTextBuffer::EmptyString[1] = { 0 };\r\n\r\n// Helper: Text buffer for logging/accumulating text\r\nvoid ImGuiTextBuffer::appendfv(const char* fmt, va_list args)\r\n{\r\n    va_list args_copy;\r\n    va_copy(args_copy, args);\r\n\r\n    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.\r\n    if (len <= 0)\r\n    {\r\n        va_end(args_copy);\r\n        return;\r\n    }\r\n\r\n    // Add zero-terminator the first time\r\n    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;\r\n    const int needed_sz = write_off + len;\r\n    if (write_off + len >= Buf.Capacity)\r\n    {\r\n        int double_capacity = Buf.Capacity * 2;\r\n        Buf.reserve(needed_sz > double_capacity ? needed_sz : double_capacity);\r\n    }\r\n\r\n    Buf.resize(needed_sz);\r\n    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);\r\n    va_end(args_copy);\r\n}\r\n\r\nvoid ImGuiTextBuffer::appendf(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    appendfv(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImGuiListClipper\r\n// This is currently not as flexible/powerful as it should be, needs some rework (see TODO)\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)\r\n{\r\n    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.\r\n    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.\r\n    // The clipper should probably have a 4th step to display the last item in a regular manner.\r\n    ImGui::SetCursorPosY(pos_y);\r\n    ImGuiWindow* window = ImGui::GetCurrentWindow();\r\n    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.\r\n    window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.\r\n    if (window->DC.ColumnsSet)\r\n        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly\r\n}\r\n\r\n// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1\r\n// Use case B: Begin() called from constructor with items_height>0\r\n// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.\r\nvoid ImGuiListClipper::Begin(int count, float items_height)\r\n{\r\n    StartPosY = ImGui::GetCursorPosY();\r\n    ItemsHeight = items_height;\r\n    ItemsCount = count;\r\n    StepNo = 0;\r\n    DisplayEnd = DisplayStart = -1;\r\n    if (ItemsHeight > 0.0f)\r\n    {\r\n        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display\r\n        if (DisplayStart > 0)\r\n            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor\r\n        StepNo = 2;\r\n    }\r\n}\r\n\r\nvoid ImGuiListClipper::End()\r\n{\r\n    if (ItemsCount < 0)\r\n        return;\r\n    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.\r\n    if (ItemsCount < INT_MAX)\r\n        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor\r\n    ItemsCount = -1;\r\n    StepNo = 3;\r\n}\r\n\r\nbool ImGuiListClipper::Step()\r\n{\r\n    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)\r\n    {\r\n        ItemsCount = -1;\r\n        return false;\r\n    }\r\n    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.\r\n    {\r\n        DisplayStart = 0;\r\n        DisplayEnd = 1;\r\n        StartPosY = ImGui::GetCursorPosY();\r\n        StepNo = 1;\r\n        return true;\r\n    }\r\n    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.\r\n    {\r\n        if (ItemsCount == 1) { ItemsCount = -1; return false; }\r\n        float items_height = ImGui::GetCursorPosY() - StartPosY;\r\n        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically\r\n        Begin(ItemsCount-1, items_height);\r\n        DisplayStart++;\r\n        DisplayEnd++;\r\n        StepNo = 3;\r\n        return true;\r\n    }\r\n    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.\r\n    {\r\n        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);\r\n        StepNo = 3;\r\n        return true;\r\n    }\r\n    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.\r\n        End();\r\n    return false;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] RENDER HELPERS\r\n// Those (internal) functions are currently quite a legacy mess - their signature and behavior will change.\r\n// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: state.\r\n//-----------------------------------------------------------------------------\r\n\r\nconst char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)\r\n{\r\n    const char* text_display_end = text;\r\n    if (!text_end)\r\n        text_end = (const char*)-1;\r\n\r\n    while (text_display_end < text_end && *text_display_end != '\\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))\r\n        text_display_end++;\r\n    return text_display_end;\r\n}\r\n\r\n// Internal ImGui functions to render text\r\n// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()\r\nvoid ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // Hide anything after a '##' string\r\n    const char* text_display_end;\r\n    if (hide_text_after_hash)\r\n    {\r\n        text_display_end = FindRenderedTextEnd(text, text_end);\r\n    }\r\n    else\r\n    {\r\n        if (!text_end)\r\n            text_end = text + strlen(text); // FIXME-OPT\r\n        text_display_end = text_end;\r\n    }\r\n\r\n    if (text != text_display_end)\r\n    {\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);\r\n        if (g.LogEnabled)\r\n            LogRenderedText(&pos, text, text_display_end);\r\n    }\r\n}\r\n\r\nvoid ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (!text_end)\r\n        text_end = text + strlen(text); // FIXME-OPT\r\n\r\n    if (text != text_end)\r\n    {\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);\r\n        if (g.LogEnabled)\r\n            LogRenderedText(&pos, text, text_end);\r\n    }\r\n}\r\n\r\n// Default clip_rect uses (pos_min,pos_max)\r\n// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)\r\nvoid ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)\r\n{\r\n    // Hide anything after a '##' string\r\n    const char* text_display_end = FindRenderedTextEnd(text, text_end);\r\n    const int text_len = (int)(text_display_end - text);\r\n    if (text_len == 0)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // Perform CPU side clipping for single clipped element to avoid using scissor state\r\n    ImVec2 pos = pos_min;\r\n    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);\r\n\r\n    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;\r\n    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;\r\n    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);\r\n    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min\r\n        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);\r\n\r\n    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.\r\n    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);\r\n    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);\r\n\r\n    // Render\r\n    if (need_clipping)\r\n    {\r\n        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);\r\n    }\r\n    else\r\n    {\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);\r\n    }\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&pos, text, text_display_end);\r\n}\r\n\r\n// Render a rectangle shaped with optional rounding and borders\r\nvoid ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);\r\n    const float border_size = g.Style.FrameBorderSize;\r\n    if (border && border_size > 0.0f)\r\n    {\r\n        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);\r\n        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);\r\n    }\r\n}\r\n\r\nvoid ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    const float border_size = g.Style.FrameBorderSize;\r\n    if (border_size > 0.0f)\r\n    {\r\n        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);\r\n        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);\r\n    }\r\n}\r\n\r\n// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state\r\nvoid ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    const float h = g.FontSize * 1.00f;\r\n    float r = h * 0.40f * scale;\r\n    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);\r\n\r\n    ImVec2 a, b, c;\r\n    switch (dir)\r\n    {\r\n    case ImGuiDir_Up:\r\n    case ImGuiDir_Down:\r\n        if (dir == ImGuiDir_Up) r = -r;\r\n        a = ImVec2(+0.000f,+0.750f) * r;\r\n        b = ImVec2(-0.866f,-0.750f) * r;\r\n        c = ImVec2(+0.866f,-0.750f) * r;\r\n        break;\r\n    case ImGuiDir_Left:\r\n    case ImGuiDir_Right:\r\n        if (dir == ImGuiDir_Left) r = -r;\r\n        a = ImVec2(+0.750f,+0.000f) * r;\r\n        b = ImVec2(-0.750f,+0.866f) * r;\r\n        c = ImVec2(-0.750f,-0.866f) * r;\r\n        break;\r\n    case ImGuiDir_None:\r\n    case ImGuiDir_COUNT:\r\n        IM_ASSERT(0);\r\n        break;\r\n    }\r\n\r\n    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));\r\n}\r\n\r\nvoid ImGui::RenderBullet(ImVec2 pos)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    window->DrawList->AddCircleFilled(pos, g.FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);\r\n}\r\n\r\nvoid ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    float thickness = ImMax(sz / 5.0f, 1.0f);\r\n    sz -= thickness*0.5f;\r\n    pos += ImVec2(thickness*0.25f, thickness*0.25f);\r\n\r\n    float third = sz / 3.0f;\r\n    float bx = pos.x + third;\r\n    float by = pos.y + sz - third*0.5f;\r\n    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));\r\n    window->DrawList->PathLineTo(ImVec2(bx, by));\r\n    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));\r\n    window->DrawList->PathStroke(col, false, thickness);\r\n}\r\n\r\nvoid ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (id != g.NavId)\r\n        return;\r\n    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (window->DC.NavHideHighlightOneFrame)\r\n        return;\r\n\r\n    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;\r\n    ImRect display_rect = bb;\r\n    display_rect.ClipWith(window->ClipRect);\r\n    if (flags & ImGuiNavHighlightFlags_TypeDefault)\r\n    {\r\n        const float THICKNESS = 2.0f;\r\n        const float DISTANCE = 3.0f + THICKNESS * 0.5f;\r\n        display_rect.Expand(ImVec2(DISTANCE,DISTANCE));\r\n        bool fully_visible = window->ClipRect.Contains(display_rect);\r\n        if (!fully_visible)\r\n            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);\r\n        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);\r\n        if (!fully_visible)\r\n            window->DrawList->PopClipRect();\r\n    }\r\n    if (flags & ImGuiNavHighlightFlags_TypeThin)\r\n    {\r\n        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\r\n//-----------------------------------------------------------------------------\r\n\r\n// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods\r\nImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)\r\n    : DrawListInst(&context->DrawListSharedData)\r\n{\r\n    Name = ImStrdup(name);\r\n    ID = ImHash(name, 0);\r\n    IDStack.push_back(ID);\r\n    Flags = 0;\r\n    Pos = ImVec2(0.0f, 0.0f);\r\n    Size = SizeFull = ImVec2(0.0f, 0.0f);\r\n    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);\r\n    WindowPadding = ImVec2(0.0f, 0.0f);\r\n    WindowRounding = 0.0f;\r\n    WindowBorderSize = 0.0f;\r\n    MoveId = GetID(\"#MOVE\");\r\n    ChildId = 0;\r\n    Scroll = ImVec2(0.0f, 0.0f);\r\n    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);\r\n    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);\r\n    ScrollbarSizes = ImVec2(0.0f, 0.0f);\r\n    ScrollbarX = ScrollbarY = false;\r\n    Active = WasActive = false;\r\n    WriteAccessed = false;\r\n    Collapsed = false;\r\n    WantCollapseToggle = false;\r\n    SkipItems = false;\r\n    Appearing = false;\r\n    Hidden = false;\r\n    HasCloseButton = false;\r\n    BeginCount = 0;\r\n    BeginOrderWithinParent = -1;\r\n    BeginOrderWithinContext = -1;\r\n    PopupId = 0;\r\n    AutoFitFramesX = AutoFitFramesY = -1;\r\n    AutoFitOnlyGrows = false;\r\n    AutoFitChildAxises = 0x00;\r\n    AutoPosLastDirection = ImGuiDir_None;\r\n    HiddenFramesRegular = HiddenFramesForResize = 0;\r\n    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;\r\n    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n    LastFrameActive = -1;\r\n    ItemWidthDefault = 0.0f;\r\n    FontWindowScale = 1.0f;\r\n    SettingsIdx = -1;\r\n\r\n    DrawList = &DrawListInst;\r\n    DrawList->_OwnerName = Name;\r\n    ParentWindow = NULL;\r\n    RootWindow = NULL;\r\n    RootWindowForTitleBarHighlight = NULL;\r\n    RootWindowForNav = NULL;\r\n\r\n    NavLastIds[0] = NavLastIds[1] = 0;\r\n    NavRectRel[0] = NavRectRel[1] = ImRect();\r\n    NavLastChildNavWindow = NULL;\r\n\r\n    FocusIdxAllCounter = FocusIdxTabCounter = -1;\r\n    FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;\r\n    FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;\r\n}\r\n\r\nImGuiWindow::~ImGuiWindow()\r\n{\r\n    IM_ASSERT(DrawList == &DrawListInst);\r\n    IM_DELETE(Name);\r\n    for (int i = 0; i != ColumnsStorage.Size; i++)\r\n        ColumnsStorage[i].~ImGuiColumnsSet();\r\n}\r\n\r\nImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    ImGuiID id = ImHash(str, str_end ? (int)(str_end - str) : 0, seed);\r\n    ImGui::KeepAliveID(id);\r\n    return id;\r\n}\r\n\r\nImGuiID ImGuiWindow::GetID(const void* ptr)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    ImGuiID id = ImHash(&ptr, sizeof(void*), seed);\r\n    ImGui::KeepAliveID(id);\r\n    return id;\r\n}\r\n\r\nImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    return ImHash(str, str_end ? (int)(str_end - str) : 0, seed);\r\n}\r\n\r\nImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    return ImHash(&ptr, sizeof(void*), seed);\r\n}\r\n\r\n// This is only used in rare/specific situations to manufacture an ID out of nowhere.\r\nImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };\r\n    ImGuiID id = ImHash(&r_rel, sizeof(r_rel), seed);\r\n    ImGui::KeepAliveID(id);\r\n    return id;\r\n}\r\n\r\nstatic void SetCurrentWindow(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.CurrentWindow = window;\r\n    if (window)\r\n        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();\r\n}\r\n\r\nvoid ImGui::SetNavID(ImGuiID id, int nav_layer)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.NavWindow);\r\n    IM_ASSERT(nav_layer == 0 || nav_layer == 1);\r\n    g.NavId = id;\r\n    g.NavWindow->NavLastIds[nav_layer] = id;\r\n}\r\n\r\nvoid ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    SetNavID(id, nav_layer);\r\n    g.NavWindow->NavRectRel[nav_layer] = rect_rel;\r\n    g.NavMousePosDirty = true;\r\n    g.NavDisableHighlight = false;\r\n    g.NavDisableMouseHover = true;\r\n}\r\n\r\nvoid ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.ActiveIdIsJustActivated = (g.ActiveId != id);\r\n    if (g.ActiveIdIsJustActivated)\r\n    {\r\n        g.ActiveIdTimer = 0.0f;\r\n        g.ActiveIdHasBeenEdited = false;\r\n        if (id != 0)\r\n        {\r\n            g.LastActiveId = id;\r\n            g.LastActiveIdTimer = 0.0f;\r\n        }\r\n    }\r\n    g.ActiveId = id;\r\n    g.ActiveIdAllowNavDirFlags = 0;\r\n    g.ActiveIdAllowOverlap = false;\r\n    g.ActiveIdWindow = window;\r\n    if (id)\r\n    {\r\n        g.ActiveIdIsAlive = id;\r\n        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;\r\n    }\r\n}\r\n\r\nvoid ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(id != 0);\r\n\r\n    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.\r\n    const int nav_layer = window->DC.NavLayerCurrent;\r\n    if (g.NavWindow != window)\r\n        g.NavInitRequest = false;\r\n    g.NavId = id;\r\n    g.NavWindow = window;\r\n    g.NavLayer = nav_layer;\r\n    window->NavLastIds[nav_layer] = id;\r\n    if (window->DC.LastItemId == id)\r\n        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);\r\n\r\n    if (g.ActiveIdSource == ImGuiInputSource_Nav)\r\n        g.NavDisableMouseHover = true;\r\n    else\r\n        g.NavDisableHighlight = true;\r\n}\r\n\r\nvoid ImGui::ClearActiveID()\r\n{\r\n    SetActiveID(0, NULL);\r\n}\r\n\r\nvoid ImGui::SetHoveredID(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.HoveredId = id;\r\n    g.HoveredIdAllowOverlap = false;\r\n    if (id != 0 && g.HoveredIdPreviousFrame != id)\r\n        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;\r\n}\r\n\r\nImGuiID ImGui::GetHoveredID()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;\r\n}\r\n\r\nvoid ImGui::KeepAliveID(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.ActiveId == id)\r\n        g.ActiveIdIsAlive = id;\r\n    if (g.ActiveIdPreviousFrame == id)\r\n        g.ActiveIdPreviousFrameIsAlive = true;\r\n}\r\n\r\nvoid ImGui::MarkItemEdited(ImGuiID id)\r\n{\r\n    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().\r\n    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.\r\n    (void)id; // Avoid unused variable warnings when asserts are compiled out.\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);\r\n    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);\r\n    g.ActiveIdHasBeenEdited = true;\r\n    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;\r\n}\r\n\r\nstatic inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)\r\n{\r\n    // An active popup disable hovering on other windows (apart from its own children)\r\n    // FIXME-OPT: This could be cached/stored within the window.\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NavWindow)\r\n        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)\r\n            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)\r\n            {\r\n                // For the purpose of those flags we differentiate \"standard popup\" from \"modal popup\"\r\n                // NB: The order of those two tests is important because Modal windows are also Popups.\r\n                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)\r\n                    return false;\r\n                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n                    return false;\r\n            }\r\n\r\n    return true;\r\n}\r\n\r\n// Advance cursor given item size for layout.\r\nvoid ImGui::ItemSize(const ImVec2& size, float text_offset_y)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    // Always align ourselves on pixel boundaries\r\n    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);\r\n    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);\r\n    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]\r\n    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);\r\n    window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));\r\n    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);\r\n    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);\r\n    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]\r\n\r\n    window->DC.PrevLineSize.y = line_height;\r\n    window->DC.PrevLineTextBaseOffset = text_base_offset;\r\n    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;\r\n\r\n    // Horizontal layout mode\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\r\n        SameLine();\r\n}\r\n\r\nvoid ImGui::ItemSize(const ImRect& bb, float text_offset_y)\r\n{\r\n    ItemSize(bb.GetSize(), text_offset_y);\r\n}\r\n\r\n// Declare item bounding box for clipping and interaction.\r\n// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface\r\n// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().\r\nbool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)\r\n{\r\n#ifdef IMGUI_ENABLE_TEST_ENGINE_HOOKS\r\n    ImGuiTestEngineHook_ItemAdd(bb, id, nav_bb_arg);\r\n#endif\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (id != 0)\r\n    {\r\n        // Navigation processing runs prior to clipping early-out\r\n        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget\r\n        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.\r\n        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.\r\n        //      We could early out with \"if (is_clipped && !g.NavInitRequest) return false;\" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)\r\n        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;\r\n        if (g.NavId == id || g.NavAnyRequest)\r\n            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)\r\n                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))\r\n                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);\r\n    }\r\n\r\n    window->DC.LastItemId = id;\r\n    window->DC.LastItemRect = bb;\r\n    window->DC.LastItemStatusFlags = 0;\r\n\r\n    // Clipping test\r\n    const bool is_clipped = IsClippedEx(bb, id, false);\r\n    if (is_clipped)\r\n        return false;\r\n    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]\r\n\r\n    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)\r\n    if (IsMouseHoveringRect(bb.Min, bb.Max))\r\n        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;\r\n    return true;\r\n}\r\n\r\n// This is roughly matching the behavior of internal-facing ItemHoverable()\r\n// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()\r\n// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId\r\nbool ImGui::IsItemHovered(ImGuiHoveredFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.NavDisableMouseHover && !g.NavDisableHighlight)\r\n        return IsItemFocused();\r\n\r\n    // Test for bounding box overlap, as updated as ItemAdd()\r\n    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))\r\n        return false;\r\n    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function\r\n\r\n    // Test if we are hovering the right window (our window could be behind another window)\r\n    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.\r\n    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.\r\n    //if (g.HoveredWindow != window)\r\n    //    return false;\r\n    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))\r\n        return false;\r\n\r\n    // Test if another item is active (e.g. being dragged)\r\n    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\r\n        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)\r\n            return false;\r\n\r\n    // Test if interactions on this window are blocked by an active popup or modal\r\n    if (!IsWindowContentHoverable(window, flags))\r\n        return false;\r\n\r\n    // Test if the item is disabled\r\n    if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))\r\n        return false;\r\n\r\n    // Special handling for the 1st item after Begin() which represent the title bar. When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect tht case.\r\n    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)\r\n        return false;\r\n    return true;\r\n}\r\n\r\n// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().\r\nbool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)\r\n        return false;\r\n\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.HoveredWindow != window)\r\n        return false;\r\n    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)\r\n        return false;\r\n    if (!IsMouseHoveringRect(bb.Min, bb.Max))\r\n        return false;\r\n    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))\r\n        return false;\r\n    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)\r\n        return false;\r\n\r\n    SetHoveredID(id);\r\n    return true;\r\n}\r\n\r\nbool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (!bb.Overlaps(window->ClipRect))\r\n        if (id == 0 || id != g.ActiveId)\r\n            if (clip_even_when_logged || !g.LogEnabled)\r\n                return true;\r\n    return false;\r\n}\r\n\r\nbool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    const bool is_tab_stop = (window->DC.ItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;\r\n    window->FocusIdxAllCounter++;\r\n    if (is_tab_stop)\r\n        window->FocusIdxTabCounter++;\r\n\r\n    // Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.\r\n    // Note that we can always TAB out of a widget that doesn't allow tabbing in.\r\n    if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))\r\n        window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.\r\n\r\n    if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)\r\n        return true;\r\n    if (is_tab_stop && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)\r\n    {\r\n        g.NavJustTabbedId = id;\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid ImGui::FocusableItemUnregister(ImGuiWindow* window)\r\n{\r\n    window->FocusIdxAllCounter--;\r\n    window->FocusIdxTabCounter--;\r\n}\r\n\r\nImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImVec2 content_max;\r\n    if (size.x < 0.0f || size.y < 0.0f)\r\n        content_max = g.CurrentWindow->Pos + GetContentRegionMax();\r\n    if (size.x <= 0.0f)\r\n        size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;\r\n    if (size.y <= 0.0f)\r\n        size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;\r\n    return size;\r\n}\r\n\r\nfloat ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)\r\n{\r\n    if (wrap_pos_x < 0.0f)\r\n        return 0.0f;\r\n\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    if (wrap_pos_x == 0.0f)\r\n        wrap_pos_x = GetContentRegionMax().x + window->Pos.x;\r\n    else if (wrap_pos_x > 0.0f)\r\n        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space\r\n\r\n    return ImMax(wrap_pos_x - pos.x, 1.0f);\r\n}\r\n\r\nvoid* ImGui::MemAlloc(size_t size)\r\n{\r\n    if (ImGuiContext* ctx = GImGui)\r\n        ctx->IO.MetricsActiveAllocations++;\r\n    return GImAllocatorAllocFunc(size, GImAllocatorUserData);\r\n}\r\n\r\nvoid ImGui::MemFree(void* ptr)\r\n{\r\n    if (ptr) \r\n        if (ImGuiContext* ctx = GImGui)\r\n            ctx->IO.MetricsActiveAllocations--;\r\n    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);\r\n}\r\n\r\nconst char* ImGui::GetClipboardText()\r\n{\r\n    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : \"\";\r\n}\r\n\r\nvoid ImGui::SetClipboardText(const char* text)\r\n{\r\n    if (GImGui->IO.SetClipboardTextFn)\r\n        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);\r\n}\r\n\r\nconst char* ImGui::GetVersion()\r\n{\r\n    return IMGUI_VERSION;\r\n}\r\n\r\n// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself\r\n// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module\r\nImGuiContext* ImGui::GetCurrentContext()\r\n{\r\n    return GImGui;\r\n}\r\n\r\nvoid ImGui::SetCurrentContext(ImGuiContext* ctx)\r\n{\r\n#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC\r\n    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.\r\n#else\r\n    GImGui = ctx;\r\n#endif\r\n}\r\n\r\n// Helper function to verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit\r\n// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. you may see different structures from what imgui.cpp sees which is highly problematic.\r\nbool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert)\r\n{\r\n    bool error = false;\r\n    if (strcmp(version, IMGUI_VERSION)!=0) { error = true; IM_ASSERT(strcmp(version,IMGUI_VERSION)==0 && \"Mismatched version string!\");  }\r\n    if (sz_io    != sizeof(ImGuiIO))       { error = true; IM_ASSERT(sz_io    == sizeof(ImGuiIO)      && \"Mismatched struct layout!\"); }\r\n    if (sz_style != sizeof(ImGuiStyle))    { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle)   && \"Mismatched struct layout!\"); }\r\n    if (sz_vec2  != sizeof(ImVec2))        { error = true; IM_ASSERT(sz_vec2  == sizeof(ImVec2)       && \"Mismatched struct layout!\"); }\r\n    if (sz_vec4  != sizeof(ImVec4))        { error = true; IM_ASSERT(sz_vec4  == sizeof(ImVec4)       && \"Mismatched struct layout!\"); }\r\n    if (sz_vert  != sizeof(ImDrawVert))    { error = true; IM_ASSERT(sz_vert  == sizeof(ImDrawVert)   && \"Mismatched struct layout!\"); }\r\n    return !error;\r\n}\r\n\r\nvoid ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data)\r\n{\r\n    GImAllocatorAllocFunc = alloc_func;\r\n    GImAllocatorFreeFunc = free_func;\r\n    GImAllocatorUserData = user_data;\r\n}\r\n\r\nImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)\r\n{\r\n    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);\r\n    if (GImGui == NULL)\r\n        SetCurrentContext(ctx);\r\n    Initialize(ctx);\r\n    return ctx;\r\n}\r\n\r\nvoid ImGui::DestroyContext(ImGuiContext* ctx)\r\n{\r\n    if (ctx == NULL)\r\n        ctx = GImGui;\r\n    Shutdown(ctx);\r\n    if (GImGui == ctx)\r\n        SetCurrentContext(NULL);\r\n    IM_DELETE(ctx);\r\n}\r\n\r\nImGuiIO& ImGui::GetIO()\r\n{\r\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?\");\r\n    return GImGui->IO;\r\n}\r\n\r\nImGuiStyle& ImGui::GetStyle()\r\n{\r\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?\");\r\n    return GImGui->Style;\r\n}\r\n\r\n// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()\r\nImDrawData* ImGui::GetDrawData()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.DrawData.Valid ? &g.DrawData : NULL;\r\n}\r\n\r\ndouble ImGui::GetTime()\r\n{\r\n    return GImGui->Time;\r\n}\r\n\r\nint ImGui::GetFrameCount()\r\n{\r\n    return GImGui->FrameCount;\r\n}\r\n\r\nstatic ImDrawList* GetOverlayDrawList(ImGuiWindow*)\r\n{\r\n    // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'viewport' branches.\r\n    return &GImGui->OverlayDrawList;\r\n}\r\n\r\nImDrawList* ImGui::GetOverlayDrawList()\r\n{\r\n    return &GImGui->OverlayDrawList;\r\n}\r\n\r\nImDrawListSharedData* ImGui::GetDrawListSharedData()\r\n{\r\n    return &GImGui->DrawListSharedData;\r\n}\r\n\r\nvoid ImGui::StartMouseMovingWindow(ImGuiWindow* window)\r\n{\r\n    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.\r\n    ImGuiContext& g = *GImGui;\r\n    FocusWindow(window);\r\n    SetActiveID(window->MoveId, window);\r\n    g.NavDisableHighlight = true;\r\n    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;\r\n    if (!(window->Flags & ImGuiWindowFlags_NoMove) && !(window->RootWindow->Flags & ImGuiWindowFlags_NoMove))\r\n        g.MovingWindow = window;\r\n}\r\n\r\n// Handle mouse moving window\r\n// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()\r\nvoid ImGui::UpdateMouseMovingWindow()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.MovingWindow != NULL)\r\n    {\r\n        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).\r\n        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.\r\n        KeepAliveID(g.ActiveId);\r\n        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);\r\n        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;\r\n        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))\r\n        {\r\n            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;\r\n            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)\r\n            {\r\n                MarkIniSettingsDirty(moving_window);\r\n                SetWindowPos(moving_window, pos, ImGuiCond_Always);\r\n            }\r\n            FocusWindow(g.MovingWindow);\r\n        }\r\n        else\r\n        {\r\n            ClearActiveID();\r\n            g.MovingWindow = NULL;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.\r\n        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)\r\n        {\r\n            KeepAliveID(g.ActiveId);\r\n            if (!g.IO.MouseDown[0])\r\n                ClearActiveID();\r\n        }\r\n    }\r\n}\r\n\r\nstatic bool IsWindowActiveAndVisible(ImGuiWindow* window)\r\n{\r\n    return (window->Active) && (!window->Hidden);\r\n}\r\n\r\nstatic void ImGui::UpdateMouseInputs()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)\r\n    if (IsMousePosValid(&g.IO.MousePos))\r\n        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);\r\n\r\n    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta\r\n    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))\r\n        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;\r\n    else\r\n        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);\r\n    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)\r\n        g.NavDisableMouseHover = false;\r\n\r\n    g.IO.MousePosPrev = g.IO.MousePos;\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)\r\n    {\r\n        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;\r\n        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;\r\n        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];\r\n        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;\r\n        g.IO.MouseDoubleClicked[i] = false;\r\n        if (g.IO.MouseClicked[i])\r\n        {\r\n            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)\r\n            {\r\n                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);\r\n                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)\r\n                    g.IO.MouseDoubleClicked[i] = true;\r\n                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click\r\n            }\r\n            else\r\n            {\r\n                g.IO.MouseClickedTime[i] = g.Time;\r\n            }\r\n            g.IO.MouseClickedPos[i] = g.IO.MousePos;\r\n            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);\r\n            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;\r\n        }\r\n        else if (g.IO.MouseDown[i])\r\n        {\r\n            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold\r\n            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);\r\n            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));\r\n            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);\r\n            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);\r\n        }\r\n        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation\r\n            g.NavDisableMouseHover = false;\r\n    }\r\n}\r\n\r\nvoid ImGui::UpdateMouseWheel()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)\r\n        return;\r\n    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)\r\n        return;\r\n\r\n    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).\r\n    ImGuiWindow* window = g.HoveredWindow;\r\n    ImGuiWindow* scroll_window = window;\r\n    while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs) && scroll_window->ParentWindow)\r\n        scroll_window = scroll_window->ParentWindow;\r\n    const bool scroll_allowed = !(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoMouseInputs);\r\n\r\n    if (g.IO.MouseWheel != 0.0f)\r\n    {\r\n        if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)\r\n        {\r\n            // Zoom / Scale window\r\n            const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);\r\n            const float scale = new_font_scale / window->FontWindowScale;\r\n            window->FontWindowScale = new_font_scale;\r\n\r\n            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;\r\n            window->Pos += offset;\r\n            window->Size *= scale;\r\n            window->SizeFull *= scale;\r\n        }\r\n        else if (!g.IO.KeyCtrl && scroll_allowed)\r\n        {\r\n            // Mouse wheel vertical scrolling\r\n            float scroll_amount = 5 * scroll_window->CalcFontSize();\r\n            scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);\r\n            SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);\r\n        }\r\n    }\r\n    if (g.IO.MouseWheelH != 0.0f && scroll_allowed && !g.IO.KeyCtrl)\r\n    {\r\n        // Mouse wheel horizontal scrolling (for hardware that supports it)\r\n        float scroll_amount = scroll_window->CalcFontSize();\r\n        SetWindowScrollX(scroll_window, scroll_window->Scroll.x - g.IO.MouseWheelH * scroll_amount);\r\n    }\r\n}\r\n\r\n// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)\r\nvoid ImGui::UpdateHoveredWindowAndCaptureFlags()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Find the window hovered by mouse:\r\n    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.\r\n    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.\r\n    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.\r\n    FindHoveredWindow();\r\n\r\n    // Modal windows prevents cursor from hovering behind them.\r\n    ImGuiWindow* modal_window = GetFrontMostPopupModal();\r\n    if (modal_window)\r\n        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))\r\n            g.HoveredRootWindow = g.HoveredWindow = NULL;\r\n\r\n    // Disabled mouse?\r\n    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)\r\n        g.HoveredWindow = g.HoveredRootWindow = NULL;\r\n\r\n    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.\r\n    int mouse_earliest_button_down = -1;\r\n    bool mouse_any_down = false;\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)\r\n    {\r\n        if (g.IO.MouseClicked[i])\r\n            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());\r\n        mouse_any_down |= g.IO.MouseDown[i];\r\n        if (g.IO.MouseDown[i])\r\n            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])\r\n                mouse_earliest_button_down = i;\r\n    }\r\n    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];\r\n\r\n    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.\r\n    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)\r\n    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;\r\n    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)\r\n        g.HoveredWindow = g.HoveredRootWindow = NULL;\r\n\r\n    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)\r\n    if (g.WantCaptureMouseNextFrame != -1)\r\n        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);\r\n    else\r\n        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());\r\n\r\n    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)\r\n    if (g.WantCaptureKeyboardNextFrame != -1)\r\n        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);\r\n    else\r\n        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);\r\n    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))\r\n        g.IO.WantCaptureKeyboard = true;\r\n\r\n    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible\r\n    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;\r\n}\r\n\r\nvoid ImGui::NewFrame()\r\n{\r\n    IM_ASSERT(GImGui != NULL && \"No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?\");\r\n    ImGuiContext& g = *GImGui;\r\n\r\n#ifdef IMGUI_ENABLE_TEST_ENGINE_HOOKS\r\n    ImGuiTestEngineHook_PreNewFrame();\r\n#endif\r\n\r\n    // Check user data\r\n    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)\r\n    IM_ASSERT(g.Initialized);\r\n    IM_ASSERT(g.IO.DeltaTime >= 0.0f                                    && \"Need a positive DeltaTime (zero is tolerated but will cause some timing issues)\");\r\n    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && \"Invalid DisplaySize value\");\r\n    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && \"Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?\");\r\n    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && \"Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?\");\r\n    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && \"Invalid style setting\");\r\n    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && \"Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)\");\r\n    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && \"Forgot to call Render() or EndFrame() at the end of the previous frame?\");\r\n    for (int n = 0; n < ImGuiKey_COUNT; n++)\r\n        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && \"io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)\");\r\n\r\n    // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)\r\n    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)\r\n        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && \"ImGuiKey_Space is not mapped, required for keyboard navigation.\");\r\n\r\n    // Perform simple check: the beta io.ConfigResizeWindowsFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.\r\n    if (g.IO.ConfigResizeWindowsFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))\r\n        g.IO.ConfigResizeWindowsFromEdges = false;\r\n\r\n    // Load settings on first frame (if not explicitly loaded manually before)\r\n    if (!g.SettingsLoaded)\r\n    {\r\n        IM_ASSERT(g.SettingsWindows.empty());\r\n        if (g.IO.IniFilename)\r\n            LoadIniSettingsFromDisk(g.IO.IniFilename);\r\n        g.SettingsLoaded = true;\r\n    }\r\n\r\n    // Save settings (with a delay after the last modification, so we don't spam disk too much)\r\n    if (g.SettingsDirtyTimer > 0.0f)\r\n    {\r\n        g.SettingsDirtyTimer -= g.IO.DeltaTime;\r\n        if (g.SettingsDirtyTimer <= 0.0f)\r\n        {\r\n            if (g.IO.IniFilename != NULL)\r\n                SaveIniSettingsToDisk(g.IO.IniFilename);\r\n            else\r\n                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.\r\n            g.SettingsDirtyTimer = 0.0f;\r\n        }\r\n    }\r\n\r\n    g.Time += g.IO.DeltaTime;\r\n    g.FrameScopeActive = true;\r\n    g.FrameCount += 1;\r\n    g.TooltipOverrideCount = 0;\r\n    g.WindowsActiveCount = 0;\r\n\r\n    // Setup current font and draw list\r\n    g.IO.Fonts->Locked = true;\r\n    SetCurrentFont(GetDefaultFont());\r\n    IM_ASSERT(g.Font->IsLoaded());\r\n    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);\r\n    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;\r\n\r\n    g.OverlayDrawList.Clear();\r\n    g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);\r\n    g.OverlayDrawList.PushClipRectFullScreen();\r\n    g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);\r\n\r\n    // Mark rendering data as invalid to prevent user who may have a handle on it to use it\r\n    g.DrawData.Clear();\r\n\r\n    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent\r\n    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)\r\n        KeepAliveID(g.DragDropPayload.SourceId);\r\n\r\n    // Clear reference to active widget if the widget isn't alive anymore\r\n    if (!g.HoveredIdPreviousFrame)\r\n        g.HoveredIdTimer = 0.0f;\r\n    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))\r\n        g.HoveredIdNotActiveTimer = 0.0f;\r\n    if (g.HoveredId)\r\n        g.HoveredIdTimer += g.IO.DeltaTime;\r\n    if (g.HoveredId && g.ActiveId != g.HoveredId)\r\n        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;\r\n    g.HoveredIdPreviousFrame = g.HoveredId;\r\n    g.HoveredId = 0;\r\n    g.HoveredIdAllowOverlap = false;\r\n    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)\r\n        ClearActiveID();\r\n    if (g.ActiveId)\r\n        g.ActiveIdTimer += g.IO.DeltaTime;\r\n    g.LastActiveIdTimer += g.IO.DeltaTime;\r\n    g.ActiveIdPreviousFrame = g.ActiveId;\r\n    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;\r\n    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;\r\n    g.ActiveIdIsAlive = 0;\r\n    g.ActiveIdPreviousFrameIsAlive = false;\r\n    g.ActiveIdIsJustActivated = false;\r\n    if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)\r\n        g.ScalarAsInputTextId = 0;\r\n\r\n    // Drag and drop\r\n    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;\r\n    g.DragDropAcceptIdCurr = 0;\r\n    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;\r\n    g.DragDropWithinSourceOrTarget = false;\r\n\r\n    // Update keyboard input state\r\n    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)\r\n        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;\r\n\r\n    // Update gamepad/keyboard directional navigation\r\n    NavUpdate();\r\n\r\n    // Update mouse input state\r\n    UpdateMouseInputs();\r\n\r\n    // Calculate frame-rate for the user, as a purely luxurious feature\r\n    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];\r\n    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;\r\n    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);\r\n    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;\r\n\r\n    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)\r\n    UpdateMouseMovingWindow();\r\n    UpdateHoveredWindowAndCaptureFlags();\r\n\r\n    // Background darkening/whitening\r\n    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))\r\n        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);\r\n    else\r\n        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);\r\n\r\n    g.MouseCursor = ImGuiMouseCursor_Arrow;\r\n    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;\r\n    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default\r\n\r\n    // Mouse wheel scrolling, scale\r\n    UpdateMouseWheel();\r\n\r\n    // Pressing TAB activate widget focus\r\n    if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))\r\n    {\r\n        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)\r\n            g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);\r\n        else\r\n            g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;\r\n    }\r\n    g.NavIdTabCounter = INT_MAX;\r\n\r\n    // Mark all windows as not visible\r\n    IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);\r\n    for (int i = 0; i != g.Windows.Size; i++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        window->WasActive = window->Active;\r\n        window->Active = false;\r\n        window->WriteAccessed = false;\r\n    }\r\n\r\n    // Closing the focused window restore focus to the first active root window in descending z-order\r\n    if (g.NavWindow && !g.NavWindow->WasActive)\r\n        FocusPreviousWindowIgnoringOne(NULL);\r\n\r\n    // No window should be open at the beginning of the frame.\r\n    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.\r\n    g.CurrentWindowStack.resize(0);\r\n    g.CurrentPopupStack.resize(0);\r\n    ClosePopupsOverWindow(g.NavWindow);\r\n\r\n    // Create implicit window - we will only render it if the user has added something to it.\r\n    // We don't use \"Debug\" to avoid colliding with user trying to create a \"Debug\" window with custom flags.\r\n    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);\r\n    Begin(\"Debug##Default\");\r\n\r\n#ifdef IMGUI_ENABLE_TEST_ENGINE_HOOKS\r\n    ImGuiTestEngineHook_PostNewFrame();\r\n#endif\r\n}\r\n\r\nvoid ImGui::Initialize(ImGuiContext* context)\r\n{\r\n    ImGuiContext& g = *context;\r\n    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);\r\n\r\n    // Add .ini handle for ImGuiWindow type\r\n    ImGuiSettingsHandler ini_handler;\r\n    ini_handler.TypeName = \"Window\";\r\n    ini_handler.TypeHash = ImHash(\"Window\", 0, 0);\r\n    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;\r\n    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;\r\n    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;\r\n    g.SettingsHandlers.push_front(ini_handler);\r\n\r\n    g.Initialized = true;\r\n}\r\n\r\n// This function is merely here to free heap allocations.\r\nvoid ImGui::Shutdown(ImGuiContext* context)\r\n{\r\n    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)\r\n    ImGuiContext& g = *context;\r\n    if (g.IO.Fonts && g.FontAtlasOwnedByContext)\r\n    {\r\n        g.IO.Fonts->Locked = false;\r\n        IM_DELETE(g.IO.Fonts);\r\n    }\r\n    g.IO.Fonts = NULL;\r\n\r\n    // Cleanup of other data are conditional on actually having initialized ImGui.\r\n    if (!g.Initialized)\r\n        return;\r\n\r\n    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)\r\n    if (g.SettingsLoaded && g.IO.IniFilename != NULL)\r\n    {\r\n        ImGuiContext* backup_context = GImGui;\r\n        SetCurrentContext(context);\r\n        SaveIniSettingsToDisk(g.IO.IniFilename);\r\n        SetCurrentContext(backup_context);\r\n    }\r\n\r\n    // Clear everything else\r\n    for (int i = 0; i < g.Windows.Size; i++)\r\n        IM_DELETE(g.Windows[i]);\r\n    g.Windows.clear();\r\n    g.WindowsFocusOrder.clear();\r\n    g.WindowsSortBuffer.clear();\r\n    g.CurrentWindow = NULL;\r\n    g.CurrentWindowStack.clear();\r\n    g.WindowsById.Clear();\r\n    g.NavWindow = NULL;\r\n    g.HoveredWindow = NULL;\r\n    g.HoveredRootWindow = NULL;\r\n    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;\r\n    g.MovingWindow = NULL;\r\n    g.ColorModifiers.clear();\r\n    g.StyleModifiers.clear();\r\n    g.FontStack.clear();\r\n    g.OpenPopupStack.clear();\r\n    g.CurrentPopupStack.clear();\r\n    g.DrawDataBuilder.ClearFreeMemory();\r\n    g.OverlayDrawList.ClearFreeMemory();\r\n    g.PrivateClipboard.clear();\r\n    g.InputTextState.TextW.clear();\r\n    g.InputTextState.InitialText.clear();\r\n    g.InputTextState.TempBuffer.clear();\r\n\r\n    for (int i = 0; i < g.SettingsWindows.Size; i++)\r\n        IM_DELETE(g.SettingsWindows[i].Name);\r\n    g.SettingsWindows.clear();\r\n    g.SettingsHandlers.clear();\r\n\r\n    if (g.LogFile && g.LogFile != stdout)\r\n    {\r\n        fclose(g.LogFile);\r\n        g.LogFile = NULL;\r\n    }\r\n    g.LogClipboard.clear();\r\n\r\n    g.Initialized = false;\r\n}\r\n\r\n// FIXME: Add a more explicit sort order in the window structure.\r\nstatic int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)\r\n{\r\n    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;\r\n    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;\r\n    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))\r\n        return d;\r\n    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))\r\n        return d;\r\n    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);\r\n}\r\n\r\nstatic void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)\r\n{\r\n    out_sorted_windows->push_back(window);\r\n    if (window->Active)\r\n    {\r\n        int count = window->DC.ChildWindows.Size;\r\n        if (count > 1)\r\n            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            ImGuiWindow* child = window->DC.ChildWindows[i];\r\n            if (child->Active)\r\n                AddWindowToSortBuffer(out_sorted_windows, child);\r\n        }\r\n    }\r\n}\r\n\r\nstatic void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)\r\n{\r\n    if (draw_list->CmdBuffer.empty())\r\n        return;\r\n\r\n    // Remove trailing command if unused\r\n    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();\r\n    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)\r\n    {\r\n        draw_list->CmdBuffer.pop_back();\r\n        if (draw_list->CmdBuffer.empty())\r\n            return;\r\n    }\r\n\r\n    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.\r\n    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);\r\n    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);\r\n    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);\r\n\r\n    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)\r\n    // If this assert triggers because you are drawing lots of stuff manually:\r\n    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.\r\n    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.\r\n    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:\r\n    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);\r\n    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.\r\n    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.\r\n    if (sizeof(ImDrawIdx) == 2)\r\n        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && \"Too many vertices in ImDrawList using 16-bit indices. Read comment above\");\r\n\r\n    out_list->push_back(draw_list);\r\n}\r\n\r\nstatic void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.IO.MetricsRenderWindows++;\r\n    AddDrawListToDrawData(out_render_list, window->DrawList);\r\n    for (int i = 0; i < window->DC.ChildWindows.Size; i++)\r\n    {\r\n        ImGuiWindow* child = window->DC.ChildWindows[i];\r\n        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active\r\n            AddWindowToDrawData(out_render_list, child);\r\n    }\r\n}\r\n\r\nstatic void AddWindowToDrawDataSelectLayer(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (window->Flags & ImGuiWindowFlags_Tooltip)\r\n        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);\r\n    else\r\n        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);\r\n}\r\n\r\nvoid ImDrawDataBuilder::FlattenIntoSingleLayer()\r\n{\r\n    int n = Layers[0].Size;\r\n    int size = n;\r\n    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)\r\n        size += Layers[i].Size;\r\n    Layers[0].resize(size);\r\n    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)\r\n    {\r\n        ImVector<ImDrawList*>& layer = Layers[layer_n];\r\n        if (layer.empty())\r\n            continue;\r\n        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));\r\n        n += layer.Size;\r\n        layer.resize(0);\r\n    }\r\n}\r\n\r\nstatic void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data)\r\n{\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    draw_data->Valid = true;\r\n    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;\r\n    draw_data->CmdListsCount = draw_lists->Size;\r\n    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;\r\n    draw_data->DisplayPos = ImVec2(0.0f, 0.0f);\r\n    draw_data->DisplaySize = io.DisplaySize;\r\n    for (int n = 0; n < draw_lists->Size; n++)\r\n    {\r\n        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;\r\n        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;\r\n    }\r\n}\r\n\r\n// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.\r\nvoid ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);\r\n    window->ClipRect = window->DrawList->_ClipRectStack.back();\r\n}\r\n\r\nvoid ImGui::PopClipRect()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DrawList->PopClipRect();\r\n    window->ClipRect = window->DrawList->_ClipRectStack.back();\r\n}\r\n\r\n// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.\r\nvoid ImGui::EndFrame()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.Initialized);\r\n    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.\r\n        return;\r\n    IM_ASSERT(g.FrameScopeActive && \"Forgot to call ImGui::NewFrame()\");\r\n\r\n    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)\r\n    if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f)\r\n    {\r\n        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);\r\n        g.PlatformImeLastPos = g.PlatformImePos;\r\n    }\r\n\r\n    // Hide implicit \"Debug\" window if it hasn't been used\r\n    IM_ASSERT(g.CurrentWindowStack.Size == 1);    // Mismatched Begin()/End() calls, did you forget to call end on g.CurrentWindow->Name?\r\n    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)\r\n        g.CurrentWindow->Active = false;\r\n    End();\r\n\r\n    // Show CTRL+TAB list\r\n    if (g.NavWindowingTarget)\r\n        NavUpdateWindowingList();\r\n\r\n    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)\r\n    if (g.DragDropActive)\r\n    {\r\n        bool is_delivered = g.DragDropPayload.Delivery;\r\n        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));\r\n        if (is_delivered || is_elapsed)\r\n            ClearDragDrop();\r\n    }\r\n\r\n    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.\r\n    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)\r\n    {\r\n        g.DragDropWithinSourceOrTarget = true;\r\n        SetTooltip(\"...\");\r\n        g.DragDropWithinSourceOrTarget = false;\r\n    }\r\n\r\n    // Initiate moving window\r\n    if (g.ActiveId == 0 && g.HoveredId == 0)\r\n    {\r\n        if (!g.NavWindow || !g.NavWindow->Appearing) // Unless we just made a window/popup appear\r\n        {\r\n            // Click to focus window and start moving (after we're done with all our widgets)\r\n            if (g.IO.MouseClicked[0])\r\n            {\r\n                if (g.HoveredRootWindow != NULL)\r\n                    StartMouseMovingWindow(g.HoveredWindow);\r\n                else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)\r\n                    FocusWindow(NULL);  // Clicking on void disable focus\r\n            }\r\n\r\n            // With right mouse button we close popups without changing focus\r\n            // (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)\r\n            if (g.IO.MouseClicked[1])\r\n            {\r\n                // Find the top-most window between HoveredWindow and the front most Modal Window.\r\n                // This is where we can trim the popup stack.\r\n                ImGuiWindow* modal = GetFrontMostPopupModal();\r\n                bool hovered_window_above_modal = false;\r\n                if (modal == NULL)\r\n                    hovered_window_above_modal = true;\r\n                for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)\r\n                {\r\n                    ImGuiWindow* window = g.Windows[i];\r\n                    if (window == modal)\r\n                        break;\r\n                    if (window == g.HoveredWindow)\r\n                        hovered_window_above_modal = true;\r\n                }\r\n                ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sort the window list so that all child windows are after their parent\r\n    // We cannot do that on FocusWindow() because childs may not exist yet\r\n    g.WindowsSortBuffer.resize(0);\r\n    g.WindowsSortBuffer.reserve(g.Windows.Size);\r\n    for (int i = 0; i != g.Windows.Size; i++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it\r\n            continue;\r\n        AddWindowToSortBuffer(&g.WindowsSortBuffer, window);\r\n    }\r\n\r\n    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);  // we done something wrong\r\n    g.Windows.swap(g.WindowsSortBuffer);\r\n    g.IO.MetricsActiveWindows = g.WindowsActiveCount;\r\n\r\n    // Unlock font atlas\r\n    g.IO.Fonts->Locked = false;\r\n\r\n    // Clear Input data for next frame\r\n    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;\r\n    memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));\r\n    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));\r\n\r\n    g.FrameScopeActive = false;\r\n    g.FrameCountEnded = g.FrameCount;\r\n}\r\n\r\nvoid ImGui::Render()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.Initialized);\r\n\r\n    if (g.FrameCountEnded != g.FrameCount)\r\n        EndFrame();\r\n    g.FrameCountRendered = g.FrameCount;\r\n\r\n    // Gather ImDrawList to render (for each active window)\r\n    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;\r\n    g.DrawDataBuilder.Clear();\r\n    ImGuiWindow* windows_to_render_front_most[2];\r\n    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;\r\n    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;\r\n    for (int n = 0; n != g.Windows.Size; n++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[n];\r\n        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])\r\n            AddWindowToDrawDataSelectLayer(window);\r\n    }\r\n    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)\r\n        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window\r\n            AddWindowToDrawDataSelectLayer(windows_to_render_front_most[n]);\r\n    g.DrawDataBuilder.FlattenIntoSingleLayer();\r\n\r\n    // Draw software mouse cursor if requested\r\n    if (g.IO.MouseDrawCursor)\r\n        RenderMouseCursor(&g.OverlayDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);\r\n\r\n    if (!g.OverlayDrawList.VtxBuffer.empty())\r\n        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.OverlayDrawList);\r\n\r\n    // Setup ImDrawData structure for end-user\r\n    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);\r\n    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;\r\n    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;\r\n\r\n    // Render. If user hasn't set a callback then they may retrieve the draw data via GetDrawData()\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)\r\n        g.IO.RenderDrawListsFn(&g.DrawData);\r\n#endif\r\n}\r\n\r\n// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.\r\n// CalcTextSize(\"\") should return ImVec2(0.0f, GImGui->FontSize)\r\nImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    const char* text_display_end;\r\n    if (hide_text_after_double_hash)\r\n        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string\r\n    else\r\n        text_display_end = text_end;\r\n\r\n    ImFont* font = g.Font;\r\n    const float font_size = g.FontSize;\r\n    if (text == text_display_end)\r\n        return ImVec2(0.0f, font_size);\r\n    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);\r\n\r\n    // Cancel out character spacing for the last character of a line (it is baked into glyph->AdvanceX field)\r\n    const float font_scale = font_size / font->FontSize;\r\n    const float character_spacing_x = 1.0f * font_scale;\r\n    if (text_size.x > 0.0f)\r\n        text_size.x -= character_spacing_x;\r\n    text_size.x = (float)(int)(text_size.x + 0.95f);\r\n\r\n    return text_size;\r\n}\r\n\r\n// Helper to calculate coarse clipping of large list of evenly sized items.\r\n// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.\r\n// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX\r\nvoid ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.LogEnabled)\r\n    {\r\n        // If logging is active, do not perform any clipping\r\n        *out_items_display_start = 0;\r\n        *out_items_display_end = items_count;\r\n        return;\r\n    }\r\n    if (window->SkipItems)\r\n    {\r\n        *out_items_display_start = *out_items_display_end = 0;\r\n        return;\r\n    }\r\n\r\n    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect\r\n    ImRect unclipped_rect = window->ClipRect;\r\n    if (g.NavMoveRequest)\r\n        unclipped_rect.Add(g.NavScoringRectScreen);\r\n\r\n    const ImVec2 pos = window->DC.CursorPos;\r\n    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);\r\n    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);\r\n\r\n    // When performing a navigation request, ensure we have one item extra in the direction we are moving to\r\n    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)\r\n        start--;\r\n    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)\r\n        end++;\r\n\r\n    start = ImClamp(start, 0, items_count);\r\n    end = ImClamp(end + 1, start, items_count);\r\n    *out_items_display_start = start;\r\n    *out_items_display_end = end;\r\n}\r\n\r\n// Find window given position, search front-to-back\r\n// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programatically \r\n// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is \r\n// called, aka before the next Begin(). Moving window isn't affected.\r\nstatic void FindHoveredWindow()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    ImGuiWindow* hovered_window = NULL;\r\n    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))\r\n        hovered_window = g.MovingWindow;\r\n\r\n    ImVec2 padding_regular = g.Style.TouchExtraPadding;\r\n    ImVec2 padding_for_resize_from_edges = g.IO.ConfigResizeWindowsFromEdges ? ImMax(g.Style.TouchExtraPadding, ImVec2(RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS, RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS)) : padding_regular;\r\n    for (int i = g.Windows.Size - 1; i >= 0 && hovered_window == NULL; i--)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        if (!window->Active || window->Hidden)\r\n            continue;\r\n        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)\r\n            continue;\r\n\r\n        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)\r\n        ImRect bb(window->OuterRectClipped);\r\n        if ((window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_NoResize))\r\n            bb.Expand(padding_regular);\r\n        else\r\n            bb.Expand(padding_for_resize_from_edges);\r\n        if (!bb.Contains(g.IO.MousePos))\r\n            continue;\r\n\r\n        // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.\r\n        if (hovered_window == NULL)\r\n            hovered_window = window;\r\n        if (hovered_window)\r\n            break;\r\n    }\r\n\r\n    g.HoveredWindow = hovered_window;\r\n    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;\r\n\r\n}\r\n\r\n// Test if mouse cursor is hovering given rectangle\r\n// NB- Rectangle is clipped by our current clip setting\r\n// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)\r\nbool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Clip\r\n    ImRect rect_clipped(r_min, r_max);\r\n    if (clip)\r\n        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);\r\n\r\n    // Expand for touch input\r\n    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);\r\n    if (!rect_for_touch.Contains(g.IO.MousePos))\r\n        return false;\r\n    return true;\r\n}\r\n\r\nint ImGui::GetKeyIndex(ImGuiKey imgui_key)\r\n{\r\n    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);\r\n    return GImGui->IO.KeyMap[imgui_key];\r\n}\r\n\r\n// Note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!\r\nbool ImGui::IsKeyDown(int user_key_index)\r\n{\r\n    if (user_key_index < 0) return false;\r\n    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));\r\n    return GImGui->IO.KeysDown[user_key_index];\r\n}\r\n\r\nint ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)\r\n{\r\n    if (t == 0.0f)\r\n        return 1;\r\n    if (t <= repeat_delay || repeat_rate <= 0.0f)\r\n        return 0;\r\n    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);\r\n    return (count > 0) ? count : 0;\r\n}\r\n\r\nint ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (key_index < 0) return false;\r\n    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));\r\n    const float t = g.IO.KeysDownDuration[key_index];\r\n    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);\r\n}\r\n\r\nbool ImGui::IsKeyPressed(int user_key_index, bool repeat)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (user_key_index < 0) return false;\r\n    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));\r\n    const float t = g.IO.KeysDownDuration[user_key_index];\r\n    if (t == 0.0f)\r\n        return true;\r\n    if (repeat && t > g.IO.KeyRepeatDelay)\r\n        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsKeyReleased(int user_key_index)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (user_key_index < 0) return false;\r\n    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));\r\n    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];\r\n}\r\n\r\nbool ImGui::IsMouseDown(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    return g.IO.MouseDown[button];\r\n}\r\n\r\nbool ImGui::IsAnyMouseDown()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)\r\n        if (g.IO.MouseDown[n])\r\n            return true;\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsMouseClicked(int button, bool repeat)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    const float t = g.IO.MouseDownDuration[button];\r\n    if (t == 0.0f)\r\n        return true;\r\n\r\n    if (repeat && t > g.IO.KeyRepeatDelay)\r\n    {\r\n        float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;\r\n        if ((ImFmod(t - delay, rate) > rate*0.5f) != (ImFmod(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsMouseReleased(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    return g.IO.MouseReleased[button];\r\n}\r\n\r\nbool ImGui::IsMouseDoubleClicked(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    return g.IO.MouseDoubleClicked[button];\r\n}\r\n\r\nbool ImGui::IsMouseDragging(int button, float lock_threshold)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    if (!g.IO.MouseDown[button])\r\n        return false;\r\n    if (lock_threshold < 0.0f)\r\n        lock_threshold = g.IO.MouseDragThreshold;\r\n    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;\r\n}\r\n\r\nImVec2 ImGui::GetMousePos()\r\n{\r\n    return GImGui->IO.MousePos;\r\n}\r\n\r\n// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!\r\nImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.CurrentPopupStack.Size > 0)\r\n        return g.OpenPopupStack[g.CurrentPopupStack.Size-1].OpenMousePos;\r\n    return g.IO.MousePos;\r\n}\r\n\r\n// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position\r\nbool ImGui::IsMousePosValid(const ImVec2* mouse_pos)\r\n{\r\n    if (mouse_pos == NULL)\r\n        mouse_pos = &GImGui->IO.MousePos;\r\n    const float MOUSE_INVALID = -256000.0f;\r\n    return mouse_pos->x >= MOUSE_INVALID && mouse_pos->y >= MOUSE_INVALID;\r\n}\r\n\r\n// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.\r\nImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    if (lock_threshold < 0.0f)\r\n        lock_threshold = g.IO.MouseDragThreshold;\r\n    if (g.IO.MouseDown[button])\r\n        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)\r\n            return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).\r\n    return ImVec2(0.0f, 0.0f);\r\n}\r\n\r\nvoid ImGui::ResetMouseDragDelta(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr\r\n    g.IO.MouseClickedPos[button] = g.IO.MousePos;\r\n}\r\n\r\nImGuiMouseCursor ImGui::GetMouseCursor()\r\n{\r\n    return GImGui->MouseCursor;\r\n}\r\n\r\nvoid ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)\r\n{\r\n    GImGui->MouseCursor = cursor_type;\r\n}\r\n\r\nvoid ImGui::CaptureKeyboardFromApp(bool capture)\r\n{\r\n    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;\r\n}\r\n\r\nvoid ImGui::CaptureMouseFromApp(bool capture)\r\n{\r\n    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;\r\n}\r\n\r\nbool ImGui::IsItemActive()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.ActiveId)\r\n    {\r\n        ImGuiWindow* window = g.CurrentWindow;\r\n        return g.ActiveId == window->DC.LastItemId;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsItemDeactivated()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);\r\n}\r\n\r\nbool ImGui::IsItemDeactivatedAfterEdit()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));\r\n}\r\n\r\nbool ImGui::IsItemFocused()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.NavId && !g.NavDisableHighlight && g.NavId == g.CurrentWindow->DC.LastItemId;\r\n}\r\n\r\nbool ImGui::IsItemClicked(int mouse_button)\r\n{\r\n    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);\r\n}\r\n\r\nbool ImGui::IsAnyItemHovered()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;\r\n}\r\n\r\nbool ImGui::IsAnyItemActive()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.ActiveId != 0;\r\n}\r\n\r\nbool ImGui::IsAnyItemFocused()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.NavId != 0 && !g.NavDisableHighlight;\r\n}\r\n\r\nbool ImGui::IsItemVisible()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ClipRect.Overlaps(window->DC.LastItemRect);\r\n}\r\n\r\nbool ImGui::IsItemEdited()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;\r\n}\r\n\r\n// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.\r\nvoid ImGui::SetItemAllowOverlap()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)\r\n        g.HoveredIdAllowOverlap = true;\r\n    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)\r\n        g.ActiveIdAllowOverlap = true;\r\n}\r\n\r\nImVec2 ImGui::GetItemRectMin()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.LastItemRect.Min;\r\n}\r\n\r\nImVec2 ImGui::GetItemRectMax()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.LastItemRect.Max;\r\n}\r\n\r\nImVec2 ImGui::GetItemRectSize()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.LastItemRect.GetSize();\r\n}\r\n\r\nstatic ImRect GetViewportRect()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.IO.DisplayVisibleMin.x != g.IO.DisplayVisibleMax.x && g.IO.DisplayVisibleMin.y != g.IO.DisplayVisibleMax.y)\r\n        return ImRect(g.IO.DisplayVisibleMin, g.IO.DisplayVisibleMax);\r\n    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);\r\n}\r\n\r\nstatic bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* parent_window = g.CurrentWindow;\r\n\r\n    flags |= ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;\r\n    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag\r\n\r\n    // Size\r\n    const ImVec2 content_avail = GetContentRegionAvail();\r\n    ImVec2 size = ImFloor(size_arg);\r\n    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);\r\n    if (size.x <= 0.0f)\r\n        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)\r\n    if (size.y <= 0.0f)\r\n        size.y = ImMax(content_avail.y + size.y, 4.0f);\r\n    SetNextWindowSize(size);\r\n\r\n    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.\r\n    char title[256];\r\n    if (name)\r\n        ImFormatString(title, IM_ARRAYSIZE(title), \"%s/%s_%08X\", parent_window->Name, name, id);\r\n    else\r\n        ImFormatString(title, IM_ARRAYSIZE(title), \"%s/%08X\", parent_window->Name, id);\r\n\r\n    const float backup_border_size = g.Style.ChildBorderSize;\r\n    if (!border)\r\n        g.Style.ChildBorderSize = 0.0f;\r\n    bool ret = Begin(title, NULL, flags);\r\n    g.Style.ChildBorderSize = backup_border_size;\r\n\r\n    ImGuiWindow* child_window = g.CurrentWindow;\r\n    child_window->ChildId = id;\r\n    child_window->AutoFitChildAxises = auto_fit_axises;\r\n\r\n    // Process navigation-in immediately so NavInit can run on first frame\r\n    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))\r\n    {\r\n        FocusWindow(child_window);\r\n        NavInitWindow(child_window, false);\r\n        SetActiveID(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item\r\n        g.ActiveIdSource = ImGuiInputSource_Nav;\r\n    }\r\n    return ret;\r\n}\r\n\r\nbool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);\r\n}\r\n\r\nbool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)\r\n{\r\n    IM_ASSERT(id != 0);\r\n    return BeginChildEx(NULL, id, size_arg, border, extra_flags);\r\n}\r\n\r\nvoid ImGui::EndChild()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss\r\n    if (window->BeginCount > 1)\r\n    {\r\n        End();\r\n    }\r\n    else\r\n    {\r\n        ImVec2 sz = window->Size;\r\n        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f\r\n            sz.x = ImMax(4.0f, sz.x);\r\n        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))\r\n            sz.y = ImMax(4.0f, sz.y);\r\n        End();\r\n\r\n        ImGuiWindow* parent_window = g.CurrentWindow;\r\n        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);\r\n        ItemSize(sz);\r\n        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))\r\n        {\r\n            ItemAdd(bb, window->ChildId);\r\n            RenderNavHighlight(bb, window->ChildId);\r\n\r\n            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child\r\n            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)\r\n                RenderNavHighlight(ImRect(bb.Min - ImVec2(2,2), bb.Max + ImVec2(2,2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);\r\n        }\r\n        else\r\n        {\r\n            // Not navigable into\r\n            ItemAdd(bb, 0);\r\n        }\r\n    }\r\n}\r\n\r\n// Helper to create a child window / scrolling region that looks like a normal widget frame.\r\nbool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);\r\n    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);\r\n    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);\r\n    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);\r\n    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);\r\n    PopStyleVar(3);\r\n    PopStyleColor();\r\n    return ret;\r\n}\r\n\r\nvoid ImGui::EndChildFrame()\r\n{\r\n    EndChild();\r\n}\r\n\r\n// Save and compare stack sizes on Begin()/End() to detect usage errors\r\nstatic void CheckStacksSize(ImGuiWindow* window, bool write)\r\n{\r\n    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)\r\n    ImGuiContext& g = *GImGui;\r\n    int* p_backup = &window->DC.StackSizesBackup[0];\r\n    { int current = window->IDStack.Size;       if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"PushID/PopID or TreeNode/TreePop Mismatch!\");   p_backup++; }    // Too few or too many PopID()/TreePop()\r\n    { int current = window->DC.GroupStack.Size; if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"BeginGroup/EndGroup Mismatch!\");                p_backup++; }    // Too few or too many EndGroup()\r\n    { int current = g.CurrentPopupStack.Size;   if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch\"); p_backup++;}// Too few or too many EndMenu()/EndPopup()\r\n    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.\r\n    { int current = g.ColorModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup >= current && \"PushStyleColor/PopStyleColor Mismatch!\");       p_backup++; }    // Too few or too many PopStyleColor()\r\n    { int current = g.StyleModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup >= current && \"PushStyleVar/PopStyleVar Mismatch!\");           p_backup++; }    // Too few or too many PopStyleVar()\r\n    { int current = g.FontStack.Size;           if (write) *p_backup = current; else IM_ASSERT(*p_backup >= current && \"PushFont/PopFont Mismatch!\");                   p_backup++; }    // Too few or too many PopFont()\r\n    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));\r\n}\r\n\r\nstatic void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)\r\n{\r\n    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);\r\n    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);\r\n    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);\r\n}\r\n\r\nImGuiWindow* ImGui::FindWindowByID(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);\r\n}\r\n\r\nImGuiWindow* ImGui::FindWindowByName(const char* name)\r\n{\r\n    ImGuiID id = ImHash(name, 0);\r\n    return FindWindowByID(id);\r\n}\r\n\r\nstatic ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Create window the first time\r\n    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);\r\n    window->Flags = flags;\r\n    g.WindowsById.SetVoidPtr(window->ID, window);\r\n\r\n    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.\r\n    window->Pos = ImVec2(60, 60);\r\n\r\n    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.\r\n    if (!(flags & ImGuiWindowFlags_NoSavedSettings))\r\n        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))\r\n        {\r\n            // Retrieve settings from .ini file\r\n            window->SettingsIdx = g.SettingsWindows.index_from_pointer(settings);\r\n            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);\r\n            window->Pos = ImFloor(settings->Pos);\r\n            window->Collapsed = settings->Collapsed;\r\n            if (ImLengthSqr(settings->Size) > 0.00001f)\r\n                size = ImFloor(settings->Size);\r\n        }\r\n    window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);\r\n    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values\r\n\r\n    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)\r\n    {\r\n        window->AutoFitFramesX = window->AutoFitFramesY = 2;\r\n        window->AutoFitOnlyGrows = false;\r\n    }\r\n    else\r\n    {\r\n        if (window->Size.x <= 0.0f)\r\n            window->AutoFitFramesX = 2;\r\n        if (window->Size.y <= 0.0f)\r\n            window->AutoFitFramesY = 2;\r\n        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);\r\n    }\r\n\r\n    g.WindowsFocusOrder.push_back(window);\r\n    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)\r\n        g.Windows.push_front(window); // Quite slow but rare and only once\r\n    else\r\n        g.Windows.push_back(window);\r\n    return window;\r\n}\r\n\r\nstatic ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NextWindowData.SizeConstraintCond != 0)\r\n    {\r\n        // Using -1,-1 on either X/Y axis to preserve the current size.\r\n        ImRect cr = g.NextWindowData.SizeConstraintRect;\r\n        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;\r\n        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;\r\n        if (g.NextWindowData.SizeCallback)\r\n        {\r\n            ImGuiSizeCallbackData data;\r\n            data.UserData = g.NextWindowData.SizeCallbackUserData;\r\n            data.Pos = window->Pos;\r\n            data.CurrentSize = window->SizeFull;\r\n            data.DesiredSize = new_size;\r\n            g.NextWindowData.SizeCallback(&data);\r\n            new_size = data.DesiredSize;\r\n        }\r\n    }\r\n\r\n    // Minimum size\r\n    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))\r\n    {\r\n        new_size = ImMax(new_size, g.Style.WindowMinSize);\r\n        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows\r\n    }\r\n    return new_size;\r\n}\r\n\r\nstatic ImVec2 CalcSizeContents(ImGuiWindow* window)\r\n{\r\n    ImVec2 sz;\r\n    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));\r\n    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));\r\n    return sz + window->WindowPadding;\r\n}\r\n\r\nstatic ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiStyle& style = g.Style;\r\n    if (window->Flags & ImGuiWindowFlags_Tooltip)\r\n    {\r\n        // Tooltip always resize\r\n        return size_contents;\r\n    }\r\n    else\r\n    {\r\n        // When the window cannot fit all contents (either because of constraints, either because screen is too small): we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than DisplaySize-WindowPadding.\r\n        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;\r\n        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;\r\n        ImVec2 size_min = style.WindowMinSize;\r\n        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)\r\n            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));\r\n        ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));\r\n        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);\r\n        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))\r\n            size_auto_fit.y += style.ScrollbarSize;\r\n        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))\r\n            size_auto_fit.x += style.ScrollbarSize;\r\n        return size_auto_fit;\r\n    }\r\n}\r\n\r\nImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)\r\n{\r\n    ImVec2 size_contents = CalcSizeContents(window);\r\n    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));\r\n}\r\n\r\nfloat ImGui::GetWindowScrollMaxX(ImGuiWindow* window)\r\n{\r\n    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));\r\n}\r\n\r\nfloat ImGui::GetWindowScrollMaxY(ImGuiWindow* window)\r\n{\r\n    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));\r\n}\r\n\r\nstatic ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImVec2 scroll = window->Scroll;\r\n    if (window->ScrollTarget.x < FLT_MAX)\r\n    {\r\n        float cr_x = window->ScrollTargetCenterRatio.x;\r\n        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);\r\n    }\r\n    if (window->ScrollTarget.y < FLT_MAX)\r\n    {\r\n        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.\r\n        float cr_y = window->ScrollTargetCenterRatio.y;\r\n        float target_y = window->ScrollTarget.y;\r\n        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)\r\n            target_y = 0.0f;\r\n        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)\r\n            target_y = window->SizeContents.y;\r\n        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);\r\n    }\r\n    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));\r\n    if (!window->Collapsed && !window->SkipItems)\r\n    {\r\n        scroll.x = ImMin(scroll.x, ImGui::GetWindowScrollMaxX(window));\r\n        scroll.y = ImMin(scroll.y, ImGui::GetWindowScrollMaxY(window));\r\n    }\r\n    return scroll;\r\n}\r\n\r\nstatic ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)\r\n{\r\n    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))\r\n        return ImGuiCol_PopupBg;\r\n    if (flags & ImGuiWindowFlags_ChildWindow)\r\n        return ImGuiCol_ChildBg;\r\n    return ImGuiCol_WindowBg;\r\n}\r\n\r\nstatic void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)\r\n{\r\n    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left\r\n    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right\r\n    ImVec2 size_expected = pos_max - pos_min;\r\n    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);\r\n    *out_pos = pos_min;\r\n    if (corner_norm.x == 0.0f)\r\n        out_pos->x -= (size_constrained.x - size_expected.x);\r\n    if (corner_norm.y == 0.0f)\r\n        out_pos->y -= (size_constrained.y - size_expected.y);\r\n    *out_size = size_constrained;\r\n}\r\n\r\nstruct ImGuiResizeGripDef\r\n{\r\n    ImVec2  CornerPos;\r\n    ImVec2  InnerDir;\r\n    int     AngleMin12, AngleMax12;\r\n};\r\n\r\nconst ImGuiResizeGripDef resize_grip_def[4] =\r\n{\r\n    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right\r\n    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left\r\n    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left\r\n    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right\r\n};\r\n\r\nstatic ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)\r\n{\r\n    ImRect rect = window->Rect();\r\n    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);\r\n    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);\r\n    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding);\r\n    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);\r\n    if (border_n == 3) return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);\r\n    IM_ASSERT(0);\r\n    return ImRect();\r\n}\r\n\r\n// Handle resize for: Resize Grips, Borders, Gamepad\r\nstatic void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindowFlags flags = window->Flags;\r\n    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)\r\n        return;\r\n    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit Debug window.\r\n        return;\r\n\r\n    const int resize_border_count = g.IO.ConfigResizeWindowsFromEdges ? 4 : 0;\r\n    const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);\r\n    const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);\r\n    const float grip_hover_outer_size = g.IO.ConfigResizeWindowsFromEdges ? RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS : 0.0f;\r\n\r\n    ImVec2 pos_target(FLT_MAX, FLT_MAX);\r\n    ImVec2 size_target(FLT_MAX, FLT_MAX);\r\n\r\n    // Manual resize grips\r\n    PushID(\"#RESIZE\");\r\n    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)\r\n    {\r\n        const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];\r\n        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);\r\n\r\n        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window\r\n        ImRect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);\r\n        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);\r\n        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);\r\n        bool hovered, held;\r\n        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);\r\n        //GetOverlayDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));\r\n        if (hovered || held)\r\n            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;\r\n\r\n        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)\r\n        {\r\n            // Manual auto-fit when double-clicking\r\n            size_target = CalcSizeAfterConstraint(window, size_auto_fit);\r\n            ClearActiveID();\r\n        }\r\n        else if (held)\r\n        {\r\n            // Resize from any of the four corners\r\n            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position\r\n            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPos); // Corner of the window corresponding to our corner grip\r\n            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPos, &pos_target, &size_target);\r\n        }\r\n        if (resize_grip_n == 0 || held || hovered)\r\n            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);\r\n    }\r\n    for (int border_n = 0; border_n < resize_border_count; border_n++)\r\n    {\r\n        bool hovered, held;\r\n        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS);\r\n        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);\r\n        //GetOverlayDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));\r\n        if ((hovered && g.HoveredIdTimer > RESIZE_WINDOWS_FROM_EDGES_FEEDBACK_TIMER) || held)\r\n        {\r\n            g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;\r\n            if (held) *border_held = border_n;\r\n        }\r\n        if (held)\r\n        {\r\n            ImVec2 border_target = window->Pos;\r\n            ImVec2 border_posn;\r\n            if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS); }\r\n            if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS); }\r\n            if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS); }\r\n            if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + RESIZE_WINDOWS_FROM_EDGES_HALF_THICKNESS); }\r\n            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);\r\n        }\r\n    }\r\n    PopID();\r\n\r\n    // Navigation resize (keyboard/gamepad)\r\n    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)\r\n    {\r\n        ImVec2 nav_resize_delta;\r\n        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)\r\n            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);\r\n        if (g.NavInputSource == ImGuiInputSource_NavGamepad)\r\n            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);\r\n        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)\r\n        {\r\n            const float NAV_RESIZE_SPEED = 600.0f;\r\n            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));\r\n            g.NavWindowingToggleLayer = false;\r\n            g.NavDisableMouseHover = true;\r\n            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);\r\n            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.\r\n            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);\r\n        }\r\n    }\r\n\r\n    // Apply back modified position/size to window\r\n    if (size_target.x != FLT_MAX)\r\n    {\r\n        window->SizeFull = size_target;\r\n        MarkIniSettingsDirty(window);\r\n    }\r\n    if (pos_target.x != FLT_MAX)\r\n    {\r\n        window->Pos = ImFloor(pos_target);\r\n        MarkIniSettingsDirty(window);\r\n    }\r\n\r\n    window->Size = window->SizeFull;\r\n}\r\n\r\nvoid ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)\r\n{\r\n    window->ParentWindow = parent_window;\r\n    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;\r\n    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))\r\n        window->RootWindow = parent_window->RootWindow;\r\n    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))\r\n        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;\r\n    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)\r\n        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;\r\n}\r\n\r\n// Push a new ImGui window to add widgets to.\r\n// - A default window called \"Debug\" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.\r\n// - Begin/End can be called multiple times during the frame with the same window name to append content.\r\n// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).\r\n//   You can use the \"##\" or \"###\" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.\r\n// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.\r\n// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.\r\nbool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    IM_ASSERT(name != NULL);                        // Window name required\r\n    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()\r\n    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet\r\n\r\n    // Find or create\r\n    ImGuiWindow* window = FindWindowByName(name);\r\n    const bool window_just_created = (window == NULL);\r\n    if (window_just_created)\r\n    {\r\n        ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.\r\n        window = CreateNewWindow(name, size_on_first_use, flags);\r\n    }\r\n\r\n    // Automatically disable manual moving/resizing when NoInputs is set\r\n    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)\r\n        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;\r\n\r\n    if (flags & ImGuiWindowFlags_NavFlattened)\r\n        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);\r\n\r\n    const int current_frame = g.FrameCount;\r\n    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);\r\n    if (first_begin_of_the_frame)\r\n        window->Flags = (ImGuiWindowFlags)flags;\r\n    else\r\n        flags = window->Flags;\r\n\r\n    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack\r\n    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();\r\n    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;\r\n    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));\r\n    window->HasCloseButton = (p_open != NULL);\r\n\r\n    // Update the Appearing flag\r\n    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit \"Debug\" window would always toggle off->on\r\n    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesForResize > 0);\r\n    if (flags & ImGuiWindowFlags_Popup)\r\n    {\r\n        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];\r\n        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed\r\n        window_just_activated_by_user |= (window != popup_ref.Window);\r\n    }\r\n    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);\r\n    if (window->Appearing)\r\n        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);\r\n\r\n    // Add to stack\r\n    g.CurrentWindowStack.push_back(window);\r\n    SetCurrentWindow(window);\r\n    CheckStacksSize(window, true);\r\n    if (flags & ImGuiWindowFlags_Popup)\r\n    {\r\n        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];\r\n        popup_ref.Window = window;\r\n        g.CurrentPopupStack.push_back(popup_ref);\r\n        window->PopupId = popup_ref.PopupId;\r\n    }\r\n\r\n    if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))\r\n        window->NavLastIds[0] = 0;\r\n\r\n    // Process SetNextWindow***() calls\r\n    bool window_pos_set_by_api = false;\r\n    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;\r\n    if (g.NextWindowData.PosCond)\r\n    {\r\n        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;\r\n        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)\r\n        {\r\n            // May be processed on the next frame if this is our first frame and we are measuring size\r\n            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.\r\n            window->SetWindowPosVal = g.NextWindowData.PosVal;\r\n            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;\r\n            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n        }\r\n        else\r\n        {\r\n            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);\r\n        }\r\n    }\r\n    if (g.NextWindowData.SizeCond)\r\n    {\r\n        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);\r\n        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);\r\n        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);\r\n    }\r\n    if (g.NextWindowData.ContentSizeCond)\r\n    {\r\n        // Adjust passed \"client size\" to become a \"window size\"\r\n        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;\r\n        if (window->SizeContentsExplicit.y != 0.0f)\r\n            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();\r\n    }\r\n    else if (first_begin_of_the_frame)\r\n    {\r\n        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);\r\n    }\r\n    if (g.NextWindowData.CollapsedCond)\r\n        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);\r\n    if (g.NextWindowData.FocusCond)\r\n        FocusWindow(window);\r\n    if (window->Appearing)\r\n        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);\r\n\r\n    // When reusing window again multiple times a frame, just append content (don't need to setup again)\r\n    if (first_begin_of_the_frame)\r\n    {\r\n        // Initialize\r\n        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)\r\n        UpdateWindowParentAndRootLinks(window, flags, parent_window);\r\n\r\n        window->Active = true;\r\n        window->BeginOrderWithinParent = 0;\r\n        window->BeginOrderWithinContext = g.WindowsActiveCount++;\r\n        window->BeginCount = 0;\r\n        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);\r\n        window->LastFrameActive = current_frame;\r\n        window->IDStack.resize(1);\r\n\r\n        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS\r\n\r\n        // Update contents size from last frame for auto-fitting (or use explicit size)\r\n        window->SizeContents = CalcSizeContents(window);\r\n        if (window->HiddenFramesRegular > 0)\r\n            window->HiddenFramesRegular--;\r\n        if (window->HiddenFramesForResize > 0)\r\n            window->HiddenFramesForResize--;\r\n\r\n        // Hide new windows for one frame until they calculate their size\r\n        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))\r\n            window->HiddenFramesForResize = 1;\r\n\r\n        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)\r\n        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.\r\n        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)\r\n        {\r\n            window->HiddenFramesForResize = 1;\r\n            if (flags & ImGuiWindowFlags_AlwaysAutoResize)\r\n            {\r\n                if (!window_size_x_set_by_api)\r\n                    window->Size.x = window->SizeFull.x = 0.f;\r\n                if (!window_size_y_set_by_api)\r\n                    window->Size.y = window->SizeFull.y = 0.f;\r\n                window->SizeContents = ImVec2(0.f, 0.f);\r\n            }\r\n        }\r\n\r\n        SetCurrentWindow(window);\r\n\r\n        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)\r\n        window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;\r\n        window->WindowPadding = style.WindowPadding;\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)\r\n            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);\r\n        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);\r\n        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;\r\n\r\n        // Collapse window by double-clicking on title bar\r\n        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing\r\n        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))\r\n        {\r\n            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.\r\n            ImRect title_bar_rect = window->TitleBarRect();\r\n            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])\r\n                window->WantCollapseToggle = true;\r\n            if (window->WantCollapseToggle)\r\n            {\r\n                window->Collapsed = !window->Collapsed;\r\n                MarkIniSettingsDirty(window);\r\n                FocusWindow(window);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            window->Collapsed = false;\r\n        }\r\n        window->WantCollapseToggle = false;\r\n\r\n        // SIZE\r\n\r\n        // Calculate auto-fit size, handle automatic resize\r\n        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);\r\n        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);\r\n        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)\r\n        {\r\n            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.\r\n            if (!window_size_x_set_by_api)\r\n                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;\r\n            if (!window_size_y_set_by_api)\r\n                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;\r\n        }\r\n        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)\r\n        {\r\n            // Auto-fit may only grow window during the first few frames\r\n            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.\r\n            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)\r\n                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;\r\n            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)\r\n                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;\r\n            if (!window->Collapsed)\r\n                MarkIniSettingsDirty(window);\r\n        }\r\n\r\n        // Apply minimum/maximum window size constraints and final size\r\n        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);\r\n        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;\r\n\r\n        // SCROLLBAR STATUS\r\n\r\n        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).\r\n        if (!window->Collapsed)\r\n        {\r\n            // When reading the current size we need to read it after size constraints have been applied\r\n            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;\r\n            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;\r\n            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));\r\n            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));\r\n            if (window->ScrollbarX && !window->ScrollbarY)\r\n                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);\r\n            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);\r\n        }\r\n\r\n        // POSITION\r\n\r\n        // Popup latch its initial position, will position itself when it appears next frame\r\n        if (window_just_activated_by_user)\r\n        {\r\n            window->AutoPosLastDirection = ImGuiDir_None;\r\n            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)\r\n                window->Pos = g.CurrentPopupStack.back().OpenPopupPos;\r\n        }\r\n\r\n        // Position child window\r\n        if (flags & ImGuiWindowFlags_ChildWindow)\r\n        {\r\n            window->BeginOrderWithinParent = parent_window->DC.ChildWindows.Size;\r\n            parent_window->DC.ChildWindows.push_back(window);\r\n            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)\r\n                window->Pos = parent_window->DC.CursorPos;\r\n        }\r\n\r\n        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesForResize == 0);\r\n        if (window_pos_with_pivot)\r\n            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)\r\n        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)\r\n            window->Pos = FindBestWindowPosForPopup(window);\r\n        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)\r\n            window->Pos = FindBestWindowPosForPopup(window);\r\n        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)\r\n            window->Pos = FindBestWindowPosForPopup(window);\r\n\r\n        // Clamp position so it stays visible\r\n        if (!(flags & ImGuiWindowFlags_ChildWindow))\r\n        {\r\n            if (!window_pos_set_by_api && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.\r\n            {\r\n                ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);\r\n                window->Pos = ImMax(window->Pos + window->Size, padding) - window->Size;\r\n                window->Pos = ImMin(window->Pos, g.IO.DisplaySize - padding);\r\n            }\r\n        }\r\n        window->Pos = ImFloor(window->Pos);\r\n\r\n        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)\r\n        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;\r\n\r\n        // Prepare for item focus requests\r\n        window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter+1)) % (window->FocusIdxAllCounter+1);\r\n        window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter+1)) % (window->FocusIdxTabCounter+1);\r\n        window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;\r\n        window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;\r\n\r\n        // Apply scrolling\r\n        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);\r\n        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n        // Apply window focus (new and reactivated windows are moved to front)\r\n        bool want_focus = false;\r\n        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))\r\n            if (!(flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) || (flags & ImGuiWindowFlags_Popup))\r\n                want_focus = true;\r\n\r\n        // Handle manual resize: Resize Grips, Borders, Gamepad\r\n        int border_held = -1;\r\n        ImU32 resize_grip_col[4] = { 0 };\r\n        const int resize_grip_count = g.IO.ConfigResizeWindowsFromEdges ? 2 : 1; // 4\r\n        const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);\r\n        if (!window->Collapsed)\r\n            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);\r\n\r\n        // Default item width. Make it proportional to window size if window manually resizes\r\n        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))\r\n            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);\r\n        else\r\n            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);\r\n\r\n        // DRAWING\r\n\r\n        // Setup draw list and outer clipping rectangle\r\n        window->DrawList->Clear();\r\n        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);\r\n        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);\r\n        ImRect viewport_rect(GetViewportRect());\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)\r\n            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);\r\n        else\r\n            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);\r\n\r\n        // Draw modal window background (darkens what is behind them, all viewports)\r\n        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesForResize <= 0;\r\n        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);\r\n        if (dim_bg_for_modal || dim_bg_for_window_list)\r\n        {\r\n            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);\r\n            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);\r\n        }\r\n\r\n        // Draw navigation selection/windowing rectangle background\r\n        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)\r\n        {\r\n            ImRect bb = window->Rect();\r\n            bb.Expand(g.FontSize);\r\n            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway\r\n                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);\r\n        }\r\n\r\n        // Draw window + handle manual resize\r\n        const float window_rounding = window->WindowRounding;\r\n        const float window_border_size = window->WindowBorderSize;\r\n        const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;\r\n        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);\r\n        const ImRect title_bar_rect = window->TitleBarRect();\r\n        if (window->Collapsed)\r\n        {\r\n            // Title bar only\r\n            float backup_border_size = style.FrameBorderSize;\r\n            g.Style.FrameBorderSize = window->WindowBorderSize;\r\n            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);\r\n            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);\r\n            g.Style.FrameBorderSize = backup_border_size;\r\n        }\r\n        else\r\n        {\r\n            // Window background\r\n            if (!(flags & ImGuiWindowFlags_NoBackground))\r\n            {\r\n                ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));\r\n                if (g.NextWindowData.BgAlphaCond != 0)\r\n                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(g.NextWindowData.BgAlphaVal) << IM_COL32_A_SHIFT);\r\n                window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);\r\n            }\r\n            g.NextWindowData.BgAlphaCond = 0;\r\n\r\n            // Title bar\r\n            ImU32 title_bar_col = GetColorU32(window->Collapsed ? ImGuiCol_TitleBgCollapsed : title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);\r\n            if (!(flags & ImGuiWindowFlags_NoTitleBar))\r\n                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);\r\n\r\n            // Menu bar\r\n            if (flags & ImGuiWindowFlags_MenuBar)\r\n            {\r\n                ImRect menu_bar_rect = window->MenuBarRect();\r\n                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.\r\n                window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);\r\n                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)\r\n                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);\r\n            }\r\n\r\n            // Scrollbars\r\n            if (window->ScrollbarX)\r\n                Scrollbar(ImGuiLayoutType_Horizontal);\r\n            if (window->ScrollbarY)\r\n                Scrollbar(ImGuiLayoutType_Vertical);\r\n\r\n            // Render resize grips (after their input handling so we don't have a frame of latency)\r\n            if (!(flags & ImGuiWindowFlags_NoResize))\r\n            {\r\n                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)\r\n                {\r\n                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];\r\n                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);\r\n                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));\r\n                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));\r\n                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);\r\n                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);\r\n                }\r\n            }\r\n\r\n            // Borders\r\n            if (window_border_size > 0.0f && !(flags & ImGuiWindowFlags_NoBackground))\r\n                window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), window_rounding, ImDrawCornerFlags_All, window_border_size);\r\n            if (border_held != -1)\r\n            {\r\n                ImRect border = GetResizeBorderRect(window, border_held, grip_draw_size, 0.0f);\r\n                window->DrawList->AddLine(border.Min, border.Max, GetColorU32(ImGuiCol_SeparatorActive), ImMax(1.0f, window_border_size));\r\n            }\r\n            if (style.FrameBorderSize > 0 && !(flags & ImGuiWindowFlags_NoTitleBar))\r\n                window->DrawList->AddLine(title_bar_rect.GetBL() + ImVec2(style.WindowBorderSize, -1), title_bar_rect.GetBR() + ImVec2(-style.WindowBorderSize, -1), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);\r\n        }\r\n\r\n        // Draw navigation selection/windowing rectangle border\r\n        if (g.NavWindowingTargetAnim == window)\r\n        {\r\n            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);\r\n            ImRect bb = window->Rect();\r\n            bb.Expand(g.FontSize);\r\n            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward\r\n            {\r\n                bb.Expand(-g.FontSize - 1.0f);\r\n                rounding = window->WindowRounding;\r\n            }\r\n            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);\r\n        }\r\n\r\n        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.\r\n        window->SizeFullAtLastBegin = window->SizeFull;\r\n\r\n        // Update various regions. Variables they depends on are set above in this function.\r\n        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.\r\n        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;\r\n        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();\r\n        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));\r\n        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));\r\n\r\n        // Setup drawing context\r\n        // (NB: That term \"drawing context / DC\" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)\r\n        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;\r\n        window->DC.GroupOffset.x = 0.0f;\r\n        window->DC.ColumnsOffset.x = 0.0f;\r\n        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);\r\n        window->DC.CursorPos = window->DC.CursorStartPos;\r\n        window->DC.CursorPosPrevLine = window->DC.CursorPos;\r\n        window->DC.CursorMaxPos = window->DC.CursorStartPos;\r\n        window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);\r\n        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;\r\n        window->DC.NavHideHighlightOneFrame = false;\r\n        window->DC.NavHasScroll = (GetScrollMaxY() > 0.0f);\r\n        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;\r\n        window->DC.NavLayerActiveMaskNext = 0x00;\r\n        window->DC.MenuBarAppending = false;\r\n        window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;\r\n        window->DC.ChildWindows.resize(0);\r\n        window->DC.LayoutType = ImGuiLayoutType_Vertical;\r\n        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;\r\n        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;\r\n        window->DC.ItemWidth = window->ItemWidthDefault;\r\n        window->DC.TextWrapPos = -1.0f; // disabled\r\n        window->DC.ItemFlagsStack.resize(0);\r\n        window->DC.ItemWidthStack.resize(0);\r\n        window->DC.TextWrapPosStack.resize(0);\r\n        window->DC.ColumnsSet = NULL;\r\n        window->DC.TreeDepth = 0;\r\n        window->DC.TreeDepthMayJumpToParentOnPop = 0x00;\r\n        window->DC.StateStorage = &window->StateStorage;\r\n        window->DC.GroupStack.resize(0);\r\n        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);\r\n\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))\r\n        {\r\n            window->DC.ItemFlags = parent_window->DC.ItemFlags;\r\n            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);\r\n        }\r\n\r\n        if (window->AutoFitFramesX > 0)\r\n            window->AutoFitFramesX--;\r\n        if (window->AutoFitFramesY > 0)\r\n            window->AutoFitFramesY--;\r\n\r\n        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)\r\n        if (want_focus)\r\n        {\r\n            FocusWindow(window);\r\n            NavInitWindow(window, false);\r\n        }\r\n\r\n        // Title bar\r\n        if (!(flags & ImGuiWindowFlags_NoTitleBar))\r\n        {\r\n            // Close & collapse button are on layer 1 (same as menus) and don't default focus\r\n            const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;\r\n            window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;\r\n            window->DC.NavLayerCurrent++;\r\n            window->DC.NavLayerCurrentMask <<= 1;\r\n\r\n            // Collapse button\r\n            if (!(flags & ImGuiWindowFlags_NoCollapse))\r\n                if (CollapseButton(window->GetID(\"#COLLAPSE\"), window->Pos))\r\n                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function\r\n\r\n            // Close button\r\n            if (p_open != NULL)\r\n            {\r\n                const float pad = style.FramePadding.y;\r\n                const float rad = g.FontSize * 0.5f;\r\n                if (CloseButton(window->GetID(\"#CLOSE\"), window->Rect().GetTR() + ImVec2(-pad - rad, pad + rad), rad + 1))\r\n                    *p_open = false;\r\n            }\r\n\r\n            window->DC.NavLayerCurrent--;\r\n            window->DC.NavLayerCurrentMask >>= 1;\r\n            window->DC.ItemFlags = item_flags_backup;\r\n\r\n            // Title text (FIXME: refactor text alignment facilities along with RenderText helpers, this is too much code for what it does.)\r\n            ImVec2 text_size = CalcTextSize(name, NULL, true);\r\n            ImRect text_r = title_bar_rect;\r\n            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);\r\n            float pad_right = (p_open == NULL)                     ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);\r\n            if (style.WindowTitleAlign.x > 0.0f)\r\n                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);\r\n            text_r.Min.x += pad_left;\r\n            text_r.Max.x -= pad_right;\r\n            ImRect clip_rect = text_r;\r\n            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()\r\n            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);\r\n        }\r\n\r\n        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()\r\n        window->OuterRectClipped = window->Rect();\r\n        window->OuterRectClipped.ClipWith(window->ClipRect);\r\n\r\n        // Pressing CTRL+C while holding on a window copy its content to the clipboard\r\n        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.\r\n        // Maybe we can support CTRL+C on every element?\r\n        /*\r\n        if (g.ActiveId == move_id)\r\n            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))\r\n                LogToClipboard();\r\n        */\r\n\r\n        // Inner rectangle\r\n        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame\r\n        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.\r\n        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;\r\n        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);\r\n        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;\r\n        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;\r\n        //window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);\r\n\r\n        // Inner clipping rectangle\r\n        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.\r\n        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));\r\n        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);\r\n        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));\r\n        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);\r\n\r\n        // After Begin() we fill the last item / hovered data based on title bar data. It is a standard behavior (to allow creation of context menus on title bar only, etc.).\r\n        window->DC.LastItemId = window->MoveId;\r\n        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;\r\n        window->DC.LastItemRect = title_bar_rect;\r\n    }\r\n\r\n    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);\r\n\r\n    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default \"Debug\" window is unused)\r\n    if (first_begin_of_the_frame)\r\n        window->WriteAccessed = false;\r\n\r\n    window->BeginCount++;\r\n    g.NextWindowData.Clear();\r\n\r\n    if (flags & ImGuiWindowFlags_ChildWindow)\r\n    {\r\n        // Child window can be out of sight and have \"negative\" clip windows.\r\n        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).\r\n        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);\r\n\r\n        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)\r\n            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)\r\n                window->HiddenFramesRegular = 1;\r\n\r\n        // Completely hide along with parent or if parent is collapsed\r\n        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))\r\n            window->HiddenFramesRegular = 1;\r\n    }\r\n\r\n    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)\r\n    if (style.Alpha <= 0.0f)\r\n        window->HiddenFramesRegular = 1;\r\n\r\n    // Update the Hidden flag\r\n    window->Hidden = (window->HiddenFramesRegular > 0) || (window->HiddenFramesForResize);\r\n\r\n    // Return false if we don't intend to display anything to allow user to perform an early out optimization\r\n    window->SkipItems = (window->Collapsed || !window->Active || window->Hidden) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesForResize <= 0;\r\n\r\n    return !window->SkipItems;\r\n}\r\n\r\n// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\nbool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)\r\n{\r\n    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.\r\n    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)\r\n        SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);\r\n\r\n    // Old API feature: override the window background alpha with a parameter.\r\n    if (bg_alpha_override >= 0.0f)\r\n        SetNextWindowBgAlpha(bg_alpha_override);\r\n\r\n    return Begin(name, p_open, flags);\r\n}\r\n#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n\r\nvoid ImGui::End()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (window->DC.ColumnsSet != NULL)\r\n        EndColumns();\r\n    PopClipRect();   // Inner window clip rectangle\r\n\r\n    // Stop logging\r\n    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging\r\n        LogFinish();\r\n\r\n    // Pop from window stack\r\n    g.CurrentWindowStack.pop_back();\r\n    if (window->Flags & ImGuiWindowFlags_Popup)\r\n        g.CurrentPopupStack.pop_back();\r\n    CheckStacksSize(window, false);\r\n    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());\r\n}\r\n\r\nvoid ImGui::BringWindowToFocusFront(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.WindowsFocusOrder.back() == window)\r\n        return;\r\n    for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window\r\n        if (g.WindowsFocusOrder[i] == window)\r\n        {\r\n            memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(ImGuiWindow*));\r\n            g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;\r\n            break;\r\n        }\r\n}\r\n\r\nvoid ImGui::BringWindowToDisplayFront(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* current_front_window = g.Windows.back();\r\n    if (current_front_window == window || current_front_window->RootWindow == window)\r\n        return;\r\n    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window\r\n        if (g.Windows[i] == window)\r\n        {\r\n            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));\r\n            g.Windows[g.Windows.Size - 1] = window;\r\n            break;\r\n        }\r\n}\r\n\r\nvoid ImGui::BringWindowToDisplayBack(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.Windows[0] == window)\r\n        return;\r\n    for (int i = 0; i < g.Windows.Size; i++)\r\n        if (g.Windows[i] == window)\r\n        {\r\n            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));\r\n            g.Windows[0] = window;\r\n            break;\r\n        }\r\n}\r\n\r\n// Moving window to front of display and set focus (which happens to be back of our sorted list)\r\nvoid ImGui::FocusWindow(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    if (g.NavWindow != window)\r\n    {\r\n        g.NavWindow = window;\r\n        if (window && g.NavDisableMouseHover)\r\n            g.NavMousePosDirty = true;\r\n        g.NavInitRequest = false;\r\n        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId\r\n        g.NavIdIsAlive = false;\r\n        g.NavLayer = 0;\r\n        //printf(\"[%05d] FocusWindow(\\\"%s\\\")\\n\", g.FrameCount, window ? window->Name : NULL);\r\n    }\r\n\r\n    // Passing NULL allow to disable keyboard focus\r\n    if (!window)\r\n        return;\r\n\r\n    // Move the root window to the top of the pile\r\n    if (window->RootWindow)\r\n        window = window->RootWindow;\r\n\r\n    // Steal focus on active widgets\r\n    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..\r\n        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)\r\n            ClearActiveID();\r\n\r\n    // Bring to front\r\n    BringWindowToFocusFront(window);\r\n    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))\r\n        BringWindowToDisplayFront(window);\r\n}\r\n\r\nvoid ImGui::FocusPreviousWindowIgnoringOne(ImGuiWindow* ignore_window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)\r\n    {\r\n        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.\r\n        ImGuiWindow* window = g.WindowsFocusOrder[i];\r\n        if (window != ignore_window && window->WasActive && !(window->Flags & ImGuiWindowFlags_ChildWindow))\r\n            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))\r\n            {\r\n                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);\r\n                FocusWindow(focus_window);\r\n                return;\r\n            }\r\n    }\r\n}\r\n\r\nvoid ImGui::PushItemWidth(float item_width)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);\r\n    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);\r\n}\r\n\r\nvoid ImGui::PushMultiItemsWidths(int components, float w_full)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    const ImGuiStyle& style = GImGui->Style;\r\n    if (w_full <= 0.0f)\r\n        w_full = CalcItemWidth();\r\n    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));\r\n    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));\r\n    window->DC.ItemWidthStack.push_back(w_item_last);\r\n    for (int i = 0; i < components-1; i++)\r\n        window->DC.ItemWidthStack.push_back(w_item_one);\r\n    window->DC.ItemWidth = window->DC.ItemWidthStack.back();\r\n}\r\n\r\nvoid ImGui::PopItemWidth()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.ItemWidthStack.pop_back();\r\n    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();\r\n}\r\n\r\nfloat ImGui::CalcItemWidth()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    float w = window->DC.ItemWidth;\r\n    if (w < 0.0f)\r\n    {\r\n        // Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.\r\n        float width_to_right_edge = GetContentRegionAvail().x;\r\n        w = ImMax(1.0f, width_to_right_edge + w);\r\n    }\r\n    w = (float)(int)w;\r\n    return w;\r\n}\r\n\r\nvoid ImGui::SetCurrentFont(ImFont* font)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?\r\n    IM_ASSERT(font->Scale > 0.0f);\r\n    g.Font = font;\r\n    g.FontBaseSize = g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale;\r\n    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;\r\n\r\n    ImFontAtlas* atlas = g.Font->ContainerAtlas;\r\n    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;\r\n    g.DrawListSharedData.Font = g.Font;\r\n    g.DrawListSharedData.FontSize = g.FontSize;\r\n}\r\n\r\nvoid ImGui::PushFont(ImFont* font)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!font)\r\n        font = GetDefaultFont();\r\n    SetCurrentFont(font);\r\n    g.FontStack.push_back(font);\r\n    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);\r\n}\r\n\r\nvoid  ImGui::PopFont()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.CurrentWindow->DrawList->PopTextureID();\r\n    g.FontStack.pop_back();\r\n    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());\r\n}\r\n\r\nvoid ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (enabled)\r\n        window->DC.ItemFlags |= option;\r\n    else\r\n        window->DC.ItemFlags &= ~option;\r\n    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);\r\n}\r\n\r\nvoid ImGui::PopItemFlag()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.ItemFlagsStack.pop_back();\r\n    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();\r\n}\r\n\r\n// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.\r\nvoid ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)\r\n{\r\n    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);\r\n}\r\n\r\nvoid ImGui::PopAllowKeyboardFocus()\r\n{\r\n    PopItemFlag();\r\n}\r\n\r\nvoid ImGui::PushButtonRepeat(bool repeat)\r\n{\r\n    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);\r\n}\r\n\r\nvoid ImGui::PopButtonRepeat()\r\n{\r\n    PopItemFlag();\r\n}\r\n\r\nvoid ImGui::PushTextWrapPos(float wrap_pos_x)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.TextWrapPos = wrap_pos_x;\r\n    window->DC.TextWrapPosStack.push_back(wrap_pos_x);\r\n}\r\n\r\nvoid ImGui::PopTextWrapPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.TextWrapPosStack.pop_back();\r\n    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();\r\n}\r\n\r\n// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32\r\nvoid ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiColorMod backup;\r\n    backup.Col = idx;\r\n    backup.BackupValue = g.Style.Colors[idx];\r\n    g.ColorModifiers.push_back(backup);\r\n    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);\r\n}\r\n\r\nvoid ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiColorMod backup;\r\n    backup.Col = idx;\r\n    backup.BackupValue = g.Style.Colors[idx];\r\n    g.ColorModifiers.push_back(backup);\r\n    g.Style.Colors[idx] = col;\r\n}\r\n\r\nvoid ImGui::PopStyleColor(int count)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    while (count > 0)\r\n    {\r\n        ImGuiColorMod& backup = g.ColorModifiers.back();\r\n        g.Style.Colors[backup.Col] = backup.BackupValue;\r\n        g.ColorModifiers.pop_back();\r\n        count--;\r\n    }\r\n}\r\n\r\nstruct ImGuiStyleVarInfo\r\n{\r\n    ImGuiDataType   Type;\r\n    ImU32           Count;\r\n    ImU32           Offset;\r\n    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }\r\n};\r\n\r\nstatic const ImGuiStyleVarInfo GStyleVarInfo[] =\r\n{\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },              // ImGuiStyleVar_Alpha\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },      // ImGuiStyleVar_WindowPadding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },     // ImGuiStyleVar_WindowRounding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },   // ImGuiStyleVar_WindowBorderSize\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },      // ImGuiStyleVar_WindowMinSize\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },   // ImGuiStyleVar_WindowTitleAlign\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },      // ImGuiStyleVar_ChildRounding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },    // ImGuiStyleVar_ChildBorderSize\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },      // ImGuiStyleVar_PopupRounding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },    // ImGuiStyleVar_PopupBorderSize\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },       // ImGuiStyleVar_FramePadding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },      // ImGuiStyleVar_FrameRounding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },    // ImGuiStyleVar_FrameBorderSize\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },        // ImGuiStyleVar_ItemSpacing\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },   // ImGuiStyleVar_ItemInnerSpacing\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },      // ImGuiStyleVar_IndentSpacing\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },      // ImGuiStyleVar_ScrollbarSize\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },  // ImGuiStyleVar_ScrollbarRounding\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },        // ImGuiStyleVar_GrabMinSize\r\n    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },       // ImGuiStyleVar_GrabRounding\r\n    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },    // ImGuiStyleVar_ButtonTextAlign\r\n};\r\n\r\nstatic const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)\r\n{\r\n    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);\r\n    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);\r\n    return &GStyleVarInfo[idx];\r\n}\r\n\r\nvoid ImGui::PushStyleVar(ImGuiStyleVar idx, float val)\r\n{\r\n    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);\r\n    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)\r\n    {\r\n        ImGuiContext& g = *GImGui;\r\n        float* pvar = (float*)var_info->GetVarPtr(&g.Style);\r\n        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));\r\n        *pvar = val;\r\n        return;\r\n    }\r\n    IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.\r\n}\r\n\r\nvoid ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)\r\n{\r\n    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);\r\n    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)\r\n    {\r\n        ImGuiContext& g = *GImGui;\r\n        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);\r\n        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));\r\n        *pvar = val;\r\n        return;\r\n    }\r\n    IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.\r\n}\r\n\r\nvoid ImGui::PopStyleVar(int count)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    while (count > 0)\r\n    {\r\n        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.\r\n        ImGuiStyleMod& backup = g.StyleModifiers.back();\r\n        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);\r\n        void* data = info->GetVarPtr(&g.Style);\r\n        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }\r\n        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }\r\n        g.StyleModifiers.pop_back();\r\n        count--;\r\n    }\r\n}\r\n\r\nconst char* ImGui::GetStyleColorName(ImGuiCol idx)\r\n{\r\n    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\\1: return \"\\1\";\r\n    switch (idx)\r\n    {\r\n    case ImGuiCol_Text: return \"Text\";\r\n    case ImGuiCol_TextDisabled: return \"TextDisabled\";\r\n    case ImGuiCol_WindowBg: return \"WindowBg\";\r\n    case ImGuiCol_ChildBg: return \"ChildBg\";\r\n    case ImGuiCol_PopupBg: return \"PopupBg\";\r\n    case ImGuiCol_Border: return \"Border\";\r\n    case ImGuiCol_BorderShadow: return \"BorderShadow\";\r\n    case ImGuiCol_FrameBg: return \"FrameBg\";\r\n    case ImGuiCol_FrameBgHovered: return \"FrameBgHovered\";\r\n    case ImGuiCol_FrameBgActive: return \"FrameBgActive\";\r\n    case ImGuiCol_TitleBg: return \"TitleBg\";\r\n    case ImGuiCol_TitleBgActive: return \"TitleBgActive\";\r\n    case ImGuiCol_TitleBgCollapsed: return \"TitleBgCollapsed\";\r\n    case ImGuiCol_MenuBarBg: return \"MenuBarBg\";\r\n    case ImGuiCol_ScrollbarBg: return \"ScrollbarBg\";\r\n    case ImGuiCol_ScrollbarGrab: return \"ScrollbarGrab\";\r\n    case ImGuiCol_ScrollbarGrabHovered: return \"ScrollbarGrabHovered\";\r\n    case ImGuiCol_ScrollbarGrabActive: return \"ScrollbarGrabActive\";\r\n    case ImGuiCol_CheckMark: return \"CheckMark\";\r\n    case ImGuiCol_SliderGrab: return \"SliderGrab\";\r\n    case ImGuiCol_SliderGrabActive: return \"SliderGrabActive\";\r\n    case ImGuiCol_Button: return \"Button\";\r\n    case ImGuiCol_ButtonHovered: return \"ButtonHovered\";\r\n    case ImGuiCol_ButtonActive: return \"ButtonActive\";\r\n    case ImGuiCol_Header: return \"Header\";\r\n    case ImGuiCol_HeaderHovered: return \"HeaderHovered\";\r\n    case ImGuiCol_HeaderActive: return \"HeaderActive\";\r\n    case ImGuiCol_Separator: return \"Separator\";\r\n    case ImGuiCol_SeparatorHovered: return \"SeparatorHovered\";\r\n    case ImGuiCol_SeparatorActive: return \"SeparatorActive\";\r\n    case ImGuiCol_ResizeGrip: return \"ResizeGrip\";\r\n    case ImGuiCol_ResizeGripHovered: return \"ResizeGripHovered\";\r\n    case ImGuiCol_ResizeGripActive: return \"ResizeGripActive\";\r\n    case ImGuiCol_PlotLines: return \"PlotLines\";\r\n    case ImGuiCol_PlotLinesHovered: return \"PlotLinesHovered\";\r\n    case ImGuiCol_PlotHistogram: return \"PlotHistogram\";\r\n    case ImGuiCol_PlotHistogramHovered: return \"PlotHistogramHovered\";\r\n    case ImGuiCol_TextSelectedBg: return \"TextSelectedBg\";\r\n    case ImGuiCol_DragDropTarget: return \"DragDropTarget\";\r\n    case ImGuiCol_NavHighlight: return \"NavHighlight\";\r\n    case ImGuiCol_NavWindowingHighlight: return \"NavWindowingHighlight\";\r\n    case ImGuiCol_NavWindowingDimBg: return \"NavWindowingDimBg\";\r\n    case ImGuiCol_ModalWindowDimBg: return \"ModalWindowDimBg\";\r\n    }\r\n    IM_ASSERT(0);\r\n    return \"Unknown\";\r\n}\r\n\r\nbool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)\r\n{\r\n    if (window->RootWindow == potential_parent)\r\n        return true;\r\n    while (window != NULL)\r\n    {\r\n        if (window == potential_parent)\r\n            return true;\r\n        window = window->ParentWindow;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)\r\n{\r\n    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    if (flags & ImGuiHoveredFlags_AnyWindow)\r\n    {\r\n        if (g.HoveredWindow == NULL)\r\n            return false;\r\n    }\r\n    else\r\n    {\r\n        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))\r\n        {\r\n        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:\r\n            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)\r\n                return false;\r\n            break;\r\n        case ImGuiHoveredFlags_RootWindow:\r\n            if (g.HoveredWindow != g.CurrentWindow->RootWindow)\r\n                return false;\r\n            break;\r\n        case ImGuiHoveredFlags_ChildWindows:\r\n            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))\r\n                return false;\r\n            break;\r\n        default:\r\n            if (g.HoveredWindow != g.CurrentWindow)\r\n                return false;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))\r\n        return false;\r\n    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\r\n        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)\r\n            return false;\r\n    return true;\r\n}\r\n\r\nbool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    if (flags & ImGuiFocusedFlags_AnyWindow)\r\n        return g.NavWindow != NULL;\r\n\r\n    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()\r\n    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))\r\n    {\r\n    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:\r\n        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;\r\n    case ImGuiFocusedFlags_RootWindow:\r\n        return g.NavWindow == g.CurrentWindow->RootWindow;\r\n    case ImGuiFocusedFlags_ChildWindows:\r\n        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);\r\n    default:\r\n        return g.NavWindow == g.CurrentWindow;\r\n    }\r\n}\r\n\r\n// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)\r\n// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmaticaly.\r\n// If you want a window to never be focused, you may use the e.g. NoInputs flag.\r\nbool ImGui::IsWindowNavFocusable(ImGuiWindow* window)\r\n{\r\n    return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);\r\n}\r\n\r\nfloat ImGui::GetWindowWidth()\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    return window->Size.x;\r\n}\r\n\r\nfloat ImGui::GetWindowHeight()\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    return window->Size.y;\r\n}\r\n\r\nImVec2 ImGui::GetWindowPos()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    return window->Pos;\r\n}\r\n\r\nvoid ImGui::SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)\r\n{\r\n    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.\r\n    window->Scroll.x = new_scroll_x;\r\n    window->DC.CursorMaxPos.x -= window->Scroll.x;\r\n}\r\n\r\nvoid ImGui::SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)\r\n{\r\n    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.\r\n    window->Scroll.y = new_scroll_y;\r\n    window->DC.CursorMaxPos.y -= window->Scroll.y;\r\n}\r\n\r\nstatic void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)\r\n{\r\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\r\n    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)\r\n        return;\r\n\r\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\r\n    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n    // Set\r\n    const ImVec2 old_pos = window->Pos;\r\n    window->Pos = ImFloor(pos);\r\n    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor\r\n    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.\r\n}\r\n\r\nvoid ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    SetWindowPos(window, pos, cond);\r\n}\r\n\r\nvoid ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)\r\n{\r\n    if (ImGuiWindow* window = FindWindowByName(name))\r\n        SetWindowPos(window, pos, cond);\r\n}\r\n\r\nImVec2 ImGui::GetWindowSize()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->Size;\r\n}\r\n\r\nstatic void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)\r\n{\r\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\r\n    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)\r\n        return;\r\n\r\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\r\n    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n\r\n    // Set\r\n    if (size.x > 0.0f)\r\n    {\r\n        window->AutoFitFramesX = 0;\r\n        window->SizeFull.x = ImFloor(size.x);\r\n    }\r\n    else\r\n    {\r\n        window->AutoFitFramesX = 2;\r\n        window->AutoFitOnlyGrows = false;\r\n    }\r\n    if (size.y > 0.0f)\r\n    {\r\n        window->AutoFitFramesY = 0;\r\n        window->SizeFull.y = ImFloor(size.y);\r\n    }\r\n    else\r\n    {\r\n        window->AutoFitFramesY = 2;\r\n        window->AutoFitOnlyGrows = false;\r\n    }\r\n}\r\n\r\nvoid ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)\r\n{\r\n    SetWindowSize(GImGui->CurrentWindow, size, cond);\r\n}\r\n\r\nvoid ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)\r\n{\r\n    if (ImGuiWindow* window = FindWindowByName(name))\r\n        SetWindowSize(window, size, cond);\r\n}\r\n\r\nstatic void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)\r\n{\r\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\r\n    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)\r\n        return;\r\n    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n\r\n    // Set\r\n    window->Collapsed = collapsed;\r\n}\r\n\r\nvoid ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)\r\n{\r\n    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);\r\n}\r\n\r\nbool ImGui::IsWindowCollapsed()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->Collapsed;\r\n}\r\n\r\nbool ImGui::IsWindowAppearing()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->Appearing;\r\n}\r\n\r\nvoid ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)\r\n{\r\n    if (ImGuiWindow* window = FindWindowByName(name))\r\n        SetWindowCollapsed(window, collapsed, cond);\r\n}\r\n\r\nvoid ImGui::SetWindowFocus()\r\n{\r\n    FocusWindow(GImGui->CurrentWindow);\r\n}\r\n\r\nvoid ImGui::SetWindowFocus(const char* name)\r\n{\r\n    if (name)\r\n    {\r\n        if (ImGuiWindow* window = FindWindowByName(name))\r\n            FocusWindow(window);\r\n    }\r\n    else\r\n    {\r\n        FocusWindow(NULL);\r\n    }\r\n}\r\n\r\nvoid ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\r\n    g.NextWindowData.PosVal = pos;\r\n    g.NextWindowData.PosPivotVal = pivot;\r\n    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\r\n    g.NextWindowData.SizeVal = size;\r\n    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;\r\n    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);\r\n    g.NextWindowData.SizeCallback = custom_callback;\r\n    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;\r\n}\r\n\r\nvoid ImGui::SetNextWindowContentSize(const ImVec2& size)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.\r\n    g.NextWindowData.ContentSizeCond = ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.\r\n    g.NextWindowData.CollapsedVal = collapsed;\r\n    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowFocus()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)\r\n}\r\n\r\nvoid ImGui::SetNextWindowBgAlpha(float alpha)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NextWindowData.BgAlphaVal = alpha;\r\n    g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)\r\n}\r\n\r\n// In window space (not screen space!)\r\nImVec2 ImGui::GetContentRegionMax()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;\r\n    if (window->DC.ColumnsSet)\r\n        mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;\r\n    return mx;\r\n}\r\n\r\nImVec2 ImGui::GetContentRegionAvail()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);\r\n}\r\n\r\nfloat ImGui::GetContentRegionAvailWidth()\r\n{\r\n    return GetContentRegionAvail().x;\r\n}\r\n\r\n// In window space (not screen space!)\r\nImVec2 ImGui::GetWindowContentRegionMin()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ContentsRegionRect.Min - window->Pos;\r\n}\r\n\r\nImVec2 ImGui::GetWindowContentRegionMax()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ContentsRegionRect.Max - window->Pos;\r\n}\r\n\r\nfloat ImGui::GetWindowContentRegionWidth()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ContentsRegionRect.GetWidth();\r\n}\r\n\r\nfloat ImGui::GetTextLineHeight()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize;\r\n}\r\n\r\nfloat ImGui::GetTextLineHeightWithSpacing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + g.Style.ItemSpacing.y;\r\n}\r\n\r\nfloat ImGui::GetFrameHeight()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + g.Style.FramePadding.y * 2.0f;\r\n}\r\n\r\nfloat ImGui::GetFrameHeightWithSpacing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;\r\n}\r\n\r\nImDrawList* ImGui::GetWindowDrawList()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    return window->DrawList;\r\n}\r\n\r\nImFont* ImGui::GetFont()\r\n{\r\n    return GImGui->Font;\r\n}\r\n\r\nfloat ImGui::GetFontSize()\r\n{\r\n    return GImGui->FontSize;\r\n}\r\n\r\nImVec2 ImGui::GetFontTexUvWhitePixel()\r\n{\r\n    return GImGui->DrawListSharedData.TexUvWhitePixel;\r\n}\r\n\r\nvoid ImGui::SetWindowFontScale(float scale)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->FontWindowScale = scale;\r\n    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();\r\n}\r\n\r\n// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.\r\n// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.\r\nImVec2 ImGui::GetCursorPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos - window->Pos + window->Scroll;\r\n}\r\n\r\nfloat ImGui::GetCursorPosX()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;\r\n}\r\n\r\nfloat ImGui::GetCursorPosY()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;\r\n}\r\n\r\nvoid ImGui::SetCursorPos(const ImVec2& local_pos)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;\r\n    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);\r\n}\r\n\r\nvoid ImGui::SetCursorPosX(float x)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;\r\n    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);\r\n}\r\n\r\nvoid ImGui::SetCursorPosY(float y)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;\r\n    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);\r\n}\r\n\r\nImVec2 ImGui::GetCursorStartPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorStartPos - window->Pos;\r\n}\r\n\r\nImVec2 ImGui::GetCursorScreenPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos;\r\n}\r\n\r\nvoid ImGui::SetCursorScreenPos(const ImVec2& screen_pos)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos = screen_pos;\r\n    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);\r\n}\r\n\r\nfloat ImGui::GetScrollX()\r\n{\r\n    return GImGui->CurrentWindow->Scroll.x;\r\n}\r\n\r\nfloat ImGui::GetScrollY()\r\n{\r\n    return GImGui->CurrentWindow->Scroll.y;\r\n}\r\n\r\nfloat ImGui::GetScrollMaxX()\r\n{\r\n    return GetWindowScrollMaxX(GImGui->CurrentWindow);\r\n}\r\n\r\nfloat ImGui::GetScrollMaxY()\r\n{\r\n    return GetWindowScrollMaxY(GImGui->CurrentWindow);\r\n}\r\n\r\nvoid ImGui::SetScrollX(float scroll_x)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->ScrollTarget.x = scroll_x;\r\n    window->ScrollTargetCenterRatio.x = 0.0f;\r\n}\r\n\r\nvoid ImGui::SetScrollY(float scroll_y)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY\r\n    window->ScrollTargetCenterRatio.y = 0.0f;\r\n}\r\n\r\nvoid ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)\r\n{\r\n    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);\r\n    window->ScrollTarget.y = (float)(int)(pos_y + window->Scroll.y);\r\n    window->ScrollTargetCenterRatio.y = center_y_ratio;\r\n}\r\n\r\n// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.\r\nvoid ImGui::SetScrollHereY(float center_y_ratio)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space\r\n    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.\r\n    SetScrollFromPosY(target_y, center_y_ratio);\r\n}\r\n\r\nvoid ImGui::ActivateItem(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NavNextActivateId = id;\r\n}\r\n\r\nvoid ImGui::SetKeyboardFocusHere(int offset)\r\n{\r\n    IM_ASSERT(offset >= -1);    // -1 is allowed but not below\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;\r\n    window->FocusIdxTabRequestNext = INT_MAX;\r\n}\r\n\r\nvoid ImGui::SetItemDefaultFocus()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (!window->Appearing)\r\n        return;\r\n    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)\r\n    {\r\n        g.NavInitRequest = false;\r\n        g.NavInitResultId = g.NavWindow->DC.LastItemId;\r\n        g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);\r\n        NavUpdateAnyRequestFlag();\r\n        if (!IsItemVisible())\r\n            SetScrollHereY();\r\n    }\r\n}\r\n\r\nvoid ImGui::SetStateStorage(ImGuiStorage* tree)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.StateStorage = tree ? tree : &window->StateStorage;\r\n}\r\n\r\nImGuiStorage* ImGui::GetStateStorage()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.StateStorage;\r\n}\r\n\r\nvoid ImGui::PushID(const char* str_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));\r\n}\r\n\r\nvoid ImGui::PushID(const char* str_id_begin, const char* str_id_end)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));\r\n}\r\n\r\nvoid ImGui::PushID(const void* ptr_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));\r\n}\r\n\r\nvoid ImGui::PushID(int int_id)\r\n{\r\n    const void* ptr_id = (void*)(intptr_t)int_id;\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));\r\n}\r\n\r\nvoid ImGui::PopID()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.pop_back();\r\n}\r\n\r\nImGuiID ImGui::GetID(const char* str_id)\r\n{\r\n    return GImGui->CurrentWindow->GetID(str_id);\r\n}\r\n\r\nImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)\r\n{\r\n    return GImGui->CurrentWindow->GetID(str_id_begin, str_id_end);\r\n}\r\n\r\nImGuiID ImGui::GetID(const void* ptr_id)\r\n{\r\n    return GImGui->CurrentWindow->GetID(ptr_id);\r\n}\r\n\r\nbool ImGui::IsRectVisible(const ImVec2& size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));\r\n}\r\n\r\nbool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));\r\n}\r\n\r\n// Lock horizontal starting position + capture group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\r\nvoid ImGui::BeginGroup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);\r\n    ImGuiGroupData& group_data = window->DC.GroupStack.back();\r\n    group_data.BackupCursorPos = window->DC.CursorPos;\r\n    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;\r\n    group_data.BackupIndent = window->DC.Indent;\r\n    group_data.BackupGroupOffset = window->DC.GroupOffset;\r\n    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;\r\n    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;\r\n    group_data.BackupLogLinePosY = window->DC.LogLinePosY;\r\n    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;\r\n    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;\r\n    group_data.AdvanceCursor = true;\r\n\r\n    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;\r\n    window->DC.Indent = window->DC.GroupOffset;\r\n    window->DC.CursorMaxPos = window->DC.CursorPos;\r\n    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);\r\n    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return\r\n}\r\n\r\nvoid ImGui::EndGroup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls\r\n\r\n    ImGuiGroupData& group_data = window->DC.GroupStack.back();\r\n\r\n    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);\r\n    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);\r\n\r\n    window->DC.CursorPos = group_data.BackupCursorPos;\r\n    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);\r\n    window->DC.Indent = group_data.BackupIndent;\r\n    window->DC.GroupOffset = group_data.BackupGroupOffset;\r\n    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;\r\n    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;\r\n    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return\r\n\r\n    if (group_data.AdvanceCursor)\r\n    {\r\n        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.\r\n        ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);\r\n        ItemAdd(group_bb, 0);\r\n    }\r\n\r\n    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.\r\n    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.\r\n    // (and if you grep for LastItemId you'll notice it is only used in that context.\r\n    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)\r\n        window->DC.LastItemId = g.ActiveId;\r\n    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)\r\n        window->DC.LastItemId = g.ActiveIdPreviousFrame;\r\n    window->DC.LastItemRect = group_bb;\r\n\r\n    window->DC.GroupStack.pop_back();\r\n\r\n    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]\r\n}\r\n\r\n// Gets back to previous line and continue with horizontal layout\r\n//      pos_x == 0      : follow right after previous item\r\n//      pos_x != 0      : align to specified x position (relative to window/group left)\r\n//      spacing_w < 0   : use default spacing if pos_x == 0, no spacing if pos_x != 0\r\n//      spacing_w >= 0  : enforce spacing amount\r\nvoid ImGui::SameLine(float pos_x, float spacing_w)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    if (pos_x != 0.0f)\r\n    {\r\n        if (spacing_w < 0.0f) spacing_w = 0.0f;\r\n        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;\r\n        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;\r\n    }\r\n    else\r\n    {\r\n        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;\r\n        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;\r\n        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;\r\n    }\r\n    window->DC.CurrentLineSize = window->DC.PrevLineSize;\r\n    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;\r\n}\r\n\r\nvoid ImGui::Indent(float indent_w)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;\r\n    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;\r\n}\r\n\r\nvoid ImGui::Unindent(float indent_w)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;\r\n    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] TOOLTIPS\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::BeginTooltip()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.DragDropWithinSourceOrTarget)\r\n    {\r\n        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)\r\n        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.\r\n        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.\r\n        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;\r\n        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);\r\n        SetNextWindowPos(tooltip_pos);\r\n        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);\r\n        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(\r\n        BeginTooltipEx(0, true);\r\n    }\r\n    else\r\n    {\r\n        BeginTooltipEx(0, false);\r\n    }\r\n}\r\n\r\n// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.\r\nvoid ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    char window_name[16];\r\n    ImFormatString(window_name, IM_ARRAYSIZE(window_name), \"##Tooltip_%02d\", g.TooltipOverrideCount);\r\n    if (override_previous_tooltip)\r\n        if (ImGuiWindow* window = FindWindowByName(window_name))\r\n            if (window->Active)\r\n            {\r\n                // Hide previous tooltip from being displayed. We can't easily \"reset\" the content of a window so we create a new one.\r\n                window->Hidden = true;\r\n                window->HiddenFramesRegular = 1;\r\n                ImFormatString(window_name, IM_ARRAYSIZE(window_name), \"##Tooltip_%02d\", ++g.TooltipOverrideCount);\r\n            }\r\n    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoInputs|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;\r\n    Begin(window_name, NULL, flags | extra_flags);\r\n}\r\n\r\nvoid ImGui::EndTooltip()\r\n{\r\n    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls\r\n    End();\r\n}\r\n\r\nvoid ImGui::SetTooltipV(const char* fmt, va_list args)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.DragDropWithinSourceOrTarget)\r\n        BeginTooltip();\r\n    else\r\n        BeginTooltipEx(0, true);\r\n    TextV(fmt, args);\r\n    EndTooltip();\r\n}\r\n\r\nvoid ImGui::SetTooltip(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    SetTooltipV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] POPUPS\r\n//-----------------------------------------------------------------------------\r\n\r\nbool ImGui::IsPopupOpen(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;\r\n}\r\n\r\nbool ImGui::IsPopupOpen(const char* str_id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);\r\n}\r\n\r\nImGuiWindow* ImGui::GetFrontMostPopupModal()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)\r\n        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)\r\n            if (popup->Flags & ImGuiWindowFlags_Modal)\r\n                return popup;\r\n    return NULL;\r\n}\r\n\r\nvoid ImGui::OpenPopup(const char* str_id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    OpenPopupEx(g.CurrentWindow->GetID(str_id));\r\n}\r\n\r\n// Mark popup as open (toggle toward open state).\r\n// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.\r\n// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).\r\n// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)\r\nvoid ImGui::OpenPopupEx(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* parent_window = g.CurrentWindow;\r\n    int current_stack_size = g.CurrentPopupStack.Size;\r\n    ImGuiPopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.\r\n    popup_ref.PopupId = id;\r\n    popup_ref.Window = NULL;\r\n    popup_ref.ParentWindow = parent_window;\r\n    popup_ref.OpenFrameCount = g.FrameCount;\r\n    popup_ref.OpenParentId = parent_window->IDStack.back();\r\n    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();\r\n    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;\r\n\r\n    //printf(\"[%05d] OpenPopupEx(0x%08X)\\n\", g.FrameCount, id);\r\n    if (g.OpenPopupStack.Size < current_stack_size + 1)\r\n    {\r\n        g.OpenPopupStack.push_back(popup_ref);\r\n    }\r\n    else\r\n    {\r\n        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui\r\n        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing\r\n        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.\r\n        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)\r\n        {\r\n            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;\r\n        }\r\n        else\r\n        {\r\n            // Close child popups if any, then flag popup for open/reopen\r\n            g.OpenPopupStack.resize(current_stack_size + 1);\r\n            g.OpenPopupStack[current_stack_size] = popup_ref;\r\n        }\r\n\r\n        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().\r\n        // This is equivalent to what ClosePopupToLevel() does.\r\n        //if (g.OpenPopupStack[current_stack_size].PopupId == id)\r\n        //    FocusWindow(parent_window);\r\n    }\r\n}\r\n\r\nbool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n    {\r\n        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!\r\n        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)\r\n        OpenPopupEx(id);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.OpenPopupStack.empty())\r\n        return;\r\n\r\n    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.\r\n    // Don't close our own child popup windows.\r\n    int n = 0;\r\n    if (ref_window)\r\n    {\r\n        for (n = 0; n < g.OpenPopupStack.Size; n++)\r\n        {\r\n            ImGuiPopupRef& popup = g.OpenPopupStack[n];\r\n            if (!popup.Window)\r\n                continue;\r\n            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);\r\n            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)\r\n                continue;\r\n\r\n            // Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)\r\n            bool has_focus = false;\r\n            for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)\r\n                has_focus = (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow);\r\n            if (!has_focus)\r\n                break;\r\n        }\r\n    }\r\n    if (n < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the block below\r\n        ClosePopupToLevel(n);\r\n}\r\n\r\nvoid ImGui::ClosePopupToLevel(int remaining)\r\n{\r\n    IM_ASSERT(remaining >= 0);\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* focus_window = (remaining > 0) ? g.OpenPopupStack[remaining-1].Window : g.OpenPopupStack[0].ParentWindow;\r\n    if (g.NavLayer == 0)\r\n        focus_window = NavRestoreLastChildNavWindow(focus_window);\r\n    FocusWindow(focus_window);\r\n    focus_window->DC.NavHideHighlightOneFrame = true;\r\n    g.OpenPopupStack.resize(remaining);\r\n}\r\n\r\nvoid ImGui::ClosePopup(ImGuiID id)\r\n{\r\n    if (!IsPopupOpen(id))\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n    ClosePopupToLevel(g.OpenPopupStack.Size - 1);\r\n}\r\n\r\n// Close the popup we have begin-ed into.\r\nvoid ImGui::CloseCurrentPopup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    int popup_idx = g.CurrentPopupStack.Size - 1;\r\n    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)\r\n        return;\r\n    while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))\r\n        popup_idx--;\r\n    ClosePopupToLevel(popup_idx);\r\n}\r\n\r\nbool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!IsPopupOpen(id))\r\n    {\r\n        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values\r\n        return false;\r\n    }\r\n\r\n    char name[20];\r\n    if (extra_flags & ImGuiWindowFlags_ChildMenu)\r\n        ImFormatString(name, IM_ARRAYSIZE(name), \"##Menu_%02d\", g.CurrentPopupStack.Size);    // Recycle windows based on depth\r\n    else\r\n        ImFormatString(name, IM_ARRAYSIZE(name), \"##Popup_%08x\", id); // Not recycling, so we can close/open during the same frame\r\n\r\n    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);\r\n    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)\r\n        EndPopup();\r\n\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.OpenPopupStack.Size <= g.CurrentPopupStack.Size) // Early out for performance\r\n    {\r\n        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values\r\n        return false;\r\n    }\r\n    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags|ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nbool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    const ImGuiID id = window->GetID(name);\r\n    if (!IsPopupOpen(id))\r\n    {\r\n        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values\r\n        return false;\r\n    }\r\n\r\n    // Center modal windows by default\r\n    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.\r\n    if (g.NextWindowData.PosCond == 0)\r\n        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));\r\n\r\n    bool is_open = Begin(name, p_open, flags | ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);\r\n    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)\r\n    {\r\n        EndPopup();\r\n        if (is_open)\r\n            ClosePopup(id);\r\n        return false;\r\n    }\r\n    return is_open;\r\n}\r\n\r\nvoid ImGui::EndPopup()\r\n{\r\n    ImGuiContext& g = *GImGui; (void)g;\r\n    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls\r\n    IM_ASSERT(g.CurrentPopupStack.Size > 0);\r\n\r\n    // Make all menus and popups wrap around for now, may need to expose that policy.\r\n    NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);\r\n\r\n    End();\r\n}\r\n\r\n// This is a helper to handle the simplest case of associating one named popup to one given widget.\r\n// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).\r\n// You can pass a NULL str_id to use the identifier of the last item.\r\nbool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!\r\n    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)\r\n    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n        OpenPopupEx(id);\r\n    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nbool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)\r\n{\r\n    if (!str_id)\r\n        str_id = \"window_context\";\r\n    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);\r\n    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n        if (also_over_items || !IsAnyItemHovered())\r\n            OpenPopupEx(id);\r\n    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nbool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)\r\n{\r\n    if (!str_id)\r\n        str_id = \"void_context\";\r\n    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);\r\n    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))\r\n        OpenPopupEx(id);\r\n    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow*)\r\n{\r\n    ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;\r\n    ImRect r_screen = GetViewportRect();\r\n    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));\r\n    return r_screen;\r\n}\r\n\r\n// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)\r\n// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.\r\nImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)\r\n{\r\n    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);\r\n    //GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));\r\n    //GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));\r\n\r\n    // Combo Box policy (we want a connecting edge)\r\n    if (policy == ImGuiPopupPositionPolicy_ComboBox)\r\n    {\r\n        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };\r\n        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)\r\n        {\r\n            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];\r\n            if (n != -1 && dir == *last_dir) // Already tried this direction?\r\n                continue;\r\n            ImVec2 pos;\r\n            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)\r\n            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right\r\n            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left\r\n            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left\r\n            if (!r_outer.Contains(ImRect(pos, pos + size)))\r\n                continue;\r\n            *last_dir = dir;\r\n            return pos;\r\n        }\r\n    }\r\n\r\n    // Default popup policy\r\n    const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };\r\n    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)\r\n    {\r\n        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];\r\n        if (n != -1 && dir == *last_dir) // Already tried this direction?\r\n            continue;\r\n        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);\r\n        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);\r\n        if (avail_w < size.x || avail_h < size.y)\r\n            continue;\r\n        ImVec2 pos;\r\n        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;\r\n        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;\r\n        *last_dir = dir;\r\n        return pos;\r\n    }\r\n\r\n    // Fallback, try to keep within display\r\n    *last_dir = ImGuiDir_None;\r\n    ImVec2 pos = ref_pos;\r\n    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);\r\n    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);\r\n    return pos;\r\n}\r\n\r\nImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    ImRect r_outer = GetWindowAllowedExtentRect(window);\r\n    if (window->Flags & ImGuiWindowFlags_ChildMenu)\r\n    {\r\n        // Child menus typically request _any_ position within the parent menu item, and then our FindBestWindowPosForPopup() function will move the new menu outside the parent bounds.\r\n        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.\r\n        IM_ASSERT(g.CurrentWindow == window);\r\n        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];\r\n        float horizontal_overlap = g.Style.ItemSpacing.x;       // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).\r\n        ImRect r_avoid;\r\n        if (parent_window->DC.MenuBarAppending)\r\n            r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());\r\n        else\r\n            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);\r\n        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);\r\n    }\r\n    if (window->Flags & ImGuiWindowFlags_Popup)\r\n    {\r\n        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);\r\n        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);\r\n    }\r\n    if (window->Flags & ImGuiWindowFlags_Tooltip)\r\n    {\r\n        // Position tooltip (always follows mouse)\r\n        float sc = g.Style.MouseCursorScale;\r\n        ImVec2 ref_pos = NavCalcPreferredRefPos();\r\n        ImRect r_avoid;\r\n        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))\r\n            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);\r\n        else\r\n            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.\r\n        ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);\r\n        if (window->AutoPosLastDirection == ImGuiDir_None)\r\n            pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.\r\n        return pos;\r\n    }\r\n    IM_ASSERT(0);\r\n    return window->Pos;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\r\n//-----------------------------------------------------------------------------\r\n\r\nImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)\r\n{\r\n    if (ImFabs(dx) > ImFabs(dy))\r\n        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;\r\n    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;\r\n}\r\n\r\nstatic float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)\r\n{\r\n    if (a1 < b0)\r\n        return a1 - b0;\r\n    if (b1 < a0)\r\n        return a0 - b1;\r\n    return 0.0f;\r\n}\r\n\r\nstatic void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)\r\n{\r\n    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)\r\n    {\r\n        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);\r\n        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);\r\n    }\r\n    else\r\n    {\r\n        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);\r\n        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);\r\n    }\r\n}\r\n\r\n// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057\r\nstatic bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.NavLayer != window->DC.NavLayerCurrent)\r\n        return false;\r\n\r\n    const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)\r\n    g.NavScoringCount++;\r\n\r\n    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring\r\n    if (window->ParentWindow == g.NavWindow)\r\n    {\r\n        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);\r\n        if (!window->ClipRect.Contains(cand))\r\n            return false;\r\n        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window\r\n    }\r\n\r\n    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)\r\n    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.\r\n    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);\r\n\r\n    // Compute distance between boxes\r\n    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.\r\n    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);\r\n    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items\r\n    if (dby != 0.0f && dbx != 0.0f)\r\n       dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);\r\n    float dist_box = ImFabs(dbx) + ImFabs(dby);\r\n\r\n    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)\r\n    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);\r\n    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);\r\n    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)\r\n\r\n    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance\r\n    ImGuiDir quadrant;\r\n    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;\r\n    if (dbx != 0.0f || dby != 0.0f)\r\n    {\r\n        // For non-overlapping boxes, use distance between boxes\r\n        dax = dbx;\r\n        day = dby;\r\n        dist_axial = dist_box;\r\n        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);\r\n    }\r\n    else if (dcx != 0.0f || dcy != 0.0f)\r\n    {\r\n        // For overlapping boxes with different centers, use distance between centers\r\n        dax = dcx;\r\n        day = dcy;\r\n        dist_axial = dist_center;\r\n        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);\r\n    }\r\n    else\r\n    {\r\n        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)\r\n        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;\r\n    }\r\n\r\n#if IMGUI_DEBUG_NAV_SCORING\r\n    char buf[128];\r\n    if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))\r\n    {\r\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"dbox (%.2f,%.2f->%.4f)\\ndcen (%.2f,%.2f->%.4f)\\nd (%.2f,%.2f->%.4f)\\nnav %c, quadrant %c\", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, \"WENS\"[g.NavMoveDir], \"WENS\"[quadrant]);\r\n        ImDrawList* draw_list = GetOverlayDrawList(window);\r\n        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));\r\n        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));\r\n        draw_list->AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));\r\n        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);\r\n    }\r\n    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.\r\n    {\r\n        if (ImGui::IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }\r\n        if (quadrant == g.NavMoveDir)\r\n        {\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"%.0f/%.0f\", dist_box, dist_center);\r\n            ImDrawList* draw_list = GetOverlayDrawList(window);\r\n            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));\r\n            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);\r\n        }\r\n    }\r\n #endif\r\n\r\n    // Is it in the quadrant we're interesting in moving to?\r\n    bool new_best = false;\r\n    if (quadrant == g.NavMoveDir)\r\n    {\r\n        // Does it beat the current best candidate?\r\n        if (dist_box < result->DistBox)\r\n        {\r\n            result->DistBox = dist_box;\r\n            result->DistCenter = dist_center;\r\n            return true;\r\n        }\r\n        if (dist_box == result->DistBox)\r\n        {\r\n            // Try using distance between center points to break ties\r\n            if (dist_center < result->DistCenter)\r\n            {\r\n                result->DistCenter = dist_center;\r\n                new_best = true;\r\n            }\r\n            else if (dist_center == result->DistCenter)\r\n            {\r\n                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving \"later\" items\r\n                // (with higher index) to the right/downwards by an infinitesimal amount since we the current \"best\" button already (so it must have a lower index),\r\n                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.\r\n                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance\r\n                    new_best = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no \"real\" matches\r\n    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)\r\n    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.\r\n    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.\r\n    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?\r\n    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match\r\n        if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))\r\n            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))\r\n            {\r\n                result->DistAxial = dist_axial;\r\n                new_best = true;\r\n            }\r\n\r\n    return new_best;\r\n}\r\n\r\n// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)\r\nstatic void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.\r\n    //    return;\r\n\r\n    const ImGuiItemFlags item_flags = window->DC.ItemFlags;\r\n    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);\r\n\r\n    // Process Init Request\r\n    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)\r\n    {\r\n        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback\r\n        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)\r\n        {\r\n            g.NavInitResultId = id;\r\n            g.NavInitResultRectRel = nav_bb_rel;\r\n        }\r\n        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))\r\n        {\r\n            g.NavInitRequest = false; // Found a match, clear request\r\n            NavUpdateAnyRequestFlag();\r\n        }\r\n    }\r\n\r\n    // Process Move Request (scoring for navigation)\r\n    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)\r\n    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_NoNav))\r\n    {\r\n        ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;\r\n#if IMGUI_DEBUG_NAV_SCORING\r\n        // [DEBUG] Score all items in NavWindow at all times\r\n        if (!g.NavMoveRequest)\r\n            g.NavMoveDir = g.NavMoveDirLast;\r\n        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;\r\n#else\r\n        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);\r\n#endif\r\n        if (new_best)\r\n        {\r\n            result->ID = id;\r\n            result->Window = window;\r\n            result->RectRel = nav_bb_rel;\r\n        }\r\n\r\n        const float VISIBLE_RATIO = 0.70f;\r\n        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))\r\n            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)\r\n                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))\r\n                {\r\n                    result = &g.NavMoveResultLocalVisibleSet;\r\n                    result->ID = id;\r\n                    result->Window = window;\r\n                    result->RectRel = nav_bb_rel;\r\n                }\r\n    }\r\n\r\n    // Update window-relative bounding box of navigated item\r\n    if (g.NavId == id)\r\n    {\r\n        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.\r\n        g.NavLayer = window->DC.NavLayerCurrent;\r\n        g.NavIdIsAlive = true;\r\n        g.NavIdTabCounter = window->FocusIdxTabCounter;\r\n        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)\r\n    }\r\n}\r\n\r\nbool ImGui::NavMoveRequestButNoResultYet()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;\r\n}\r\n\r\nvoid ImGui::NavMoveRequestCancel()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NavMoveRequest = false;\r\n    NavUpdateAnyRequestFlag();\r\n}\r\n\r\nvoid ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);\r\n    ImGui::NavMoveRequestCancel();\r\n    g.NavMoveDir = move_dir;\r\n    g.NavMoveClipDir = clip_dir;\r\n    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;\r\n    g.NavMoveRequestFlags = move_flags;\r\n    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;\r\n}\r\n\r\nvoid ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)\r\n        return;\r\n    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping\r\n    ImRect bb_rel = window->NavRectRel[0];\r\n\r\n    ImGuiDir clip_dir = g.NavMoveDir;\r\n    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))\r\n    {\r\n        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;\r\n        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }\r\n        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);\r\n    }\r\n    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))\r\n    {\r\n        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;\r\n        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }\r\n        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);\r\n    }\r\n    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))\r\n    {\r\n        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;\r\n        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }\r\n        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);\r\n    }\r\n    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))\r\n    {\r\n        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;\r\n        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }\r\n        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);\r\n    }\r\n}\r\n\r\nstatic void ImGui::NavSaveLastChildNavWindow(ImGuiWindow* nav_window)\r\n{\r\n    ImGuiWindow* parent_window = nav_window;\r\n    while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)\r\n        parent_window = parent_window->ParentWindow;\r\n    if (parent_window && parent_window != nav_window)\r\n        parent_window->NavLastChildNavWindow = nav_window;\r\n}\r\n\r\n// Call when we are expected to land on Layer 0 after FocusWindow()\r\nstatic ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)\r\n{\r\n    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;\r\n}\r\n\r\nstatic void NavRestoreLayer(int layer)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NavLayer = layer;\r\n    if (layer == 0)\r\n        g.NavWindow = ImGui::NavRestoreLastChildNavWindow(g.NavWindow);\r\n    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)\r\n        ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);\r\n    else\r\n        ImGui::NavInitWindow(g.NavWindow, true);\r\n}\r\n\r\nstatic inline void ImGui::NavUpdateAnyRequestFlag()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);\r\n    if (g.NavAnyRequest)\r\n        IM_ASSERT(g.NavWindow != NULL);\r\n}\r\n\r\n// This needs to be called before we submit any widget (aka in or before Begin)\r\nvoid ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(window == g.NavWindow);\r\n    bool init_for_nav = false;\r\n    if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))\r\n        if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)\r\n            init_for_nav = true;\r\n    if (init_for_nav)\r\n    {\r\n        SetNavID(0, g.NavLayer);\r\n        g.NavInitRequest = true;\r\n        g.NavInitRequestFromMove = false;\r\n        g.NavInitResultId = 0;\r\n        g.NavInitResultRectRel = ImRect();\r\n        NavUpdateAnyRequestFlag();\r\n    }\r\n    else\r\n    {\r\n        g.NavId = window->NavLastIds[0];\r\n    }\r\n}\r\n\r\nstatic ImVec2 ImGui::NavCalcPreferredRefPos()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)\r\n    {\r\n        // Mouse (we need a fallback in case the mouse becomes invalid after being used)\r\n        if (IsMousePosValid(&g.IO.MousePos))\r\n            return g.IO.MousePos;\r\n        return g.LastValidMousePos;\r\n    }\r\n    else\r\n    {\r\n        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.\r\n        const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];\r\n        ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));\r\n        ImRect visible_rect = GetViewportRect();\r\n        return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.\r\n    }\r\n}\r\n\r\nfloat ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (mode == ImGuiInputReadMode_Down)\r\n        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)\r\n\r\n    const float t = g.IO.NavInputsDownDuration[n];\r\n    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.\r\n        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);\r\n    if (t < 0.0f)\r\n        return 0.0f;\r\n    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.\r\n        return (t == 0.0f) ? 1.0f : 0.0f;\r\n    if (mode == ImGuiInputReadMode_Repeat)\r\n        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);\r\n    if (mode == ImGuiInputReadMode_RepeatSlow)\r\n        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);\r\n    if (mode == ImGuiInputReadMode_RepeatFast)\r\n        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);\r\n    return 0.0f;\r\n}\r\n\r\nImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)\r\n{\r\n    ImVec2 delta(0.0f, 0.0f);\r\n    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)\r\n        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));\r\n    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)\r\n        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));\r\n    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)\r\n        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));\r\n    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))\r\n        delta *= slow_factor;\r\n    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))\r\n        delta *= fast_factor;\r\n    return delta;\r\n}\r\n\r\n// Scroll to keep newly navigated item fully into view\r\n// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.\r\nstatic void NavScrollToBringItemIntoView(ImGuiWindow* window, const ImRect& item_rect)\r\n{\r\n    ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));\r\n    //g.OverlayDrawList.AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]\r\n    if (window_rect.Contains(item_rect))\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)\r\n    {\r\n        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;\r\n        window->ScrollTargetCenterRatio.x = 0.0f;\r\n    }\r\n    else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)\r\n    {\r\n        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;\r\n        window->ScrollTargetCenterRatio.x = 1.0f;\r\n    }\r\n    if (item_rect.Min.y < window_rect.Min.y)\r\n    {\r\n        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;\r\n        window->ScrollTargetCenterRatio.y = 0.0f;\r\n    }\r\n    else if (item_rect.Max.y >= window_rect.Max.y)\r\n    {\r\n        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;\r\n        window->ScrollTargetCenterRatio.y = 1.0f;\r\n    }\r\n}\r\n\r\nstatic void ImGui::NavUpdate()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.IO.WantSetMousePos = false;\r\n#if 0\r\n    if (g.NavScoringCount > 0) printf(\"[%05d] NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\\n\", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : \"NULL\", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);\r\n#endif\r\n\r\n    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)\r\n    bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;\r\n    bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;\r\n    if (nav_gamepad_active)\r\n        if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)\r\n            g.NavInputSource = ImGuiInputSource_NavGamepad;\r\n\r\n    // Update Keyboard->Nav inputs mapping\r\n    if (nav_keyboard_active)\r\n    {\r\n        #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }\r\n        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );\r\n        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );\r\n        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );\r\n        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );\r\n        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);\r\n        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );\r\n        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );\r\n        if (g.IO.KeyCtrl)   g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;\r\n        if (g.IO.KeyShift)  g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;\r\n        if (g.IO.KeyAlt)    g.IO.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;\r\n        #undef NAV_MAP_KEY\r\n    }\r\n    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)\r\n        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;\r\n\r\n    // Process navigation init request (select first/default focus)\r\n    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))\r\n    {\r\n        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)\r\n        IM_ASSERT(g.NavWindow);\r\n        if (g.NavInitRequestFromMove)\r\n            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);\r\n        else\r\n            SetNavID(g.NavInitResultId, g.NavLayer);\r\n        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;\r\n    }\r\n    g.NavInitRequest = false;\r\n    g.NavInitRequestFromMove = false;\r\n    g.NavInitResultId = 0;\r\n    g.NavJustMovedToId = 0;\r\n\r\n    // Process navigation move request\r\n    if (g.NavMoveRequest)\r\n        NavUpdateMoveResult();\r\n\r\n    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame\r\n    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)\r\n    {\r\n        IM_ASSERT(g.NavMoveRequest);\r\n        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)\r\n            g.NavDisableHighlight = false;\r\n        g.NavMoveRequestForward = ImGuiNavForward_None;\r\n    }\r\n\r\n    // Apply application mouse position movement, after we had a chance to process move request result.\r\n    if (g.NavMousePosDirty && g.NavIdIsAlive)\r\n    {\r\n        // Set mouse position given our knowledge of the navigated item position from last frame\r\n        if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))\r\n        {\r\n            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)\r\n            {\r\n                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();\r\n                g.IO.WantSetMousePos = true;\r\n            }\r\n        }\r\n        g.NavMousePosDirty = false;\r\n    }\r\n    g.NavIdIsAlive = false;\r\n    g.NavJustTabbedId = 0;\r\n    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);\r\n\r\n    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0\r\n    if (g.NavWindow)\r\n        NavSaveLastChildNavWindow(g.NavWindow);\r\n    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)\r\n        g.NavWindow->NavLastChildNavWindow = NULL;\r\n\r\n    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)\r\n    NavUpdateWindowing();\r\n\r\n    // Set output flags for user application\r\n    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);\r\n    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL) || g.NavInitRequest;\r\n\r\n    // Process NavCancel input (to close a popup, get back to parent, clear focus)\r\n    if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))\r\n    {\r\n        if (g.ActiveId != 0)\r\n        {\r\n            ClearActiveID();\r\n        }\r\n        else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)\r\n        {\r\n            // Exit child window\r\n            ImGuiWindow* child_window = g.NavWindow;\r\n            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;\r\n            IM_ASSERT(child_window->ChildId != 0);\r\n            FocusWindow(parent_window);\r\n            SetNavID(child_window->ChildId, 0);\r\n            g.NavIdIsAlive = false;\r\n            if (g.NavDisableMouseHover)\r\n                g.NavMousePosDirty = true;\r\n        }\r\n        else if (g.OpenPopupStack.Size > 0)\r\n        {\r\n            // Close open popup/menu\r\n            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))\r\n                ClosePopupToLevel(g.OpenPopupStack.Size - 1);\r\n        }\r\n        else if (g.NavLayer != 0)\r\n        {\r\n            // Leave the \"menu\" layer\r\n            NavRestoreLayer(0);\r\n        }\r\n        else\r\n        {\r\n            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were\r\n            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))\r\n                g.NavWindow->NavLastIds[0] = 0;\r\n            g.NavId = 0;\r\n        }\r\n    }\r\n\r\n    // Process manual activation request\r\n    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;\r\n    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))\r\n    {\r\n        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);\r\n        bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);\r\n        if (g.ActiveId == 0 && activate_pressed)\r\n            g.NavActivateId = g.NavId;\r\n        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)\r\n            g.NavActivateDownId = g.NavId;\r\n        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)\r\n            g.NavActivatePressedId = g.NavId;\r\n        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))\r\n            g.NavInputId = g.NavId;\r\n    }\r\n    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))\r\n        g.NavDisableHighlight = true;\r\n    if (g.NavActivateId != 0)\r\n        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);\r\n    g.NavMoveRequest = false;\r\n\r\n    // Process programmatic activation request\r\n    if (g.NavNextActivateId != 0)\r\n        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;\r\n    g.NavNextActivateId = 0;\r\n\r\n    // Initiate directional inputs request\r\n    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;\r\n    if (g.NavMoveRequestForward == ImGuiNavForward_None)\r\n    {\r\n        g.NavMoveDir = ImGuiDir_None;\r\n        g.NavMoveRequestFlags = 0;\r\n        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))\r\n        {\r\n            if ((allowed_dir_flags & (1<<ImGuiDir_Left))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;\r\n            if ((allowed_dir_flags & (1<<ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight,ImGuiNavInput_KeyRight_,ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;\r\n            if ((allowed_dir_flags & (1<<ImGuiDir_Up))    && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp,   ImGuiNavInput_KeyUp_,   ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;\r\n            if ((allowed_dir_flags & (1<<ImGuiDir_Down))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;\r\n        }\r\n        g.NavMoveClipDir = g.NavMoveDir;\r\n    }\r\n    else\r\n    {\r\n        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)\r\n        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)\r\n        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);\r\n        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);\r\n        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;\r\n    }\r\n\r\n    // Update PageUp/PageDown scroll\r\n    float nav_scoring_rect_offset_y = 0.0f;\r\n    if (nav_keyboard_active)\r\n        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);\r\n\r\n    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match\r\n    if (g.NavMoveDir != ImGuiDir_None)\r\n    {\r\n        g.NavMoveRequest = true;\r\n        g.NavMoveDirLast = g.NavMoveDir;\r\n    }\r\n    if (g.NavMoveRequest && g.NavId == 0)\r\n    {\r\n        g.NavInitRequest = g.NavInitRequestFromMove = true;\r\n        g.NavInitResultId = 0;\r\n        g.NavDisableHighlight = false;\r\n    }\r\n    NavUpdateAnyRequestFlag();\r\n\r\n    // Scrolling\r\n    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)\r\n    {\r\n        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item\r\n        ImGuiWindow* window = g.NavWindow;\r\n        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.\r\n        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)\r\n        {\r\n            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)\r\n                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));\r\n            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)\r\n                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));\r\n        }\r\n\r\n        // *Normal* Manual scroll with NavScrollXXX keys\r\n        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.\r\n        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f/10.0f, 10.0f);\r\n        if (scroll_dir.x != 0.0f && window->ScrollbarX)\r\n        {\r\n            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));\r\n            g.NavMoveFromClampedRefRect = true;\r\n        }\r\n        if (scroll_dir.y != 0.0f)\r\n        {\r\n            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));\r\n            g.NavMoveFromClampedRefRect = true;\r\n        }\r\n    }\r\n\r\n    // Reset search results\r\n    g.NavMoveResultLocal.Clear();\r\n    g.NavMoveResultLocalVisibleSet.Clear();\r\n    g.NavMoveResultOther.Clear();\r\n\r\n    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items\r\n    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)\r\n    {\r\n        ImGuiWindow* window = g.NavWindow;\r\n        ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1,1), window->InnerMainRect.Max - window->Pos + ImVec2(1,1));\r\n        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))\r\n        {\r\n            float pad = window->CalcFontSize() * 0.5f;\r\n            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item\r\n            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);\r\n            g.NavId = 0;\r\n        }\r\n        g.NavMoveFromClampedRefRect = false;\r\n    }\r\n\r\n    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)\r\n    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0,0,0,0);\r\n    g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();\r\n    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);\r\n    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);\r\n    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;\r\n    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().\r\n    //g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]\r\n    g.NavScoringCount = 0;\r\n#if IMGUI_DEBUG_NAV_RECTS\r\n    if (g.NavWindow) { for (int layer = 0; layer < 2; layer++) GetOverlayDrawList(g.NavWindow)->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG]\r\n    if (g.NavWindow) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, \"%d\", g.NavLayer); GetOverlayDrawList(g.NavWindow)->AddCircleFilled(p, 3.0f, col); GetOverlayDrawList(g.NavWindow)->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }\r\n#endif\r\n}\r\n\r\n// Apply result from previous frame navigation directional move request\r\nstatic void ImGui::NavUpdateMoveResult()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)\r\n    {\r\n        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)\r\n        if (g.NavId != 0)\r\n        {\r\n            g.NavDisableHighlight = false;\r\n            g.NavDisableMouseHover = true;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Select which result to use\r\n    ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;\r\n\r\n    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.\r\n    if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)\r\n        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)\r\n            result = &g.NavMoveResultLocalVisibleSet;\r\n\r\n    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.\r\n    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)\r\n        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))\r\n            result = &g.NavMoveResultOther;\r\n    IM_ASSERT(g.NavWindow && result->Window);\r\n\r\n    // Scroll to keep newly navigated item fully into view.\r\n    if (g.NavLayer == 0)\r\n    {\r\n        ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);\r\n        NavScrollToBringItemIntoView(result->Window, rect_abs);\r\n\r\n        // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()\r\n        ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);\r\n        ImVec2 delta_scroll = result->Window->Scroll - next_scroll;\r\n        result->RectRel.Translate(delta_scroll);\r\n\r\n        // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).\r\n        if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)\r\n            NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));\r\n    }\r\n\r\n    ClearActiveID();\r\n    g.NavWindow = result->Window;\r\n    SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);\r\n    g.NavJustMovedToId = result->ID;\r\n    g.NavMoveFromClampedRefRect = false;\r\n}\r\n\r\nstatic float ImGui::NavUpdatePageUpPageDown(int allowed_dir_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)\r\n    {\r\n        ImGuiWindow* window = g.NavWindow;\r\n        bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));\r\n        bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));\r\n        if ((page_up_held && !page_down_held) || (page_down_held && !page_up_held))\r\n        {\r\n            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)\r\n            {\r\n                // Fallback manual-scroll when window has no navigable item\r\n                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))\r\n                    SetWindowScrollY(window, window->Scroll.y - window->InnerClipRect.GetHeight());\r\n                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))\r\n                    SetWindowScrollY(window, window->Scroll.y + window->InnerClipRect.GetHeight());\r\n            }\r\n            else\r\n            {\r\n                const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];\r\n                const float page_offset_y = ImMax(0.0f, window->InnerClipRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());\r\n                float nav_scoring_rect_offset_y = 0.0f;\r\n                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))\r\n                {\r\n                    nav_scoring_rect_offset_y = -page_offset_y;\r\n                    g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)\r\n                    g.NavMoveClipDir = ImGuiDir_Up;\r\n                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;\r\n                }\r\n                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))\r\n                {\r\n                    nav_scoring_rect_offset_y = +page_offset_y;\r\n                    g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)\r\n                    g.NavMoveClipDir = ImGuiDir_Down;\r\n                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;\r\n                }\r\n                return nav_scoring_rect_offset_y;\r\n            }\r\n        }\r\n    }\r\n    return 0.0f;\r\n}\r\n\r\nstatic int FindWindowFocusIndex(ImGuiWindow* window) // FIXME-OPT O(N)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = g.WindowsFocusOrder.Size-1; i >= 0; i--)\r\n        if (g.WindowsFocusOrder[i] == window)\r\n            return i;\r\n    return -1;\r\n}\r\n\r\nstatic ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)\r\n        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))\r\n            return g.WindowsFocusOrder[i];\r\n    return NULL;\r\n}\r\n\r\nstatic void NavUpdateWindowingHighlightWindow(int focus_change_dir)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.NavWindowingTarget);\r\n    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)\r\n        return;\r\n\r\n    const int i_current = FindWindowFocusIndex(g.NavWindowingTarget);\r\n    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);\r\n    if (!window_target)\r\n        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);\r\n    if (window_target) // Don't reset windowing target if there's a single window in the list\r\n        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;\r\n    g.NavWindowingToggleLayer = false;\r\n}\r\n\r\n// Window management mode (hold to: change focus/move/resize, tap to: toggle menu layer)\r\nstatic void ImGui::NavUpdateWindowing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* apply_focus_window = NULL;\r\n    bool apply_toggle_layer = false;\r\n\r\n    ImGuiWindow* modal_window = GetFrontMostPopupModal();\r\n    if (modal_window != NULL)\r\n    {\r\n        g.NavWindowingTarget = NULL;\r\n        return;\r\n    }\r\n\r\n    // Fade out\r\n    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)\r\n    {\r\n        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);\r\n        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)\r\n            g.NavWindowingTargetAnim = NULL;\r\n    }\r\n\r\n    // Start CTRL-TAB or Square+L/R window selection\r\n    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);\r\n    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);\r\n    if (start_windowing_with_gamepad || start_windowing_with_keyboard)\r\n        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))\r\n        {\r\n            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;\r\n            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;\r\n            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;\r\n            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;\r\n        }\r\n\r\n    // Gamepad update\r\n    g.NavWindowingTimer += g.IO.DeltaTime;\r\n    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)\r\n    {\r\n        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise\r\n        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));\r\n\r\n        // Select window to focus\r\n        const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);\r\n        if (focus_change_dir != 0)\r\n        {\r\n            NavUpdateWindowingHighlightWindow(focus_change_dir);\r\n            g.NavWindowingHighlightAlpha = 1.0f;\r\n        }\r\n\r\n        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)\r\n        if (!IsNavInputDown(ImGuiNavInput_Menu))\r\n        {\r\n            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.\r\n            if (g.NavWindowingToggleLayer && g.NavWindow)\r\n                apply_toggle_layer = true;\r\n            else if (!g.NavWindowingToggleLayer)\r\n                apply_focus_window = g.NavWindowingTarget;\r\n            g.NavWindowingTarget = NULL;\r\n        }\r\n    }\r\n\r\n    // Keyboard: Focus\r\n    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)\r\n    {\r\n        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise\r\n        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f\r\n        if (IsKeyPressedMap(ImGuiKey_Tab, true))\r\n            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);\r\n        if (!g.IO.KeyCtrl)\r\n            apply_focus_window = g.NavWindowingTarget;\r\n    }\r\n\r\n    // Keyboard: Press and Release ALT to toggle menu layer\r\n    // FIXME: We lack an explicit IO variable for \"is the imgui window focused\", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB\r\n    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))\r\n        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))\r\n            apply_toggle_layer = true;\r\n\r\n    // Move window\r\n    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))\r\n    {\r\n        ImVec2 move_delta;\r\n        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)\r\n            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);\r\n        if (g.NavInputSource == ImGuiInputSource_NavGamepad)\r\n            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);\r\n        if (move_delta.x != 0.0f || move_delta.y != 0.0f)\r\n        {\r\n            const float NAV_MOVE_SPEED = 800.0f;\r\n            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well\r\n            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;\r\n            g.NavDisableMouseHover = true;\r\n            MarkIniSettingsDirty(g.NavWindowingTarget);\r\n        }\r\n    }\r\n\r\n    // Apply final focus\r\n    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))\r\n    {\r\n        g.NavDisableHighlight = false;\r\n        g.NavDisableMouseHover = true;\r\n        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);\r\n        ClosePopupsOverWindow(apply_focus_window);\r\n        FocusWindow(apply_focus_window);\r\n        if (apply_focus_window->NavLastIds[0] == 0)\r\n            NavInitWindow(apply_focus_window, false);\r\n\r\n        // If the window only has a menu layer, select it directly\r\n        if (apply_focus_window->DC.NavLayerActiveMask == (1 << 1))\r\n            g.NavLayer = 1;\r\n    }\r\n    if (apply_focus_window)\r\n        g.NavWindowingTarget = NULL;\r\n\r\n    // Apply menu/layer toggle\r\n    if (apply_toggle_layer && g.NavWindow)\r\n    {\r\n        // Move to parent menu if necessary\r\n        ImGuiWindow* new_nav_window = g.NavWindow;\r\n        while ((new_nav_window->DC.NavLayerActiveMask & (1 << 1)) == 0 && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)\r\n            new_nav_window = new_nav_window->ParentWindow;\r\n        if (new_nav_window != g.NavWindow)\r\n        {\r\n            ImGuiWindow* old_nav_window = g.NavWindow;\r\n            FocusWindow(new_nav_window);\r\n            new_nav_window->NavLastChildNavWindow = old_nav_window;\r\n        }\r\n        g.NavDisableHighlight = false;\r\n        g.NavDisableMouseHover = true;\r\n        NavRestoreLayer((g.NavWindow->DC.NavLayerActiveMask & (1 << 1)) ? (g.NavLayer ^ 1) : 0);\r\n    }\r\n}\r\n\r\n// Window has already passed the IsWindowNavFocusable()\r\nstatic const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)\r\n{\r\n    if (window->Flags & ImGuiWindowFlags_Popup)\r\n        return \"(Popup)\";\r\n    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, \"##MainMenuBar\") == 0)\r\n        return \"(Main menu bar)\";\r\n    return \"(Untitled)\";\r\n}\r\n\r\n// Overlay displayed when using CTRL+TAB. Called by EndFrame().\r\nvoid ImGui::NavUpdateWindowingList()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.NavWindowingTarget != NULL);\r\n\r\n    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)\r\n        return;\r\n\r\n    if (g.NavWindowingList == NULL)\r\n        g.NavWindowingList = FindWindowByName(\"###NavWindowingList\");\r\n    SetNextWindowSizeConstraints(ImVec2(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));\r\n    SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2(0.5f, 0.5f));\r\n    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);\r\n    Begin(\"###NavWindowingList\", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);\r\n    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)\r\n    {\r\n        ImGuiWindow* window = g.WindowsFocusOrder[n];\r\n        if (!IsWindowNavFocusable(window))\r\n            continue;\r\n        const char* label = window->Name;\r\n        if (label == FindRenderedTextEnd(label))\r\n            label = GetFallbackWindowNameForWindowingList(window);\r\n        Selectable(label, g.NavWindowingTarget == window);\r\n    }\r\n    End();\r\n    PopStyleVar();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] COLUMNS\r\n// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::NextColumn()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems || window->DC.ColumnsSet == NULL)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    PopItemWidth();\r\n    PopClipRect();\r\n\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);\r\n    if (++columns->Current < columns->Count)\r\n    {\r\n        // Columns 1+ cancel out IndentX\r\n        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;\r\n        window->DrawList->ChannelsSetCurrent(columns->Current);\r\n    }\r\n    else\r\n    {\r\n        window->DC.ColumnsOffset.x = 0.0f;\r\n        window->DrawList->ChannelsSetCurrent(0);\r\n        columns->Current = 0;\r\n        columns->LineMinY = columns->LineMaxY;\r\n    }\r\n    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\r\n    window->DC.CursorPos.y = columns->LineMinY;\r\n    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);\r\n    window->DC.CurrentLineTextBaseOffset = 0.0f;\r\n\r\n    PushColumnClipRect();\r\n    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup\r\n}\r\n\r\nint ImGui::GetColumnIndex()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;\r\n}\r\n\r\nint ImGui::GetColumnsCount()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;\r\n}\r\n\r\nstatic float OffsetNormToPixels(const ImGuiColumnsSet* columns, float offset_norm)\r\n{\r\n    return offset_norm * (columns->MaxX - columns->MinX);\r\n}\r\n\r\nstatic float PixelsToOffsetNorm(const ImGuiColumnsSet* columns, float offset)\r\n{\r\n    return offset / (columns->MaxX - columns->MinX);\r\n}\r\n\r\nstatic inline float GetColumnsRectHalfWidth() { return 4.0f; }\r\n\r\nstatic float GetDraggedColumnOffset(ImGuiColumnsSet* columns, int column_index)\r\n{\r\n    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing\r\n    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.\r\n    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));\r\n\r\n    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;\r\n    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);\r\n    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))\r\n        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);\r\n\r\n    return x;\r\n}\r\n\r\nfloat ImGui::GetColumnOffset(int column_index)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    IM_ASSERT(column_index < columns->Columns.Size);\r\n\r\n    const float t = columns->Columns[column_index].OffsetNorm;\r\n    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);\r\n    return x_offset;\r\n}\r\n\r\nstatic float GetColumnWidthEx(ImGuiColumnsSet* columns, int column_index, bool before_resize = false)\r\n{\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n\r\n    float offset_norm;\r\n    if (before_resize)\r\n        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;\r\n    else\r\n        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;\r\n    return OffsetNormToPixels(columns, offset_norm);\r\n}\r\n\r\nfloat ImGui::GetColumnWidth(int column_index)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);\r\n}\r\n\r\nvoid ImGui::SetColumnOffset(int column_index, float offset)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    IM_ASSERT(column_index < columns->Columns.Size);\r\n\r\n    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);\r\n    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;\r\n\r\n    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))\r\n        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));\r\n    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);\r\n\r\n    if (preserve_width)\r\n        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));\r\n}\r\n\r\nvoid ImGui::SetColumnWidth(int column_index, float width)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);\r\n}\r\n\r\nvoid ImGui::PushColumnClipRect(int column_index)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n\r\n    PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);\r\n}\r\n\r\nstatic ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow* window, ImGuiID id)\r\n{\r\n    for (int n = 0; n < window->ColumnsStorage.Size; n++)\r\n        if (window->ColumnsStorage[n].ID == id)\r\n            return &window->ColumnsStorage[n];\r\n\r\n    window->ColumnsStorage.push_back(ImGuiColumnsSet());\r\n    ImGuiColumnsSet* columns = &window->ColumnsStorage.back();\r\n    columns->ID = id;\r\n    return columns;\r\n}\r\n\r\nvoid ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    IM_ASSERT(columns_count > 1);\r\n    IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported\r\n\r\n    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.\r\n    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.\r\n    PushID(0x11223347 + (str_id ? 0 : columns_count));\r\n    ImGuiID id = window->GetID(str_id ? str_id : \"columns\");\r\n    PopID();\r\n\r\n    // Acquire storage for the columns set\r\n    ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);\r\n    IM_ASSERT(columns->ID == id);\r\n    columns->Current = 0;\r\n    columns->Count = columns_count;\r\n    columns->Flags = flags;\r\n    window->DC.ColumnsSet = columns;\r\n\r\n    // Set state for first column\r\n    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);\r\n    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range\r\n    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);\r\n    columns->StartPosY = window->DC.CursorPos.y;\r\n    columns->StartMaxPosX = window->DC.CursorMaxPos.x;\r\n    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;\r\n    window->DC.ColumnsOffset.x = 0.0f;\r\n    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\r\n\r\n    // Clear data if columns count changed\r\n    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)\r\n        columns->Columns.resize(0);\r\n\r\n    // Initialize defaults\r\n    columns->IsFirstFrame = (columns->Columns.Size == 0);\r\n    if (columns->Columns.Size == 0)\r\n    {\r\n        columns->Columns.reserve(columns_count + 1);\r\n        for (int n = 0; n < columns_count + 1; n++)\r\n        {\r\n            ImGuiColumnData column;\r\n            column.OffsetNorm = n / (float)columns_count;\r\n            columns->Columns.push_back(column);\r\n        }\r\n    }\r\n\r\n    for (int n = 0; n < columns_count; n++)\r\n    {\r\n        // Compute clipping rectangle\r\n        ImGuiColumnData* column = &columns->Columns[n];\r\n        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);\r\n        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);\r\n        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);\r\n        column->ClipRect.ClipWith(window->ClipRect);\r\n    }\r\n\r\n    window->DrawList->ChannelsSplit(columns->Count);\r\n    PushColumnClipRect();\r\n    PushItemWidth(GetColumnWidth() * 0.65f);\r\n}\r\n\r\nvoid ImGui::EndColumns()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    PopItemWidth();\r\n    PopClipRect();\r\n    window->DrawList->ChannelsMerge();\r\n\r\n    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);\r\n    window->DC.CursorPos.y = columns->LineMaxY;\r\n    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))\r\n        window->DC.CursorMaxPos.x = columns->StartMaxPosX;  // Restore cursor max pos, as columns don't grow parent\r\n\r\n    // Draw columns borders and handle resize\r\n    bool is_being_resized = false;\r\n    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)\r\n    {\r\n        const float y1 = columns->StartPosY;\r\n        const float y2 = window->DC.CursorPos.y;\r\n        int dragging_column = -1;\r\n        for (int n = 1; n < columns->Count; n++)\r\n        {\r\n            float x = window->Pos.x + GetColumnOffset(n);\r\n            const ImGuiID column_id = columns->ID + ImGuiID(n);\r\n            const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction\r\n            const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));\r\n            KeepAliveID(column_id);\r\n            if (IsClippedEx(column_rect, column_id, false))\r\n                continue;\r\n\r\n            bool hovered = false, held = false;\r\n            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))\r\n            {\r\n                ButtonBehavior(column_rect, column_id, &hovered, &held);\r\n                if (hovered || held)\r\n                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;\r\n                if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))\r\n                    dragging_column = n;\r\n            }\r\n\r\n            // Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)\r\n            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);\r\n            const float xi = (float)(int)x;\r\n            window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);\r\n        }\r\n\r\n        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.\r\n        if (dragging_column != -1)\r\n        {\r\n            if (!columns->IsBeingResized)\r\n                for (int n = 0; n < columns->Count + 1; n++)\r\n                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;\r\n            columns->IsBeingResized = is_being_resized = true;\r\n            float x = GetDraggedColumnOffset(columns, dragging_column);\r\n            SetColumnOffset(dragging_column, x);\r\n        }\r\n    }\r\n    columns->IsBeingResized = is_being_resized;\r\n\r\n    window->DC.ColumnsSet = NULL;\r\n    window->DC.ColumnsOffset.x = 0.0f;\r\n    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);\r\n}\r\n\r\n// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]\r\nvoid ImGui::Columns(int columns_count, const char* id, bool border)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    IM_ASSERT(columns_count >= 1);\r\n\r\n    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);\r\n    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior\r\n    if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count == columns_count && window->DC.ColumnsSet->Flags == flags)\r\n        return;\r\n\r\n    if (window->DC.ColumnsSet != NULL)\r\n        EndColumns();\r\n\r\n    if (columns_count != 1)\r\n        BeginColumns(id, columns_count, flags);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] DRAG AND DROP\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::ClearDragDrop()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.DragDropActive = false;\r\n    g.DragDropPayload.Clear();\r\n    g.DragDropAcceptFlags = 0;\r\n    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;\r\n    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;\r\n    g.DragDropAcceptFrameCount = -1;\r\n\r\n    g.DragDropPayloadBufHeap.clear();\r\n    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));\r\n}\r\n\r\n// Call when current ID is active.\r\n// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()\r\nbool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    bool source_drag_active = false;\r\n    ImGuiID source_id = 0;\r\n    ImGuiID source_parent_id = 0;\r\n    int mouse_button = 0;\r\n    if (!(flags & ImGuiDragDropFlags_SourceExtern))\r\n    {\r\n        source_id = window->DC.LastItemId;\r\n        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case\r\n            return false;\r\n        if (g.IO.MouseDown[mouse_button] == false)\r\n            return false;\r\n\r\n        if (source_id == 0)\r\n        {\r\n            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:\r\n            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.\r\n            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))\r\n            {\r\n                IM_ASSERT(0);\r\n                return false;\r\n            }\r\n\r\n            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()\r\n            // We build a throwaway ID based on current ID stack + relative AABB of items in window.\r\n            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.\r\n            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.\r\n            bool is_hovered = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) != 0;\r\n            if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))\r\n                return false;\r\n            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);\r\n            if (is_hovered)\r\n                SetHoveredID(source_id);\r\n            if (is_hovered && g.IO.MouseClicked[mouse_button])\r\n            {\r\n                SetActiveID(source_id, window);\r\n                FocusWindow(window);\r\n            }\r\n            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.\r\n                g.ActiveIdAllowOverlap = is_hovered;\r\n        }\r\n        else\r\n        {\r\n            g.ActiveIdAllowOverlap = false;\r\n        }\r\n        if (g.ActiveId != source_id)\r\n            return false;\r\n        source_parent_id = window->IDStack.back();\r\n        source_drag_active = IsMouseDragging(mouse_button);\r\n    }\r\n    else\r\n    {\r\n        window = NULL;\r\n        source_id = ImHash(\"#SourceExtern\", 0);\r\n        source_drag_active = true;\r\n    }\r\n\r\n    if (source_drag_active)\r\n    {\r\n        if (!g.DragDropActive)\r\n        {\r\n            IM_ASSERT(source_id != 0);\r\n            ClearDragDrop();\r\n            ImGuiPayload& payload = g.DragDropPayload;\r\n            payload.SourceId = source_id;\r\n            payload.SourceParentId = source_parent_id;\r\n            g.DragDropActive = true;\r\n            g.DragDropSourceFlags = flags;\r\n            g.DragDropMouseButton = mouse_button;\r\n        }\r\n        g.DragDropSourceFrameCount = g.FrameCount;\r\n        g.DragDropWithinSourceOrTarget = true;\r\n\r\n        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))\r\n        {\r\n            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)\r\n            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents. \r\n            BeginTooltip();\r\n            if (g.DragDropActive && g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))\r\n            {\r\n                ImGuiWindow* tooltip_window = g.CurrentWindow;\r\n                tooltip_window->SkipItems = true;\r\n                tooltip_window->HiddenFramesRegular = 1;\r\n            }\r\n        }\r\n\r\n        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))\r\n            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid ImGui::EndDragDropSource()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.DragDropActive);\r\n    IM_ASSERT(g.DragDropWithinSourceOrTarget && \"Not after a BeginDragDropSource()?\");\r\n\r\n    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))\r\n        EndTooltip();\r\n\r\n    // Discard the drag if have not called SetDragDropPayload()\r\n    if (g.DragDropPayload.DataFrameCount == -1)\r\n        ClearDragDrop();\r\n    g.DragDropWithinSourceOrTarget = false;\r\n}\r\n\r\n// Use 'cond' to choose to submit payload on drag start or every frame\r\nbool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiPayload& payload = g.DragDropPayload;\r\n    if (cond == 0)\r\n        cond = ImGuiCond_Always;\r\n\r\n    IM_ASSERT(type != NULL);\r\n    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && \"Payload type can be at most 32 characters long\");\r\n    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));\r\n    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);\r\n    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()\r\n\r\n    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)\r\n    {\r\n        // Copy payload\r\n        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));\r\n        g.DragDropPayloadBufHeap.resize(0);\r\n        if (data_size > sizeof(g.DragDropPayloadBufLocal))\r\n        {\r\n            // Store in heap\r\n            g.DragDropPayloadBufHeap.resize((int)data_size);\r\n            payload.Data = g.DragDropPayloadBufHeap.Data;\r\n            memcpy(payload.Data, data, data_size);\r\n        }\r\n        else if (data_size > 0)\r\n        {\r\n            // Store locally\r\n            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));\r\n            payload.Data = g.DragDropPayloadBufLocal;\r\n            memcpy(payload.Data, data, data_size);\r\n        }\r\n        else\r\n        {\r\n            payload.Data = NULL;\r\n        }\r\n        payload.DataSize = (int)data_size;\r\n    }\r\n    payload.DataFrameCount = g.FrameCount;\r\n\r\n    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);\r\n}\r\n\r\nbool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.DragDropActive)\r\n        return false;\r\n\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)\r\n        return false;\r\n    IM_ASSERT(id != 0);\r\n    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))\r\n        return false;\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);\r\n    g.DragDropTargetRect = bb;\r\n    g.DragDropTargetId = id;\r\n    g.DragDropWithinSourceOrTarget = true;\r\n    return true;\r\n}\r\n\r\n// We don't use BeginDragDropTargetCustom() and duplicate its code because:\r\n// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.\r\n// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.\r\n// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)\r\nbool ImGui::BeginDragDropTarget()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.DragDropActive)\r\n        return false;\r\n\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))\r\n        return false;\r\n    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)\r\n        return false;\r\n\r\n    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;\r\n    ImGuiID id = window->DC.LastItemId;\r\n    if (id == 0)\r\n        id = window->GetIDFromRectangle(display_rect);\r\n    if (g.DragDropPayload.SourceId == id)\r\n        return false;\r\n\r\n    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);\r\n    g.DragDropTargetRect = display_rect;\r\n    g.DragDropTargetId = id;\r\n    g.DragDropWithinSourceOrTarget = true;\r\n    return true;\r\n}\r\n\r\nbool ImGui::IsDragDropPayloadBeingAccepted()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;\r\n}\r\n\r\nconst ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    ImGuiPayload& payload = g.DragDropPayload;\r\n    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?\r\n    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?\r\n    if (type != NULL && !payload.IsDataType(type))\r\n        return NULL;\r\n\r\n    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.\r\n    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!\r\n    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);\r\n    ImRect r = g.DragDropTargetRect;\r\n    float r_surface = r.GetWidth() * r.GetHeight();\r\n    if (r_surface < g.DragDropAcceptIdCurrRectSurface)\r\n    {\r\n        g.DragDropAcceptFlags = flags;\r\n        g.DragDropAcceptIdCurr = g.DragDropTargetId;\r\n        g.DragDropAcceptIdCurrRectSurface = r_surface;\r\n    }\r\n\r\n    // Render default drop visuals\r\n    payload.Preview = was_accepted_previously;\r\n    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)\r\n    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)\r\n    {\r\n        // FIXME-DRAG: Settle on a proper default visuals for drop target.\r\n        r.Expand(3.5f);\r\n        bool push_clip_rect = !window->ClipRect.Contains(r);\r\n        if (push_clip_rect) window->DrawList->PushClipRect(r.Min-ImVec2(1,1), r.Max+ImVec2(1,1));\r\n        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);\r\n        if (push_clip_rect) window->DrawList->PopClipRect();\r\n    }\r\n\r\n    g.DragDropAcceptFrameCount = g.FrameCount;\r\n    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()\r\n    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))\r\n        return NULL;\r\n\r\n    return &payload;\r\n}\r\n\r\nconst ImGuiPayload* ImGui::GetDragDropPayload()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.DragDropActive ? &g.DragDropPayload : NULL;\r\n}\r\n\r\n// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.\r\nvoid ImGui::EndDragDropTarget()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.DragDropActive);\r\n    IM_ASSERT(g.DragDropWithinSourceOrTarget);\r\n    g.DragDropWithinSourceOrTarget = false;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] LOGGING/CAPTURING\r\n//-----------------------------------------------------------------------------\r\n\r\n// Pass text data straight to log (without being displayed)\r\nvoid ImGui::LogText(const char* fmt, ...)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.LogEnabled)\r\n        return;\r\n\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    if (g.LogFile)\r\n        vfprintf(g.LogFile, fmt, args);\r\n    else\r\n        g.LogClipboard.appendfv(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\n// Internal version that takes a position to decide on newline placement and pad items according to their depth.\r\n// We split text into individual lines to add current tree level padding\r\nvoid ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (!text_end)\r\n        text_end = FindRenderedTextEnd(text, text_end);\r\n\r\n    const bool log_new_line = ref_pos && (ref_pos->y > window->DC.LogLinePosY + 1);\r\n    if (ref_pos)\r\n        window->DC.LogLinePosY = ref_pos->y;\r\n\r\n    const char* text_remaining = text;\r\n    if (g.LogStartDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth\r\n        g.LogStartDepth = window->DC.TreeDepth;\r\n    const int tree_depth = (window->DC.TreeDepth - g.LogStartDepth);\r\n    for (;;)\r\n    {\r\n        // Split the string. Each new line (after a '\\n') is followed by spacing corresponding to the current depth of our log entry.\r\n        const char* line_start = text_remaining;\r\n        const char* line_end = ImStreolRange(line_start, text_end);\r\n        const bool is_first_line = (line_start == text);\r\n        const bool is_last_line = (line_end == text_end);\r\n        if (!is_last_line || (line_start != line_end))\r\n        {\r\n            const int char_count = (int)(line_end - line_start);\r\n            if (log_new_line || !is_first_line)\r\n                LogText(IM_NEWLINE \"%*s%.*s\", tree_depth*4, \"\", char_count, line_start);\r\n            else\r\n                LogText(\" %.*s\", char_count, line_start);\r\n        }\r\n\r\n        if (is_last_line)\r\n            break;\r\n        text_remaining = line_end + 1;\r\n    }\r\n}\r\n\r\n// Start logging ImGui output to TTY\r\nvoid ImGui::LogToTTY(int max_depth)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.LogEnabled)\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    IM_ASSERT(g.LogFile == NULL);\r\n    g.LogFile = stdout;\r\n    g.LogEnabled = true;\r\n    g.LogStartDepth = window->DC.TreeDepth;\r\n    if (max_depth >= 0)\r\n        g.LogAutoExpandMaxDepth = max_depth;\r\n}\r\n\r\n// Start logging ImGui output to given file\r\nvoid ImGui::LogToFile(int max_depth, const char* filename)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.LogEnabled)\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (!filename)\r\n    {\r\n        filename = g.IO.LogFilename;\r\n        if (!filename)\r\n            return;\r\n    }\r\n\r\n    IM_ASSERT(g.LogFile == NULL);\r\n    g.LogFile = ImFileOpen(filename, \"ab\");\r\n    if (!g.LogFile)\r\n    {\r\n        IM_ASSERT(g.LogFile != NULL); // Consider this an error\r\n        return;\r\n    }\r\n    g.LogEnabled = true;\r\n    g.LogStartDepth = window->DC.TreeDepth;\r\n    if (max_depth >= 0)\r\n        g.LogAutoExpandMaxDepth = max_depth;\r\n}\r\n\r\n// Start logging ImGui output to clipboard\r\nvoid ImGui::LogToClipboard(int max_depth)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.LogEnabled)\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    IM_ASSERT(g.LogFile == NULL);\r\n    g.LogFile = NULL;\r\n    g.LogEnabled = true;\r\n    g.LogStartDepth = window->DC.TreeDepth;\r\n    if (max_depth >= 0)\r\n        g.LogAutoExpandMaxDepth = max_depth;\r\n}\r\n\r\nvoid ImGui::LogFinish()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.LogEnabled)\r\n        return;\r\n\r\n    LogText(IM_NEWLINE);\r\n    if (g.LogFile != NULL)\r\n    {\r\n        if (g.LogFile == stdout)\r\n            fflush(g.LogFile);\r\n        else\r\n            fclose(g.LogFile);\r\n        g.LogFile = NULL;\r\n    }\r\n    if (g.LogClipboard.size() > 1)\r\n    {\r\n        SetClipboardText(g.LogClipboard.begin());\r\n        g.LogClipboard.clear();\r\n    }\r\n    g.LogEnabled = false;\r\n}\r\n\r\n// Helper to display logging buttons\r\nvoid ImGui::LogButtons()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    PushID(\"LogButtons\");\r\n    const bool log_to_tty = Button(\"Log To TTY\"); SameLine();\r\n    const bool log_to_file = Button(\"Log To File\"); SameLine();\r\n    const bool log_to_clipboard = Button(\"Log To Clipboard\"); SameLine();\r\n    PushItemWidth(80.0f);\r\n    PushAllowKeyboardFocus(false);\r\n    SliderInt(\"Depth\", &g.LogAutoExpandMaxDepth, 0, 9, NULL);\r\n    PopAllowKeyboardFocus();\r\n    PopItemWidth();\r\n    PopID();\r\n\r\n    // Start logging at the end of the function so that the buttons don't appear in the log\r\n    if (log_to_tty)\r\n        LogToTTY(g.LogAutoExpandMaxDepth);\r\n    if (log_to_file)\r\n        LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);\r\n    if (log_to_clipboard)\r\n        LogToClipboard(g.LogAutoExpandMaxDepth);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] SETTINGS\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::MarkIniSettingsDirty()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.SettingsDirtyTimer <= 0.0f)\r\n        g.SettingsDirtyTimer = g.IO.IniSavingRate;\r\n}\r\n\r\nvoid ImGui::MarkIniSettingsDirty(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))\r\n        if (g.SettingsDirtyTimer <= 0.0f)\r\n            g.SettingsDirtyTimer = g.IO.IniSavingRate;\r\n}\r\n\r\nImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SettingsWindows.push_back(ImGuiWindowSettings());\r\n    ImGuiWindowSettings* settings = &g.SettingsWindows.back();\r\n    settings->Name = ImStrdup(name);\r\n    settings->ID = ImHash(name, 0);\r\n    return settings;\r\n}\r\n\r\nImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = 0; i != g.SettingsWindows.Size; i++)\r\n        if (g.SettingsWindows[i].ID == id)\r\n            return &g.SettingsWindows[i];\r\n    return NULL;\r\n}\r\n\r\nvoid ImGui::LoadIniSettingsFromDisk(const char* ini_filename)\r\n{\r\n    size_t file_data_size = 0;\r\n    char* file_data = (char*)ImFileLoadToMemory(ini_filename, \"rb\", &file_data_size);\r\n    if (!file_data)\r\n        return;\r\n    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);\r\n    ImGui::MemFree(file_data);\r\n}\r\n\r\nImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiID type_hash = ImHash(type_name, 0, 0);\r\n    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)\r\n        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)\r\n            return &g.SettingsHandlers[handler_n];\r\n    return NULL;\r\n}\r\n\r\n// Zero-tolerance, no error reporting, cheap .ini parsing\r\nvoid ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.Initialized);\r\n    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);\r\n\r\n    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).\r\n    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..\r\n    if (ini_size == 0)\r\n        ini_size = strlen(ini_data);\r\n    char* buf = (char*)ImGui::MemAlloc(ini_size + 1);\r\n    char* buf_end = buf + ini_size;\r\n    memcpy(buf, ini_data, ini_size);\r\n    buf[ini_size] = 0;\r\n\r\n    void* entry_data = NULL;\r\n    ImGuiSettingsHandler* entry_handler = NULL;\r\n\r\n    char* line_end = NULL;\r\n    for (char* line = buf; line < buf_end; line = line_end + 1)\r\n    {\r\n        // Skip new lines markers, then find end of the line\r\n        while (*line == '\\n' || *line == '\\r')\r\n            line++;\r\n        line_end = line;\r\n        while (line_end < buf_end && *line_end != '\\n' && *line_end != '\\r')\r\n            line_end++;\r\n        line_end[0] = 0;\r\n        if (line[0] == ';')\r\n            continue;\r\n        if (line[0] == '[' && line_end > line && line_end[-1] == ']')\r\n        {\r\n            // Parse \"[Type][Name]\". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.\r\n            line_end[-1] = 0;\r\n            const char* name_end = line_end - 1;\r\n            const char* type_start = line + 1;\r\n            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');\r\n            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;\r\n            if (!type_end || !name_start)\r\n            {\r\n                name_start = type_start; // Import legacy entries that have no type\r\n                type_start = \"Window\";\r\n            }\r\n            else\r\n            {\r\n                *type_end = 0; // Overwrite first ']'\r\n                name_start++;  // Skip second '['\r\n            }\r\n            entry_handler = FindSettingsHandler(type_start);\r\n            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;\r\n        }\r\n        else if (entry_handler != NULL && entry_data != NULL)\r\n        {\r\n            // Let type handler parse the line\r\n            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);\r\n        }\r\n    }\r\n    ImGui::MemFree(buf);\r\n    g.SettingsLoaded = true;\r\n}\r\n\r\nvoid ImGui::SaveIniSettingsToDisk(const char* ini_filename)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SettingsDirtyTimer = 0.0f;\r\n    if (!ini_filename)\r\n        return;\r\n\r\n    size_t ini_data_size = 0;\r\n    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);\r\n    FILE* f = ImFileOpen(ini_filename, \"wt\");\r\n    if (!f)\r\n        return;\r\n    fwrite(ini_data, sizeof(char), ini_data_size, f);\r\n    fclose(f);\r\n}\r\n\r\n// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer\r\nconst char* ImGui::SaveIniSettingsToMemory(size_t* out_size)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SettingsDirtyTimer = 0.0f;\r\n    g.SettingsIniData.Buf.resize(0);\r\n    g.SettingsIniData.Buf.push_back(0);\r\n    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)\r\n    {\r\n        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];\r\n        handler->WriteAllFn(&g, handler, &g.SettingsIniData);\r\n    }\r\n    if (out_size)\r\n        *out_size = (size_t)g.SettingsIniData.size();\r\n    return g.SettingsIniData.c_str();\r\n}\r\n\r\nstatic void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)\r\n{\r\n    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHash(name, 0));\r\n    if (!settings)\r\n        settings = ImGui::CreateNewWindowSettings(name);\r\n    return (void*)settings;\r\n}\r\n\r\nstatic void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)\r\n{\r\n    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;\r\n    float x, y;\r\n    int i;\r\n    if (sscanf(line, \"Pos=%f,%f\", &x, &y) == 2)         settings->Pos = ImVec2(x, y);\r\n    else if (sscanf(line, \"Size=%f,%f\", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), GImGui->Style.WindowMinSize);\r\n    else if (sscanf(line, \"Collapsed=%d\", &i) == 1)     settings->Collapsed = (i != 0);\r\n}\r\n\r\nstatic void SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)\r\n{\r\n    // Gather data from windows that were active during this session\r\n    // (if a window wasn't opened in this session we preserve its settings)\r\n    ImGuiContext& g = *imgui_ctx;\r\n    for (int i = 0; i != g.Windows.Size; i++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)\r\n            continue;\r\n\r\n        ImGuiWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : ImGui::FindWindowSettings(window->ID);\r\n        if (!settings)\r\n        {\r\n            settings = ImGui::CreateNewWindowSettings(window->Name);\r\n            window->SettingsIdx = g.SettingsWindows.index_from_pointer(settings);\r\n        }\r\n        IM_ASSERT(settings->ID == window->ID);\r\n        settings->Pos = window->Pos;\r\n        settings->Size = window->SizeFull;\r\n        settings->Collapsed = window->Collapsed;\r\n    }\r\n\r\n    // Write to text buffer\r\n    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve\r\n    for (int i = 0; i != g.SettingsWindows.Size; i++)\r\n    {\r\n        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];\r\n        if (settings->Pos.x == FLT_MAX)\r\n            continue;\r\n        const char* name = settings->Name;\r\n        if (const char* p = strstr(name, \"###\"))  // Skip to the \"###\" marker if any. We don't skip past to match the behavior of GetID()\r\n            name = p;\r\n        buf->appendf(\"[%s][%s]\\n\", handler->TypeName, name);\r\n        buf->appendf(\"Pos=%d,%d\\n\", (int)settings->Pos.x, (int)settings->Pos.y);\r\n        buf->appendf(\"Size=%d,%d\\n\", (int)settings->Size.x, (int)settings->Size.y);\r\n        buf->appendf(\"Collapsed=%d\\n\", settings->Collapsed);\r\n        buf->appendf(\"\\n\");\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] PLATFORM DEPENDENT HELPERS\r\n//-----------------------------------------------------------------------------\r\n\r\n#if defined(_WIN32) && !defined(_WINDOWS_) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))\r\n#ifndef WIN32_LEAN_AND_MEAN\r\n#define WIN32_LEAN_AND_MEAN\r\n#endif\r\n#ifndef __MINGW32__\r\n#include <Windows.h>\r\n#else\r\n#include <windows.h>\r\n#endif\r\n#endif\r\n\r\n// Win32 API clipboard implementation\r\n#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)\r\n\r\n#ifdef _MSC_VER\r\n#pragma comment(lib, \"user32\")\r\n#endif\r\n\r\nstatic const char* GetClipboardTextFn_DefaultImpl(void*)\r\n{\r\n    static ImVector<char> buf_local;\r\n    buf_local.clear();\r\n    if (!::OpenClipboard(NULL))\r\n        return NULL;\r\n    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);\r\n    if (wbuf_handle == NULL)\r\n    {\r\n        ::CloseClipboard();\r\n        return NULL;\r\n    }\r\n    if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))\r\n    {\r\n        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;\r\n        buf_local.resize(buf_len);\r\n        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);\r\n    }\r\n    ::GlobalUnlock(wbuf_handle);\r\n    ::CloseClipboard();\r\n    return buf_local.Data;\r\n}\r\n\r\nstatic void SetClipboardTextFn_DefaultImpl(void*, const char* text)\r\n{\r\n    if (!::OpenClipboard(NULL))\r\n        return;\r\n    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;\r\n    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));\r\n    if (wbuf_handle == NULL)\r\n    {\r\n        ::CloseClipboard();\r\n        return;\r\n    }\r\n    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);\r\n    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);\r\n    ::GlobalUnlock(wbuf_handle);\r\n    ::EmptyClipboard();\r\n    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)\r\n        ::GlobalFree(wbuf_handle);\r\n    ::CloseClipboard();\r\n}\r\n\r\n#else\r\n\r\n// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers\r\nstatic const char* GetClipboardTextFn_DefaultImpl(void*)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();\r\n}\r\n\r\n// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers\r\nstatic void SetClipboardTextFn_DefaultImpl(void*, const char* text)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.PrivateClipboard.clear();\r\n    const char* text_end = text + strlen(text);\r\n    g.PrivateClipboard.resize((int)(text_end - text) + 1);\r\n    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));\r\n    g.PrivateClipboard[(int)(text_end - text)] = 0;\r\n}\r\n\r\n#endif\r\n\r\n// Win32 API IME support (for Asian languages, etc.)\r\n#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)\r\n\r\n#include <imm.h>\r\n#ifdef _MSC_VER\r\n#pragma comment(lib, \"imm32\")\r\n#endif\r\n\r\nstatic void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)\r\n{\r\n    // Notify OS Input Method Editor of text input position\r\n    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)\r\n        if (HIMC himc = ::ImmGetContext(hwnd))\r\n        {\r\n            COMPOSITIONFORM cf;\r\n            cf.ptCurrentPos.x = x;\r\n            cf.ptCurrentPos.y = y;\r\n            cf.dwStyle = CFS_FORCE_POSITION;\r\n            ::ImmSetCompositionWindow(himc, &cf);\r\n            ::ImmReleaseContext(hwnd, himc);\r\n        }\r\n}\r\n\r\n#else\r\n\r\nstatic void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] METRICS/DEBUG WINDOW\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::ShowMetricsWindow(bool* p_open)\r\n{\r\n    if (!ImGui::Begin(\"ImGui Metrics\", p_open))\r\n    {\r\n        ImGui::End();\r\n        return;\r\n    }\r\n    static bool show_draw_cmd_clip_rects = true;\r\n    static bool show_window_begin_order = false;\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    ImGui::Text(\"Dear ImGui %s\", ImGui::GetVersion());\r\n    ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / io.Framerate, io.Framerate);\r\n    ImGui::Text(\"%d vertices, %d indices (%d triangles)\", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);\r\n    ImGui::Text(\"%d active windows (%d visible)\", io.MetricsActiveWindows, io.MetricsRenderWindows);\r\n    ImGui::Text(\"%d allocations\", io.MetricsActiveAllocations);\r\n    ImGui::Checkbox(\"Show clipping rectangles when hovering draw commands\", &show_draw_cmd_clip_rects);\r\n    ImGui::Checkbox(\"Ctrl shows window begin order\", &show_window_begin_order);\r\n\r\n    ImGui::Separator();\r\n\r\n    struct Funcs\r\n    {\r\n        static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)\r\n        {\r\n            bool node_open = ImGui::TreeNode(draw_list, \"%s: '%s' %d vtx, %d indices, %d cmds\", label, draw_list->_OwnerName ? draw_list->_OwnerName : \"\", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);\r\n            if (draw_list == ImGui::GetWindowDrawList())\r\n            {\r\n                ImGui::SameLine();\r\n                ImGui::TextColored(ImColor(255,100,100), \"CURRENTLY APPENDING\"); // Can't display stats for active draw list! (we don't have the data double-buffered)\r\n                if (node_open) ImGui::TreePop();\r\n                return;\r\n            }\r\n\r\n            ImDrawList* overlay_draw_list = GetOverlayDrawList(window); // Render additional visuals into the top-most draw list\r\n            if (window && IsItemHovered())\r\n                overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));\r\n            if (!node_open)\r\n                return;\r\n\r\n            int elem_offset = 0;\r\n            for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)\r\n            {\r\n                if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)\r\n                    continue;\r\n                if (pcmd->UserCallback)\r\n                {\r\n                    ImGui::BulletText(\"Callback %p, user_data %p\", pcmd->UserCallback, pcmd->UserCallbackData);\r\n                    continue;\r\n                }\r\n                ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;\r\n                bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), \"Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)\", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? \"indexed\" : \"non-indexed\", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);\r\n                if (show_draw_cmd_clip_rects && ImGui::IsItemHovered())\r\n                {\r\n                    ImRect clip_rect = pcmd->ClipRect;\r\n                    ImRect vtxs_rect;\r\n                    for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)\r\n                        vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);\r\n                    clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));\r\n                    vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));\r\n                }\r\n                if (!pcmd_node_open)\r\n                    continue;\r\n\r\n                // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.\r\n                ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.\r\n                while (clipper.Step())\r\n                    for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)\r\n                    {\r\n                        char buf[300];\r\n                        char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);\r\n                        ImVec2 triangles_pos[3];\r\n                        for (int n = 0; n < 3; n++, vtx_i++)\r\n                        {\r\n                            ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];\r\n                            triangles_pos[n] = v.pos;\r\n                            buf_p += ImFormatString(buf_p, (int)(buf_end - buf_p), \"%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\\n\", (n == 0) ? \"vtx\" : \"   \", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);\r\n                        }\r\n                        ImGui::Selectable(buf, false);\r\n                        if (ImGui::IsItemHovered())\r\n                        {\r\n                            ImDrawListFlags backup_flags = overlay_draw_list->Flags;\r\n                            overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.\r\n                            overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);\r\n                            overlay_draw_list->Flags = backup_flags;\r\n                        }\r\n                    }\r\n                ImGui::TreePop();\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)\r\n        {\r\n            if (!ImGui::TreeNode(label, \"%s (%d)\", label, windows.Size))\r\n                return;\r\n            for (int i = 0; i < windows.Size; i++)\r\n                Funcs::NodeWindow(windows[i], \"Window\");\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        static void NodeWindow(ImGuiWindow* window, const char* label)\r\n        {\r\n            if (!ImGui::TreeNode(window, \"%s '%s', %d @ 0x%p\", label, window->Name, window->Active || window->WasActive, window))\r\n                return;\r\n            ImGuiWindowFlags flags = window->Flags;\r\n            NodeDrawList(window, window->DrawList, \"DrawList\");\r\n            ImGui::BulletText(\"Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)\", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);\r\n            ImGui::BulletText(\"Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)\", flags,\r\n                (flags & ImGuiWindowFlags_ChildWindow)  ? \"Child \" : \"\",      (flags & ImGuiWindowFlags_Tooltip)     ? \"Tooltip \"   : \"\",  (flags & ImGuiWindowFlags_Popup) ? \"Popup \" : \"\",\r\n                (flags & ImGuiWindowFlags_Modal)        ? \"Modal \" : \"\",      (flags & ImGuiWindowFlags_ChildMenu)   ? \"ChildMenu \" : \"\",  (flags & ImGuiWindowFlags_NoSavedSettings) ? \"NoSavedSettings \" : \"\",\r\n                (flags & ImGuiWindowFlags_NoMouseInputs)? \"NoMouseInputs\":\"\", (flags & ImGuiWindowFlags_NoNavInputs) ? \"NoNavInputs\" : \"\", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? \"AlwaysAutoResize\" : \"\");\r\n            ImGui::BulletText(\"Scroll: (%.2f/%.2f,%.2f/%.2f)\", window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));\r\n            ImGui::BulletText(\"Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d\", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);\r\n            ImGui::BulletText(\"Appearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d\", window->Appearing, window->Hidden, window->HiddenFramesRegular, window->HiddenFramesForResize, window->SkipItems);\r\n            ImGui::BulletText(\"NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X\", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);\r\n            ImGui::BulletText(\"NavLastChildNavWindow: %s\", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : \"NULL\");\r\n            if (!window->NavRectRel[0].IsInverted())\r\n                ImGui::BulletText(\"NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)\", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);\r\n            else\r\n                ImGui::BulletText(\"NavRectRel[0]: <None>\");\r\n            if (window->RootWindow != window) NodeWindow(window->RootWindow, \"RootWindow\");\r\n            if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, \"ParentWindow\");\r\n            if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, \"ChildWindows\");\r\n            if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode(\"Columns\", \"Columns sets (%d)\", window->ColumnsStorage.Size))\r\n            {\r\n                for (int n = 0; n < window->ColumnsStorage.Size; n++)\r\n                {\r\n                    const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];\r\n                    if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, \"Columns Id: 0x%08X, Count: %d, Flags: 0x%04X\", columns->ID, columns->Count, columns->Flags))\r\n                    {\r\n                        ImGui::BulletText(\"Width: %.1f (MinX: %.1f, MaxX: %.1f)\", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);\r\n                        for (int column_n = 0; column_n < columns->Columns.Size; column_n++)\r\n                            ImGui::BulletText(\"Column %02d: OffsetNorm %.3f (= %.1f px)\", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));\r\n                        ImGui::TreePop();\r\n                    }\r\n                }\r\n                ImGui::TreePop();\r\n            }\r\n            ImGui::BulletText(\"Storage: %d bytes\", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));\r\n            ImGui::TreePop();\r\n        }\r\n    };\r\n\r\n    // Access private state, we are going to display the draw lists from last frame\r\n    ImGuiContext& g = *GImGui;\r\n    Funcs::NodeWindows(g.Windows, \"Windows\");\r\n    if (ImGui::TreeNode(\"DrawList\", \"Active DrawLists (%d)\", g.DrawDataBuilder.Layers[0].Size))\r\n    {\r\n        for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)\r\n            Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], \"DrawList\");\r\n        ImGui::TreePop();\r\n    }\r\n    if (ImGui::TreeNode(\"Popups\", \"Popups (%d)\", g.OpenPopupStack.Size))\r\n    {\r\n        for (int i = 0; i < g.OpenPopupStack.Size; i++)\r\n        {\r\n            ImGuiWindow* window = g.OpenPopupStack[i].Window;\r\n            ImGui::BulletText(\"PopupID: %08x, Window: '%s'%s%s\", g.OpenPopupStack[i].PopupId, window ? window->Name : \"NULL\", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? \" ChildWindow\" : \"\", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? \" ChildMenu\" : \"\");\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n    if (ImGui::TreeNode(\"Internal state\"))\r\n    {\r\n        const char* input_source_names[] = { \"None\", \"Mouse\", \"Nav\", \"NavKeyboard\", \"NavGamepad\" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);\r\n        ImGui::Text(\"HoveredWindow: '%s'\", g.HoveredWindow ? g.HoveredWindow->Name : \"NULL\");\r\n        ImGui::Text(\"HoveredRootWindow: '%s'\", g.HoveredRootWindow ? g.HoveredRootWindow->Name : \"NULL\");\r\n        ImGui::Text(\"HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d\", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is \"in-flight\" so depending on when the Metrics window is called we may see current frame information or not\r\n        ImGui::Text(\"ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s\", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);\r\n        ImGui::Text(\"ActiveIdWindow: '%s'\", g.ActiveIdWindow ? g.ActiveIdWindow->Name : \"NULL\");\r\n        ImGui::Text(\"MovingWindow: '%s'\", g.MovingWindow ? g.MovingWindow->Name : \"NULL\");\r\n        ImGui::Text(\"NavWindow: '%s'\", g.NavWindow ? g.NavWindow->Name : \"NULL\");\r\n        ImGui::Text(\"NavId: 0x%08X, NavLayer: %d\", g.NavId, g.NavLayer);\r\n        ImGui::Text(\"NavInputSource: %s\", input_source_names[g.NavInputSource]);\r\n        ImGui::Text(\"NavActive: %d, NavVisible: %d\", g.IO.NavActive, g.IO.NavVisible);\r\n        ImGui::Text(\"NavActivateId: 0x%08X, NavInputId: 0x%08X\", g.NavActivateId, g.NavInputId);\r\n        ImGui::Text(\"NavDisableHighlight: %d, NavDisableMouseHover: %d\", g.NavDisableHighlight, g.NavDisableMouseHover);\r\n        ImGui::Text(\"NavWindowingTarget: '%s'\", g.NavWindowingTarget ? g.NavWindowingTarget->Name : \"NULL\");\r\n        ImGui::Text(\"DragDrop: %d, SourceId = 0x%08X, Payload \\\"%s\\\" (%d bytes)\", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);\r\n        ImGui::TreePop();\r\n    }\r\n\r\n\r\n    if (g.IO.KeyCtrl && show_window_begin_order)\r\n    {\r\n        for (int n = 0; n < g.Windows.Size; n++)\r\n        {\r\n            ImGuiWindow* window = g.Windows[n];\r\n            if ((window->Flags & ImGuiWindowFlags_ChildWindow) || !window->WasActive)\r\n                continue;\r\n            char buf[32];\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"%d\", window->BeginOrderWithinContext);\r\n            float font_size = ImGui::GetFontSize() * 2;\r\n            ImDrawList* overlay_draw_list = GetOverlayDrawList(window);\r\n            overlay_draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));\r\n            overlay_draw_list->AddText(NULL, font_size, window->Pos, IM_COL32(255, 255, 255, 255), buf);\r\n        }\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n\r\n// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.\r\n// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.\r\n#ifdef IMGUI_INCLUDE_IMGUI_USER_INL\r\n#include \"imgui_user.inl\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n","// dear imgui, v1.67 WIP\r\n// (internal structures/api)\r\n\r\n// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!\r\n// Set:\r\n//   #define IMGUI_DEFINE_MATH_OPERATORS\r\n// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)\r\n\r\n#pragma once\r\n\r\n#ifndef IMGUI_VERSION\r\n#error Must include imgui.h before imgui_internal.h\r\n#endif\r\n\r\n#include <stdio.h>      // FILE*\r\n#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof\r\n#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf\r\n#include <limits.h>     // INT_MIN, INT_MAX\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (push)\r\n#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wunused-function\"        // for stb_textedit.h\r\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"     // for stb_textedit.h\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Forward Declarations\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImRect;                      // An axis-aligned rectangle (2 points)\r\nstruct ImDrawDataBuilder;           // Helper to build a ImDrawData instance\r\nstruct ImDrawListSharedData;        // Data shared between all ImDrawList instances\r\nstruct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it\r\nstruct ImGuiColumnData;             // Storage data for a single column\r\nstruct ImGuiColumnsSet;             // Storage data for a columns set\r\nstruct ImGuiContext;                // Main imgui context\r\nstruct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()\r\nstruct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box\r\nstruct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data\r\nstruct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only\r\nstruct ImGuiNavMoveResult;          // Result of a directional navigation move query result\r\nstruct ImGuiNextWindowData;         // Storage for SetNexWindow** functions\r\nstruct ImGuiPopupRef;               // Storage for current popup stack\r\nstruct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file\r\nstruct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it\r\nstruct ImGuiWindow;                 // Storage for one window\r\nstruct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)\r\nstruct ImGuiWindowSettings;         // Storage for window settings stored in .ini file (we keep one of those even if the actual window wasn't instanced during this session)\r\n\r\n// Use your programming IDE \"Go to definition\" facility on the names of the center columns to find the actual flags/enum lists.\r\ntypedef int ImGuiLayoutType;        // -> enum ImGuiLayoutType_        // Enum: Horizontal or vertical\r\ntypedef int ImGuiButtonFlags;       // -> enum ImGuiButtonFlags_       // Flags: for ButtonEx(), ButtonBehavior()\r\ntypedef int ImGuiItemFlags;         // -> enum ImGuiItemFlags_         // Flags: for PushItemFlag()\r\ntypedef int ImGuiItemStatusFlags;   // -> enum ImGuiItemStatusFlags_   // Flags: for DC.LastItemStatusFlags\r\ntypedef int ImGuiNavHighlightFlags; // -> enum ImGuiNavHighlightFlags_ // Flags: for RenderNavHighlight()\r\ntypedef int ImGuiNavDirSourceFlags; // -> enum ImGuiNavDirSourceFlags_ // Flags: for GetNavInputAmount2d()\r\ntypedef int ImGuiNavMoveFlags;      // -> enum ImGuiNavMoveFlags_      // Flags: for navigation requests\r\ntypedef int ImGuiSeparatorFlags;    // -> enum ImGuiSeparatorFlags_    // Flags: for Separator() - internal\r\ntypedef int ImGuiSliderFlags;       // -> enum ImGuiSliderFlags_       // Flags: for SliderBehavior()\r\ntypedef int ImGuiDragFlags;         // -> enum ImGuiDragFlags_         // Flags: for DragBehavior()\r\n\r\n//-------------------------------------------------------------------------\r\n// STB libraries\r\n//-------------------------------------------------------------------------\r\n\r\nnamespace ImGuiStb\r\n{\r\n\r\n#undef STB_TEXTEDIT_STRING\r\n#undef STB_TEXTEDIT_CHARTYPE\r\n#define STB_TEXTEDIT_STRING             ImGuiInputTextState\r\n#define STB_TEXTEDIT_CHARTYPE           ImWchar\r\n#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f\r\n#include \"imstb_textedit.h\"\r\n\r\n} // namespace ImGuiStb\r\n\r\n//-----------------------------------------------------------------------------\r\n// Context\r\n//-----------------------------------------------------------------------------\r\n\r\n#ifndef GImGui\r\nextern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n#define IM_PI           3.14159265358979323846f\r\n#ifdef _WIN32\r\n#define IM_NEWLINE      \"\\r\\n\"   // Play it nice with Windows users (2018/05 news: Microsoft announced that Notepad will finally display Unix-style carriage returns!)\r\n#else\r\n#define IM_NEWLINE      \"\\n\"\r\n#endif\r\n#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]\r\n#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose\r\n#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255\r\n\r\n// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall\r\n#ifdef _MSC_VER\r\n#define IMGUI_CDECL __cdecl\r\n#else\r\n#define IMGUI_CDECL\r\n#endif\r\n\r\n// Helpers: UTF-8 <> wchar\r\nIMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count\r\nIMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // read one character. return input UTF-8 bytes count\r\nIMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count\r\nIMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)\r\nIMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                        // return number of bytes to express one char in UTF-8\r\nIMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string in UTF-8\r\n\r\n// Helpers: Misc\r\nIMGUI_API ImU32         ImHash(const void* data, int data_size, ImU32 seed = 0);    // Pass data_size==0 for zero-terminated strings\r\nIMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size = NULL, int padding_bytes = 0);\r\nIMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);\r\nstatic inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\\t'; }\r\nstatic inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\\t' || c == 0x3000; }\r\nstatic inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }\r\nstatic inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }\r\n#define ImQsort         qsort\r\n\r\n// Helpers: Geometry\r\nIMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);\r\nIMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);\r\nIMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);\r\nIMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);\r\nIMGUI_API ImGuiDir      ImGetDirQuadrantFromDelta(float dx, float dy);\r\n\r\n// Helpers: String\r\nIMGUI_API int           ImStricmp(const char* str1, const char* str2);\r\nIMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);\r\nIMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);\r\nIMGUI_API char*         ImStrdup(const char* str);\r\nIMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);\r\nIMGUI_API int           ImStrlenW(const ImWchar* str);\r\nIMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line\r\nIMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line\r\nIMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);\r\nIMGUI_API void          ImStrTrimBlanks(char* str);\r\nIMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);\r\nIMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);\r\nIMGUI_API const char*   ImParseFormatFindStart(const char* format);\r\nIMGUI_API const char*   ImParseFormatFindEnd(const char* format);\r\nIMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, int buf_size);\r\nIMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);\r\n\r\n// Helpers: ImVec2/ImVec4 operators\r\n// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)\r\n// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.\r\n#ifdef IMGUI_DEFINE_MATH_OPERATORS\r\nstatic inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }\r\nstatic inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }\r\nstatic inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }\r\nstatic inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }\r\nstatic inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }\r\nstatic inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }\r\nstatic inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }\r\nstatic inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }\r\nstatic inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }\r\nstatic inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }\r\nstatic inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }\r\nstatic inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }\r\nstatic inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }\r\n#endif\r\n\r\n// Helpers: Maths\r\n// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)\r\n#ifndef IMGUI_DISABLE_MATH_FUNCTIONS\r\nstatic inline float  ImFabs(float x)                                            { return fabsf(x); }\r\nstatic inline float  ImSqrt(float x)                                            { return sqrtf(x); }\r\nstatic inline float  ImPow(float x, float y)                                    { return powf(x, y); }\r\nstatic inline double ImPow(double x, double y)                                  { return pow(x, y); }\r\nstatic inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }\r\nstatic inline double ImFmod(double x, double y)                                 { return fmod(x, y); }\r\nstatic inline float  ImCos(float x)                                             { return cosf(x); }\r\nstatic inline float  ImSin(float x)                                             { return sinf(x); }\r\nstatic inline float  ImAcos(float x)                                            { return acosf(x); }\r\nstatic inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }\r\nstatic inline double ImAtof(const char* s)                                      { return atof(s); }\r\nstatic inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)\r\nstatic inline float  ImCeil(float x)                                            { return ceilf(x); }\r\n#endif\r\n// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support for variety of types: signed/unsigned int/long long float/double, using templates here but we could also redefine them 6 times\r\ntemplate<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }\r\ntemplate<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }\r\ntemplate<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }\r\ntemplate<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }\r\ntemplate<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }\r\n// - Misc maths helpers\r\nstatic inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }\r\nstatic inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }\r\nstatic inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }\r\nstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }\r\nstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }\r\nstatic inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }\r\nstatic inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }\r\nstatic inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }\r\nstatic inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }\r\nstatic inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / ImSqrt(d); return fail_value; }\r\nstatic inline float  ImFloor(float f)                                           { return (float)(int)f; }\r\nstatic inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }\r\nstatic inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }\r\nstatic inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }\r\nstatic inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }\r\nstatic inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }\r\n\r\n// Helper: ImPool<>. Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,\r\n// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.\r\ntypedef int ImPoolIdx;\r\ntemplate<typename T>\r\nstruct IMGUI_API ImPool\r\n{\r\n    ImVector<T>     Data;       // Contiguous data\r\n    ImGuiStorage    Map;        // ID->Index\r\n    ImPoolIdx       FreeIdx;    // Next free idx to use\r\n\r\n    ImPool()    { FreeIdx = 0; }\r\n    ~ImPool()   { Clear(); }\r\n    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Data[idx] : NULL; }\r\n    T*          GetByIndex(ImPoolIdx n)             { return &Data[n]; }\r\n    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Data.Data && p < Data.Data + Data.Size); return (ImPoolIdx)(p - Data.Data); }\r\n    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }\r\n    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); }  Map.Clear(); Data.clear(); FreeIdx = 0; }\r\n    T*          Add()                               { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }\r\n    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }\r\n    void        Remove(ImGuiID key, ImPoolIdx idx)  { Data[idx].~T(); *(int*)&Data[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }\r\n    void        Reserve(int capacity)               { Data.reserve(capacity); Map.Data.reserve(capacity); }\r\n    int         GetSize() const                     { return Data.Size; }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Types\r\n//-----------------------------------------------------------------------------\r\n\r\n// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D and maintenance of some patches)\r\nstruct ImVec1\r\n{\r\n    float     x;\r\n    ImVec1() { x = 0.0f; }\r\n    ImVec1(float _x) { x = _x; }\r\n};\r\n\r\nenum ImGuiButtonFlags_\r\n{\r\n    ImGuiButtonFlags_None                   = 0,\r\n    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat\r\n    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // return true on click + release on same item [DEFAULT if no PressedOn* flag is set]\r\n    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)\r\n    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)\r\n    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)\r\n    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping\r\n    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()\r\n    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]\r\n    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions\r\n    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine\r\n    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable interaction if a key modifier is held\r\n    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)\r\n    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)\r\n    ImGuiButtonFlags_NoNavFocus             = 1 << 13   // don't override navigation focus when activated\r\n};\r\n\r\nenum ImGuiSliderFlags_\r\n{\r\n    ImGuiSliderFlags_None                   = 0,\r\n    ImGuiSliderFlags_Vertical               = 1 << 0\r\n};\r\n\r\nenum ImGuiDragFlags_\r\n{\r\n    ImGuiDragFlags_None                     = 0,\r\n    ImGuiDragFlags_Vertical                 = 1 << 0\r\n};\r\n\r\nenum ImGuiColumnsFlags_\r\n{\r\n    // Default: 0\r\n    ImGuiColumnsFlags_None                  = 0,\r\n    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers\r\n    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers\r\n    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns\r\n    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window\r\n    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.\r\n};\r\n\r\nenum ImGuiSelectableFlagsPrivate_\r\n{\r\n    // NB: need to be in sync with last value of ImGuiSelectableFlags_\r\n    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 10,\r\n    ImGuiSelectableFlags_PressedOnClick     = 1 << 11,\r\n    ImGuiSelectableFlags_PressedOnRelease   = 1 << 12,\r\n    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 13\r\n};\r\n\r\nenum ImGuiSeparatorFlags_\r\n{\r\n    ImGuiSeparatorFlags_None                = 0,\r\n    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar\r\n    ImGuiSeparatorFlags_Vertical            = 1 << 1\r\n};\r\n\r\n// Storage for LastItem data\r\nenum ImGuiItemStatusFlags_\r\n{\r\n    ImGuiItemStatusFlags_None               = 0,\r\n    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,\r\n    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,\r\n    ImGuiItemStatusFlags_Edited             = 1 << 2    // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)\r\n};\r\n\r\n// FIXME: this is in development, not exposed/functional as a generic feature yet.\r\nenum ImGuiLayoutType_\r\n{\r\n    ImGuiLayoutType_Vertical,\r\n    ImGuiLayoutType_Horizontal\r\n};\r\n\r\nenum ImGuiAxis\r\n{\r\n    ImGuiAxis_None = -1,\r\n    ImGuiAxis_X = 0,\r\n    ImGuiAxis_Y = 1\r\n};\r\n\r\nenum ImGuiPlotType\r\n{\r\n    ImGuiPlotType_Lines,\r\n    ImGuiPlotType_Histogram\r\n};\r\n\r\nenum ImGuiInputSource\r\n{\r\n    ImGuiInputSource_None = 0,\r\n    ImGuiInputSource_Mouse,\r\n    ImGuiInputSource_Nav,\r\n    ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code\r\n    ImGuiInputSource_NavGamepad,    // \"\r\n    ImGuiInputSource_COUNT\r\n};\r\n\r\n// FIXME-NAV: Clarify/expose various repeat delay/rate\r\nenum ImGuiInputReadMode\r\n{\r\n    ImGuiInputReadMode_Down,\r\n    ImGuiInputReadMode_Pressed,\r\n    ImGuiInputReadMode_Released,\r\n    ImGuiInputReadMode_Repeat,\r\n    ImGuiInputReadMode_RepeatSlow,\r\n    ImGuiInputReadMode_RepeatFast\r\n};\r\n\r\nenum ImGuiNavHighlightFlags_\r\n{\r\n    ImGuiNavHighlightFlags_None         = 0,\r\n    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,\r\n    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,\r\n    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,\r\n    ImGuiNavHighlightFlags_NoRounding   = 1 << 3\r\n};\r\n\r\nenum ImGuiNavDirSourceFlags_\r\n{\r\n    ImGuiNavDirSourceFlags_None         = 0,\r\n    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,\r\n    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,\r\n    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2\r\n};\r\n\r\nenum ImGuiNavMoveFlags_\r\n{\r\n    ImGuiNavMoveFlags_None                  = 0,\r\n    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side\r\n    ImGuiNavMoveFlags_LoopY                 = 1 << 1,\r\n    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)\r\n    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful for provided for completeness\r\n    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)\r\n    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5    // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.\r\n};\r\n\r\nenum ImGuiNavForward\r\n{\r\n    ImGuiNavForward_None,\r\n    ImGuiNavForward_ForwardQueued,\r\n    ImGuiNavForward_ForwardActive\r\n};\r\n\r\nenum ImGuiPopupPositionPolicy\r\n{\r\n    ImGuiPopupPositionPolicy_Default,\r\n    ImGuiPopupPositionPolicy_ComboBox\r\n};\r\n\r\n// 2D axis aligned bounding-box\r\n// NB: we can't rely on ImVec2 math operators being available here\r\nstruct IMGUI_API ImRect\r\n{\r\n    ImVec2      Min;    // Upper-left\r\n    ImVec2      Max;    // Lower-right\r\n\r\n    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}\r\n    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}\r\n    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}\r\n    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}\r\n\r\n    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }\r\n    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }\r\n    float       GetWidth() const                    { return Max.x - Min.x; }\r\n    float       GetHeight() const                   { return Max.y - Min.y; }\r\n    ImVec2      GetTL() const                       { return Min; }                   // Top-left\r\n    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right\r\n    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left\r\n    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right\r\n    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }\r\n    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }\r\n    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }\r\n    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }\r\n    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }\r\n    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }\r\n    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }\r\n    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }\r\n    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }\r\n    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }\r\n    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.\r\n    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.\r\n    void        Floor()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }\r\n    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }\r\n};\r\n\r\n// Stacked color modifier, backup of modified data so we can restore it\r\nstruct ImGuiColorMod\r\n{\r\n    ImGuiCol    Col;\r\n    ImVec4      BackupValue;\r\n};\r\n\r\n// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.\r\nstruct ImGuiStyleMod\r\n{\r\n    ImGuiStyleVar   VarIdx;\r\n    union           { int BackupInt[2]; float BackupFloat[2]; };\r\n    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }\r\n    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }\r\n    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }\r\n};\r\n\r\n// Stacked storage data for BeginGroup()/EndGroup()\r\nstruct ImGuiGroupData\r\n{\r\n    ImVec2      BackupCursorPos;\r\n    ImVec2      BackupCursorMaxPos;\r\n    ImVec1      BackupIndent;\r\n    ImVec1      BackupGroupOffset;\r\n    ImVec2      BackupCurrentLineSize;\r\n    float       BackupCurrentLineTextBaseOffset;\r\n    float       BackupLogLinePosY;\r\n    ImGuiID     BackupActiveIdIsAlive;\r\n    bool        BackupActiveIdPreviousFrameIsAlive;\r\n    bool        AdvanceCursor;\r\n};\r\n\r\n// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.\r\nstruct IMGUI_API ImGuiMenuColumns\r\n{\r\n    int         Count;\r\n    float       Spacing;\r\n    float       Width, NextWidth;\r\n    float       Pos[4], NextWidths[4];\r\n\r\n    ImGuiMenuColumns();\r\n    void        Update(int count, float spacing, bool clear);\r\n    float       DeclColumns(float w0, float w1, float w2);\r\n    float       CalcExtraSpace(float avail_w);\r\n};\r\n\r\n// Internal state of the currently focused/edited text input box\r\nstruct IMGUI_API ImGuiInputTextState\r\n{\r\n    ImGuiID                 ID;                     // widget id owning the text state\r\n    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.\r\n    ImVector<char>          InitialText;            // backup of end-user buffer at the time of focus (in UTF-8, unaltered)\r\n    ImVector<char>          TempBuffer;             // temporary buffer for callback and other other operations. size=capacity.\r\n    int                     CurLenA, CurLenW;       // we need to maintain our buffer length in both UTF-8 and wchar format.\r\n    int                     BufCapacityA;           // end-user buffer capacity\r\n    float                   ScrollX;\r\n    ImGuiStb::STB_TexteditState StbState;\r\n    float                   CursorAnim;\r\n    bool                    CursorFollow;\r\n    bool                    SelectedAllMouseLock;\r\n\r\n    // Temporarily set when active\r\n    ImGuiInputTextFlags     UserFlags;\r\n    ImGuiInputTextCallback  UserCallback;\r\n    void*                   UserCallbackData;\r\n\r\n    ImGuiInputTextState()                           { memset(this, 0, sizeof(*this)); }\r\n    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking\r\n    void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }\r\n    bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }\r\n    void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }\r\n    void                SelectAll()                 { StbState.select_start = 0; StbState.cursor = StbState.select_end = CurLenW; StbState.has_preferred_x = false; }\r\n    void                OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation\r\n};\r\n\r\n// Windows data saved in imgui.ini file\r\nstruct ImGuiWindowSettings\r\n{\r\n    char*       Name;\r\n    ImGuiID     ID;\r\n    ImVec2      Pos;\r\n    ImVec2      Size;\r\n    bool        Collapsed;\r\n\r\n    ImGuiWindowSettings() { Name = NULL; ID = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }\r\n};\r\n\r\nstruct ImGuiSettingsHandler\r\n{\r\n    const char* TypeName;   // Short description stored in .ini file. Disallowed characters: '[' ']'\r\n    ImGuiID     TypeHash;   // == ImHash(TypeName, 0, 0)\r\n    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. \"[Window][Name]\"\r\n    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry\r\n    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'\r\n    void*       UserData;\r\n\r\n    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }\r\n};\r\n\r\n// Storage for current popup stack\r\nstruct ImGuiPopupRef\r\n{\r\n    ImGuiID             PopupId;        // Set on OpenPopup()\r\n    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()\r\n    ImGuiWindow*        ParentWindow;   // Set on OpenPopup()\r\n    int                 OpenFrameCount; // Set on OpenPopup()\r\n    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differenciate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)\r\n    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)\r\n    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup\r\n};\r\n\r\nstruct ImGuiColumnData\r\n{\r\n    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)\r\n    float               OffsetNormBeforeResize;\r\n    ImGuiColumnsFlags   Flags;              // Not exposed\r\n    ImRect              ClipRect;\r\n\r\n    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = 0; }\r\n};\r\n\r\nstruct ImGuiColumnsSet\r\n{\r\n    ImGuiID             ID;\r\n    ImGuiColumnsFlags   Flags;\r\n    bool                IsFirstFrame;\r\n    bool                IsBeingResized;\r\n    int                 Current;\r\n    int                 Count;\r\n    float               MinX, MaxX;\r\n    float               LineMinY, LineMaxY;\r\n    float               StartPosY;          // Copy of CursorPos\r\n    float               StartMaxPosX;       // Copy of CursorMaxPos\r\n    ImVector<ImGuiColumnData> Columns;\r\n\r\n    ImGuiColumnsSet()   { Clear(); }\r\n    void Clear()\r\n    {\r\n        ID = 0;\r\n        Flags = 0;\r\n        IsFirstFrame = false;\r\n        IsBeingResized = false;\r\n        Current = 0;\r\n        Count = 1;\r\n        MinX = MaxX = 0.0f;\r\n        LineMinY = LineMaxY = 0.0f;\r\n        StartPosY = 0.0f;\r\n        StartMaxPosX = 0.0f;\r\n        Columns.clear();\r\n    }\r\n};\r\n\r\n// Data shared between all ImDrawList instances\r\nstruct IMGUI_API ImDrawListSharedData\r\n{\r\n    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas\r\n    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)\r\n    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)\r\n    float           CurveTessellationTol;\r\n    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()\r\n\r\n    // Const data\r\n    // FIXME: Bake rounded corners fill/borders in atlas\r\n    ImVec2          CircleVtx12[12];\r\n\r\n    ImDrawListSharedData();\r\n};\r\n\r\nstruct ImDrawDataBuilder\r\n{\r\n    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip\r\n\r\n    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }\r\n    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }\r\n    IMGUI_API void FlattenIntoSingleLayer();\r\n};\r\n\r\nstruct ImGuiNavMoveResult\r\n{\r\n    ImGuiID       ID;           // Best candidate\r\n    ImGuiWindow*  Window;       // Best candidate window\r\n    float         DistBox;      // Best candidate box distance to current NavId\r\n    float         DistCenter;   // Best candidate center distance to current NavId\r\n    float         DistAxial;\r\n    ImRect        RectRel;      // Best candidate bounding box in window relative space\r\n\r\n    ImGuiNavMoveResult() { Clear(); }\r\n    void Clear()         { ID = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }\r\n};\r\n\r\n// Storage for SetNexWindow** functions\r\nstruct ImGuiNextWindowData\r\n{\r\n    ImGuiCond               PosCond;\r\n    ImGuiCond               SizeCond;\r\n    ImGuiCond               ContentSizeCond;\r\n    ImGuiCond               CollapsedCond;\r\n    ImGuiCond               SizeConstraintCond;\r\n    ImGuiCond               FocusCond;\r\n    ImGuiCond               BgAlphaCond;\r\n    ImVec2                  PosVal;\r\n    ImVec2                  PosPivotVal;\r\n    ImVec2                  SizeVal;\r\n    ImVec2                  ContentSizeVal;\r\n    bool                    CollapsedVal;\r\n    ImRect                  SizeConstraintRect;\r\n    ImGuiSizeCallback       SizeCallback;\r\n    void*                   SizeCallbackUserData;\r\n    float                   BgAlphaVal;\r\n    ImVec2                  MenuBarOffsetMinVal;                // This is not exposed publicly, so we don't clear it.\r\n\r\n    ImGuiNextWindowData()\r\n    {\r\n        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;\r\n        PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);\r\n        ContentSizeVal = ImVec2(0.0f, 0.0f);\r\n        CollapsedVal = false;\r\n        SizeConstraintRect = ImRect();\r\n        SizeCallback = NULL;\r\n        SizeCallbackUserData = NULL;\r\n        BgAlphaVal = FLT_MAX;\r\n        MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);\r\n    }\r\n\r\n    void    Clear()\r\n    {\r\n        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;\r\n    }\r\n};\r\n\r\n// Main imgui context\r\nstruct ImGuiContext\r\n{\r\n    bool                    Initialized;\r\n    bool                    FrameScopeActive;                   // Set by NewFrame(), cleared by EndFrame()/Render()\r\n    bool                    FontAtlasOwnedByContext;            // Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.\r\n    ImGuiIO                 IO;\r\n    ImGuiStyle              Style;\r\n    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()\r\n    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.\r\n    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.\r\n    ImDrawListSharedData    DrawListSharedData;\r\n\r\n    double                  Time;\r\n    int                     FrameCount;\r\n    int                     FrameCountEnded;\r\n    int                     FrameCountRendered;\r\n    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front\r\n    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front\r\n    ImVector<ImGuiWindow*>  WindowsSortBuffer;\r\n    ImVector<ImGuiWindow*>  CurrentWindowStack;\r\n    ImGuiStorage            WindowsById;\r\n    int                     WindowsActiveCount;\r\n    ImGuiWindow*            CurrentWindow;                      // Being drawn into\r\n    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs\r\n    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)\r\n    ImGuiID                 HoveredId;                          // Hovered widget\r\n    bool                    HoveredIdAllowOverlap;\r\n    ImGuiID                 HoveredIdPreviousFrame;\r\n    float                   HoveredIdTimer;                     // Measure contiguous hovering time\r\n    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active\r\n    ImGuiID                 ActiveId;                           // Active widget\r\n    ImGuiID                 ActiveIdPreviousFrame;\r\n    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)\r\n    float                   ActiveIdTimer;\r\n    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame\r\n    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)\r\n    bool                    ActiveIdHasBeenEdited;              // Was the value associated to the widget Edited over the course of the Active state.\r\n    bool                    ActiveIdPreviousFrameIsAlive;\r\n    bool                    ActiveIdPreviousFrameHasBeenEdited;\r\n    int                     ActiveIdAllowNavDirFlags;           // Active widget allows using directional navigation (e.g. can activate a button and move away from it)\r\n    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)\r\n    ImGuiWindow*            ActiveIdWindow;\r\n    ImGuiWindow*            ActiveIdPreviousFrameWindow;\r\n    ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)\r\n    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.\r\n    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.\r\n    ImVec2                  LastValidMousePos;\r\n    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.\r\n    ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()\r\n    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()\r\n    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()\r\n    ImVector<ImGuiPopupRef> OpenPopupStack;                     // Which popups are open (persistent)\r\n    ImVector<ImGuiPopupRef> CurrentPopupStack;                  // Which level of BeginPopup() we are in (reset every frame)\r\n    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions\r\n    bool                    NextTreeNodeOpenVal;                // Storage for SetNextTreeNode** functions\r\n    ImGuiCond               NextTreeNodeOpenCond;\r\n\r\n    // Navigation data (for gamepad/keyboard)\r\n    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'\r\n    ImGuiID                 NavId;                              // Focused item for navigation\r\n    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()\r\n    ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0\r\n    ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0\r\n    ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0\r\n    ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.\r\n    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest)\r\n    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame\r\n    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.\r\n    ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.\r\n    int                     NavScoringCount;                    // Metrics for debugging\r\n    ImGuiWindow*            NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed front-most.\r\n    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f\r\n    ImGuiWindow*            NavWindowingList;\r\n    float                   NavWindowingTimer;\r\n    float                   NavWindowingHighlightAlpha;\r\n    bool                    NavWindowingToggleLayer;\r\n    int                     NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.\r\n    int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing\r\n    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid\r\n    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)\r\n    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)\r\n    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.\r\n    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest\r\n    bool                    NavInitRequest;                     // Init request for appearing window to select first item\r\n    bool                    NavInitRequestFromMove;\r\n    ImGuiID                 NavInitResultId;\r\n    ImRect                  NavInitResultRectRel;\r\n    bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items\r\n    bool                    NavMoveRequest;                     // Move request for this frame\r\n    ImGuiNavMoveFlags       NavMoveRequestFlags;\r\n    ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)\r\n    ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request\r\n    ImGuiDir                NavMoveClipDir;\r\n    ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow\r\n    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)\r\n    ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)\r\n\r\n    // Render\r\n    ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user\r\n    ImDrawDataBuilder       DrawDataBuilder;\r\n    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)\r\n    ImDrawList              OverlayDrawList;                    // Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays\r\n    ImGuiMouseCursor        MouseCursor;\r\n\r\n    // Drag and Drop\r\n    bool                    DragDropActive;\r\n    bool                    DragDropWithinSourceOrTarget;\r\n    ImGuiDragDropFlags      DragDropSourceFlags;\r\n    int                     DragDropSourceFrameCount;\r\n    int                     DragDropMouseButton;\r\n    ImGuiPayload            DragDropPayload;\r\n    ImRect                  DragDropTargetRect;\r\n    ImGuiID                 DragDropTargetId;\r\n    ImGuiDragDropFlags      DragDropAcceptFlags;\r\n    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)\r\n    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)\r\n    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)\r\n    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source\r\n    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly\r\n    unsigned char           DragDropPayloadBufLocal[8];         // Local buffer for small payloads\r\n\r\n    // Widget state\r\n    ImGuiInputTextState     InputTextState;\r\n    ImFont                  InputTextPasswordFont;\r\n    ImGuiID                 ScalarAsInputTextId;                // Temporary text input when CTRL+clicking on a slider, etc.\r\n    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets\r\n    ImVec4                  ColorPickerRef;\r\n    bool                    DragCurrentAccumDirty;\r\n    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings\r\n    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio\r\n    ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?\r\n    int                     TooltipOverrideCount;\r\n    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined\r\n    ImVec2                  PlatformImePos, PlatformImeLastPos; // Cursor position request & last passed to the OS Input Method Editor\r\n\r\n    // Settings\r\n    bool                           SettingsLoaded;\r\n    float                          SettingsDirtyTimer;          // Save .ini Settings to memory when time reaches zero\r\n    ImGuiTextBuffer                SettingsIniData;             // In memory .ini settings\r\n    ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers\r\n    ImVector<ImGuiWindowSettings>  SettingsWindows;             // ImGuiWindow .ini settings entries (parsed from the last loaded .ini file and maintained on saving)\r\n\r\n    // Logging\r\n    bool                    LogEnabled;\r\n    FILE*                   LogFile;                            // If != NULL log to stdout/ file\r\n    ImGuiTextBuffer         LogClipboard;                       // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.\r\n    int                     LogStartDepth;\r\n    int                     LogAutoExpandMaxDepth;\r\n\r\n    // Misc\r\n    float                   FramerateSecPerFrame[120];          // Calculate estimate of framerate for user over the last 2 seconds.\r\n    int                     FramerateSecPerFrameIdx;\r\n    float                   FramerateSecPerFrameAccum;\r\n    int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags\r\n    int                     WantCaptureKeyboardNextFrame;\r\n    int                     WantTextInputNextFrame;\r\n    char                    TempBuffer[1024*3+1];               // Temporary text buffer\r\n\r\n    ImGuiContext(ImFontAtlas* shared_font_atlas) : OverlayDrawList(NULL)\r\n    {\r\n        Initialized = false;\r\n        FrameScopeActive = false;\r\n        Font = NULL;\r\n        FontSize = FontBaseSize = 0.0f;\r\n        FontAtlasOwnedByContext = shared_font_atlas ? false : true;\r\n        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();\r\n\r\n        Time = 0.0f;\r\n        FrameCount = 0;\r\n        FrameCountEnded = FrameCountRendered = -1;\r\n        WindowsActiveCount = 0;\r\n        CurrentWindow = NULL;\r\n        HoveredWindow = NULL;\r\n        HoveredRootWindow = NULL;\r\n        HoveredId = 0;\r\n        HoveredIdAllowOverlap = false;\r\n        HoveredIdPreviousFrame = 0;\r\n        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;\r\n        ActiveId = 0;\r\n        ActiveIdPreviousFrame = 0;\r\n        ActiveIdIsAlive = 0;\r\n        ActiveIdTimer = 0.0f;\r\n        ActiveIdIsJustActivated = false;\r\n        ActiveIdAllowOverlap = false;\r\n        ActiveIdHasBeenEdited = false;\r\n        ActiveIdPreviousFrameIsAlive = false;\r\n        ActiveIdPreviousFrameHasBeenEdited = false;\r\n        ActiveIdAllowNavDirFlags = 0;\r\n        ActiveIdClickOffset = ImVec2(-1,-1);\r\n        ActiveIdWindow = ActiveIdPreviousFrameWindow = NULL;\r\n        ActiveIdSource = ImGuiInputSource_None;\r\n        LastActiveId = 0;\r\n        LastActiveIdTimer = 0.0f;\r\n        LastValidMousePos = ImVec2(0.0f, 0.0f);\r\n        MovingWindow = NULL;\r\n        NextTreeNodeOpenVal = false;\r\n        NextTreeNodeOpenCond = 0;\r\n\r\n        NavWindow = NULL;\r\n        NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;\r\n        NavJustTabbedId = NavJustMovedToId = NavNextActivateId = 0;\r\n        NavInputSource = ImGuiInputSource_None;\r\n        NavScoringRectScreen = ImRect();\r\n        NavScoringCount = 0;\r\n        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;\r\n        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;\r\n        NavWindowingToggleLayer = false;\r\n        NavLayer = 0;\r\n        NavIdTabCounter = INT_MAX;\r\n        NavIdIsAlive = false;\r\n        NavMousePosDirty = false;\r\n        NavDisableHighlight = true;\r\n        NavDisableMouseHover = false;\r\n        NavAnyRequest = false;\r\n        NavInitRequest = false;\r\n        NavInitRequestFromMove = false;\r\n        NavInitResultId = 0;\r\n        NavMoveFromClampedRefRect = false;\r\n        NavMoveRequest = false;\r\n        NavMoveRequestFlags = 0;\r\n        NavMoveRequestForward = ImGuiNavForward_None;\r\n        NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;\r\n\r\n        DimBgRatio = 0.0f;\r\n        OverlayDrawList._Data = &DrawListSharedData;\r\n        OverlayDrawList._OwnerName = \"##Overlay\"; // Give it a name for debugging\r\n        MouseCursor = ImGuiMouseCursor_Arrow;\r\n\r\n        DragDropActive = DragDropWithinSourceOrTarget = false;\r\n        DragDropSourceFlags = 0;\r\n        DragDropSourceFrameCount = -1;\r\n        DragDropMouseButton = -1;\r\n        DragDropTargetId = 0;\r\n        DragDropAcceptFlags = 0;\r\n        DragDropAcceptIdCurrRectSurface = 0.0f;\r\n        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;\r\n        DragDropAcceptFrameCount = -1;\r\n        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));\r\n\r\n        ScalarAsInputTextId = 0;\r\n        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;\r\n        DragCurrentAccumDirty = false;\r\n        DragCurrentAccum = 0.0f;\r\n        DragSpeedDefaultRatio = 1.0f / 100.0f;\r\n        ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);\r\n        TooltipOverrideCount = 0;\r\n        PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n        SettingsLoaded = false;\r\n        SettingsDirtyTimer = 0.0f;\r\n\r\n        LogEnabled = false;\r\n        LogFile = NULL;\r\n        LogStartDepth = 0;\r\n        LogAutoExpandMaxDepth = 2;\r\n\r\n        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));\r\n        FramerateSecPerFrameIdx = 0;\r\n        FramerateSecPerFrameAccum = 0.0f;\r\n        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;\r\n        memset(TempBuffer, 0, sizeof(TempBuffer));\r\n    }\r\n};\r\n\r\n// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().\r\n// This is going to be exposed in imgui.h when stabilized enough.\r\nenum ImGuiItemFlags_\r\n{\r\n    ImGuiItemFlags_NoTabStop                    = 1 << 0,  // false\r\n    ImGuiItemFlags_ButtonRepeat                 = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.\r\n    ImGuiItemFlags_Disabled                     = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211\r\n    ImGuiItemFlags_NoNav                        = 1 << 3,  // false\r\n    ImGuiItemFlags_NoNavDefaultFocus            = 1 << 4,  // false\r\n    ImGuiItemFlags_SelectableDontClosePopup     = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window\r\n    ImGuiItemFlags_Default_                     = 0\r\n};\r\n\r\n// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.\r\n// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.\r\nstruct IMGUI_API ImGuiWindowTempData\r\n{\r\n    ImVec2                  CursorPos;\r\n    ImVec2                  CursorPosPrevLine;\r\n    ImVec2                  CursorStartPos;         // Initial position in client area with padding\r\n    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame\r\n    ImVec2                  CurrentLineSize;\r\n    float                   CurrentLineTextBaseOffset;\r\n    ImVec2                  PrevLineSize;\r\n    float                   PrevLineTextBaseOffset;\r\n    float                   LogLinePosY;\r\n    int                     TreeDepth;\r\n    ImU32                   TreeDepthMayJumpToParentOnPop; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31\r\n    ImGuiID                 LastItemId;\r\n    ImGuiItemStatusFlags    LastItemStatusFlags;\r\n    ImRect                  LastItemRect;           // Interaction rect\r\n    ImRect                  LastItemDisplayRect;    // End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)\r\n    bool                    NavHideHighlightOneFrame;\r\n    bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)\r\n    int                     NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)\r\n    int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.\r\n    int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)\r\n    int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)\r\n    bool                    MenuBarAppending;       // FIXME: Remove this\r\n    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.\r\n    ImVector<ImGuiWindow*>  ChildWindows;\r\n    ImGuiStorage*           StateStorage;\r\n    ImGuiLayoutType         LayoutType;\r\n    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()\r\n\r\n    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.\r\n    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]\r\n    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window\r\n    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]\r\n    ImVector<ImGuiItemFlags>ItemFlagsStack;\r\n    ImVector<float>         ItemWidthStack;\r\n    ImVector<float>         TextWrapPosStack;\r\n    ImVector<ImGuiGroupData>GroupStack;\r\n    int                     StackSizesBackup[6];    // Store size of various stacks for asserting\r\n\r\n    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)\r\n    ImVec1                  GroupOffset;\r\n    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.\r\n    ImGuiColumnsSet*        ColumnsSet;             // Current columns set\r\n\r\n    ImGuiWindowTempData()\r\n    {\r\n        CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);\r\n        CurrentLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);\r\n        CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;\r\n        LogLinePosY = -1.0f;\r\n        TreeDepth = 0;\r\n        TreeDepthMayJumpToParentOnPop = 0x00;\r\n        LastItemId = 0;\r\n        LastItemStatusFlags = 0;\r\n        LastItemRect = LastItemDisplayRect = ImRect();\r\n        NavHideHighlightOneFrame = false;\r\n        NavHasScroll = false;\r\n        NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;\r\n        NavLayerCurrent = 0;\r\n        NavLayerCurrentMask = 1 << 0;\r\n        MenuBarAppending = false;\r\n        MenuBarOffset = ImVec2(0.0f, 0.0f);\r\n        StateStorage = NULL;\r\n        LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;\r\n        ItemWidth = 0.0f;\r\n        ItemFlags = ImGuiItemFlags_Default_;\r\n        TextWrapPos = -1.0f;\r\n        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));\r\n\r\n        Indent = ImVec1(0.0f);\r\n        GroupOffset = ImVec1(0.0f);\r\n        ColumnsOffset = ImVec1(0.0f);\r\n        ColumnsSet = NULL;\r\n    }\r\n};\r\n\r\n// Storage for one window\r\nstruct IMGUI_API ImGuiWindow\r\n{\r\n    char*                   Name;\r\n    ImGuiID                 ID;                                 // == ImHash(Name)\r\n    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_\r\n    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)\r\n    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)\r\n    ImVec2                  SizeFull;                           // Size when non collapsed\r\n    ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.\r\n    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.\r\n    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()\r\n    ImVec2                  WindowPadding;                      // Window padding at the time of begin.\r\n    float                   WindowRounding;                     // Window rounding at the time of begin.\r\n    float                   WindowBorderSize;                   // Window border size at the time of begin.\r\n    ImGuiID                 MoveId;                             // == window->GetID(\"#MOVE\")\r\n    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)\r\n    ImVec2                  Scroll;\r\n    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)\r\n    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered\r\n    ImVec2                  ScrollbarSizes;                     // Size taken by scrollbars on each axis\r\n    bool                    ScrollbarX, ScrollbarY;\r\n    bool                    Active;                             // Set to true on Begin(), unless Collapsed\r\n    bool                    WasActive;\r\n    bool                    WriteAccessed;                      // Set to true when any widget access the current window\r\n    bool                    Collapsed;                          // Set when collapsing window to become only title-bar\r\n    bool                    WantCollapseToggle;\r\n    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)\r\n    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)\r\n    bool                    Hidden;                             // Do not display (== (HiddenFramesForResize > 0) ||\r\n    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)\r\n    int                     BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)\r\n    int                     BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.\r\n    int                     BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.\r\n    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)\r\n    int                     AutoFitFramesX, AutoFitFramesY;\r\n    bool                    AutoFitOnlyGrows;\r\n    int                     AutoFitChildAxises;\r\n    ImGuiDir                AutoPosLastDirection;\r\n    int                     HiddenFramesRegular;                // Hide the window for N frames\r\n    int                     HiddenFramesForResize;              // Hide the window for N frames while allowing items to be submitted so we can measure their size\r\n    ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.\r\n    ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.\r\n    ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.\r\n    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)\r\n    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.\r\n\r\n    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the \"DC\" variable name.\r\n    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack\r\n    ImRect                  ClipRect;                           // Current clipping rectangle. = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.\r\n    ImRect                  OuterRectClipped;                   // = WindowRect just after setup in Begin(). == window->Rect() for root window.\r\n    ImRect                  InnerMainRect, InnerClipRect;\r\n    ImRect                  ContentsRegionRect;                 // FIXME: This is currently confusing/misleading. Maximum visible content position ~~ Pos + (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis\r\n    int                     LastFrameActive;                    // Last frame number the window was Active.\r\n    float                   ItemWidthDefault;\r\n    ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items\r\n    ImGuiStorage            StateStorage;\r\n    ImVector<ImGuiColumnsSet> ColumnsStorage;\r\n    float                   FontWindowScale;                    // User scale multiplier per-window\r\n    int                     SettingsIdx;                        // Index into SettingsWindow[] (indices are always valid as we only grow the array from the back)\r\n\r\n    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)\r\n    ImDrawList              DrawListInst;\r\n    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.\r\n    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window.\r\n    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.\r\n    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.\r\n\r\n    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)\r\n    ImGuiID                 NavLastIds[2];                      // Last known NavId for this window, per layer (0/1)\r\n    ImRect                  NavRectRel[2];                      // Reference rectangle, in window relative space\r\n\r\n    // Navigation / Focus\r\n    // FIXME-NAV: Merge all this with the new Nav system, at least the request variables should be moved to ImGuiContext\r\n    int                     FocusIdxAllCounter;                 // Start at -1 and increase as assigned via FocusItemRegister()\r\n    int                     FocusIdxTabCounter;                 // (same, but only count widgets which you can Tab through)\r\n    int                     FocusIdxAllRequestCurrent;          // Item being requested for focus\r\n    int                     FocusIdxTabRequestCurrent;          // Tab-able item being requested for focus\r\n    int                     FocusIdxAllRequestNext;             // Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)\r\n    int                     FocusIdxTabRequestNext;             // \"\r\n\r\npublic:\r\n    ImGuiWindow(ImGuiContext* context, const char* name);\r\n    ~ImGuiWindow();\r\n\r\n    ImGuiID     GetID(const char* str, const char* str_end = NULL);\r\n    ImGuiID     GetID(const void* ptr);\r\n    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);\r\n    ImGuiID     GetIDNoKeepAlive(const void* ptr);\r\n    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);\r\n\r\n    // We don't use g.FontSize because the window may be != g.CurrentWidow.\r\n    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }\r\n    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }\r\n    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }\r\n    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }\r\n    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }\r\n    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }\r\n};\r\n\r\n// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.\r\nstruct ImGuiItemHoveredDataBackup\r\n{\r\n    ImGuiID                 LastItemId;\r\n    ImGuiItemStatusFlags    LastItemStatusFlags;\r\n    ImRect                  LastItemRect;\r\n    ImRect                  LastItemDisplayRect;\r\n\r\n    ImGuiItemHoveredDataBackup() { Backup(); }\r\n    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }\r\n    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Internal API\r\n// No guarantee of forward compatibility here.\r\n//-----------------------------------------------------------------------------\r\n\r\nnamespace ImGui\r\n{\r\n    // We should always have a CurrentWindow in the stack (there is an implicit \"Debug\" window)\r\n    // If this ever crash because g.CurrentWindow is NULL it means that either\r\n    // - ImGui::NewFrame() has never been called, which is illegal.\r\n    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.\r\n    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }\r\n    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }\r\n    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);\r\n    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);\r\n    IMGUI_API void          FocusWindow(ImGuiWindow* window);\r\n    IMGUI_API void          FocusPreviousWindowIgnoringOne(ImGuiWindow* ignore_window);\r\n    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);\r\n    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);\r\n    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);\r\n    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);\r\n    IMGUI_API ImVec2        CalcWindowExpectedSize(ImGuiWindow* window);\r\n    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);\r\n    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);\r\n    IMGUI_API void          SetWindowScrollX(ImGuiWindow* window, float new_scroll_x);\r\n    IMGUI_API void          SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);\r\n    IMGUI_API float         GetWindowScrollMaxX(ImGuiWindow* window);\r\n    IMGUI_API float         GetWindowScrollMaxY(ImGuiWindow* window);\r\n    IMGUI_API ImRect        GetWindowAllowedExtentRect(ImGuiWindow* window);\r\n    IMGUI_API void          SetCurrentFont(ImFont* font);\r\n    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }\r\n\r\n    // Init\r\n    IMGUI_API void          Initialize(ImGuiContext* context);\r\n    IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().\r\n\r\n    // NewFrame\r\n    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();\r\n    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);\r\n    IMGUI_API void          UpdateMouseMovingWindow();\r\n\r\n    // Settings\r\n    IMGUI_API void                  MarkIniSettingsDirty();\r\n    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);\r\n    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);\r\n    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);\r\n    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);\r\n\r\n    // Basic Accessors\r\n    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }\r\n    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }\r\n    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }\r\n    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);\r\n    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);\r\n    IMGUI_API void          ClearActiveID();\r\n    IMGUI_API ImGuiID       GetHoveredID();\r\n    IMGUI_API void          SetHoveredID(ImGuiID id);\r\n    IMGUI_API void          KeepAliveID(ImGuiID id);\r\n    IMGUI_API void          MarkItemEdited(ImGuiID id);\r\n\r\n    // Basic Helpers for widget code\r\n    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);\r\n    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);\r\n    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);\r\n    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);\r\n    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);\r\n    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop = true);      // Return true if focus is requested\r\n    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);\r\n    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);\r\n    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);\r\n    IMGUI_API void          PushMultiItemsWidths(int components, float width_full = 0.0f);\r\n    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);\r\n    IMGUI_API void          PopItemFlag();\r\n\r\n    // Popups, Modals, Tooltips\r\n    IMGUI_API void          OpenPopupEx(ImGuiID id);\r\n    IMGUI_API void          ClosePopup(ImGuiID id);\r\n    IMGUI_API void          ClosePopupToLevel(int remaining);\r\n    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window);\r\n    IMGUI_API bool          IsPopupOpen(ImGuiID id);\r\n    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);\r\n    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);\r\n    IMGUI_API ImGuiWindow*  GetFrontMostPopupModal();\r\n    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);\r\n    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default);\r\n\r\n    // Navigation\r\n    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);\r\n    IMGUI_API bool          NavMoveRequestButNoResultYet();\r\n    IMGUI_API void          NavMoveRequestCancel();\r\n    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags);\r\n    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);\r\n    IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);\r\n    IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);\r\n    IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);\r\n    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.\r\n    IMGUI_API void          SetNavID(ImGuiID id, int nav_layer);\r\n    IMGUI_API void          SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel);\r\n\r\n    // Inputs\r\n    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }\r\n    inline bool             IsNavInputDown(ImGuiNavInput n)                             { return GImGui->IO.NavInputs[n] > 0.0f; }\r\n    inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }\r\n    inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }\r\n\r\n    // Drag and Drop\r\n    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);\r\n    IMGUI_API void          ClearDragDrop();\r\n    IMGUI_API bool          IsDragDropPayloadBeingAccepted();\r\n\r\n    // New Columns API (FIXME-WIP)\r\n    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().\r\n    IMGUI_API void          EndColumns();                                                             // close columns\r\n    IMGUI_API void          PushColumnClipRect(int column_index = -1);\r\n\r\n    // Render helpers\r\n    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.\r\n    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)\r\n    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);\r\n    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);\r\n    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);\r\n    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);\r\n    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);\r\n    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);\r\n    IMGUI_API void          RenderArrow(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);\r\n    IMGUI_API void          RenderBullet(ImVec2 pos);\r\n    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);\r\n    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight\r\n    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.\r\n    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);\r\n\r\n    // Render helpers (those functions don't access any ImGui state!)\r\n    IMGUI_API void          RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor = ImGuiMouseCursor_Arrow);\r\n    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);\r\n    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);\r\n\r\n    // Widgets\r\n    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);\r\n    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);\r\n    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);\r\n    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags);\r\n    IMGUI_API void          Scrollbar(ImGuiLayoutType direction);\r\n    IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.\r\n\r\n    // Widgets low-level behaviors\r\n    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);\r\n    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags);\r\n    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);\r\n    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);\r\n    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);\r\n    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging\r\n    IMGUI_API void          TreePushRawID(ImGuiID id);\r\n\r\n    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types. \r\n    // To use them externally (for custom widget) you may need an \"extern template\" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).\r\n    // e.g. \" extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); \"\r\n    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, const T v_min, const T v_max, const char* format, float power, ImGuiDragFlags flags);\r\n    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, const T v_min, const T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);\r\n    template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos);\r\n    template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);\r\n\r\n    // InputText\r\n    IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format);\r\n\r\n    // Color\r\n    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);\r\n    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);\r\n    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);\r\n\r\n    // Plot\r\n    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size);\r\n\r\n    // Shade functions (write over already created vertices)\r\n    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);\r\n    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);\r\n\r\n} // namespace ImGui\r\n\r\n// ImFontAtlas internals\r\nIMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);\r\nIMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);\r\nIMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);\r\nIMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* spc);\r\nIMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);\r\nIMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);\r\nIMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (pop)\r\n#endif\r\n","// dear imgui, v1.67 WIP\r\n// (headers)\r\n\r\n// See imgui.cpp file for documentation.\r\n// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.\r\n// Read 'Programmer guide' in imgui.cpp for notes on how to setup ImGui in your codebase.\r\n// Get latest version at https://github.com/ocornut/imgui\r\n\r\n/*\r\n\r\nIndex of this file:\r\n// Header mess\r\n// Forward declarations and basic types\r\n// ImGui API (Dear ImGui end-user API)\r\n// Flags & Enumerations\r\n// ImGuiStyle\r\n// ImGuiIO\r\n// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)\r\n// Obsolete functions\r\n// Helpers (ImVector, ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)\r\n// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)\r\n// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFont)\r\n\r\n*/\r\n\r\n#pragma once\r\n\r\n// Configuration file (edit imconfig.h or define IMGUI_USER_CONFIG to your own filename)\r\n#ifdef IMGUI_USER_CONFIG\r\n#include IMGUI_USER_CONFIG\r\n#endif\r\n#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)\r\n#include \"imconfig.h\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Header mess\r\n//-----------------------------------------------------------------------------\r\n\r\n#include <float.h>                  // FLT_MAX\r\n#include <stdarg.h>                 // va_list\r\n#include <stddef.h>                 // ptrdiff_t, NULL\r\n#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp\r\n\r\n// Version\r\n// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY00 then bounced up to XYY01 when release tagging happens)\r\n#define IMGUI_VERSION               \"1.66b\"\r\n#define IMGUI_VERSION_NUM           16602\r\n#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert))\r\n\r\n// Define attributes of all API symbols declarations (e.g. for DLL under Windows)\r\n// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)\r\n#ifndef IMGUI_API\r\n#define IMGUI_API\r\n#endif\r\n#ifndef IMGUI_IMPL_API\r\n#define IMGUI_IMPL_API              IMGUI_API\r\n#endif\r\n\r\n// Helper Macros\r\n#ifndef IM_ASSERT\r\n#include <assert.h>\r\n#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h\r\n#endif\r\n#if defined(__clang__) || defined(__GNUC__)\r\n#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.\r\n#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))\r\n#else\r\n#define IM_FMTARGS(FMT)\r\n#define IM_FMTLIST(FMT)\r\n#endif\r\n#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers!\r\n#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.\r\n\r\n// Warnings\r\n#if defined(__clang__)\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\r\n#elif defined(__GNUC__) && __GNUC__ >= 8\r\n#pragma GCC diagnostic push\r\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Forward declarations and basic types\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImDrawChannel;               // Temporary storage for outputting drawing commands out of order, used by ImDrawList::ChannelsSplit()\r\nstruct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call)\r\nstruct ImDrawData;                  // All draw command lists required to render the frame\r\nstruct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic \"mesh\" builder)\r\nstruct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)\r\nstruct ImDrawVert;                  // A single vertex (20 bytes by default, override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)\r\nstruct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas\r\nstruct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader\r\nstruct ImFontConfig;                // Configuration data when adding a font or merging fonts\r\nstruct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*obsolete* please avoid using)\r\n#ifndef ImTextureID\r\ntypedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)\r\n#endif\r\nstruct ImGuiContext;                // ImGui context (opaque)\r\nstruct ImGuiIO;                     // Main configuration and I/O between your application and ImGui\r\nstruct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)\r\nstruct ImGuiListClipper;            // Helper to manually clip large list of items\r\nstruct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro\r\nstruct ImGuiPayload;                // User data payload for drag and drop operations\r\nstruct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)\r\nstruct ImGuiStorage;                // Helper for key->value storage\r\nstruct ImGuiStyle;                  // Runtime data for styling/colors\r\nstruct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. \"aaaaa[,bbbb][,ccccc]\")\r\nstruct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)\r\n\r\n// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)\r\n// Use your programming IDE \"Go to definition\" facility on the names of the center columns to find the actual flags/enum lists.\r\ntypedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)\r\ntypedef unsigned short ImWchar;     // Character for keyboard input/display\r\ntypedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling\r\ntypedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for Set*()\r\ntypedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type\r\ntypedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction\r\ntypedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)\r\ntypedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation\r\ntypedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier\r\ntypedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling\r\ntypedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect*() etc.\r\ntypedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList\r\ntypedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas\r\ntypedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags\r\ntypedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit*(), ColorPicker*()\r\ntypedef int ImGuiColumnsFlags;      // -> enum ImGuiColumnsFlags_    // Flags: for Columns(), BeginColumns()\r\ntypedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags\r\ntypedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()\r\ntypedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for *DragDrop*()\r\ntypedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()\r\ntypedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.\r\ntypedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText*()\r\ntypedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()\r\ntypedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode*(),CollapsingHeader()\r\ntypedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin*()\r\ntypedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);\r\ntypedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);\r\n\r\n// Scalar data types\r\ntypedef signed int          ImS32;  // 32-bit signed integer == int\r\ntypedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)\r\n#if defined(_MSC_VER) && !defined(__clang__)\r\ntypedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)\r\ntypedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)\r\n#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)\r\n#include <stdint.h>\r\ntypedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)\r\ntypedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)\r\n#else\r\ntypedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)\r\ntypedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)\r\n#endif\r\n\r\n// 2D vector (often used to store positions, sizes, etc.)\r\nstruct ImVec2\r\n{\r\n    float     x, y;\r\n    ImVec2()  { x = y = 0.0f; }\r\n    ImVec2(float _x, float _y) { x = _x; y = _y; }\r\n    float operator[] (size_t i) const { IM_ASSERT(i <= 1); return (&x)[i]; }    // We very rarely use this [] operator, the assert overhead is fine.\r\n#ifdef IM_VEC2_CLASS_EXTRA\r\n    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.\r\n#endif\r\n};\r\n\r\n// 4D vector (often used to store floating-point colors)\r\nstruct ImVec4\r\n{\r\n    float     x, y, z, w;\r\n    ImVec4()  { x = y = z = w = 0.0f; }\r\n    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }\r\n#ifdef IM_VEC4_CLASS_EXTRA\r\n    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.\r\n#endif\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGui: Dear ImGui end-user API\r\n// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui.cpp/.h!)\r\n//-----------------------------------------------------------------------------\r\n\r\nnamespace ImGui\r\n{\r\n    // Context creation and access\r\n    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.\r\n    // All those functions are not reliant on the current context.\r\n    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);\r\n    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context\r\n    IMGUI_API ImGuiContext* GetCurrentContext();\r\n    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);\r\n    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert);\r\n\r\n    // Main\r\n    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)\r\n    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.\r\n    IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().\r\n    IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all!\r\n    IMGUI_API void          Render();                                   // ends the ImGui frame, finalize the draw data. (Obsolete: optionally call io.RenderDrawListsFn if set. Nowadays, prefer calling your render function yourself.)\r\n    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render. (Obsolete: this used to be passed to your io.RenderDrawListsFn() function.)\r\n\r\n    // Demo, Debug, Information\r\n    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!\r\n    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create about window. display Dear ImGui version, credits and build/system information.\r\n    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.\r\n    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)\r\n    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.\r\n    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.\r\n    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).\r\n    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. \"1.23\"\r\n\r\n    // Styles\r\n    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)\r\n    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style\r\n    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font\r\n\r\n    // Windows\r\n    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.\r\n    // - You may append multiple times to the same window during the same frame.\r\n    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window, which clicking will set the boolean to false when clicked.\r\n    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.\r\n    //   Always call a matching End() for each Begin() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]\r\n    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);\r\n    IMGUI_API void          End();\r\n\r\n    // Child Windows\r\n    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.\r\n    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).\r\n    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.\r\n    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]\r\n    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);\r\n    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);\r\n    IMGUI_API void          EndChild();\r\n\r\n    // Windows Utilities\r\n    IMGUI_API bool          IsWindowAppearing();\r\n    IMGUI_API bool          IsWindowCollapsed();\r\n    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.\r\n    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!\r\n    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the window, to append your own drawing primitives\r\n    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)\r\n    IMGUI_API ImVec2        GetWindowSize();                            // get current window size\r\n    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)\r\n    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)\r\n    IMGUI_API ImVec2        GetContentRegionMax();                      // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates\r\n    IMGUI_API ImVec2        GetContentRegionAvail();                    // == GetContentRegionMax() - GetCursorPos()\r\n    IMGUI_API float         GetContentRegionAvailWidth();               //\r\n    IMGUI_API ImVec2        GetWindowContentRegionMin();                // content boundaries min (roughly (0,0)-Scroll), in window coordinates\r\n    IMGUI_API ImVec2        GetWindowContentRegionMax();                // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates\r\n    IMGUI_API float         GetWindowContentRegionWidth();              //\r\n\r\n    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.\r\n    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()\r\n    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.\r\n    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()\r\n    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()\r\n    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()\r\n    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.\r\n    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.\r\n    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.\r\n    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().\r\n    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().\r\n    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows\r\n    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.\r\n    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.\r\n    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state\r\n    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.\r\n\r\n    // Windows Scrolling\r\n    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]\r\n    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]\r\n    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X\r\n    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y\r\n    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]\r\n    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]\r\n    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                     // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead.\r\n    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);    // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.\r\n\r\n    // Parameters stacks (shared)\r\n    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font\r\n    IMGUI_API void          PopFont();\r\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);\r\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);\r\n    IMGUI_API void          PopStyleColor(int count = 1);\r\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);\r\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);\r\n    IMGUI_API void          PopStyleVar(int count = 1);\r\n    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.\r\n    IMGUI_API ImFont*       GetFont();                                                      // get current font\r\n    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied\r\n    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API\r\n    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier\r\n    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied\r\n    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied\r\n\r\n    // Parameters stacks (current window)\r\n    IMGUI_API void          PushItemWidth(float item_width);                                // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)\r\n    IMGUI_API void          PopItemWidth();\r\n    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position\r\n    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                       // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space\r\n    IMGUI_API void          PopTextWrapPos();\r\n    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets\r\n    IMGUI_API void          PopAllowKeyboardFocus();\r\n    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.\r\n    IMGUI_API void          PopButtonRepeat();\r\n\r\n    // Cursor / Layout\r\n    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.\r\n    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);          // call between widgets or groups to layout them horizontally\r\n    IMGUI_API void          NewLine();                                                      // undo a SameLine()\r\n    IMGUI_API void          Spacing();                                                      // add vertical spacing\r\n    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size\r\n    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0\r\n    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0\r\n    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position + capture group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\r\n    IMGUI_API void          EndGroup();\r\n    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position is relative to window position\r\n    IMGUI_API float         GetCursorPosX();                                                // \"\r\n    IMGUI_API float         GetCursorPosY();                                                // \"\r\n    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          // \"\r\n    IMGUI_API void          SetCursorPosX(float x);                                         // \"\r\n    IMGUI_API void          SetCursorPosY(float y);                                         // \"\r\n    IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position\r\n    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)\r\n    IMGUI_API void          SetCursorScreenPos(const ImVec2& screen_pos);                   // cursor position in absolute screen coordinates [0..io.DisplaySize]\r\n    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)\r\n    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize\r\n    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)\r\n    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2\r\n    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)\r\n\r\n    // ID stack/scopes\r\n    // Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most\r\n    // likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.\r\n    // You can also use the \"##foobar\" syntax within widget label to distinguish them from each others.\r\n    // In this header file we use the \"label\"/\"name\" terminology to denote a string that will be displayed and used as an ID,\r\n    // whereas \"str_id\" denote a string that is only used as an ID and not aimed to be displayed.\r\n    IMGUI_API void          PushID(const char* str_id);                                     // push identifier into the ID stack. IDs are hash of the entire stack!\r\n    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);\r\n    IMGUI_API void          PushID(const void* ptr_id);\r\n    IMGUI_API void          PushID(int int_id);\r\n    IMGUI_API void          PopID();\r\n    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself\r\n    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);\r\n    IMGUI_API ImGuiID       GetID(const void* ptr_id);\r\n\r\n    // Widgets: Text\r\n    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.\r\n    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text\r\n    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);\r\n    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();\r\n    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);\r\n    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();\r\n    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);\r\n    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().\r\n    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);\r\n    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets\r\n    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);\r\n    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()\r\n    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);\r\n\r\n    // Widgets: Main\r\n    // Most widgets return true when the value has been changed or when pressed/selected\r\n    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button\r\n    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text\r\n    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)\r\n    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape\r\n    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));\r\n    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding\r\n    IMGUI_API bool          Checkbox(const char* label, bool* v);\r\n    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);\r\n    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton(\"one\", my_value==1)) { my_value = 1; }\r\n    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer\r\n    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);\r\n    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses\r\n\r\n    // Widgets: Combo Box\r\n    // The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.\r\n    // The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.\r\n    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);\r\n    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\"\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);\r\n\r\n    // Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x\r\n    // Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc.\r\n    // Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).\r\n    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);     // If v_min >= v_max we have no bound\r\n    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = \"%.3f\", const char* format_max = NULL, float power = 1.0f);\r\n    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");                                       // If v_min >= v_max we have no bound\r\n    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");\r\n    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");\r\n    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\");\r\n    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = \"%d\", const char* format_max = NULL);\r\n    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);\r\n    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);\r\n\r\n    // Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc.\r\n    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders\r\n    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = \"%.0f deg\");\r\n    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = \"%d\");\r\n    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);\r\n\r\n    // Widgets: Input with Keyboard\r\n    // If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h\r\n    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = \"%.3f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0f, double step_fast = 0.0f, const char* format = \"%.6f\", ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags extra_flags = 0);\r\n\r\n    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)\r\n    // Note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x\r\n    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);\r\n    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.\r\n    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.\r\n\r\n    // Widgets: Trees\r\n    // TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.\r\n    IMGUI_API bool          TreeNode(const char* label);\r\n    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to completely decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().\r\n    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // \"\r\n    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);\r\n    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.\r\n    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // \"\r\n    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()\r\n    IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()\r\n    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode\r\n    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.\r\n    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().\r\n    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header\r\n\r\n    // Widgets: Selectables\r\n    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // \"bool selected\" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height\r\n    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // \"bool* p_selected\" point to the selection state (read-write), as a convenient helper.\r\n\r\n    // Widgets: List Boxes\r\n    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);\r\n    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);\r\n    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.\r\n    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // \"\r\n    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!\r\n\r\n    // Widgets: Data Plotting\r\n    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));\r\n    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));\r\n    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));\r\n    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));\r\n\r\n    // Widgets: Value() Helpers. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)\r\n    IMGUI_API void          Value(const char* prefix, bool b);\r\n    IMGUI_API void          Value(const char* prefix, int v);\r\n    IMGUI_API void          Value(const char* prefix, unsigned int v);\r\n    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);\r\n\r\n    // Widgets: Menus\r\n    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.\r\n    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!\r\n    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).\r\n    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!\r\n    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!\r\n    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!\r\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment\r\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL\r\n\r\n    // Tooltips\r\n    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).\r\n    IMGUI_API void          EndTooltip();\r\n    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().\r\n    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);\r\n\r\n    // Popups\r\n    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).\r\n    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!\r\n    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!\r\n    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.\r\n    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).\r\n    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)\r\n    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!\r\n    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.\r\n    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open\r\n    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.\r\n\r\n    // Columns\r\n    // You can also use SameLine(pos_x) for simplified columns. The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)\r\n    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);\r\n    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished\r\n    IMGUI_API int           GetColumnIndex();                                                   // get current column index\r\n    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column\r\n    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column\r\n    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f\r\n    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column\r\n    IMGUI_API int           GetColumnsCount();\r\n\r\n    // Logging/Capture: all text output from interface is captured to tty/file/clipboard. By default, tree nodes are automatically opened during logging.\r\n    IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty\r\n    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file\r\n    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard\r\n    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)\r\n    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard\r\n    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)\r\n\r\n    // Drag and Drop\r\n    // [BETA API] Missing Demo code. API may evolve.\r\n    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()\r\n    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.\r\n    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!\r\n    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()\r\n    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.\r\n    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!\r\n    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.\r\n    \r\n    // Clipping\r\n    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);\r\n    IMGUI_API void          PopClipRect();\r\n\r\n    // Focus, Activation\r\n    // (Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHereY()\" when applicable to signify \"this is the default item\")\r\n    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.\r\n    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.\r\n\r\n    // Item/Widgets Utilities\r\n    // See Demo Window under \"Widgets->Querying Status\" for an interactive visualization of many of those functions.\r\n    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.\r\n    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)\r\n    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?\r\n    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()\r\n    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)\r\n    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the \"bool\" return value of many widgets.\r\n    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.\r\n    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).\r\n    IMGUI_API bool          IsAnyItemHovered();\r\n    IMGUI_API bool          IsAnyItemActive();\r\n    IMGUI_API bool          IsAnyItemFocused();\r\n    IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rectangle of last item, in screen space\r\n    IMGUI_API ImVec2        GetItemRectMax();                                                   // \"\r\n    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item, in screen space\r\n    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.\r\n\r\n    // Miscellaneous Utilities\r\n    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.\r\n    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.\r\n    IMGUI_API double        GetTime();\r\n    IMGUI_API int           GetFrameCount();\r\n    IMGUI_API ImDrawList*   GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text\r\n    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances\r\n    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);\r\n    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)\r\n    IMGUI_API ImGuiStorage* GetStateStorage();\r\n    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);\r\n    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.\r\n    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame\r\n    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)\r\n\r\n    // Color Utilities\r\n    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);\r\n    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);\r\n    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);\r\n    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);\r\n\r\n    // Inputs Utilities\r\n    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]\r\n    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]!\r\n    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate\r\n    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..\r\n    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate\r\n    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held (0=left, 1=right, 2=middle)\r\n    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held\r\n    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down) (0=left, 1=right, 2=middle)\r\n    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.\r\n    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)\r\n    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but  disregarding of other consideration of focus/window ordering/popup-block.\r\n    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //\r\n    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls\r\n    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into\r\n    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //\r\n    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you\r\n    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type\r\n    IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        // manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered.\r\n    IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           // manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle).\r\n\r\n    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)\r\n    IMGUI_API const char*   GetClipboardText();\r\n    IMGUI_API void          SetClipboardText(const char* text);\r\n\r\n    // Settings/.Ini Utilities\r\n    // The disk functions are automatically called if io.IniFilename != NULL (default is \"imgui.ini\").\r\n    // Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.\r\n    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).\r\n    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.\r\n    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);\r\n    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.\r\n\r\n    // Memory Utilities\r\n    // All those functions are not reliant on the current context.\r\n    // If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again.\r\n    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data = NULL);\r\n    IMGUI_API void*         MemAlloc(size_t size);\r\n    IMGUI_API void          MemFree(void* ptr);\r\n\r\n} // namespace ImGui\r\n\r\n//-----------------------------------------------------------------------------\r\n// Flags & Enumerations\r\n//-----------------------------------------------------------------------------\r\n\r\n// Flags for ImGui::Begin()\r\nenum ImGuiWindowFlags_\r\n{\r\n    ImGuiWindowFlags_None                   = 0,\r\n    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar\r\n    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip\r\n    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window\r\n    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)\r\n    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.\r\n    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it\r\n    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame\r\n    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).\r\n    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file\r\n    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.\r\n    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar\r\n    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section.\r\n    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state\r\n    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)\r\n    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)\r\n    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)\r\n    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)\r\n    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window\r\n    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)\r\n    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,\r\n    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,\r\n    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,\r\n\r\n    // [Internal]\r\n    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)\r\n    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()\r\n    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()\r\n    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()\r\n    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()\r\n    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()\r\n\r\n    // [Obsolete]\r\n    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f / style.WindowBorderSize=1.0f to enable borders around windows and items\r\n    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigResizeWindowsFromEdges and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)\r\n};\r\n\r\n// Flags for ImGui::InputText()\r\nenum ImGuiInputTextFlags_\r\n{\r\n    ImGuiInputTextFlags_None                = 0,\r\n    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/\r\n    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef\r\n    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z\r\n    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs\r\n    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus\r\n    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)\r\n    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)\r\n    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)\r\n    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.\r\n    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\r\n    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\\t' character into the text field\r\n    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).\r\n    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally\r\n    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode\r\n    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode\r\n    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'\r\n    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().\r\n    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)\r\n    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)\r\n    // [Internal]\r\n    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()\r\n};\r\n\r\n// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()\r\nenum ImGuiTreeNodeFlags_\r\n{\r\n    ImGuiTreeNodeFlags_None                 = 0,\r\n    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected\r\n    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)\r\n    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one\r\n    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack\r\n    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)\r\n    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open\r\n    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node\r\n    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.\r\n    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).\r\n    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow\r\n    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().\r\n    //ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed\r\n    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible\r\n    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)\r\n    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap\r\n#endif\r\n};\r\n\r\n// Flags for ImGui::Selectable()\r\nenum ImGuiSelectableFlags_\r\n{\r\n    ImGuiSelectableFlags_None               = 0,\r\n    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window\r\n    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)\r\n    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too\r\n    ImGuiSelectableFlags_Disabled           = 1 << 3    // Cannot be selected, display greyed out text\r\n};\r\n\r\n// Flags for ImGui::BeginCombo()\r\nenum ImGuiComboFlags_\r\n{\r\n    ImGuiComboFlags_None                    = 0,\r\n    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default\r\n    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()\r\n    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)\r\n    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible\r\n    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible\r\n    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button\r\n    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button\r\n    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest\r\n};\r\n\r\n// Flags for ImGui::IsWindowFocused()\r\nenum ImGuiFocusedFlags_\r\n{\r\n    ImGuiFocusedFlags_None                          = 0,\r\n    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused\r\n    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)\r\n    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.\r\n    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows\r\n};\r\n\r\n// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()\r\n// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!\r\n// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.\r\nenum ImGuiHoveredFlags_\r\n{\r\n    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.\r\n    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered\r\n    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)\r\n    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered\r\n    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window\r\n    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.\r\n    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.\r\n    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window\r\n    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled\r\n    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,\r\n    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows\r\n};\r\n\r\n// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()\r\nenum ImGuiDragDropFlags_\r\n{\r\n    ImGuiDragDropFlags_None                         = 0,\r\n    // BeginDragDropSource() flags\r\n    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.\r\n    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.\r\n    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.\r\n    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.\r\n    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.\r\n    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)\r\n    // AcceptDragDropPayload() flags\r\n    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.\r\n    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.\r\n    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.\r\n    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.\r\n};\r\n\r\n// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.\r\n#define IMGUI_PAYLOAD_TYPE_COLOR_3F     \"_COL3F\"    // float[3]: Standard type for colors, without alpha. User code may use this type.\r\n#define IMGUI_PAYLOAD_TYPE_COLOR_4F     \"_COL4F\"    // float[4]: Standard type for colors. User code may use this type.\r\n\r\n// A primary data type\r\nenum ImGuiDataType_\r\n{\r\n    ImGuiDataType_S32,      // int\r\n    ImGuiDataType_U32,      // unsigned int\r\n    ImGuiDataType_S64,      // long long, __int64\r\n    ImGuiDataType_U64,      // unsigned long long, unsigned __int64\r\n    ImGuiDataType_Float,    // float\r\n    ImGuiDataType_Double,   // double\r\n    ImGuiDataType_COUNT\r\n};\r\n\r\n// A cardinal direction\r\nenum ImGuiDir_\r\n{\r\n    ImGuiDir_None    = -1,\r\n    ImGuiDir_Left    = 0,\r\n    ImGuiDir_Right   = 1,\r\n    ImGuiDir_Up      = 2,\r\n    ImGuiDir_Down    = 3,\r\n    ImGuiDir_COUNT\r\n};\r\n\r\n// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array\r\nenum ImGuiKey_\r\n{\r\n    ImGuiKey_Tab,\r\n    ImGuiKey_LeftArrow,\r\n    ImGuiKey_RightArrow,\r\n    ImGuiKey_UpArrow,\r\n    ImGuiKey_DownArrow,\r\n    ImGuiKey_PageUp,\r\n    ImGuiKey_PageDown,\r\n    ImGuiKey_Home,\r\n    ImGuiKey_End,\r\n    ImGuiKey_Insert,\r\n    ImGuiKey_Delete,\r\n    ImGuiKey_Backspace,\r\n    ImGuiKey_Space,\r\n    ImGuiKey_Enter,\r\n    ImGuiKey_Escape,\r\n    ImGuiKey_A,         // for text edit CTRL+A: select all\r\n    ImGuiKey_C,         // for text edit CTRL+C: copy\r\n    ImGuiKey_V,         // for text edit CTRL+V: paste\r\n    ImGuiKey_X,         // for text edit CTRL+X: cut\r\n    ImGuiKey_Y,         // for text edit CTRL+Y: redo\r\n    ImGuiKey_Z,         // for text edit CTRL+Z: undo\r\n    ImGuiKey_COUNT\r\n};\r\n\r\n// Gamepad/Keyboard directional navigation\r\n// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.\r\n// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().\r\n// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.\r\nenum ImGuiNavInput_\r\n{\r\n    // Gamepad Mapping\r\n    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)\r\n    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)\r\n    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)\r\n    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)\r\n    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)\r\n    ImGuiNavInput_DpadRight,     //\r\n    ImGuiNavInput_DpadUp,        //\r\n    ImGuiNavInput_DpadDown,      //\r\n    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down\r\n    ImGuiNavInput_LStickRight,   //\r\n    ImGuiNavInput_LStickUp,      //\r\n    ImGuiNavInput_LStickDown,    //\r\n    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)\r\n    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)\r\n    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)\r\n    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)\r\n\r\n    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.\r\n    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].\r\n    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt\r\n    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys\r\n    ImGuiNavInput_KeyRight_,     // move right\r\n    ImGuiNavInput_KeyUp_,        // move up\r\n    ImGuiNavInput_KeyDown_,      // move down\r\n    ImGuiNavInput_COUNT,\r\n    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_\r\n};\r\n\r\n// Configuration flags stored in io.ConfigFlags. Set by user/application.\r\nenum ImGuiConfigFlags_\r\n{\r\n    ImGuiConfigFlags_None                   = 0,\r\n    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].\r\n    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.\r\n    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.\r\n    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.\r\n    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.\r\n    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.\r\n\r\n    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)\r\n    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.\r\n    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.\r\n};\r\n\r\n// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.\r\nenum ImGuiBackendFlags_\r\n{\r\n    ImGuiBackendFlags_None                  = 0,\r\n    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end supports gamepad and currently has one connected.\r\n    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end supports honoring GetMouseCursor() value to change the OS cursor shape.\r\n    ImGuiBackendFlags_HasSetMousePos        = 1 << 2    // Back-end supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).\r\n};\r\n\r\n// Enumeration for PushStyleColor() / PopStyleColor()\r\nenum ImGuiCol_\r\n{\r\n    ImGuiCol_Text,\r\n    ImGuiCol_TextDisabled,\r\n    ImGuiCol_WindowBg,              // Background of normal windows\r\n    ImGuiCol_ChildBg,               // Background of child windows\r\n    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows\r\n    ImGuiCol_Border,\r\n    ImGuiCol_BorderShadow,\r\n    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input\r\n    ImGuiCol_FrameBgHovered,\r\n    ImGuiCol_FrameBgActive,\r\n    ImGuiCol_TitleBg,\r\n    ImGuiCol_TitleBgActive,\r\n    ImGuiCol_TitleBgCollapsed,\r\n    ImGuiCol_MenuBarBg,\r\n    ImGuiCol_ScrollbarBg,\r\n    ImGuiCol_ScrollbarGrab,\r\n    ImGuiCol_ScrollbarGrabHovered,\r\n    ImGuiCol_ScrollbarGrabActive,\r\n    ImGuiCol_CheckMark,\r\n    ImGuiCol_SliderGrab,\r\n    ImGuiCol_SliderGrabActive,\r\n    ImGuiCol_Button,\r\n    ImGuiCol_ButtonHovered,\r\n    ImGuiCol_ButtonActive,\r\n    ImGuiCol_Header,\r\n    ImGuiCol_HeaderHovered,\r\n    ImGuiCol_HeaderActive,\r\n    ImGuiCol_Separator,\r\n    ImGuiCol_SeparatorHovered,\r\n    ImGuiCol_SeparatorActive,\r\n    ImGuiCol_ResizeGrip,\r\n    ImGuiCol_ResizeGripHovered,\r\n    ImGuiCol_ResizeGripActive,\r\n    ImGuiCol_PlotLines,\r\n    ImGuiCol_PlotLinesHovered,\r\n    ImGuiCol_PlotHistogram,\r\n    ImGuiCol_PlotHistogramHovered,\r\n    ImGuiCol_TextSelectedBg,\r\n    ImGuiCol_DragDropTarget,\r\n    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item\r\n    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB\r\n    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active\r\n    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active\r\n    ImGuiCol_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg, ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive\r\n    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg\r\n    //ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.\r\n    //ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.\r\n#endif\r\n};\r\n\r\n// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.\r\n// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.\r\n// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.\r\nenum ImGuiStyleVar_\r\n{\r\n    // Enum name ......................// Member in ImGuiStyle structure (see ImGuiStyle for descriptions)\r\n    ImGuiStyleVar_Alpha,               // float     Alpha\r\n    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding\r\n    ImGuiStyleVar_WindowRounding,      // float     WindowRounding\r\n    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize\r\n    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize\r\n    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign\r\n    ImGuiStyleVar_ChildRounding,       // float     ChildRounding\r\n    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize\r\n    ImGuiStyleVar_PopupRounding,       // float     PopupRounding\r\n    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize\r\n    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding\r\n    ImGuiStyleVar_FrameRounding,       // float     FrameRounding\r\n    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize\r\n    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing\r\n    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing\r\n    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing\r\n    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize\r\n    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding\r\n    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize\r\n    ImGuiStyleVar_GrabRounding,        // float     GrabRounding\r\n    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign\r\n    ImGuiStyleVar_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding\r\n#endif\r\n};\r\n\r\n// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()\r\nenum ImGuiColorEditFlags_\r\n{\r\n    ImGuiColorEditFlags_None            = 0,\r\n    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).\r\n    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.\r\n    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.\r\n    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)\r\n    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).\r\n    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.\r\n    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).\r\n    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.\r\n    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.\r\n\r\n    // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.\r\n    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.\r\n    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.\r\n    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.\r\n    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).\r\n    ImGuiColorEditFlags_RGB             = 1 << 20,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.\r\n    ImGuiColorEditFlags_HSV             = 1 << 21,  // [Inputs]     // \"\r\n    ImGuiColorEditFlags_HEX             = 1 << 22,  // [Inputs]     // \"\r\n    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.\r\n    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.\r\n    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.\r\n    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.\r\n\r\n    // [Internal] Masks\r\n    ImGuiColorEditFlags__InputsMask     = ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_HSV|ImGuiColorEditFlags_HEX,\r\n    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,\r\n    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,\r\n    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_PickerHueBar    // Change application default using SetColorEditOptions()\r\n};\r\n\r\n// Enumeration for GetMouseCursor()\r\n// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here\r\nenum ImGuiMouseCursor_\r\n{\r\n    ImGuiMouseCursor_None = -1,\r\n    ImGuiMouseCursor_Arrow = 0,\r\n    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.\r\n    ImGuiMouseCursor_ResizeAll,         // (Unused by imgui functions)\r\n    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border\r\n    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column\r\n    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window\r\n    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window\r\n    ImGuiMouseCursor_Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)\r\n    ImGuiMouseCursor_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT\r\n#endif\r\n};\r\n\r\n// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions\r\n// Represent a condition.\r\n// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.\r\nenum ImGuiCond_\r\n{\r\n    ImGuiCond_Always        = 1 << 0,   // Set the variable\r\n    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)\r\n    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)\r\n    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing\r\n#endif\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiStyle\r\n// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().\r\n// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values, \r\n// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImGuiStyle\r\n{\r\n    float       Alpha;                      // Global alpha applies to everything in ImGui.\r\n    ImVec2      WindowPadding;              // Padding within a window.\r\n    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.\r\n    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().\r\n    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\r\n    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.\r\n    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)\r\n    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).\r\n    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).\r\n    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).\r\n    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.\r\n    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).\r\n    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\r\n    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\r\n    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.\r\n    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.\r\n    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.\r\n    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.\r\n    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\r\n    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.\r\n    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.\r\n    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!\r\n    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.\r\n    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.\r\n    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)\r\n    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\r\n    ImVec4      Colors[ImGuiCol_COUNT];\r\n\r\n    IMGUI_API ImGuiStyle();\r\n    IMGUI_API void ScaleAllSizes(float scale_factor);\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiIO\r\n// Communicate most settings and inputs/outputs to Dear ImGui using this structure. \r\n// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImGuiIO\r\n{\r\n    //------------------------------------------------------------------\r\n    // Configuration (fill once)            // Default value:\r\n    //------------------------------------------------------------------\r\n\r\n    ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.\r\n    ImGuiBackendFlags  BackendFlags;        // = 0                  // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.\r\n    ImVec2        DisplaySize;              // <unset>              // Main display size, in pixels. For clamping windows positions.\r\n    float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.\r\n    float         IniSavingRate;            // = 5.0f               // Minimum time between saving positions/sizes to .ini file, in seconds.\r\n    const char*   IniFilename;              // = \"imgui.ini\"        // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.\r\n    const char*   LogFilename;              // = \"imgui_log.txt\"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).\r\n    float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.\r\n    float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.\r\n    float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging.\r\n    int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array which represent your \"native\" keyboard state.\r\n    float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).\r\n    float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.\r\n    void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.\r\n\r\n    ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.\r\n    float         FontGlobalScale;          // = 1.0f               // Global scale all fonts\r\n    bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.\r\n    ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].\r\n    ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.\r\n    ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // [OBSOLETE] If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.\r\n    ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // [OBSOLETE: just use io.DisplaySize!] If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize\r\n\r\n    // Miscellaneous configuration options\r\n    bool          MouseDrawCursor;              // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.\r\n    bool          ConfigMacOSXBehaviors;        // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)\r\n    bool          ConfigInputTextCursorBlink;   // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)\r\n    bool          ConfigResizeWindowsFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)\r\n\r\n    //------------------------------------------------------------------\r\n    // Platform Functions\r\n    // (the imgui_impl_xxxx back-end files are setting those up for you)\r\n    //------------------------------------------------------------------\r\n\r\n    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window)\r\n    const char* BackendPlatformName;\r\n    const char* BackendRendererName;\r\n\r\n    // Optional: Access OS clipboard\r\n    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)\r\n    const char* (*GetClipboardTextFn)(void* user_data);\r\n    void        (*SetClipboardTextFn)(void* user_data, const char* text);\r\n    void*       ClipboardUserData;\r\n\r\n    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)\r\n    // (default to use native imm32 api on Windows)\r\n    void        (*ImeSetInputScreenPosFn)(int x, int y);\r\n    void*       ImeWindowHandle;                // (Windows) Set this to your HWND to get automatic IME cursor positioning.\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!\r\n    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.\r\n    void        (*RenderDrawListsFn)(ImDrawData* data);\r\n#else\r\n    // This is only here to keep ImGuiIO the same size, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.\r\n    void*       RenderDrawListsFnUnused;\r\n#endif\r\n\r\n    //------------------------------------------------------------------\r\n    // Input - Fill before calling NewFrame()\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)\r\n    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.\r\n    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.\r\n    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.\r\n    bool        KeyCtrl;                        // Keyboard modifier pressed: Control\r\n    bool        KeyShift;                       // Keyboard modifier pressed: Shift\r\n    bool        KeyAlt;                         // Keyboard modifier pressed: Alt\r\n    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows\r\n    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the \"native\" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).\r\n    ImWchar     InputCharacters[16+1];          // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.\r\n    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame, all values will be cleared back to zero in ImGui::EndFrame)\r\n\r\n    // Functions\r\n    IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]\r\n    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string\r\n    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually\r\n\r\n    //------------------------------------------------------------------\r\n    // Output - Retrieve after calling NewFrame()\r\n    //------------------------------------------------------------------\r\n\r\n    bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).\r\n    bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).\r\n    bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).\r\n    bool        WantSetMousePos;            // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.\r\n    bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.\r\n    bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.\r\n    bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).\r\n    float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames\r\n    int         MetricsRenderVertices;      // Vertices output during last call to Render()\r\n    int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3\r\n    int         MetricsRenderWindows;       // Number of visible windows\r\n    int         MetricsActiveWindows;       // Number of active windows\r\n    int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.\r\n    ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.\r\n\r\n    //------------------------------------------------------------------\r\n    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2      MousePosPrev;               // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)\r\n    ImVec2      MouseClickedPos[5];         // Position at time of clicking\r\n    double      MouseClickedTime[5];        // Time of last click (used to figure out double-click)\r\n    bool        MouseClicked[5];            // Mouse button went from !Down to Down\r\n    bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?\r\n    bool        MouseReleased[5];           // Mouse button went from Down to !Down\r\n    bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.\r\n    float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)\r\n    float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down\r\n    ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point\r\n    float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point\r\n    float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)\r\n    float       KeysDownDurationPrev[512];  // Previous duration the key has been down\r\n    float       NavInputsDownDuration[ImGuiNavInput_COUNT];\r\n    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];\r\n\r\n    IMGUI_API   ImGuiIO();\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Misc data structures\r\n//-----------------------------------------------------------------------------\r\n\r\n// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.\r\n// The callback function should return 0 by default.\r\n// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)\r\n// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB\r\n// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows\r\n// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration\r\n// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\r\n// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. \r\nstruct ImGuiInputTextCallbackData\r\n{\r\n    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only\r\n    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only\r\n    void*               UserData;       // What user passed to InputText()      // Read-only\r\n\r\n    // Arguments for the different callback events\r\n    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.\r\n    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.\r\n    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;\r\n    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]\r\n    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!\r\n    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()\r\n    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1\r\n    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]\r\n    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]\r\n    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)\r\n    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]\r\n\r\n    // Helper functions for text manipulation.\r\n    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.\r\n    IMGUI_API ImGuiInputTextCallbackData();\r\n    IMGUI_API void      DeleteChars(int pos, int bytes_count);\r\n    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);\r\n    bool                HasSelection() const { return SelectionStart != SelectionEnd; }\r\n};\r\n\r\n// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\r\n// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.\r\nstruct ImGuiSizeCallbackData\r\n{\r\n    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()\r\n    ImVec2  Pos;            // Read-only.   Window position, for reference.\r\n    ImVec2  CurrentSize;    // Read-only.   Current window size.\r\n    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.\r\n};\r\n\r\n// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()\r\nstruct ImGuiPayload\r\n{\r\n    // Members\r\n    void*           Data;               // Data (copied and owned by dear imgui)\r\n    int             DataSize;           // Data size\r\n\r\n    // [Internal]\r\n    ImGuiID         SourceId;           // Source item id\r\n    ImGuiID         SourceParentId;     // Source parent id (if available)\r\n    int             DataFrameCount;     // Data timestamp\r\n    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)\r\n    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)\r\n    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.\r\n\r\n    ImGuiPayload()  { Clear(); }\r\n    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }\r\n    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }\r\n    bool IsPreview() const                  { return Preview; }\r\n    bool IsDelivery() const                 { return Delivery; }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)\r\n//-----------------------------------------------------------------------------\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\nnamespace ImGui\r\n{\r\n    // OBSOLETED in 1.66 (from Sep 2018)\r\n    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }\r\n    // OBSOLETED in 1.63 (from Aug 2018)\r\n    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }\r\n    // OBSOLETED in 1.61 (from Apr 2018)\r\n    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'!\r\n    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags = 0);\r\n    // OBSOLETED in 1.60 (from Dec 2017)\r\n    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }\r\n    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }\r\n    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { (void)on_edge; (void)outward; IM_ASSERT(0); return pos; }\r\n    // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)\r\n    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }\r\n    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }\r\n    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }\r\n    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }\r\n    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }\r\n    // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)\r\n    IMGUI_API bool      Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.\r\n    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }\r\n    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }\r\n    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }\r\n    // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)\r\n    static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }\r\n    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.\r\n    static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }\r\n    static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }\r\n}\r\ntypedef ImGuiInputTextCallback      ImGuiTextEditCallback;      // OBSOLETE in 1.63 (from Aug 2018): made the names consistent\r\ntypedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n// Helper: Lightweight std::vector<> like class to avoid dragging dependencies (also: Windows implementation of STL with debug enabled is absurdly slow, so let's bypass it so our code runs fast in debug).\r\n// *Important* Our implementation does NOT call C++ constructors/destructors. This is intentional, we do not require it but you have to be mindful of that. Do _not_ use this class as a std::vector replacement in your code!\r\ntemplate<typename T>\r\nclass ImVector\r\n{\r\npublic:\r\n    int                         Size;\r\n    int                         Capacity;\r\n    T*                          Data;\r\n\r\n    typedef T                   value_type;\r\n    typedef value_type*         iterator;\r\n    typedef const value_type*   const_iterator;\r\n\r\n    inline ImVector()           { Size = Capacity = 0; Data = NULL; }\r\n    inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }\r\n    inline ImVector(const ImVector<T>& src)                     { Size = Capacity = 0; Data = NULL; operator=(src); }\r\n    inline ImVector<T>& operator=(const ImVector<T>& src)       { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(value_type)); return *this; }\r\n\r\n    inline bool                 empty() const                   { return Size == 0; }\r\n    inline int                  size() const                    { return Size; }\r\n    inline int                  capacity() const                { return Capacity; }\r\n    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }\r\n    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }\r\n\r\n    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }\r\n    inline iterator             begin()                         { return Data; }\r\n    inline const_iterator       begin() const                   { return Data; }\r\n    inline iterator             end()                           { return Data + Size; }\r\n    inline const_iterator       end() const                     { return Data + Size; }\r\n    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }\r\n    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }\r\n    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size - 1]; }\r\n    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size - 1]; }\r\n    inline void                 swap(ImVector<value_type>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }\r\n\r\n    inline int          _grow_capacity(int sz) const            { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }\r\n    inline void         resize(int new_size)                    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }\r\n    inline void         resize(int new_size,const value_type& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }\r\n    inline void         reserve(int new_capacity)\r\n    {\r\n        if (new_capacity <= Capacity)\r\n            return;\r\n        value_type* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));\r\n        if (Data)\r\n        {\r\n            memcpy(new_data, Data, (size_t)Size * sizeof(value_type));\r\n            ImGui::MemFree(Data);\r\n        }\r\n        Data = new_data;\r\n        Capacity = new_capacity;\r\n    }\r\n\r\n    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.\r\n    inline void         push_back(const value_type& v)                  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }\r\n    inline void         pop_back()                                      { IM_ASSERT(Size > 0); Size--; }\r\n    inline void         push_front(const value_type& v)                 { if (Size == 0) push_back(v); else insert(Data, v); }\r\n    inline iterator     erase(const_iterator it)                        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }\r\n    inline iterator     erase(const_iterator it, const_iterator it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(value_type)); Size -= (int)count; return Data + off; }\r\n    inline iterator     erase_unsorted(const_iterator it)               { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(value_type)); Size--; return Data + off; }\r\n    inline iterator     insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }\r\n    inline bool         contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }\r\n    inline int          index_from_pointer(const_iterator it) const     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }\r\n};\r\n\r\n// Helper: IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() macros to call MemAlloc + Placement New, Placement Delete + MemFree\r\n// We call C++ constructor on own allocated memory via the placement \"new(ptr) Type()\" syntax.\r\n// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.\r\nstruct ImNewDummy {};\r\ninline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }\r\ninline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symetrical new()\r\n#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)\r\n#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE\r\ntemplate<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }\r\n\r\n// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.\r\n// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\");\r\nstruct ImGuiOnceUponAFrame\r\n{\r\n    ImGuiOnceUponAFrame() { RefFrame = -1; }\r\n    mutable int RefFrame;\r\n    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }\r\n};\r\n\r\n// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS    // Will obsolete\r\n#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)\r\n#endif\r\n\r\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\r\nstruct ImGuiTextFilter\r\n{\r\n    IMGUI_API           ImGuiTextFilter(const char* default_filter = \"\");\r\n    IMGUI_API bool      Draw(const char* label = \"Filter (inc,-exc)\", float width = 0.0f);    // Helper calling InputText+Build\r\n    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;\r\n    IMGUI_API void      Build();\r\n    void                Clear()          { InputBuf[0] = 0; Build(); }\r\n    bool                IsActive() const { return !Filters.empty(); }\r\n\r\n    // [Internal]\r\n    struct TextRange\r\n    {\r\n        const char* b;\r\n        const char* e;\r\n\r\n        TextRange() { b = e = NULL; }\r\n        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }\r\n        const char*     begin() const   { return b; }\r\n        const char*     end () const    { return e; }\r\n        bool            empty() const   { return b == e; }\r\n        IMGUI_API void  split(char separator, ImVector<TextRange>* out) const;\r\n    };\r\n    char                InputBuf[256];\r\n    ImVector<TextRange> Filters;\r\n    int                 CountGrep;\r\n};\r\n\r\n// Helper: Growable text buffer for logging/accumulating text\r\n// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')\r\nstruct ImGuiTextBuffer\r\n{\r\n    ImVector<char>      Buf;\r\n    static char         EmptyString[1];\r\n\r\n    ImGuiTextBuffer()   { }\r\n    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }\r\n    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }\r\n    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator\r\n    int                 size() const            { return Buf.Data ? Buf.Size - 1 : 0; }\r\n    bool                empty()                 { return Buf.Size <= 1; }\r\n    void                clear()                 { Buf.clear(); }\r\n    void                reserve(int capacity)   { Buf.reserve(capacity); }\r\n    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }\r\n    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);\r\n    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);\r\n};\r\n\r\n// Helper: Key->Value storage\r\n// Typically you don't have to worry about this since a storage is held within each Window.\r\n// We use it to e.g. store collapse state for a tree (Int 0/1)\r\n// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)\r\n// You can use it as custom user storage for temporary values. Declare your own storage if, for example:\r\n// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).\r\n// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)\r\n// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.\r\nstruct ImGuiStorage\r\n{\r\n    struct Pair\r\n    {\r\n        ImGuiID key;\r\n        union { int val_i; float val_f; void* val_p; };\r\n        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }\r\n        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }\r\n        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }\r\n    };\r\n    ImVector<Pair>      Data;\r\n\r\n    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)\r\n    // - Set***() functions find pair, insertion on demand if missing.\r\n    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.\r\n    void                Clear() { Data.clear(); }\r\n    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;\r\n    IMGUI_API void      SetInt(ImGuiID key, int val);\r\n    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;\r\n    IMGUI_API void      SetBool(ImGuiID key, bool val);\r\n    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;\r\n    IMGUI_API void      SetFloat(ImGuiID key, float val);\r\n    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL\r\n    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);\r\n\r\n    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.\r\n    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\r\n    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)\r\n    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat(\"var\", pvar, 0, 100.0f); some_var += *pvar;\r\n    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);\r\n    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);\r\n    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);\r\n    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);\r\n\r\n    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)\r\n    IMGUI_API void      SetAllInt(int val);\r\n\r\n    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\r\n    IMGUI_API void      BuildSortByKey();\r\n};\r\n\r\n// Helper: Manually clip large list of items.\r\n// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.\r\n// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.\r\n// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.\r\n// Usage:\r\n//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.\r\n//     while (clipper.Step())\r\n//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n//             ImGui::Text(\"line number %d\", i);\r\n// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).\r\n// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.\r\n// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)\r\n// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.\r\nstruct ImGuiListClipper\r\n{\r\n    float   StartPosY;\r\n    float   ItemsHeight;\r\n    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;\r\n\r\n    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).\r\n    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().\r\n    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().\r\n    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).\r\n    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.\r\n\r\n    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.\r\n    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.\r\n    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.\r\n};\r\n\r\n// Helpers macros to generate 32-bits encoded colors\r\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\r\n#define IM_COL32_R_SHIFT    16\r\n#define IM_COL32_G_SHIFT    8\r\n#define IM_COL32_B_SHIFT    0\r\n#define IM_COL32_A_SHIFT    24\r\n#define IM_COL32_A_MASK     0xFF000000\r\n#else\r\n#define IM_COL32_R_SHIFT    0\r\n#define IM_COL32_G_SHIFT    8\r\n#define IM_COL32_B_SHIFT    16\r\n#define IM_COL32_A_SHIFT    24\r\n#define IM_COL32_A_MASK     0xFF000000\r\n#endif\r\n#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))\r\n#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF\r\n#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black\r\n#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000\r\n\r\n// Helper: ImColor() implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)\r\n// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.\r\n// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.\r\n// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.\r\nstruct ImColor\r\n{\r\n    ImVec4              Value;\r\n\r\n    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }\r\n    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }\r\n    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }\r\n    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }\r\n    ImColor(const ImVec4& col)                                      { Value = col; }\r\n    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }\r\n    inline operator ImVec4() const                                  { return Value; }\r\n\r\n    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.\r\n    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }\r\n    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)\r\n// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.\r\n//-----------------------------------------------------------------------------\r\n\r\n// Draw callbacks for advanced uses.\r\n// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,\r\n// you can poke into the draw list for that! Draw callback may be useful for example to: A) Change your GPU render state, \r\n// B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.\r\n// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'\r\ntypedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);\r\n\r\n// Typically, 1 command = 1 GPU draw call (unless command is a callback)\r\nstruct ImDrawCmd\r\n{\r\n    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].\r\n    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in \"viewport\" coordinates\r\n    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.\r\n    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.\r\n    void*           UserCallbackData;       // The draw callback code can access this.\r\n\r\n    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }\r\n};\r\n\r\n// Vertex index (override with '#define ImDrawIdx unsigned int' in imconfig.h)\r\n#ifndef ImDrawIdx\r\ntypedef unsigned short ImDrawIdx;\r\n#endif\r\n\r\n// Vertex layout\r\n#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT\r\nstruct ImDrawVert\r\n{\r\n    ImVec2  pos;\r\n    ImVec2  uv;\r\n    ImU32   col;\r\n};\r\n#else\r\n// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h\r\n// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.\r\n// The type has to be described within the macro (you can either declare the struct or use a typedef)\r\n// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.\r\nIMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;\r\n#endif\r\n\r\n// Draw channels are used by the Columns API to \"split\" the render list into different channels while building, so items of each column can be batched together.\r\n// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.\r\nstruct ImDrawChannel\r\n{\r\n    ImVector<ImDrawCmd>     CmdBuffer;\r\n    ImVector<ImDrawIdx>     IdxBuffer;\r\n};\r\n\r\nenum ImDrawCornerFlags_\r\n{\r\n    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1\r\n    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2\r\n    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4\r\n    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8\r\n    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3\r\n    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC\r\n    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5\r\n    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA\r\n    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience\r\n};\r\n\r\nenum ImDrawListFlags_\r\n{\r\n    ImDrawListFlags_None             = 0,\r\n    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)\r\n    ImDrawListFlags_AntiAliasedFill  = 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)\r\n};\r\n\r\n// Draw command list\r\n// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.\r\n// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.\r\n// You can interleave normal ImGui:: calls and adding primitives to the current draw list.\r\n// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)\r\n// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.\r\nstruct ImDrawList\r\n{\r\n    // This is what you have to render\r\n    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.\r\n    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those\r\n    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.\r\n    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.\r\n\r\n    // [Internal, used while building lists]\r\n    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)\r\n    const char*             _OwnerName;         // Pointer to owner window's name for debugging\r\n    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size\r\n    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n    ImVector<ImVec4>        _ClipRectStack;     // [Internal]\r\n    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]\r\n    ImVector<ImVec2>        _Path;              // [Internal] current path building\r\n    int                     _ChannelsCurrent;   // [Internal] current channel number (0)\r\n    int                     _ChannelsCount;     // [Internal] number of active channels (1+)\r\n    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)\r\n\r\n    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)\r\n    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }\r\n    ~ImDrawList() { ClearFreeMemory(); }\r\n    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\r\n    IMGUI_API void  PushClipRectFullScreen();\r\n    IMGUI_API void  PopClipRect();\r\n    IMGUI_API void  PushTextureID(ImTextureID texture_id);\r\n    IMGUI_API void  PopTextureID();\r\n    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }\r\n    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }\r\n\r\n    // Primitives\r\n    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round\r\n    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right\r\n    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);\r\n    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);\r\n    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);\r\n    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);\r\n    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);\r\n    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);\r\n    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);\r\n    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);\r\n    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);\r\n    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);\r\n    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);\r\n    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.\r\n    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);\r\n\r\n    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()\r\n    inline    void  PathClear()                                                 { _Path.resize(0); }\r\n    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }\r\n    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }\r\n    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }  // Note: Anti-aliased filling requires points to be in clockwise order.\r\n    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }\r\n    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);\r\n    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle\r\n    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);\r\n    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);\r\n\r\n    // Channels\r\n    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)\r\n    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)\r\n    IMGUI_API void  ChannelsSplit(int channels_count);\r\n    IMGUI_API void  ChannelsMerge();\r\n    IMGUI_API void  ChannelsSetCurrent(int channel_index);\r\n\r\n    // Advanced\r\n    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.\r\n    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible\r\n    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.\r\n\r\n    // Internal helpers\r\n    // NB: all primitives needs to be reserved via PrimReserve() beforehand!\r\n    IMGUI_API void  Clear();\r\n    IMGUI_API void  ClearFreeMemory();\r\n    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);\r\n    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)\r\n    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);\r\n    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);\r\n    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }\r\n    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }\r\n    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }\r\n    IMGUI_API void  UpdateClipRect();\r\n    IMGUI_API void  UpdateTextureID();\r\n};\r\n\r\n// All draw data to render an ImGui frame\r\n// (NB: the style and the naming convention here is a little inconsistent but we preserve them for backward compatibility purpose)\r\nstruct ImDrawData\r\n{\r\n    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.\r\n    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.\r\n    int             CmdListsCount;          // Number of ImDrawList* to render\r\n    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size\r\n    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size\r\n    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)\r\n    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)\r\n\r\n    // Functions\r\n    ImDrawData()    { Valid = false; Clear(); }\r\n    ~ImDrawData()   { Clear(); }\r\n    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!\r\n    IMGUI_API void  DeIndexAllBuffers();                // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\r\n    IMGUI_API void  ScaleClipRects(const ImVec2& sc);   // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFont)\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImFontConfig\r\n{\r\n    void*           FontData;               //          // TTF/OTF data\r\n    int             FontDataSize;           //          // TTF/OTF data size\r\n    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).\r\n    int             FontNo;                 // 0        // Index of font within TTF/OTF file\r\n    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).\r\n    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.\r\n    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.\r\n    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.\r\n    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.\r\n    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font\r\n    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs\r\n    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.\r\n    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.\r\n    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.\r\n\r\n    // [Internal]\r\n    char            Name[40];               // Name (strictly to ease debugging)\r\n    ImFont*         DstFont;\r\n\r\n    IMGUI_API ImFontConfig();\r\n};\r\n\r\nstruct ImFontGlyph\r\n{\r\n    ImWchar         Codepoint;          // 0x0000..0xFFFF\r\n    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)\r\n    float           X0, Y0, X1, Y1;     // Glyph corners\r\n    float           U0, V0, U1, V1;     // Texture coordinates\r\n};\r\n\r\nenum ImFontAtlasFlags_\r\n{\r\n    ImFontAtlasFlags_None               = 0,\r\n    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two\r\n    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas\r\n};\r\n\r\n// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:\r\n//  - One or more fonts.\r\n//  - Custom graphics data needed to render the shapes needed by Dear ImGui.\r\n//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).\r\n// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.\r\n//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.\r\n//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\r\n//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)\r\n//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API. \r\n//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.\r\n// Common pitfalls:\r\n// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the \r\n//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.\r\n// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.\r\n//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed, \r\n// - Even though many functions are suffixed with \"TTF\", OTF data is supported just as well.\r\n// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!\r\nstruct ImFontAtlas\r\n{\r\n    IMGUI_API ImFontAtlas();\r\n    IMGUI_API ~ImFontAtlas();\r\n    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);\r\n    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);\r\n    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);\r\n    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.\r\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.\r\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.\r\n    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.\r\n    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.\r\n    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).\r\n    IMGUI_API void              Clear();                    // Clear all input and output.\r\n\r\n    // Build atlas, retrieve pixel data.\r\n    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().\r\n    // The pitch is always = Width * BytesPerPixels (1 or 4)\r\n    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into \r\n    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.\r\n    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.\r\n    IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }\r\n    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel\r\n    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel\r\n    void                        SetTexID(ImTextureID id)    { TexID = id; }\r\n\r\n    //-------------------------------------------\r\n    // Glyph Ranges\r\n    //-------------------------------------------\r\n\r\n    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)\r\n    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8\"Hello world\" syntax. See FAQ for details.\r\n    // NB: Consider using GlyphRangesBuilder to build glyph ranges from textual data.\r\n    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin\r\n    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters\r\n    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs\r\n    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs\r\n    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese\r\n    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters\r\n    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters\r\n\r\n    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().\r\n    struct GlyphRangesBuilder\r\n    {\r\n        ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)\r\n        GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }\r\n        bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }\r\n        void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array\r\n        void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character\r\n        IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)\r\n        IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext\r\n        IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges\r\n    };\r\n\r\n    //-------------------------------------------\r\n    // Custom Rectangles/Glyphs API\r\n    //-------------------------------------------\r\n\r\n    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.\r\n    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.\r\n    struct CustomRect\r\n    {\r\n        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.\r\n        unsigned short  Width, Height;  // Input    // Desired rectangle dimension\r\n        unsigned short  X, Y;           // Output   // Packed position in Atlas\r\n        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance\r\n        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset\r\n        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font\r\n        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }\r\n        bool IsPacked() const   { return X != 0xFFFF; }\r\n    };\r\n\r\n    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList\r\n    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.\r\n    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }\r\n\r\n    // [Internal]\r\n    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);\r\n    IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);\r\n\r\n    //-------------------------------------------\r\n    // Members\r\n    //-------------------------------------------\r\n\r\n    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.\r\n    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)\r\n    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.\r\n    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.\r\n    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.\r\n\r\n    // [Internal]\r\n    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.\r\n    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight\r\n    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4\r\n    int                         TexWidth;           // Texture width calculated during Build().\r\n    int                         TexHeight;          // Texture height calculated during Build().\r\n    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)\r\n    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel\r\n    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.\r\n    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.\r\n    ImVector<ImFontConfig>      ConfigData;         // Internal data\r\n    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList\r\n};\r\n\r\n// Font runtime data and rendering\r\n// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().\r\nstruct ImFont\r\n{\r\n    // Members: Hot ~62/78 bytes\r\n    float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)\r\n    float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()\r\n    ImVec2                      DisplayOffset;      // = (0.f,0.f)  // Offset font rendering by xx pixels\r\n    ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.\r\n    ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).\r\n    ImVector<ImWchar>           IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.\r\n    const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)\r\n    float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX\r\n    ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()\r\n\r\n    // Members: Cold ~18/26 bytes\r\n    short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.\r\n    ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData\r\n    ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into\r\n    float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]\r\n    bool                        DirtyLookupTables;\r\n    int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)\r\n\r\n    // Methods\r\n    IMGUI_API ImFont();\r\n    IMGUI_API ~ImFont();\r\n    IMGUI_API void              ClearOutputData();\r\n    IMGUI_API void              BuildLookupTable();\r\n    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;\r\n    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;\r\n    IMGUI_API void              SetFallbackChar(ImWchar c);\r\n    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }\r\n    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }\r\n    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : \"<unknown>\"; }\r\n\r\n    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.\r\n    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.\r\n    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8\r\n    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;\r\n    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;\r\n    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;\r\n\r\n    // [Internal]\r\n    IMGUI_API void              GrowIndex(int new_size);\r\n    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);\r\n    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+\r\n#endif\r\n};\r\n\r\n#if defined(__clang__)\r\n#pragma clang diagnostic pop\r\n#elif defined(__GNUC__) && __GNUC__ >= 8\r\n#pragma GCC diagnostic pop\r\n#endif\r\n\r\n// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)\r\n#ifdef IMGUI_INCLUDE_IMGUI_USER_H\r\n#include \"imgui_user.h\"\r\n#endif\r\n","// -*- C++ -*-\n//===--------------------------- string.h ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING_H\n#define _LIBCPP_STRING_H\n\n/*\n    string.h synopsis\n\nMacros:\n\n    NULL\n\nTypes:\n\n    size_t\n\nvoid* memcpy(void* restrict s1, const void* restrict s2, size_t n);\nvoid* memmove(void* s1, const void* s2, size_t n);\nchar* strcpy (char* restrict s1, const char* restrict s2);\nchar* strncpy(char* restrict s1, const char* restrict s2, size_t n);\nchar* strcat (char* restrict s1, const char* restrict s2);\nchar* strncat(char* restrict s1, const char* restrict s2, size_t n);\nint memcmp(const void* s1, const void* s2, size_t n);\nint strcmp (const char* s1, const char* s2);\nint strncmp(const char* s1, const char* s2, size_t n);\nint strcoll(const char* s1, const char* s2);\nsize_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);\nconst void* memchr(const void* s, int c, size_t n);\n      void* memchr(      void* s, int c, size_t n);\nconst char* strchr(const char* s, int c);\n      char* strchr(      char* s, int c);\nsize_t strcspn(const char* s1, const char* s2);\nconst char* strpbrk(const char* s1, const char* s2);\n      char* strpbrk(      char* s1, const char* s2);\nconst char* strrchr(const char* s, int c);\n      char* strrchr(      char* s, int c);\nsize_t strspn(const char* s1, const char* s2);\nconst char* strstr(const char* s1, const char* s2);\n      char* strstr(      char* s1, const char* s2);\nchar* strtok(char* restrict s1, const char* restrict s2);\nvoid* memset(void* s, int c, size_t n);\nchar* strerror(int errnum);\nsize_t strlen(const char* s);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <string.h>\n\n// MSVCRT, GNU libc and its derivates may already have the correct prototype in\n// <string.h>. This macro can be defined by users if their C library provides\n// the right signature.\n#if defined(__CORRECT_ISO_CPP_STRING_H_PROTO) || defined(_LIBCPP_MSVCRT) || \\\n    defined(__sun__) || defined(_STRING_H_CPLUSPLUS_98_CONFORMANCE_)\n#define _LIBCPP_STRING_H_HAS_CONST_OVERLOADS\n#endif\n\n#if defined(__cplusplus) && !defined(_LIBCPP_STRING_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)\nextern \"C++\" {\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strchr(      char* __s, int __c) {return __libcpp_strchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strpbrk(      char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strrchr(      char* __s, int __c) {return __libcpp_strrchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      void* memchr(      void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strstr(      char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}\n}\n#endif\n\n#endif  // _LIBCPP_STRING_H\n","// dear imgui, v1.67 WIP\r\n// (widgets code)\r\n\r\n/*\r\n\r\nIndex of this file:\r\n\r\n// [SECTION] Forward Declarations\r\n// [SECTION] Widgets: Text, etc.\r\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\r\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\r\n// [SECTION] Widgets: ComboBox\r\n// [SECTION] Data Type and Data Formatting Helpers\r\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\r\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\r\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\r\n// [SECTION] Widgets: InputText, InputTextMultiline\r\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\r\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\r\n// [SECTION] Widgets: Selectable\r\n// [SECTION] Widgets: ListBox\r\n// [SECTION] Widgets: PlotLines, PlotHistogram\r\n// [SECTION] Widgets: Value helpers\r\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\r\n\r\n*/\r\n\r\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include \"imgui.h\"\r\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\r\n#define IMGUI_DEFINE_MATH_OPERATORS\r\n#endif\r\n#include \"imgui_internal.h\"\r\n\r\n#include <ctype.h>      // toupper, isprint\r\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\r\n#include <stddef.h>     // intptr_t\r\n#else\r\n#include <stdint.h>     // intptr_t\r\n#endif\r\n\r\n// Visual Studio warnings\r\n#ifdef _MSC_VER\r\n#pragma warning (disable: 4127) // condition expression is constant\r\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\r\n#endif\r\n\r\n// Clang/GCC warnings with -Weverything\r\n#ifdef __clang__\r\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\r\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\r\n#elif defined(__GNUC__)\r\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"        // warning: format not a string literal, format string not checked\r\n#if __GNUC__ >= 8\r\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\r\n#endif\r\n#endif\r\n\r\n//-------------------------------------------------------------------------\r\n// Data\r\n//-------------------------------------------------------------------------\r\n\r\n// Those MIN/MAX values are not define because we need to point to them\r\nstatic const ImS32  IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);\r\nstatic const ImS32  IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)\r\nstatic const ImU32  IM_U32_MIN = 0;\r\nstatic const ImU32  IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)\r\n#ifdef LLONG_MIN\r\nstatic const ImS64  IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);\r\nstatic const ImS64  IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);\r\n#else\r\nstatic const ImS64  IM_S64_MIN = -9223372036854775807LL - 1;\r\nstatic const ImS64  IM_S64_MAX = 9223372036854775807LL;\r\n#endif\r\nstatic const ImU64  IM_U64_MIN = 0;\r\n#ifdef ULLONG_MAX\r\nstatic const ImU64  IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);\r\n#else\r\nstatic const ImU64  IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);\r\n#endif\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Forward Declarations\r\n//-------------------------------------------------------------------------\r\n\r\n// Data Type helpers\r\nstatic inline int       DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format);\r\nstatic void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);\r\nstatic bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format);\r\n\r\n// For InputTextEx()\r\nstatic bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data);\r\nstatic int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);\r\nstatic ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: Text, etc.\r\n//-------------------------------------------------------------------------\r\n// - TextUnformatted()\r\n// - Text()\r\n// - TextV()\r\n// - TextColored()\r\n// - TextColoredV()\r\n// - TextDisabled()\r\n// - TextDisabledV()\r\n// - TextWrapped()\r\n// - TextWrappedV()\r\n// - LabelText()\r\n// - LabelTextV()\r\n// - BulletText()\r\n// - BulletTextV()\r\n//-------------------------------------------------------------------------\r\n\r\nvoid ImGui::TextUnformatted(const char* text, const char* text_end)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(text != NULL);\r\n    const char* text_begin = text;\r\n    if (text_end == NULL)\r\n        text_end = text + strlen(text); // FIXME-OPT\r\n\r\n    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);\r\n    const float wrap_pos_x = window->DC.TextWrapPos;\r\n    const bool wrap_enabled = wrap_pos_x >= 0.0f;\r\n    if (text_end - text > 2000 && !wrap_enabled)\r\n    {\r\n        // Long text!\r\n        // Perform manual coarse clipping to optimize for long multi-line text\r\n        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.\r\n        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.\r\n        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.\r\n        const char* line = text;\r\n        const float line_height = GetTextLineHeight();\r\n        const ImRect clip_rect = window->ClipRect;\r\n        ImVec2 text_size(0,0);\r\n\r\n        if (text_pos.y <= clip_rect.Max.y)\r\n        {\r\n            ImVec2 pos = text_pos;\r\n\r\n            // Lines to skip (can't skip when logging text)\r\n            if (!g.LogEnabled)\r\n            {\r\n                int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);\r\n                if (lines_skippable > 0)\r\n                {\r\n                    int lines_skipped = 0;\r\n                    while (line < text_end && lines_skipped < lines_skippable)\r\n                    {\r\n                        const char* line_end = (const char*)memchr(line, '\\n', text_end - line);\r\n                        if (!line_end)\r\n                            line_end = text_end;\r\n                        line = line_end + 1;\r\n                        lines_skipped++;\r\n                    }\r\n                    pos.y += lines_skipped * line_height;\r\n                }\r\n            }\r\n\r\n            // Lines to render\r\n            if (line < text_end)\r\n            {\r\n                ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));\r\n                while (line < text_end)\r\n                {\r\n                    if (IsClippedEx(line_rect, 0, false))\r\n                        break;\r\n\r\n                    const char* line_end = (const char*)memchr(line, '\\n', text_end - line);\r\n                    if (!line_end)\r\n                        line_end = text_end;\r\n                    const ImVec2 line_size = CalcTextSize(line, line_end, false);\r\n                    text_size.x = ImMax(text_size.x, line_size.x);\r\n                    RenderText(pos, line, line_end, false);\r\n                    line = line_end + 1;\r\n                    line_rect.Min.y += line_height;\r\n                    line_rect.Max.y += line_height;\r\n                    pos.y += line_height;\r\n                }\r\n\r\n                // Count remaining lines\r\n                int lines_skipped = 0;\r\n                while (line < text_end)\r\n                {\r\n                    const char* line_end = (const char*)memchr(line, '\\n', text_end - line);\r\n                    if (!line_end)\r\n                        line_end = text_end;\r\n                    line = line_end + 1;\r\n                    lines_skipped++;\r\n                }\r\n                pos.y += lines_skipped * line_height;\r\n            }\r\n\r\n            text_size.y += (pos - text_pos).y;\r\n        }\r\n\r\n        ImRect bb(text_pos, text_pos + text_size);\r\n        ItemSize(bb);\r\n        ItemAdd(bb, 0);\r\n    }\r\n    else\r\n    {\r\n        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;\r\n        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);\r\n\r\n        // Account of baseline offset\r\n        ImRect bb(text_pos, text_pos + text_size);\r\n        ItemSize(text_size);\r\n        if (!ItemAdd(bb, 0))\r\n            return;\r\n\r\n        // Render (we don't hide text after ## in this end-user function)\r\n        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);\r\n    }\r\n}\r\n\r\nvoid ImGui::Text(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextV(const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    TextUnformatted(g.TempBuffer, text_end);\r\n}\r\n\r\nvoid ImGui::TextColored(const ImVec4& col, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextColoredV(col, fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)\r\n{\r\n    PushStyleColor(ImGuiCol_Text, col);\r\n    TextV(fmt, args);\r\n    PopStyleColor();\r\n}\r\n\r\nvoid ImGui::TextDisabled(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextDisabledV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextDisabledV(const char* fmt, va_list args)\r\n{\r\n    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);\r\n    TextV(fmt, args);\r\n    PopStyleColor();\r\n}\r\n\r\nvoid ImGui::TextWrapped(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextWrappedV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextWrappedV(const char* fmt, va_list args)\r\n{\r\n    bool need_wrap = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);    // Keep existing wrap position is one ia already set\r\n    if (need_wrap) PushTextWrapPos(0.0f);\r\n    TextV(fmt, args);\r\n    if (need_wrap) PopTextWrapPos();\r\n}\r\n\r\nvoid ImGui::LabelText(const char* label, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    LabelTextV(label, fmt, args);\r\n    va_end(args);\r\n}\r\n\r\n// Add a label+text combo aligned to other label+value widgets\r\nvoid ImGui::LabelTextV(const char* label, const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));\r\n    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    if (!ItemAdd(total_bb, 0))\r\n        return;\r\n\r\n    // Render\r\n    const char* value_text_begin = &g.TempBuffer[0];\r\n    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);\r\n}\r\n\r\nvoid ImGui::BulletText(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    BulletTextV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\n// Text with a little bullet aligned to the typical tree node.\r\nvoid ImGui::BulletTextV(const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const char* text_begin = g.TempBuffer;\r\n    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);\r\n    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it\r\n    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    // Render\r\n    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));\r\n    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: Main\r\n//-------------------------------------------------------------------------\r\n// - ButtonBehavior() [Internal]\r\n// - Button()\r\n// - SmallButton()\r\n// - InvisibleButton()\r\n// - ArrowButton()\r\n// - CloseButton() [Internal]\r\n// - CollapseButton() [Internal]\r\n// - Scrollbar() [Internal]\r\n// - Image()\r\n// - ImageButton()\r\n// - Checkbox()\r\n// - CheckboxFlags()\r\n// - RadioButton()\r\n// - ProgressBar()\r\n// - Bullet()\r\n//-------------------------------------------------------------------------\r\n\r\nbool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    if (flags & ImGuiButtonFlags_Disabled)\r\n    {\r\n        if (out_hovered) *out_hovered = false;\r\n        if (out_held) *out_held = false;\r\n        if (g.ActiveId == id) ClearActiveID();\r\n        return false;\r\n    }\r\n\r\n    // Default behavior requires click+release on same spot\r\n    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)\r\n        flags |= ImGuiButtonFlags_PressedOnClickRelease;\r\n\r\n    ImGuiWindow* backup_hovered_window = g.HoveredWindow;\r\n    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)\r\n        g.HoveredWindow = window;\r\n\r\n    bool pressed = false;\r\n    bool hovered = ItemHoverable(bb, id);\r\n\r\n    // Drag source doesn't report as hovered\r\n    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))\r\n        hovered = false;\r\n\r\n    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button\r\n    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))\r\n        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\r\n        {\r\n            hovered = true;\r\n            SetHoveredID(id);\r\n            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy\r\n            {\r\n                pressed = true;\r\n                FocusWindow(window);\r\n            }\r\n        }\r\n\r\n    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)\r\n        g.HoveredWindow = backup_hovered_window;\r\n\r\n    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.\r\n    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))\r\n        hovered = false;\r\n\r\n    // Mouse\r\n    if (hovered)\r\n    {\r\n        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))\r\n        {\r\n            //                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat\r\n            // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds\r\n            // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..\r\n            // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)\r\n            // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..\r\n            // FIXME-NAV: We don't honor those different behaviors.\r\n            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])\r\n            {\r\n                SetActiveID(id, window);\r\n                if (!(flags & ImGuiButtonFlags_NoNavFocus))\r\n                    SetFocusID(id, window);\r\n                FocusWindow(window);\r\n            }\r\n            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))\r\n            {\r\n                pressed = true;\r\n                if (flags & ImGuiButtonFlags_NoHoldingActiveID)\r\n                    ClearActiveID();\r\n                else\r\n                    SetActiveID(id, window); // Hold on ID\r\n                FocusWindow(window);\r\n            }\r\n            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])\r\n            {\r\n                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>\r\n                    pressed = true;\r\n                ClearActiveID();\r\n            }\r\n\r\n            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).\r\n            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.\r\n            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))\r\n                pressed = true;\r\n        }\r\n\r\n        if (pressed)\r\n            g.NavDisableHighlight = true;\r\n    }\r\n\r\n    // Gamepad/Keyboard navigation\r\n    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.\r\n    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))\r\n        hovered = true;\r\n\r\n    if (g.NavActivateDownId == id)\r\n    {\r\n        bool nav_activated_by_code = (g.NavActivateId == id);\r\n        bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);\r\n        if (nav_activated_by_code || nav_activated_by_inputs)\r\n            pressed = true;\r\n        if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)\r\n        {\r\n            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.\r\n            g.NavActivateId = id; // This is so SetActiveId assign a Nav source\r\n            SetActiveID(id, window);\r\n            if (!(flags & ImGuiButtonFlags_NoNavFocus))\r\n                SetFocusID(id, window);\r\n            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);\r\n        }\r\n    }\r\n\r\n    bool held = false;\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (g.ActiveIdSource == ImGuiInputSource_Mouse)\r\n        {\r\n            if (g.ActiveIdIsJustActivated)\r\n                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;\r\n            if (g.IO.MouseDown[0])\r\n            {\r\n                held = true;\r\n            }\r\n            else\r\n            {\r\n                if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))\r\n                    if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>\r\n                        if (!g.DragDropActive)\r\n                            pressed = true;\r\n                ClearActiveID();\r\n            }\r\n            if (!(flags & ImGuiButtonFlags_NoNavFocus))\r\n                g.NavDisableHighlight = true;\r\n        }\r\n        else if (g.ActiveIdSource == ImGuiInputSource_Nav)\r\n        {\r\n            if (g.NavActivateDownId != id)\r\n                ClearActiveID();\r\n        }\r\n    }\r\n\r\n    if (out_hovered) *out_hovered = hovered;\r\n    if (out_held) *out_held = held;\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)\r\n        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;\r\n    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);\r\n\r\n    const ImRect bb(pos, pos + size);\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)\r\n        flags |= ImGuiButtonFlags_Repeat;\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\r\n    if (pressed)\r\n        MarkItemEdited(id);\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n    RenderNavHighlight(bb, id);\r\n    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);\r\n    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);\r\n\r\n    // Automatically close popups\r\n    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))\r\n    //    CloseCurrentPopup();\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::Button(const char* label, const ImVec2& size_arg)\r\n{\r\n    return ButtonEx(label, size_arg, 0);\r\n}\r\n\r\n// Small buttons fits within text without additional vertical spacing.\r\nbool ImGui::SmallButton(const char* label)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    float backup_padding_y = g.Style.FramePadding.y;\r\n    g.Style.FramePadding.y = 0.0f;\r\n    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);\r\n    g.Style.FramePadding.y = backup_padding_y;\r\n    return pressed;\r\n}\r\n\r\n// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.\r\n// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)\r\nbool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.\r\n    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);\r\n\r\n    const ImGuiID id = window->GetID(str_id);\r\n    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiID id = window->GetID(str_id);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    const float default_size = GetFrameHeight();\r\n    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)\r\n        flags |= ImGuiButtonFlags_Repeat;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n    RenderNavHighlight(bb, id);\r\n    RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);\r\n    RenderArrow(bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), dir);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)\r\n{\r\n    float sz = GetFrameHeight();\r\n    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);\r\n}\r\n\r\n// Button to close a window\r\nbool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.\r\n    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).\r\n    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));\r\n    bool is_clipped = !ItemAdd(bb, id);\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n    if (is_clipped)\r\n        return pressed;\r\n\r\n    // Render\r\n    ImVec2 center = bb.GetCenter();\r\n    if (hovered)\r\n        window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);\r\n\r\n    float cross_extent = (radius * 0.7071f) - 1.0f;\r\n    ImU32 cross_col = GetColorU32(ImGuiCol_Text);\r\n    center -= ImVec2(0.5f, 0.5f);\r\n    window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);\r\n    window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);\r\n    ItemAdd(bb, id);\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);\r\n\r\n    ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n    if (hovered || held)\r\n        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);\r\n    RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);\r\n\r\n    // Switch to moving the window after mouse is moved beyond the initial drag threshold\r\n    if (IsItemActive() && IsMouseDragging())\r\n        StartMouseMovingWindow(window);\r\n\r\n    return pressed;\r\n}\r\n\r\n// Vertical/Horizontal scrollbar\r\n// The entire piece of code below is rather confusing because:\r\n// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)\r\n// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar\r\n// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.\r\nvoid ImGui::Scrollbar(ImGuiLayoutType direction)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    const bool horizontal = (direction == ImGuiLayoutType_Horizontal);\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(horizontal ? \"#SCROLLX\" : \"#SCROLLY\");\r\n\r\n    // Render background\r\n    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);\r\n    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;\r\n    const ImRect window_rect = window->Rect();\r\n    const float border_size = window->WindowBorderSize;\r\n    ImRect bb = horizontal\r\n        ? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)\r\n        : ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);\r\n    if (!horizontal)\r\n        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);\r\n    if (bb.GetWidth() <= 0.0f || bb.GetHeight() <= 0.0f)\r\n        return;\r\n\r\n    int window_rounding_corners;\r\n    if (horizontal)\r\n        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);\r\n    else\r\n        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);\r\n    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);\r\n    bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));\r\n\r\n    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)\r\n    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();\r\n    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;\r\n    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;\r\n    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;\r\n\r\n    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)\r\n    // But we maintain a minimum size in pixel to allow for the user to still aim inside.\r\n    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.\r\n    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);\r\n    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);\r\n    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;\r\n\r\n    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().\r\n    bool held = false;\r\n    bool hovered = false;\r\n    const bool previously_held = (g.ActiveId == id);\r\n    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);\r\n\r\n    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);\r\n    float scroll_ratio = ImSaturate(scroll_v / scroll_max);\r\n    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;\r\n    if (held && grab_h_norm < 1.0f)\r\n    {\r\n        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;\r\n        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;\r\n        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;\r\n\r\n        // Click position in scrollbar normalized space (0.0f->1.0f)\r\n        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);\r\n        SetHoveredID(id);\r\n\r\n        bool seek_absolute = false;\r\n        if (!previously_held)\r\n        {\r\n            // On initial click calculate the distance between mouse and the center of the grab\r\n            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)\r\n            {\r\n                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;\r\n            }\r\n            else\r\n            {\r\n                seek_absolute = true;\r\n                *click_delta_to_grab_center_v = 0.0f;\r\n            }\r\n        }\r\n\r\n        // Apply scroll\r\n        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position\r\n        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));\r\n        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));\r\n        if (horizontal)\r\n            window->Scroll.x = scroll_v;\r\n        else\r\n            window->Scroll.y = scroll_v;\r\n\r\n        // Update values for rendering\r\n        scroll_ratio = ImSaturate(scroll_v / scroll_max);\r\n        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;\r\n\r\n        // Update distance to grab now that we have seeked and saturated\r\n        if (seek_absolute)\r\n            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;\r\n    }\r\n\r\n    // Render\r\n    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab);\r\n    ImRect grab_rect;\r\n    if (horizontal)\r\n        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);\r\n    else\r\n        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));\r\n    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);\r\n}\r\n\r\nvoid ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    if (border_col.w > 0.0f)\r\n        bb.Max += ImVec2(2, 2);\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    if (border_col.w > 0.0f)\r\n    {\r\n        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);\r\n        window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));\r\n    }\r\n    else\r\n    {\r\n        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));\r\n    }\r\n}\r\n\r\n// frame_padding < 0: uses FramePadding from style (default)\r\n// frame_padding = 0: no framing\r\n// frame_padding > 0: set framing size\r\n// The color used are the button colors.\r\nbool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    // Default to using texture ID as ID. User can still push string/integer prefixes.\r\n    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.\r\n    PushID((void*)(intptr_t)user_texture_id);\r\n    const ImGuiID id = window->GetID(\"#image\");\r\n    PopID();\r\n\r\n    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);\r\n    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n    RenderNavHighlight(bb, id);\r\n    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));\r\n    if (bg_col.w > 0.0f)\r\n        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));\r\n    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::Checkbox(const char* label, bool* v)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2)); // We want a square shape to we use Y twice\r\n    ItemSize(check_bb, style.FramePadding.y);\r\n\r\n    ImRect total_bb = check_bb;\r\n    if (label_size.x > 0)\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n    const ImRect text_bb(window->DC.CursorPos + ImVec2(0,style.FramePadding.y), window->DC.CursorPos + ImVec2(0,style.FramePadding.y) + label_size);\r\n    if (label_size.x > 0)\r\n    {\r\n        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);\r\n        total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));\r\n    }\r\n\r\n    if (!ItemAdd(total_bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);\r\n    if (pressed)\r\n    {\r\n        *v = !(*v);\r\n        MarkItemEdited(id);\r\n    }\r\n\r\n    RenderNavHighlight(total_bb, id);\r\n    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);\r\n    if (*v)\r\n    {\r\n        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());\r\n        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));\r\n        RenderCheckMark(check_bb.Min + ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), check_bb.GetWidth() - pad*2.0f);\r\n    }\r\n\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&text_bb.Min, *v ? \"[x]\" : \"[ ]\");\r\n    if (label_size.x > 0.0f)\r\n        RenderText(text_bb.Min, label);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)\r\n{\r\n    bool v = ((*flags & flags_value) == flags_value);\r\n    bool pressed = Checkbox(label, &v);\r\n    if (pressed)\r\n    {\r\n        if (v)\r\n            *flags |= flags_value;\r\n        else\r\n            *flags &= ~flags_value;\r\n    }\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::RadioButton(const char* label, bool active)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2-1, label_size.y + style.FramePadding.y*2-1));\r\n    ItemSize(check_bb, style.FramePadding.y);\r\n\r\n    ImRect total_bb = check_bb;\r\n    if (label_size.x > 0)\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n    const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);\r\n    if (label_size.x > 0)\r\n    {\r\n        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);\r\n        total_bb.Add(text_bb);\r\n    }\r\n\r\n    if (!ItemAdd(total_bb, id))\r\n        return false;\r\n\r\n    ImVec2 center = check_bb.GetCenter();\r\n    center.x = (float)(int)center.x + 0.5f;\r\n    center.y = (float)(int)center.y + 0.5f;\r\n    const float radius = check_bb.GetHeight() * 0.5f;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);\r\n    if (pressed)\r\n        MarkItemEdited(id);\r\n\r\n    RenderNavHighlight(total_bb, id);\r\n    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);\r\n    if (active)\r\n    {\r\n        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());\r\n        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));\r\n        window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);\r\n    }\r\n\r\n    if (style.FrameBorderSize > 0.0f)\r\n    {\r\n        window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);\r\n        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);\r\n    }\r\n\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&text_bb.Min, active ? \"(x)\" : \"( )\");\r\n    if (label_size.x > 0.0f)\r\n        RenderText(text_bb.Min, label);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::RadioButton(const char* label, int* v, int v_button)\r\n{\r\n    const bool pressed = RadioButton(label, *v == v_button);\r\n    if (pressed)\r\n        *v = v_button;\r\n    return pressed;\r\n}\r\n\r\n// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size\r\nvoid ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f));\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    // Render\r\n    fraction = ImSaturate(fraction);\r\n    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));\r\n    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);\r\n    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);\r\n\r\n    // Default displaying the fraction as percentage string, but user can override it\r\n    char overlay_buf[32];\r\n    if (!overlay)\r\n    {\r\n        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), \"%.0f%%\", fraction*100+0.01f);\r\n        overlay = overlay_buf;\r\n    }\r\n\r\n    ImVec2 overlay_size = CalcTextSize(overlay, NULL);\r\n    if (overlay_size.x > 0.0f)\r\n        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);\r\n}\r\n\r\nvoid ImGui::Bullet()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, 0))\r\n    {\r\n        SameLine(0, style.FramePadding.x*2);\r\n        return;\r\n    }\r\n\r\n    // Render and stay on same line\r\n    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));\r\n    SameLine(0, style.FramePadding.x*2);\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: Low-level Layout helpers\r\n//-------------------------------------------------------------------------\r\n// - Spacing()\r\n// - Dummy()\r\n// - NewLine()\r\n// - AlignTextToFramePadding()\r\n// - Separator()\r\n// - VerticalSeparator() [Internal]\r\n// - SplitterBehavior() [Internal]\r\n//-------------------------------------------------------------------------\r\n\r\nvoid ImGui::Spacing()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ItemSize(ImVec2(0,0));\r\n}\r\n\r\nvoid ImGui::Dummy(const ImVec2& size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    ItemSize(bb);\r\n    ItemAdd(bb, 0);\r\n}\r\n\r\nvoid ImGui::NewLine()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;\r\n    window->DC.LayoutType = ImGuiLayoutType_Vertical;\r\n    if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.\r\n        ItemSize(ImVec2(0,0));\r\n    else\r\n        ItemSize(ImVec2(0.0f, g.FontSize));\r\n    window->DC.LayoutType = backup_layout_type;\r\n}\r\n\r\nvoid ImGui::AlignTextToFramePadding()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);\r\n    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);\r\n}\r\n\r\n// Horizontal/vertical separating line\r\nvoid ImGui::Separator()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Those flags should eventually be overridable by the user\r\n    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected\r\n    if (flags & ImGuiSeparatorFlags_Vertical)\r\n    {\r\n        VerticalSeparator();\r\n        return;\r\n    }\r\n\r\n    // Horizontal Separator\r\n    if (window->DC.ColumnsSet)\r\n        PopClipRect();\r\n\r\n    float x1 = window->Pos.x;\r\n    float x2 = window->Pos.x + window->Size.x;\r\n    if (!window->DC.GroupStack.empty())\r\n        x1 += window->DC.Indent.x;\r\n\r\n    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));\r\n    ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.\r\n    if (!ItemAdd(bb, 0))\r\n    {\r\n        if (window->DC.ColumnsSet)\r\n            PushColumnClipRect();\r\n        return;\r\n    }\r\n\r\n    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));\r\n\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&bb.Min, \"--------------------------------\");\r\n\r\n    if (window->DC.ColumnsSet)\r\n    {\r\n        PushColumnClipRect();\r\n        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;\r\n    }\r\n}\r\n\r\nvoid ImGui::VerticalSeparator()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    float y1 = window->DC.CursorPos.y;\r\n    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;\r\n    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));\r\n    ItemSize(ImVec2(bb.GetWidth(), 0.0f));\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));\r\n    if (g.LogEnabled)\r\n        LogText(\" |\");\r\n}\r\n\r\n// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.\r\nbool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;\r\n    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;\r\n    bool item_add = ItemAdd(bb, id);\r\n    window->DC.ItemFlags = item_flags_backup;\r\n    if (!item_add)\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    ImRect bb_interact = bb;\r\n    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));\r\n    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);\r\n    if (g.ActiveId != id)\r\n        SetItemAllowOverlap();\r\n\r\n    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))\r\n        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);\r\n\r\n    ImRect bb_render = bb;\r\n    if (held)\r\n    {\r\n        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;\r\n        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;\r\n\r\n        // Minimum pane size\r\n        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);\r\n        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);\r\n        if (mouse_delta < -size_1_maximum_delta)\r\n            mouse_delta = -size_1_maximum_delta;\r\n        if (mouse_delta > size_2_maximum_delta)\r\n            mouse_delta = size_2_maximum_delta;\r\n\r\n        // Apply resize\r\n        if (mouse_delta != 0.0f)\r\n        {\r\n            if (mouse_delta < 0.0f)\r\n                IM_ASSERT(*size1 + mouse_delta >= min_size1);\r\n            if (mouse_delta > 0.0f)\r\n                IM_ASSERT(*size2 - mouse_delta >= min_size2);\r\n            *size1 += mouse_delta;\r\n            *size2 -= mouse_delta;\r\n            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));\r\n            MarkItemEdited(id);\r\n        }\r\n    }\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);\r\n    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);\r\n\r\n    return held;\r\n}\r\n\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: ComboBox\r\n//-------------------------------------------------------------------------\r\n// - BeginCombo()\r\n// - EndCombo()\r\n// - Combo()\r\n//-------------------------------------------------------------------------\r\n\r\nstatic float CalcMaxPopupHeightFromItemCount(int items_count)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (items_count <= 0)\r\n        return FLT_MAX;\r\n    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);\r\n}\r\n\r\nbool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)\r\n{\r\n    // Always consume the SetNextWindowSizeConstraint() call in our early return paths\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;\r\n    g.NextWindowData.SizeConstraintCond = 0;\r\n\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together\r\n\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n\r\n    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    if (!ItemAdd(total_bb, id, &frame_bb))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);\r\n    bool popup_open = IsPopupOpen(id);\r\n\r\n    const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));\r\n    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\r\n    RenderNavHighlight(frame_bb, id);\r\n    if (!(flags & ImGuiComboFlags_NoPreview))\r\n        window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);\r\n    if (!(flags & ImGuiComboFlags_NoArrowButton))\r\n    {\r\n        window->DrawList->AddRectFilled(ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);\r\n        RenderArrow(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);\r\n    }\r\n    RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);\r\n    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))\r\n        RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f,0.0f));\r\n    if (label_size.x > 0)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    if ((pressed || g.NavActivateId == id) && !popup_open)\r\n    {\r\n        if (window->DC.NavLayerCurrent == 0)\r\n            window->NavLastIds[0] = id;\r\n        OpenPopupEx(id);\r\n        popup_open = true;\r\n    }\r\n\r\n    if (!popup_open)\r\n        return false;\r\n\r\n    if (backup_next_window_size_constraint)\r\n    {\r\n        g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;\r\n        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);\r\n    }\r\n    else\r\n    {\r\n        if ((flags & ImGuiComboFlags_HeightMask_) == 0)\r\n            flags |= ImGuiComboFlags_HeightRegular;\r\n        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one\r\n        int popup_max_height_in_items = -1;\r\n        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;\r\n        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;\r\n        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;\r\n        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));\r\n    }\r\n\r\n    char name[16];\r\n    ImFormatString(name, IM_ARRAYSIZE(name), \"##Combo_%02d\", g.CurrentPopupStack.Size); // Recycle windows based on depth\r\n\r\n    // Peak into expected window size so we can position it\r\n    if (ImGuiWindow* popup_window = FindWindowByName(name))\r\n        if (popup_window->WasActive)\r\n        {\r\n            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);\r\n            if (flags & ImGuiComboFlags_PopupAlignLeft)\r\n                popup_window->AutoPosLastDirection = ImGuiDir_Left;\r\n            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);\r\n            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);\r\n            SetNextWindowPos(pos);\r\n        }\r\n\r\n    // Horizontally align ourselves with the framed text\r\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;\r\n    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));\r\n    bool ret = Begin(name, NULL, window_flags);\r\n    PopStyleVar();\r\n    if (!ret)\r\n    {\r\n        EndPopup();\r\n        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid ImGui::EndCombo()\r\n{\r\n    EndPopup();\r\n}\r\n\r\n// Getter for the old Combo() API: const char*[]\r\nstatic bool Items_ArrayGetter(void* data, int idx, const char** out_text)\r\n{\r\n    const char* const* items = (const char* const*)data;\r\n    if (out_text)\r\n        *out_text = items[idx];\r\n    return true;\r\n}\r\n\r\n// Getter for the old Combo() API: \"item1\\0item2\\0item3\\0\"\r\nstatic bool Items_SingleStringGetter(void* data, int idx, const char** out_text)\r\n{\r\n    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.\r\n    const char* items_separated_by_zeros = (const char*)data;\r\n    int items_count = 0;\r\n    const char* p = items_separated_by_zeros;\r\n    while (*p)\r\n    {\r\n        if (idx == items_count)\r\n            break;\r\n        p += strlen(p) + 1;\r\n        items_count++;\r\n    }\r\n    if (!*p)\r\n        return false;\r\n    if (out_text)\r\n        *out_text = p;\r\n    return true;\r\n}\r\n\r\n// Old API, prefer using BeginCombo() nowadays if you can.\r\nbool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Call the getter to obtain the preview string which is a parameter to BeginCombo()\r\n    const char* preview_value = NULL;\r\n    if (*current_item >= 0 && *current_item < items_count)\r\n        items_getter(data, *current_item, &preview_value);\r\n\r\n    // The old Combo() API exposed \"popup_max_height_in_items\". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.\r\n    if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)\r\n        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));\r\n\r\n    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))\r\n        return false;\r\n\r\n    // Display items\r\n    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)\r\n    bool value_changed = false;\r\n    for (int i = 0; i < items_count; i++)\r\n    {\r\n        PushID((void*)(intptr_t)i);\r\n        const bool item_selected = (i == *current_item);\r\n        const char* item_text;\r\n        if (!items_getter(data, i, &item_text))\r\n            item_text = \"*Unknown item*\";\r\n        if (Selectable(item_text, item_selected))\r\n        {\r\n            value_changed = true;\r\n            *current_item = i;\r\n        }\r\n        if (item_selected)\r\n            SetItemDefaultFocus();\r\n        PopID();\r\n    }\r\n\r\n    EndCombo();\r\n    return value_changed;\r\n}\r\n\r\n// Combo box helper allowing to pass an array of strings.\r\nbool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)\r\n{\r\n    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);\r\n    return value_changed;\r\n}\r\n\r\n// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items \"item1\\0item2\\0\" \r\nbool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)\r\n{\r\n    int items_count = 0;\r\n    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open\r\n    while (*p)\r\n    {\r\n        p += strlen(p) + 1;\r\n        items_count++;\r\n    }\r\n    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);\r\n    return value_changed;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Data Type and Data Formatting Helpers [Internal]\r\n//-------------------------------------------------------------------------\r\n// - PatchFormatStringFloatToInt()\r\n// - DataTypeFormatString()\r\n// - DataTypeApplyOp()\r\n// - DataTypeApplyOpFromText()\r\n// - GetMinimumStepAtDecimalPrecision\r\n// - RoundScalarWithFormat<>()\r\n//-------------------------------------------------------------------------\r\n\r\nstruct ImGuiDataTypeInfo\r\n{\r\n    size_t      Size;\r\n    const char* PrintFmt;   // Unused\r\n    const char* ScanFmt;\r\n};\r\n\r\nstatic const ImGuiDataTypeInfo GDataTypeInfo[] =\r\n{\r\n    { sizeof(int),          \"%d\",   \"%d\"    },\r\n    { sizeof(unsigned int), \"%u\",   \"%u\"    },\r\n#ifdef _MSC_VER\r\n    { sizeof(ImS64),        \"%I64d\",\"%I64d\" },\r\n    { sizeof(ImU64),        \"%I64u\",\"%I64u\" },\r\n#else\r\n    { sizeof(ImS64),        \"%lld\", \"%lld\"  },\r\n    { sizeof(ImU64),        \"%llu\", \"%llu\"  },\r\n#endif\r\n    { sizeof(float),        \"%f\",   \"%f\"    },  // float are promoted to double in va_arg\r\n    { sizeof(double),       \"%f\",   \"%lf\"   },\r\n};\r\nIM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);\r\n\r\n// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was \"%.0f\".\r\n// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.\r\n// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!\r\nstatic const char* PatchFormatStringFloatToInt(const char* fmt)\r\n{\r\n    if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for \"%.0f\" which is expected to be the most common case.\r\n        return \"%d\";\r\n    const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)\r\n    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).\r\n    if (fmt_end > fmt_start && fmt_end[-1] == 'f')\r\n    {\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n        if (fmt_start == fmt && fmt_end[0] == 0)\r\n            return \"%d\";\r\n        ImGuiContext& g = *GImGui;\r\n        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), \"%.*s%%d%s\", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.\r\n        return g.TempBuffer;\r\n#else\r\n        IM_ASSERT(0 && \"DragInt(): Invalid format string!\"); // Old versions used a default parameter of \"%.0f\", please replace with e.g. \"%d\"\r\n#endif\r\n    }\r\n    return fmt;\r\n}\r\n\r\nstatic inline int DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)\r\n{\r\n    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)   // Signedness doesn't matter when pushing the argument\r\n        return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);\r\n    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)   // Signedness doesn't matter when pushing the argument\r\n        return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);\r\n    if (data_type == ImGuiDataType_Float)\r\n        return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);\r\n    if (data_type == ImGuiDataType_Double)\r\n        return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);\r\n    IM_ASSERT(0);\r\n    return 0;\r\n}\r\n\r\n// FIXME: Adding support for clamping on boundaries of the data type would be nice.\r\nstatic void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)\r\n{\r\n    IM_ASSERT(op == '+' || op == '-');\r\n    switch (data_type)\r\n    {\r\n        case ImGuiDataType_S32:\r\n            if (op == '+')      *(int*)output = *(const int*)arg1 + *(const int*)arg2;\r\n            else if (op == '-') *(int*)output = *(const int*)arg1 - *(const int*)arg2;\r\n            return;\r\n        case ImGuiDataType_U32:\r\n            if (op == '+')      *(unsigned int*)output = *(const unsigned int*)arg1 + *(const ImU32*)arg2;\r\n            else if (op == '-') *(unsigned int*)output = *(const unsigned int*)arg1 - *(const ImU32*)arg2;\r\n            return;\r\n        case ImGuiDataType_S64:\r\n            if (op == '+')      *(ImS64*)output = *(const ImS64*)arg1 + *(const ImS64*)arg2;\r\n            else if (op == '-') *(ImS64*)output = *(const ImS64*)arg1 - *(const ImS64*)arg2;\r\n            return;\r\n        case ImGuiDataType_U64:\r\n            if (op == '+')      *(ImU64*)output = *(const ImU64*)arg1 + *(const ImU64*)arg2;\r\n            else if (op == '-') *(ImU64*)output = *(const ImU64*)arg1 - *(const ImU64*)arg2;\r\n            return;\r\n        case ImGuiDataType_Float:\r\n            if (op == '+')      *(float*)output = *(const float*)arg1 + *(const float*)arg2;\r\n            else if (op == '-') *(float*)output = *(const float*)arg1 - *(const float*)arg2;\r\n            return;\r\n        case ImGuiDataType_Double:\r\n            if (op == '+')      *(double*)output = *(const double*)arg1 + *(const double*)arg2;\r\n            else if (op == '-') *(double*)output = *(const double*)arg1 - *(const double*)arg2;\r\n            return;\r\n        case ImGuiDataType_COUNT: break;\r\n    }\r\n    IM_ASSERT(0);\r\n}\r\n\r\n// User can input math operators (e.g. +100) to edit a numerical values.\r\n// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..\r\nstatic bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)\r\n{\r\n    while (ImCharIsBlankA(*buf))\r\n        buf++;\r\n\r\n    // We don't support '-' op because it would conflict with inputing negative value.\r\n    // Instead you can use +-100 to subtract from an existing value\r\n    char op = buf[0];\r\n    if (op == '+' || op == '*' || op == '/')\r\n    {\r\n        buf++;\r\n        while (ImCharIsBlankA(*buf))\r\n            buf++;\r\n    }\r\n    else\r\n    {\r\n        op = 0;\r\n    }\r\n    if (!buf[0])\r\n        return false;\r\n\r\n    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.\r\n    IM_ASSERT(data_type < ImGuiDataType_COUNT);\r\n    int data_backup[2];\r\n    IM_ASSERT(GDataTypeInfo[data_type].Size <= sizeof(data_backup));\r\n    memcpy(data_backup, data_ptr, GDataTypeInfo[data_type].Size);\r\n\r\n    if (format == NULL)\r\n        format = GDataTypeInfo[data_type].ScanFmt;\r\n\r\n    int arg1i = 0;\r\n    if (data_type == ImGuiDataType_S32)\r\n    {\r\n        int* v = (int*)data_ptr;\r\n        int arg0i = *v;\r\n        float arg1f = 0.0f;\r\n        if (op && sscanf(initial_value_buf, format, &arg0i) < 1)\r\n            return false;\r\n        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision\r\n        if (op == '+')      { if (sscanf(buf, \"%d\", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use \"+-\" to subtract)\r\n        else if (op == '*') { if (sscanf(buf, \"%f\", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply\r\n        else if (op == '/') { if (sscanf(buf, \"%f\", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide\r\n        else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant\r\n    }\r\n    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)\r\n    {\r\n        // Assign constant\r\n        // FIXME: We don't bother handling support for legacy operators since they are a little too crappy. Instead we may implement a proper expression evaluator in the future.\r\n        sscanf(buf, format, data_ptr);\r\n    }\r\n    else if (data_type == ImGuiDataType_Float)\r\n    {\r\n        // For floats we have to ignore format with precision (e.g. \"%.2f\") because sscanf doesn't take them in\r\n        format = \"%f\";\r\n        float* v = (float*)data_ptr;\r\n        float arg0f = *v, arg1f = 0.0f;\r\n        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)\r\n            return false;\r\n        if (sscanf(buf, format, &arg1f) < 1)\r\n            return false;\r\n        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use \"+-\" to subtract)\r\n        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply\r\n        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide\r\n        else                { *v = arg1f; }                            // Assign constant\r\n    }\r\n    else if (data_type == ImGuiDataType_Double)\r\n    {\r\n        format = \"%lf\"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis\r\n        double* v = (double*)data_ptr;\r\n        double arg0f = *v, arg1f = 0.0;\r\n        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)\r\n            return false;\r\n        if (sscanf(buf, format, &arg1f) < 1)\r\n            return false;\r\n        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use \"+-\" to subtract)\r\n        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply\r\n        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide\r\n        else                { *v = arg1f; }                            // Assign constant\r\n    }\r\n    return memcmp(data_backup, data_ptr, GDataTypeInfo[data_type].Size) != 0;\r\n}\r\n\r\nstatic float GetMinimumStepAtDecimalPrecision(int decimal_precision)\r\n{\r\n    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };\r\n    if (decimal_precision < 0)\r\n        return FLT_MIN;\r\n    return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);\r\n}\r\n\r\ntemplate<typename TYPE>\r\nstatic const char* ImAtoi(const char* src, TYPE* output)\r\n{\r\n    int negative = 0;\r\n    if (*src == '-') { negative = 1; src++; }\r\n    if (*src == '+') { src++; }\r\n    TYPE v = 0;\r\n    while (*src >= '0' && *src <= '9')\r\n        v = (v * 10) + (*src++ - '0');\r\n    *output = negative ? -v : v;\r\n    return src;\r\n}\r\n\r\ntemplate<typename TYPE, typename SIGNEDTYPE>\r\nTYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)\r\n{\r\n    const char* fmt_start = ImParseFormatFindStart(format);\r\n    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string\r\n        return v;\r\n    char v_str[64];\r\n    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);\r\n    const char* p = v_str;\r\n    while (*p == ' ')\r\n        p++;\r\n    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)\r\n        v = (TYPE)ImAtof(p);\r\n    else\r\n        ImAtoi(p, (SIGNEDTYPE*)&v);\r\n    return v;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\r\n//-------------------------------------------------------------------------\r\n// - DragBehaviorT<>() [Internal]\r\n// - DragBehavior() [Internal]\r\n// - DragScalar()\r\n// - DragScalarN()\r\n// - DragFloat()\r\n// - DragFloat2()\r\n// - DragFloat3()\r\n// - DragFloat4()\r\n// - DragFloatRange2()\r\n// - DragInt()\r\n// - DragInt2()\r\n// - DragInt3()\r\n// - DragInt4()\r\n// - DragIntRange2()\r\n//-------------------------------------------------------------------------\r\n\r\n// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)\r\ntemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>\r\nbool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;\r\n    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);\r\n    const bool has_min_max = (v_min != v_max);\r\n\r\n    // Default tweak speed\r\n    if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))\r\n        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);\r\n\r\n    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings\r\n    float adjust_delta = 0.0f;\r\n    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)\r\n    {\r\n        adjust_delta = g.IO.MouseDelta[axis];\r\n        if (g.IO.KeyAlt)\r\n            adjust_delta *= 1.0f / 100.0f;\r\n        if (g.IO.KeyShift)\r\n            adjust_delta *= 10.0f;\r\n    }\r\n    else if (g.ActiveIdSource == ImGuiInputSource_Nav)\r\n    {\r\n        int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;\r\n        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];\r\n        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));\r\n    }\r\n    adjust_delta *= v_speed;\r\n\r\n    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.\r\n    if (axis == ImGuiAxis_Y)\r\n        adjust_delta = -adjust_delta;\r\n\r\n    // Clear current value on activation\r\n    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.\r\n    bool is_just_activated = g.ActiveIdIsJustActivated;\r\n    bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));\r\n    if (is_just_activated || is_already_past_limits_and_pushing_outward)\r\n    {\r\n        g.DragCurrentAccum = 0.0f;\r\n        g.DragCurrentAccumDirty = false;\r\n    }\r\n    else if (adjust_delta != 0.0f)\r\n    {\r\n        g.DragCurrentAccum += adjust_delta;\r\n        g.DragCurrentAccumDirty = true;\r\n    }\r\n\r\n    if (!g.DragCurrentAccumDirty)\r\n        return false;\r\n\r\n    TYPE v_cur = *v;\r\n    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;\r\n\r\n    const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));\r\n    if (is_power)\r\n    {\r\n        // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range\r\n        FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);\r\n        FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));\r\n        v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);\r\n        v_old_ref_for_accum_remainder = v_old_norm_curved;\r\n    }\r\n    else\r\n    {\r\n        v_cur += (TYPE)g.DragCurrentAccum;\r\n    }\r\n\r\n    // Round to user desired precision based on format string\r\n    v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);\r\n\r\n    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.\r\n    g.DragCurrentAccumDirty = false;\r\n    if (is_power)\r\n    {\r\n        FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);\r\n        g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);\r\n    }\r\n    else\r\n    {\r\n        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);\r\n    }\r\n\r\n    // Lose zero sign for float/double\r\n    if (v_cur == (TYPE)-0)\r\n        v_cur = (TYPE)0;\r\n\r\n    // Clamp values (+ handle overflow/wrap-around for integer types)\r\n    if (*v != v_cur && has_min_max)\r\n    {\r\n        if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))\r\n            v_cur = v_min;\r\n        if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))\r\n            v_cur = v_max;\r\n    }\r\n\r\n    // Apply result\r\n    if (*v == v_cur)\r\n        return false;\r\n    *v = v_cur;\r\n    return true;\r\n}\r\n\r\nbool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])\r\n            ClearActiveID();\r\n        else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)\r\n            ClearActiveID();\r\n    }\r\n    if (g.ActiveId != id)\r\n        return false;\r\n\r\n    switch (data_type)\r\n    {\r\n    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v,  v_speed, v_min ? *(const ImS32* )v_min : IM_S32_MIN, v_max ? *(const ImS32* )v_max : IM_S32_MAX, format, power, flags);\r\n    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v,  v_speed, v_min ? *(const ImU32* )v_min : IM_U32_MIN, v_max ? *(const ImU32* )v_max : IM_U32_MAX, format, power, flags);\r\n    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v,  v_speed, v_min ? *(const ImS64* )v_min : IM_S64_MIN, v_max ? *(const ImS64* )v_max : IM_S64_MAX, format, power, flags);\r\n    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v,  v_speed, v_min ? *(const ImU64* )v_min : IM_U64_MIN, v_max ? *(const ImU64* )v_max : IM_U64_MAX, format, power, flags);\r\n    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v,  v_speed, v_min ? *(const float* )v_min : -FLT_MAX,   v_max ? *(const float* )v_max : FLT_MAX,    format, power, flags);\r\n    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX,   v_max ? *(const double*)v_max : DBL_MAX,    format, power, flags);\r\n    case ImGuiDataType_COUNT:  break;\r\n    }\r\n    IM_ASSERT(0);\r\n    return false;\r\n}\r\n\r\nbool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    if (power != 1.0f)\r\n        IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));\r\n    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n\r\n    // NB- we don't call ItemSize() yet because we may turn into a text edit box below\r\n    if (!ItemAdd(total_bb, id, &frame_bb))\r\n    {\r\n        ItemSize(total_bb, style.FramePadding.y);\r\n        return false;\r\n    }\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n\r\n    // Default format string when passing NULL\r\n    // Patch old \"%.0f\" format string to use \"%d\", read function comments for more details.\r\n    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);\r\n    if (format == NULL)\r\n        format = GDataTypeInfo[data_type].PrintFmt;\r\n    else if (data_type == ImGuiDataType_S32 && strcmp(format, \"%d\") != 0)\r\n        format = PatchFormatStringFloatToInt(format);\r\n\r\n    // Tabbing or CTRL-clicking on Drag turns it into an input box\r\n    bool start_text_input = false;\r\n    const bool tab_focus_requested = FocusableItemRegister(window, id);\r\n    if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))\r\n    {\r\n        SetActiveID(id, window);\r\n        SetFocusID(id, window);\r\n        FocusWindow(window);\r\n        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);\r\n        if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)\r\n        {\r\n            start_text_input = true;\r\n            g.ScalarAsInputTextId = 0;\r\n        }\r\n    }\r\n    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))\r\n    {\r\n        FocusableItemUnregister(window);\r\n        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);\r\n    }\r\n\r\n    // Actual drag behavior\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, ImGuiDragFlags_None);\r\n    if (value_changed)\r\n        MarkItemEdited(id);\r\n\r\n    // Draw frame\r\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\r\n    RenderNavHighlight(frame_bb, id);\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);\r\n\r\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\r\n    char value_buf[64];\r\n    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);\r\n    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));\r\n\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    size_t type_size = GDataTypeInfo[data_type].Size;\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= DragScalar(\"##v\", data_type, v, v_speed, v_min, v_max, format, power);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n        v = (void*)((char*)v + type_size);\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)\r\n{\r\n    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)\r\n{\r\n    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)\r\n{\r\n    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)\r\n{\r\n    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    PushID(label);\r\n    BeginGroup();\r\n    PushMultiItemsWidths(2);\r\n\r\n    bool value_changed = DragFloat(\"##min\", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n    value_changed |= DragFloat(\"##max\", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    PopID();\r\n    return value_changed;\r\n}\r\n\r\n// NB: v_speed is float to allow adjusting the drag speed with more precision\r\nbool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)\r\n{\r\n    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)\r\n{\r\n    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)\r\n{\r\n    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)\r\n{\r\n    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    PushID(label);\r\n    BeginGroup();\r\n    PushMultiItemsWidths(2);\r\n\r\n    bool value_changed = DragInt(\"##min\", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n    value_changed |= DragInt(\"##max\", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    PopID();\r\n\r\n    return value_changed;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\r\n//-------------------------------------------------------------------------\r\n// - SliderBehaviorT<>() [Internal]\r\n// - SliderBehavior() [Internal]\r\n// - SliderScalar()\r\n// - SliderScalarN()\r\n// - SliderFloat()\r\n// - SliderFloat2()\r\n// - SliderFloat3()\r\n// - SliderFloat4()\r\n// - SliderAngle()\r\n// - SliderInt()\r\n// - SliderInt2()\r\n// - SliderInt3()\r\n// - SliderInt4()\r\n// - VSliderScalar()\r\n// - VSliderFloat()\r\n// - VSliderInt()\r\n//-------------------------------------------------------------------------\r\n\r\ntemplate<typename TYPE, typename FLOATTYPE>\r\nfloat ImGui::SliderCalcRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)\r\n{\r\n    if (v_min == v_max)\r\n        return 0.0f;\r\n\r\n    const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);\r\n    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);\r\n    if (is_power)\r\n    {\r\n        if (v_clamped < 0.0f)\r\n        {\r\n            const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));\r\n            return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;\r\n        }\r\n        else\r\n        {\r\n            const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));\r\n            return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);\r\n        }\r\n    }\r\n\r\n    // Linear slider\r\n    return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));\r\n}\r\n\r\n// FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.\r\ntemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>\r\nbool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;\r\n    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);\r\n    const bool is_power = (power != 1.0f) && is_decimal;\r\n\r\n    const float grab_padding = 2.0f;\r\n    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;\r\n    float grab_sz = style.GrabMinSize;\r\n    SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);\r\n    if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows\r\n        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit\r\n    grab_sz = ImMin(grab_sz, slider_sz);\r\n    const float slider_usable_sz = slider_sz - grab_sz;\r\n    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz*0.5f;\r\n    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz*0.5f;\r\n\r\n    // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f\r\n    float linear_zero_pos;   // 0.0->1.0f\r\n    if (is_power && v_min * v_max < 0.0f)\r\n    {\r\n        // Different sign\r\n        const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f/power);\r\n        const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f/power);\r\n        linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));\r\n    }\r\n    else\r\n    {\r\n        // Same sign\r\n        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;\r\n    }\r\n\r\n    // Process interacting with the slider\r\n    bool value_changed = false;\r\n    if (g.ActiveId == id)\r\n    {\r\n        bool set_new_value = false;\r\n        float clicked_t = 0.0f;\r\n        if (g.ActiveIdSource == ImGuiInputSource_Mouse)\r\n        {\r\n            if (!g.IO.MouseDown[0])\r\n            {\r\n                ClearActiveID();\r\n            }\r\n            else\r\n            {\r\n                const float mouse_abs_pos = g.IO.MousePos[axis];\r\n                clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;\r\n                if (axis == ImGuiAxis_Y)\r\n                    clicked_t = 1.0f - clicked_t;\r\n                set_new_value = true;\r\n            }\r\n        }\r\n        else if (g.ActiveIdSource == ImGuiInputSource_Nav)\r\n        {\r\n            const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);\r\n            float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;\r\n            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)\r\n            {\r\n                ClearActiveID();\r\n            }\r\n            else if (delta != 0.0f)\r\n            {\r\n                clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);\r\n                const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;\r\n                if ((decimal_precision > 0) || is_power)\r\n                {\r\n                    delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds\r\n                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))\r\n                        delta /= 10.0f;\r\n                }\r\n                else\r\n                {\r\n                    if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))\r\n                        delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps\r\n                    else\r\n                        delta /= 100.0f;\r\n                }\r\n                if (IsNavInputDown(ImGuiNavInput_TweakFast))\r\n                    delta *= 10.0f;\r\n                set_new_value = true;\r\n                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits\r\n                    set_new_value = false;\r\n                else\r\n                    clicked_t = ImSaturate(clicked_t + delta);\r\n            }\r\n        }\r\n\r\n        if (set_new_value)\r\n        {\r\n            TYPE v_new;\r\n            if (is_power)\r\n            {\r\n                // Account for power curve scale on both sides of the zero\r\n                if (clicked_t < linear_zero_pos)\r\n                {\r\n                    // Negative: rescale to the negative range before powering\r\n                    float a = 1.0f - (clicked_t / linear_zero_pos);\r\n                    a = ImPow(a, power);\r\n                    v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);\r\n                }\r\n                else\r\n                {\r\n                    // Positive: rescale to the positive range before powering\r\n                    float a;\r\n                    if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)\r\n                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);\r\n                    else\r\n                        a = clicked_t;\r\n                    a = ImPow(a, power);\r\n                    v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Linear slider\r\n                if (is_decimal)\r\n                {\r\n                    v_new = ImLerp(v_min, v_max, clicked_t);\r\n                }\r\n                else\r\n                {\r\n                    // For integer values we want the clicking position to match the grab box so we round above\r\n                    // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..\r\n                    FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;\r\n                    TYPE v_new_off_floor = (TYPE)(v_new_off_f);\r\n                    TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);\r\n                    if (!is_decimal && v_new_off_floor < v_new_off_round)\r\n                        v_new = v_min + v_new_off_round;\r\n                    else\r\n                        v_new = v_min + v_new_off_floor;\r\n                }\r\n            }\r\n\r\n            // Round to user desired precision based on format string\r\n            v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);\r\n\r\n            // Apply result\r\n            if (*v != v_new)\r\n            {\r\n                *v = v_new;\r\n                value_changed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Output grab position so it can be displayed by the caller\r\n    float grab_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);\r\n    if (axis == ImGuiAxis_Y)\r\n        grab_t = 1.0f - grab_t;\r\n    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);\r\n    if (axis == ImGuiAxis_X)\r\n        *out_grab_bb = ImRect(grab_pos - grab_sz*0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz*0.5f, bb.Max.y - grab_padding);\r\n    else\r\n        *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f);\r\n\r\n    return value_changed;\r\n}\r\n\r\n// For 32-bits and larger types, slider bounds are limited to half the natural type range.\r\n// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.\r\n// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.\r\nbool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)\r\n{\r\n    switch (data_type)\r\n    {\r\n    case ImGuiDataType_S32:\r\n        IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN/2 && *(const ImS32*)v_max <= IM_S32_MAX/2);\r\n        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v,  *(const ImS32*)v_min,  *(const ImS32*)v_max,  format, power, flags, out_grab_bb);\r\n    case ImGuiDataType_U32:\r\n        IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX/2);\r\n        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v,  *(const ImU32*)v_min,  *(const ImU32*)v_max,  format, power, flags, out_grab_bb);\r\n    case ImGuiDataType_S64:\r\n        IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN/2 && *(const ImS64*)v_max <= IM_S64_MAX/2);\r\n        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v,  *(const ImS64*)v_min,  *(const ImS64*)v_max,  format, power, flags, out_grab_bb);\r\n    case ImGuiDataType_U64:\r\n        IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX/2);\r\n        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v,  *(const ImU64*)v_min,  *(const ImU64*)v_max,  format, power, flags, out_grab_bb);\r\n    case ImGuiDataType_Float:\r\n        IM_ASSERT(*(const float*)v_min >= -FLT_MAX/2.0f && *(const float*)v_max <= FLT_MAX/2.0f);\r\n        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v,  *(const float*)v_min,  *(const float*)v_max,  format, power, flags, out_grab_bb);\r\n    case ImGuiDataType_Double:\r\n        IM_ASSERT(*(const double*)v_min >= -DBL_MAX/2.0f && *(const double*)v_max <= DBL_MAX/2.0f);\r\n        return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);\r\n    case ImGuiDataType_COUNT: break;\r\n    }\r\n    IM_ASSERT(0);\r\n    return false;\r\n}\r\n\r\nbool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n\r\n    // NB- we don't call ItemSize() yet because we may turn into a text edit box below\r\n    if (!ItemAdd(total_bb, id, &frame_bb))\r\n    {\r\n        ItemSize(total_bb, style.FramePadding.y);\r\n        return false;\r\n    }\r\n\r\n    // Default format string when passing NULL\r\n    // Patch old \"%.0f\" format string to use \"%d\", read function comments for more details.\r\n    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);\r\n    if (format == NULL)\r\n        format = GDataTypeInfo[data_type].PrintFmt;\r\n    else if (data_type == ImGuiDataType_S32 && strcmp(format, \"%d\") != 0)\r\n        format = PatchFormatStringFloatToInt(format);\r\n\r\n    // Tabbing or CTRL-clicking on Slider turns it into an input box\r\n    bool start_text_input = false;\r\n    const bool tab_focus_requested = FocusableItemRegister(window, id);\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n    if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))\r\n    {\r\n        SetActiveID(id, window);\r\n        SetFocusID(id, window);\r\n        FocusWindow(window);\r\n        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);\r\n        if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)\r\n        {\r\n            start_text_input = true;\r\n            g.ScalarAsInputTextId = 0;\r\n        }\r\n    }\r\n    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))\r\n    {\r\n        FocusableItemUnregister(window);\r\n        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);\r\n    }\r\n\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n\r\n    // Draw frame\r\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\r\n    RenderNavHighlight(frame_bb, id);\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);\r\n\r\n    // Slider behavior\r\n    ImRect grab_bb;\r\n    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);\r\n    if (value_changed)\r\n        MarkItemEdited(id);\r\n\r\n    // Render grab\r\n    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);\r\n\r\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\r\n    char value_buf[64];\r\n    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);\r\n    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));\r\n\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    return value_changed;\r\n}\r\n\r\n// Add multiple sliders on 1 line for compact edition of multiple components\r\nbool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    size_t type_size = GDataTypeInfo[data_type].Size;\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= SliderScalar(\"##v\", data_type, v, v_min, v_max, format, power);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n        v = (void*)((char*)v + type_size);\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)\r\n{\r\n    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)\r\n{\r\n    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)\r\n{\r\n    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)\r\n{\r\n    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format)\r\n{\r\n    if (format == NULL)\r\n        format = \"%.0f deg\";\r\n    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);\r\n    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);\r\n    *v_rad = v_deg * (2*IM_PI) / 360.0f;\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)\r\n{\r\n    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)\r\n{\r\n    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)\r\n{\r\n    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)\r\n{\r\n    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);\r\n}\r\n\r\nbool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(frame_bb, id))\r\n        return false;\r\n\r\n    // Default format string when passing NULL\r\n    // Patch old \"%.0f\" format string to use \"%d\", read function comments for more details.\r\n    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);\r\n    if (format == NULL)\r\n        format = GDataTypeInfo[data_type].PrintFmt;\r\n    else if (data_type == ImGuiDataType_S32 && strcmp(format, \"%d\") != 0)\r\n        format = PatchFormatStringFloatToInt(format);\r\n\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n    if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)\r\n    {\r\n        SetActiveID(id, window);\r\n        SetFocusID(id, window);\r\n        FocusWindow(window);\r\n        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);\r\n    }\r\n\r\n    // Draw frame\r\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\r\n    RenderNavHighlight(frame_bb, id);\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);\r\n\r\n    // Slider behavior\r\n    ImRect grab_bb;\r\n    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);\r\n    if (value_changed)\r\n        MarkItemEdited(id);\r\n\r\n    // Render grab\r\n    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);\r\n\r\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\r\n    // For the vertical slider we allow centered text to overlap the frame padding\r\n    char value_buf[64];\r\n    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);\r\n    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)\r\n{\r\n    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);\r\n}\r\n\r\nbool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)\r\n{\r\n    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\r\n//-------------------------------------------------------------------------\r\n// - ImParseFormatFindStart() [Internal]\r\n// - ImParseFormatFindEnd() [Internal]\r\n// - ImParseFormatTrimDecorations() [Internal]\r\n// - ImParseFormatPrecision() [Internal]\r\n// - InputScalarAsWidgetReplacement() [Internal]\r\n// - InputScalar()\r\n// - InputScalarN()\r\n// - InputFloat()\r\n// - InputFloat2()\r\n// - InputFloat3()\r\n// - InputFloat4()\r\n// - InputInt()\r\n// - InputInt2()\r\n// - InputInt3()\r\n// - InputInt4()\r\n// - InputDouble()\r\n//-------------------------------------------------------------------------\r\n\r\n// We don't use strchr() because our strings are usually very short and often start with '%'\r\nconst char* ImParseFormatFindStart(const char* fmt)\r\n{\r\n    while (char c = fmt[0])\r\n    {\r\n        if (c == '%' && fmt[1] != '%')\r\n            return fmt;\r\n        else if (c == '%')\r\n            fmt++;\r\n        fmt++;\r\n    }\r\n    return fmt;\r\n}\r\n\r\nconst char* ImParseFormatFindEnd(const char* fmt)\r\n{\r\n    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.\r\n    if (fmt[0] != '%')\r\n        return fmt;\r\n    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));\r\n    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));\r\n    for (char c; (c = *fmt) != 0; fmt++)\r\n    {\r\n        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)\r\n            return fmt + 1;\r\n        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)\r\n            return fmt + 1;\r\n    }\r\n    return fmt;\r\n}\r\n\r\n// Extract the format out of a format string with leading or trailing decorations\r\n//  fmt = \"blah blah\"  -> return fmt\r\n//  fmt = \"%.3f\"       -> return fmt\r\n//  fmt = \"hello %.3f\" -> return fmt + 6\r\n//  fmt = \"%.3f hello\" -> return buf written with \"%.3f\"\r\nconst char* ImParseFormatTrimDecorations(const char* fmt, char* buf, int buf_size)\r\n{\r\n    const char* fmt_start = ImParseFormatFindStart(fmt);\r\n    if (fmt_start[0] != '%')\r\n        return fmt;\r\n    const char* fmt_end = ImParseFormatFindEnd(fmt_start);\r\n    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.\r\n        return fmt_start;\r\n    ImStrncpy(buf, fmt_start, ImMin((int)(fmt_end + 1 - fmt_start), buf_size));\r\n    return buf;\r\n}\r\n\r\n// Parse display precision back from the display format string\r\n// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.\r\nint ImParseFormatPrecision(const char* fmt, int default_precision)\r\n{\r\n    fmt = ImParseFormatFindStart(fmt);\r\n    if (fmt[0] != '%')\r\n        return default_precision;\r\n    fmt++;\r\n    while (*fmt >= '0' && *fmt <= '9')\r\n        fmt++;\r\n    int precision = INT_MAX;\r\n    if (*fmt == '.')\r\n    {\r\n        fmt = ImAtoi<int>(fmt + 1, &precision);\r\n        if (precision < 0 || precision > 99)\r\n            precision = default_precision;\r\n    }\r\n    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation\r\n        precision = -1;\r\n    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)\r\n        precision = -1;\r\n    return (precision == INT_MAX) ? default_precision : precision;\r\n}\r\n\r\n// Create text input in place of an active drag/slider (used when doing a CTRL+Click on drag/slider widgets)\r\n// FIXME: Logic is awkward and confusing. This should be reworked to facilitate using in other situations.\r\nbool ImGui::InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    // Our replacement widget will override the focus ID (registered previously to allow for a TAB focus to happen)\r\n    // On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id\r\n    SetActiveID(g.ScalarAsInputTextId, window);\r\n    SetHoveredID(0);\r\n    g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);\r\n\r\n    char fmt_buf[32];\r\n    char data_buf[32];\r\n    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));\r\n    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);\r\n    ImStrTrimBlanks(data_buf);\r\n    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);\r\n    bool value_changed = InputTextEx(label, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);\r\n    if (g.ScalarAsInputTextId == 0)     // First frame we started displaying the InputText widget\r\n    {\r\n        IM_ASSERT(g.ActiveId == id);    // InputText ID expected to match the Slider ID\r\n        g.ScalarAsInputTextId = g.ActiveId;\r\n        SetHoveredID(id);\r\n    }\r\n    if (value_changed)\r\n        return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialText.Data, data_type, data_ptr, NULL);\r\n    return false;\r\n}\r\n\r\n// NB: format here must be a simple \"%xx\" format string with no prefix/suffix (unlike the Drag/Slider functions \"format\" argument)\r\nbool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);\r\n    if (format == NULL)\r\n        format = GDataTypeInfo[data_type].PrintFmt;\r\n\r\n    char buf[64];\r\n    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);\r\n\r\n    bool value_changed = false;\r\n    if ((extra_flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)\r\n        extra_flags |= ImGuiInputTextFlags_CharsDecimal;\r\n    extra_flags |= ImGuiInputTextFlags_AutoSelectAll;\r\n\r\n    if (step != NULL)\r\n    {\r\n        const float button_size = GetFrameHeight();\r\n\r\n        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()\r\n        PushID(label);\r\n        PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));\r\n        if (InputText(\"\", buf, IM_ARRAYSIZE(buf), extra_flags)) // PushId(label) + \"\" gives us the expected ID from outside point of view\r\n            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);\r\n        PopItemWidth();\r\n\r\n        // Step buttons\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        if (ButtonEx(\"-\", ImVec2(button_size, button_size), ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))\r\n        {\r\n            DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);\r\n            value_changed = true;\r\n        }\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        if (ButtonEx(\"+\", ImVec2(button_size, button_size), ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))\r\n        {\r\n            DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);\r\n            value_changed = true;\r\n        }\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        TextUnformatted(label, FindRenderedTextEnd(label));\r\n\r\n        PopID();\r\n        EndGroup();\r\n    }\r\n    else\r\n    {\r\n        if (InputText(label, buf, IM_ARRAYSIZE(buf), extra_flags))\r\n            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);\r\n    }\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    size_t type_size = GDataTypeInfo[data_type].Size;\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= InputScalar(\"##v\", data_type, v, step, step_fast, format, extra_flags);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n        v = (void*)((char*)v + type_size);\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    extra_flags |= ImGuiInputTextFlags_CharsScientific;\r\n    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, extra_flags);\r\n}\r\n\r\n// Prefer using \"const char* format\" directly, which is more flexible and consistent with other API.\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\nbool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    char format[16] = \"%f\";\r\n    if (decimal_precision >= 0)\r\n        ImFormatString(format, IM_ARRAYSIZE(format), \"%%.%df\", decimal_precision);\r\n    return InputFloat(label, v, step, step_fast, format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    char format[16] = \"%f\";\r\n    if (decimal_precision >= 0)\r\n        ImFormatString(format, IM_ARRAYSIZE(format), \"%%.%df\", decimal_precision);\r\n    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    char format[16] = \"%f\";\r\n    if (decimal_precision >= 0)\r\n        ImFormatString(format, IM_ARRAYSIZE(format), \"%%.%df\", decimal_precision);\r\n    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    char format[16] = \"%f\";\r\n    if (decimal_precision >= 0)\r\n        ImFormatString(format, IM_ARRAYSIZE(format), \"%%.%df\", decimal_precision);\r\n    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, extra_flags);\r\n}\r\n#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n\r\nbool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)\r\n{\r\n    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.\r\n    const char* format = (extra_flags & ImGuiInputTextFlags_CharsHexadecimal) ? \"%08X\" : \"%d\";\r\n    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, \"%d\", extra_flags);\r\n}\r\n\r\nbool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, \"%d\", extra_flags);\r\n}\r\n\r\nbool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, \"%d\", extra_flags);\r\n}\r\n\r\nbool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    extra_flags |= ImGuiInputTextFlags_CharsScientific;\r\n    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, extra_flags);\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: InputText, InputTextMultiline\r\n//-------------------------------------------------------------------------\r\n// - InputText()\r\n// - InputTextMultiline()\r\n// - InputTextEx() [Internal]\r\n//-------------------------------------------------------------------------\r\n\r\nbool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\r\n{\r\n    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()\r\n    return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);\r\n}\r\n\r\nbool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\r\n{\r\n    return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);\r\n}\r\n\r\nstatic int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)\r\n{\r\n    int line_count = 0;\r\n    const char* s = text_begin;\r\n    while (char c = *s++) // We are only matching for \\n so we can ignore UTF-8 decoding\r\n        if (c == '\\n')\r\n            line_count++;\r\n    s--;\r\n    if (s[0] != '\\n' && s[0] != '\\r')\r\n        line_count++;\r\n    *out_text_end = s;\r\n    return line_count;\r\n}\r\n\r\nstatic ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)\r\n{\r\n    ImFont* font = GImGui->Font;\r\n    const float line_height = GImGui->FontSize;\r\n    const float scale = line_height / font->FontSize;\r\n\r\n    ImVec2 text_size = ImVec2(0,0);\r\n    float line_width = 0.0f;\r\n\r\n    const ImWchar* s = text_begin;\r\n    while (s < text_end)\r\n    {\r\n        unsigned int c = (unsigned int)(*s++);\r\n        if (c == '\\n')\r\n        {\r\n            text_size.x = ImMax(text_size.x, line_width);\r\n            text_size.y += line_height;\r\n            line_width = 0.0f;\r\n            if (stop_on_new_line)\r\n                break;\r\n            continue;\r\n        }\r\n        if (c == '\\r')\r\n            continue;\r\n\r\n        const float char_width = font->GetCharAdvance((ImWchar)c) * scale;\r\n        line_width += char_width;\r\n    }\r\n\r\n    if (text_size.x < line_width)\r\n        text_size.x = line_width;\r\n\r\n    if (out_offset)\r\n        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \\n\r\n\r\n    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \\n\r\n        text_size.y += line_height;\r\n\r\n    if (remaining)\r\n        *remaining = s;\r\n\r\n    return text_size;\r\n}\r\n\r\n// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)\r\nnamespace ImGuiStb\r\n{\r\n\r\nstatic int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }\r\nstatic ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }\r\nstatic float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx+char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }\r\nstatic int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }\r\nstatic ImWchar STB_TEXTEDIT_NEWLINE = '\\n';\r\nstatic void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)\r\n{\r\n    const ImWchar* text = obj->TextW.Data;\r\n    const ImWchar* text_remaining = NULL;\r\n    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);\r\n    r->x0 = 0.0f;\r\n    r->x1 = size.x;\r\n    r->baseline_y_delta = size.y;\r\n    r->ymin = 0.0f;\r\n    r->ymax = size.y;\r\n    r->num_chars = (int)(text_remaining - (text + line_start_idx));\r\n}\r\n\r\nstatic bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }\r\nstatic int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }\r\nstatic int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }\r\n#ifdef __APPLE__    // FIXME: Move setting to IO structure\r\nstatic int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }\r\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }\r\n#else\r\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }\r\n#endif\r\n#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h\r\n#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL\r\n\r\nstatic void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)\r\n{\r\n    ImWchar* dst = obj->TextW.Data + pos;\r\n\r\n    // We maintain our buffer length in both UTF-8 and wchar formats\r\n    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);\r\n    obj->CurLenW -= n;\r\n\r\n    // Offset remaining text (FIXME-OPT: Use memmove)\r\n    const ImWchar* src = obj->TextW.Data + pos + n;\r\n    while (ImWchar c = *src++)\r\n        *dst++ = c;\r\n    *dst = '\\0';\r\n}\r\n\r\nstatic bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)\r\n{\r\n    const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;\r\n    const int text_len = obj->CurLenW;\r\n    IM_ASSERT(pos <= text_len);\r\n\r\n    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);\r\n    if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))\r\n        return false;\r\n\r\n    // Grow internal buffer if needed\r\n    if (new_text_len + text_len + 1 > obj->TextW.Size)\r\n    {\r\n        if (!is_resizable)\r\n            return false;\r\n        IM_ASSERT(text_len < obj->TextW.Size);\r\n        obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);\r\n    }\r\n\r\n    ImWchar* text = obj->TextW.Data;\r\n    if (pos != text_len)\r\n        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));\r\n    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));\r\n\r\n    obj->CurLenW += new_text_len;\r\n    obj->CurLenA += new_text_len_utf8;\r\n    obj->TextW[obj->CurLenW] = '\\0';\r\n\r\n    return true;\r\n}\r\n\r\n// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)\r\n#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left\r\n#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right\r\n#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up\r\n#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down\r\n#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line\r\n#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line\r\n#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text\r\n#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text\r\n#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor\r\n#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor\r\n#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo\r\n#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo\r\n#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word\r\n#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word\r\n#define STB_TEXTEDIT_K_SHIFT        0x20000\r\n\r\n#define STB_TEXTEDIT_IMPLEMENTATION\r\n#include \"imstb_textedit.h\"\r\n\r\n}\r\n\r\nvoid ImGuiInputTextState::OnKeyPressed(int key)\r\n{\r\n    stb_textedit_key(this, &StbState, key);\r\n    CursorFollow = true;\r\n    CursorAnimReset();\r\n}\r\n\r\nImGuiInputTextCallbackData::ImGuiInputTextCallbackData()\r\n{\r\n    memset(this, 0, sizeof(*this));\r\n}\r\n\r\n// Public API to manipulate UTF-8 text\r\n// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)\r\n// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.\r\nvoid ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)\r\n{\r\n    IM_ASSERT(pos + bytes_count <= BufTextLen);\r\n    char* dst = Buf + pos;\r\n    const char* src = Buf + pos + bytes_count;\r\n    while (char c = *src++)\r\n        *dst++ = c;\r\n    *dst = '\\0';\r\n\r\n    if (CursorPos + bytes_count >= pos)\r\n        CursorPos -= bytes_count;\r\n    else if (CursorPos >= pos)\r\n        CursorPos = pos;\r\n    SelectionStart = SelectionEnd = CursorPos;\r\n    BufDirty = true;\r\n    BufTextLen -= bytes_count;\r\n}\r\n\r\nvoid ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)\r\n{\r\n    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;\r\n    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);\r\n    if (new_text_len + BufTextLen >= BufSize)\r\n    {\r\n        if (!is_resizable)\r\n            return;\r\n\r\n        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)\r\n        ImGuiContext& g = *GImGui;\r\n        ImGuiInputTextState* edit_state = &g.InputTextState;\r\n        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);\r\n        IM_ASSERT(Buf == edit_state->TempBuffer.Data);\r\n        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;\r\n        edit_state->TempBuffer.reserve(new_buf_size + 1);\r\n        Buf = edit_state->TempBuffer.Data;\r\n        BufSize = edit_state->BufCapacityA = new_buf_size;\r\n    }\r\n\r\n    if (BufTextLen != pos)\r\n        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));\r\n    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));\r\n    Buf[BufTextLen + new_text_len] = '\\0';\r\n\r\n    if (CursorPos >= pos)\r\n        CursorPos += new_text_len;\r\n    SelectionStart = SelectionEnd = CursorPos;\r\n    BufDirty = true;\r\n    BufTextLen += new_text_len;\r\n}\r\n\r\n// Return false to discard a character.\r\nstatic bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\r\n{\r\n    unsigned int c = *p_char;\r\n\r\n    if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))\r\n    {\r\n        bool pass = false;\r\n        pass |= (c == '\\n' && (flags & ImGuiInputTextFlags_Multiline));\r\n        pass |= (c == '\\t' && (flags & ImGuiInputTextFlags_AllowTabInput));\r\n        if (!pass)\r\n            return false;\r\n    }\r\n\r\n    if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.\r\n        return false;\r\n\r\n    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))\r\n    {\r\n        if (flags & ImGuiInputTextFlags_CharsDecimal)\r\n            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))\r\n                return false;\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsScientific)\r\n            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))\r\n                return false;\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsHexadecimal)\r\n            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))\r\n                return false;\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsUppercase)\r\n            if (c >= 'a' && c <= 'z')\r\n                *p_char = (c += (unsigned int)('A'-'a'));\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsNoBlank)\r\n            if (ImCharIsBlankW(c))\r\n                return false;\r\n    }\r\n\r\n    if (flags & ImGuiInputTextFlags_CallbackCharFilter)\r\n    {\r\n        ImGuiInputTextCallbackData callback_data;\r\n        memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));\r\n        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;\r\n        callback_data.EventChar = (ImWchar)c;\r\n        callback_data.Flags = flags;\r\n        callback_data.UserData = user_data;\r\n        if (callback(&callback_data) != 0)\r\n            return false;\r\n        *p_char = callback_data.EventChar;\r\n        if (!callback_data.EventChar)\r\n            return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Edit a string of text\r\n// - buf_size account for the zero-terminator, so a buf_size of 6 can hold \"Hello\" but not \"Hello!\".\r\n//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match \r\n//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.\r\n// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.\r\n// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h\r\n// (FIXME: Rather messy function partly because we are doing UTF8 > u16 > UTF8 conversions on the go to more easily handle stb_textedit calls. Ideally we should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)\r\nbool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)\r\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiIO& io = g.IO;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;\r\n    const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;\r\n    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;\r\n    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;\r\n    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;\r\n    if (is_resizable)\r\n        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!\r\n\r\n    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope, \r\n        BeginGroup();\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));\r\n\r\n    ImGuiWindow* draw_window = window;\r\n    if (is_multiline)\r\n    {\r\n        ItemAdd(total_bb, id, &frame_bb);\r\n        if (!BeginChildFrame(id, frame_bb.GetSize()))\r\n        {\r\n            EndChildFrame();\r\n            EndGroup();\r\n            return false;\r\n        }\r\n        draw_window = GetCurrentWindow();\r\n        draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight\r\n        size.x -= draw_window->ScrollbarSizes.x;\r\n    }\r\n    else\r\n    {\r\n        ItemSize(total_bb, style.FramePadding.y);\r\n        if (!ItemAdd(total_bb, id, &frame_bb))\r\n            return false;\r\n    }\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n    if (hovered)\r\n        g.MouseCursor = ImGuiMouseCursor_TextInput;\r\n\r\n    // Password pushes a temporary font with only a fallback glyph\r\n    if (is_password)\r\n    {\r\n        const ImFontGlyph* glyph = g.Font->FindGlyph('*');\r\n        ImFont* password_font = &g.InputTextPasswordFont;\r\n        password_font->FontSize = g.Font->FontSize;\r\n        password_font->Scale = g.Font->Scale;\r\n        password_font->DisplayOffset = g.Font->DisplayOffset;\r\n        password_font->Ascent = g.Font->Ascent;\r\n        password_font->Descent = g.Font->Descent;\r\n        password_font->ContainerAtlas = g.Font->ContainerAtlas;\r\n        password_font->FallbackGlyph = glyph;\r\n        password_font->FallbackAdvanceX = glyph->AdvanceX;\r\n        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());\r\n        PushFont(password_font);\r\n    }\r\n\r\n    // NB: we are only allowed to access 'edit_state' if we are the active widget.\r\n    ImGuiInputTextState& edit_state = g.InputTextState;\r\n\r\n    const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing\r\n    const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);\r\n    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;\r\n\r\n    const bool user_clicked = hovered && io.MouseClicked[0];\r\n    const bool user_scrolled = is_multiline && g.ActiveId == 0 && edit_state.ID == id && g.ActiveIdPreviousFrame == draw_window->GetIDNoKeepAlive(\"#SCROLLY\");\r\n    const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));\r\n\r\n    bool clear_active_id = false;\r\n\r\n    bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);\r\n    if (focus_requested || user_clicked || user_scrolled || user_nav_input_start)\r\n    {\r\n        if (g.ActiveId != id)\r\n        {\r\n            // Start edition\r\n            // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)\r\n            // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)\r\n            const int prev_len_w = edit_state.CurLenW;\r\n            const int init_buf_len = (int)strlen(buf);\r\n            edit_state.TextW.resize(buf_size+1);             // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.\r\n            edit_state.InitialText.resize(init_buf_len + 1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.\r\n            memcpy(edit_state.InitialText.Data, buf, init_buf_len + 1);\r\n            const char* buf_end = NULL;\r\n            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, buf_size, buf, NULL, &buf_end);\r\n            edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.\r\n            edit_state.CursorAnimReset();\r\n\r\n            // Preserve cursor position and undo/redo stack if we come back to same widget\r\n            // FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).\r\n            const bool recycle_state = (edit_state.ID == id) && (prev_len_w == edit_state.CurLenW);\r\n            if (recycle_state)\r\n            {\r\n                // Recycle existing cursor/selection/undo stack but clamp position\r\n                // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.\r\n                edit_state.CursorClamp();\r\n            }\r\n            else\r\n            {\r\n                edit_state.ID = id;\r\n                edit_state.ScrollX = 0.0f;\r\n                stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);\r\n                if (!is_multiline && focus_requested_by_code)\r\n                    select_all = true;\r\n            }\r\n            if (flags & ImGuiInputTextFlags_AlwaysInsertMode)\r\n                edit_state.StbState.insert_mode = true;\r\n            if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))\r\n                select_all = true;\r\n        }\r\n        SetActiveID(id, window);\r\n        SetFocusID(id, window);\r\n        FocusWindow(window);\r\n        if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))\r\n            g.ActiveIdAllowNavDirFlags |= ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));\r\n    }\r\n    else if (io.MouseClicked[0])\r\n    {\r\n        // Release focus when we click outside\r\n        clear_active_id = true;\r\n    }\r\n\r\n    bool value_changed = false;\r\n    bool enter_pressed = false;\r\n    int backup_current_text_length = 0;\r\n\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (!is_editable && !g.ActiveIdIsJustActivated)\r\n        {\r\n            // When read-only we always use the live data passed to the function\r\n            edit_state.TextW.resize(buf_size+1);\r\n            const char* buf_end = NULL;\r\n            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, buf, NULL, &buf_end);\r\n            edit_state.CurLenA = (int)(buf_end - buf);\r\n            edit_state.CursorClamp();\r\n        }\r\n\r\n        backup_current_text_length = edit_state.CurLenA;\r\n        edit_state.BufCapacityA = buf_size;\r\n        edit_state.UserFlags = flags;\r\n        edit_state.UserCallback = callback;\r\n        edit_state.UserCallbackData = callback_user_data;\r\n\r\n        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.\r\n        // Down the line we should have a cleaner library-wide concept of Selected vs Active.\r\n        g.ActiveIdAllowOverlap = !io.MouseDown[0];\r\n        g.WantTextInputNextFrame = 1;\r\n\r\n        // Edit in progress\r\n        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;\r\n        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));\r\n\r\n        const bool is_osx = io.ConfigMacOSXBehaviors;\r\n        if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))\r\n        {\r\n            edit_state.SelectAll();\r\n            edit_state.SelectedAllMouseLock = true;\r\n        }\r\n        else if (hovered && is_osx && io.MouseDoubleClicked[0])\r\n        {\r\n            // Double-click select a word only, OS X style (by simulating keystrokes)\r\n            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);\r\n            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);\r\n        }\r\n        else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)\r\n        {\r\n            if (hovered)\r\n            {\r\n                stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);\r\n                edit_state.CursorAnimReset();\r\n            }\r\n        }\r\n        else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))\r\n        {\r\n            stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);\r\n            edit_state.CursorAnimReset();\r\n            edit_state.CursorFollow = true;\r\n        }\r\n        if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])\r\n            edit_state.SelectedAllMouseLock = false;\r\n\r\n        if (io.InputCharacters[0])\r\n        {\r\n            // Process text input (before we check for Return because using some IME will effectively send a Return?)\r\n            // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.\r\n            bool ignore_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);\r\n            if (!ignore_inputs && is_editable && !user_nav_input_start)\r\n                for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)\r\n                {\r\n                    // Insert character if they pass filtering\r\n                    unsigned int c = (unsigned int)io.InputCharacters[n];\r\n                    if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))\r\n                        edit_state.OnKeyPressed((int)c);\r\n                }\r\n\r\n            // Consume characters\r\n            memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));\r\n        }\r\n    }\r\n\r\n    bool cancel_edit = false;\r\n    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)\r\n    {\r\n        // Handle key-presses\r\n        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);\r\n        const bool is_osx = io.ConfigMacOSXBehaviors;\r\n        const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl\r\n        const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;\r\n        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl\r\n        const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End\r\n        const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;\r\n        const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;\r\n\r\n        const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && is_editable && !is_password && (!is_multiline || edit_state.HasSelection());\r\n        const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || edit_state.HasSelection());\r\n        const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && is_editable;\r\n        const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && is_editable && is_undoable);\r\n        const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && is_editable && is_undoable;\r\n\r\n        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_Home))                        { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_End))                         { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable)       { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)\r\n        {\r\n            if (!edit_state.HasSelection())\r\n            {\r\n                if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);\r\n                else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);\r\n            }\r\n            edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);\r\n        }\r\n        else if (IsKeyPressedMap(ImGuiKey_Enter))\r\n        {\r\n            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;\r\n            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))\r\n            {\r\n                enter_pressed = clear_active_id = true;\r\n            }\r\n            else if (is_editable)\r\n            {\r\n                unsigned int c = '\\n'; // Insert new line\r\n                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))\r\n                    edit_state.OnKeyPressed((int)c);\r\n            }\r\n        }\r\n        else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)\r\n        {\r\n            unsigned int c = '\\t'; // Insert TAB\r\n            if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))\r\n                edit_state.OnKeyPressed((int)c);\r\n        }\r\n        else if (IsKeyPressedMap(ImGuiKey_Escape))\r\n        {\r\n            clear_active_id = cancel_edit = true;\r\n        }\r\n        else if (is_undo || is_redo)\r\n        {\r\n            edit_state.OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);\r\n            edit_state.ClearSelection();\r\n        }\r\n        else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))\r\n        {\r\n            edit_state.SelectAll();\r\n            edit_state.CursorFollow = true;\r\n        }\r\n        else if (is_cut || is_copy)\r\n        {\r\n            // Cut, Copy\r\n            if (io.SetClipboardTextFn)\r\n            {\r\n                const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;\r\n                const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;\r\n                edit_state.TempBuffer.resize((ie-ib) * 4 + 1);\r\n                ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data+ib, edit_state.TextW.Data+ie);\r\n                SetClipboardText(edit_state.TempBuffer.Data);\r\n            }\r\n            if (is_cut)\r\n            {\r\n                if (!edit_state.HasSelection())\r\n                    edit_state.SelectAll();\r\n                edit_state.CursorFollow = true;\r\n                stb_textedit_cut(&edit_state, &edit_state.StbState);\r\n            }\r\n        }\r\n        else if (is_paste)\r\n        {\r\n            if (const char* clipboard = GetClipboardText())\r\n            {\r\n                // Filter pasted buffer\r\n                const int clipboard_len = (int)strlen(clipboard);\r\n                ImWchar* clipboard_filtered = (ImWchar*)MemAlloc((clipboard_len+1) * sizeof(ImWchar));\r\n                int clipboard_filtered_len = 0;\r\n                for (const char* s = clipboard; *s; )\r\n                {\r\n                    unsigned int c;\r\n                    s += ImTextCharFromUtf8(&c, s, NULL);\r\n                    if (c == 0)\r\n                        break;\r\n                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))\r\n                        continue;\r\n                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;\r\n                }\r\n                clipboard_filtered[clipboard_filtered_len] = 0;\r\n                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation\r\n                {\r\n                    stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);\r\n                    edit_state.CursorFollow = true;\r\n                }\r\n                MemFree(clipboard_filtered);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (g.ActiveId == id)\r\n    {\r\n        const char* apply_new_text = NULL;\r\n        int apply_new_text_length = 0;\r\n        if (cancel_edit)\r\n        {\r\n            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.\r\n            if (is_editable && strcmp(buf, edit_state.InitialText.Data) != 0)\r\n            {\r\n                apply_new_text = edit_state.InitialText.Data;\r\n                apply_new_text_length = edit_state.InitialText.Size - 1;\r\n            }\r\n        }\r\n\r\n        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.\r\n        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.\r\n        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);\r\n        if (apply_edit_back_to_user_buffer)\r\n        {\r\n            // Apply new value immediately - copy modified buffer back\r\n            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer\r\n            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.\r\n            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.\r\n            if (is_editable)\r\n            {\r\n                edit_state.TempBuffer.resize(edit_state.TextW.Size * 4 + 1);\r\n                ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data, NULL);\r\n            }\r\n\r\n            // User callback\r\n            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)\r\n            {\r\n                IM_ASSERT(callback != NULL);\r\n\r\n                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.\r\n                ImGuiInputTextFlags event_flag = 0;\r\n                ImGuiKey event_key = ImGuiKey_COUNT;\r\n                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))\r\n                {\r\n                    event_flag = ImGuiInputTextFlags_CallbackCompletion;\r\n                    event_key = ImGuiKey_Tab;\r\n                }\r\n                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))\r\n                {\r\n                    event_flag = ImGuiInputTextFlags_CallbackHistory;\r\n                    event_key = ImGuiKey_UpArrow;\r\n                }\r\n                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))\r\n                {\r\n                    event_flag = ImGuiInputTextFlags_CallbackHistory;\r\n                    event_key = ImGuiKey_DownArrow;\r\n                }\r\n                else if (flags & ImGuiInputTextFlags_CallbackAlways)\r\n                    event_flag = ImGuiInputTextFlags_CallbackAlways;\r\n\r\n                if (event_flag)\r\n                {\r\n                    ImGuiInputTextCallbackData callback_data;\r\n                    memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));\r\n                    callback_data.EventFlag = event_flag;\r\n                    callback_data.Flags = flags;\r\n                    callback_data.UserData = callback_user_data;\r\n\r\n                    callback_data.EventKey = event_key;\r\n                    callback_data.Buf = edit_state.TempBuffer.Data;\r\n                    callback_data.BufTextLen = edit_state.CurLenA;\r\n                    callback_data.BufSize = edit_state.BufCapacityA;\r\n                    callback_data.BufDirty = false;\r\n\r\n                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)\r\n                    ImWchar* text = edit_state.TextW.Data;\r\n                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);\r\n                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);\r\n                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);\r\n\r\n                    // Call user code\r\n                    callback(&callback_data);\r\n\r\n                    // Read back what user may have modified\r\n                    IM_ASSERT(callback_data.Buf == edit_state.TempBuffer.Data);  // Invalid to modify those fields\r\n                    IM_ASSERT(callback_data.BufSize == edit_state.BufCapacityA);\r\n                    IM_ASSERT(callback_data.Flags == flags);\r\n                    if (callback_data.CursorPos != utf8_cursor_pos)            { edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); edit_state.CursorFollow = true; }\r\n                    if (callback_data.SelectionStart != utf8_selection_start)  { edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }\r\n                    if (callback_data.SelectionEnd != utf8_selection_end)      { edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }\r\n                    if (callback_data.BufDirty)\r\n                    {\r\n                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!\r\n                        if (callback_data.BufTextLen > backup_current_text_length && is_resizable)\r\n                            edit_state.TextW.resize(edit_state.TextW.Size + (callback_data.BufTextLen - backup_current_text_length));\r\n                        edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, callback_data.Buf, NULL);\r\n                        edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()\r\n                        edit_state.CursorAnimReset();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Will copy result string if modified\r\n            if (is_editable && strcmp(edit_state.TempBuffer.Data, buf) != 0)\r\n            {\r\n                apply_new_text = edit_state.TempBuffer.Data;\r\n                apply_new_text_length = edit_state.CurLenA;\r\n            }\r\n        }\r\n\r\n        // Copy result to user buffer\r\n        if (apply_new_text)\r\n        {\r\n            IM_ASSERT(apply_new_text_length >= 0);\r\n            if (backup_current_text_length != apply_new_text_length && is_resizable)\r\n            {\r\n                ImGuiInputTextCallbackData callback_data;\r\n                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;\r\n                callback_data.Flags = flags;\r\n                callback_data.Buf = buf;\r\n                callback_data.BufTextLen = apply_new_text_length;\r\n                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);\r\n                callback_data.UserData = callback_user_data;\r\n                callback(&callback_data);\r\n                buf = callback_data.Buf;\r\n                buf_size = callback_data.BufSize;\r\n                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);\r\n                IM_ASSERT(apply_new_text_length <= buf_size);\r\n            }\r\n\r\n            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.\r\n            ImStrncpy(buf, edit_state.TempBuffer.Data, ImMin(apply_new_text_length + 1, buf_size));\r\n            value_changed = true;\r\n        }\r\n\r\n        // Clear temporary user storage\r\n        edit_state.UserFlags = 0;\r\n        edit_state.UserCallback = NULL;\r\n        edit_state.UserCallbackData = NULL;\r\n    }\r\n\r\n    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)\r\n    if (clear_active_id && g.ActiveId == id)\r\n        ClearActiveID();\r\n\r\n    // Render\r\n    // Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.\r\n    const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempBuffer.Data : buf; buf = NULL;\r\n\r\n    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line\r\n    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.\r\n    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.\r\n    const int buf_display_max_length = 2 * 1024 * 1024;\r\n\r\n    if (!is_multiline)\r\n    {\r\n        RenderNavHighlight(frame_bb, id);\r\n        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n    }\r\n\r\n    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size\r\n    ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;\r\n    ImVec2 text_size(0.f, 0.f);\r\n    const bool is_currently_scrolling = (edit_state.ID == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive(\"#SCROLLY\"));\r\n    if (g.ActiveId == id || is_currently_scrolling)\r\n    {\r\n        edit_state.CursorAnim += io.DeltaTime;\r\n\r\n        // This is going to be messy. We need to:\r\n        // - Display the text (this alone can be more easily clipped)\r\n        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)\r\n        // - Measure text height (for scrollbar)\r\n        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)\r\n        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.\r\n        const ImWchar* text_begin = edit_state.TextW.Data;\r\n        ImVec2 cursor_offset, select_start_offset;\r\n\r\n        {\r\n            // Count lines + find lines numbers straddling 'cursor' and 'select_start' position.\r\n            const ImWchar* searches_input_ptr[2];\r\n            searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;\r\n            searches_input_ptr[1] = NULL;\r\n            int searches_remaining = 1;\r\n            int searches_result_line_number[2] = { -1, -999 };\r\n            if (edit_state.StbState.select_start != edit_state.StbState.select_end)\r\n            {\r\n                searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);\r\n                searches_result_line_number[1] = -1;\r\n                searches_remaining++;\r\n            }\r\n\r\n            // Iterate all lines to find our line numbers\r\n            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.\r\n            searches_remaining += is_multiline ? 1 : 0;\r\n            int line_count = 0;\r\n            //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bits\r\n            for (const ImWchar* s = text_begin; *s != 0; s++)\r\n                if (*s == '\\n')\r\n                {\r\n                    line_count++;\r\n                    if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }\r\n                    if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }\r\n                }\r\n            line_count++;\r\n            if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;\r\n            if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;\r\n\r\n            // Calculate 2d position by finding the beginning of the line and measuring distance\r\n            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;\r\n            cursor_offset.y = searches_result_line_number[0] * g.FontSize;\r\n            if (searches_result_line_number[1] >= 0)\r\n            {\r\n                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;\r\n                select_start_offset.y = searches_result_line_number[1] * g.FontSize;\r\n            }\r\n\r\n            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)\r\n            if (is_multiline)\r\n                text_size = ImVec2(size.x, line_count * g.FontSize);\r\n        }\r\n\r\n        // Scroll\r\n        if (edit_state.CursorFollow)\r\n        {\r\n            // Horizontal scroll in chunks of quarter width\r\n            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))\r\n            {\r\n                const float scroll_increment_x = size.x * 0.25f;\r\n                if (cursor_offset.x < edit_state.ScrollX)\r\n                    edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);\r\n                else if (cursor_offset.x - size.x >= edit_state.ScrollX)\r\n                    edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);\r\n            }\r\n            else\r\n            {\r\n                edit_state.ScrollX = 0.0f;\r\n            }\r\n\r\n            // Vertical scroll\r\n            if (is_multiline)\r\n            {\r\n                float scroll_y = draw_window->Scroll.y;\r\n                if (cursor_offset.y - g.FontSize < scroll_y)\r\n                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);\r\n                else if (cursor_offset.y - size.y >= scroll_y)\r\n                    scroll_y = cursor_offset.y - size.y;\r\n                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // To avoid a frame of lag\r\n                draw_window->Scroll.y = scroll_y;\r\n                render_pos.y = draw_window->DC.CursorPos.y;\r\n            }\r\n        }\r\n        edit_state.CursorFollow = false;\r\n        const ImVec2 render_scroll = ImVec2(edit_state.ScrollX, 0.0f);\r\n\r\n        // Draw selection\r\n        if (edit_state.StbState.select_start != edit_state.StbState.select_end)\r\n        {\r\n            const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);\r\n            const ImWchar* text_selected_end = text_begin + ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end);\r\n\r\n            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.\r\n            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;\r\n            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);\r\n            ImVec2 rect_pos = render_pos + select_start_offset - render_scroll;\r\n            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )\r\n            {\r\n                if (rect_pos.y > clip_rect.w + g.FontSize)\r\n                    break;\r\n                if (rect_pos.y < clip_rect.y)\r\n                {\r\n                    //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits\r\n                    //p = p ? p + 1 : text_selected_end;\r\n                    while (p < text_selected_end)\r\n                        if (*p++ == '\\n')\r\n                            break;\r\n                }\r\n                else\r\n                {\r\n                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);\r\n                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines\r\n                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));\r\n                    rect.ClipWith(clip_rect);\r\n                    if (rect.Overlaps(clip_rect))\r\n                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);\r\n                }\r\n                rect_pos.x = render_pos.x - render_scroll.x;\r\n                rect_pos.y += g.FontSize;\r\n            }\r\n        }\r\n\r\n        const int buf_display_len = edit_state.CurLenA;\r\n        if (is_multiline || buf_display_len < buf_display_max_length)\r\n            draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + buf_display_len, 0.0f, is_multiline ? NULL : &clip_rect);\r\n\r\n        // Draw blinking cursor\r\n        bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (g.InputTextState.CursorAnim <= 0.0f) || ImFmod(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;\r\n        ImVec2 cursor_screen_pos = render_pos + cursor_offset - render_scroll;\r\n        ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);\r\n        if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))\r\n            draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));\r\n\r\n        // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)\r\n        if (is_editable)\r\n            g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);\r\n    }\r\n    else\r\n    {\r\n        // Render text only\r\n        const char* buf_end = NULL;\r\n        if (is_multiline)\r\n            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width\r\n        else\r\n            buf_end = buf_display + strlen(buf_display);\r\n        if (is_multiline || (buf_end - buf_display) < buf_display_max_length)\r\n            draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);\r\n    }\r\n\r\n    if (is_multiline)\r\n    {\r\n        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line\r\n        EndChildFrame();\r\n        EndGroup();\r\n    }\r\n\r\n    if (is_password)\r\n        PopFont();\r\n\r\n    // Log as text\r\n    if (g.LogEnabled && !is_password)\r\n        LogRenderedText(&render_pos, buf_display, NULL);\r\n\r\n    if (label_size.x > 0)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    if (value_changed)\r\n        MarkItemEdited(id);\r\n\r\n    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)\r\n        return enter_pressed;\r\n    else\r\n        return value_changed;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\r\n//-------------------------------------------------------------------------\r\n// - ColorEdit3()\r\n// - ColorEdit4()\r\n// - ColorPicker3()\r\n// - RenderColorRectWithAlphaCheckerboard() [Internal]\r\n// - ColorPicker4()\r\n// - ColorButton()\r\n// - SetColorEditOptions()\r\n// - ColorTooltip() [Internal]\r\n// - ColorEditOptionsPopup() [Internal]\r\n// - ColorPickerOptionsPopup() [Internal]\r\n//-------------------------------------------------------------------------\r\n\r\nbool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)\r\n{\r\n    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);\r\n}\r\n\r\n// Edit colors components (each component in 0.0f..1.0f range).\r\n// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\r\n// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.\r\nbool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const float square_sz = GetFrameHeight();\r\n    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);\r\n    const float w_items_all = CalcItemWidth() - w_extra;\r\n    const char* label_display_end = FindRenderedTextEnd(label);\r\n\r\n    BeginGroup();\r\n    PushID(label);\r\n\r\n    // If we're not showing any slider there's no point in doing any HSV conversions\r\n    const ImGuiColorEditFlags flags_untouched = flags;\r\n    if (flags & ImGuiColorEditFlags_NoInputs)\r\n        flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;\r\n\r\n    // Context menu: display and modify options (before defaults are applied)\r\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n        ColorEditOptionsPopup(col, flags);\r\n\r\n    // Read stored options\r\n    if (!(flags & ImGuiColorEditFlags__InputsMask))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);\r\n    if (!(flags & ImGuiColorEditFlags__DataTypeMask))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);\r\n    if (!(flags & ImGuiColorEditFlags__PickerMask))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);\r\n    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));\r\n\r\n    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;\r\n    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;\r\n    const int components = alpha ? 4 : 3;\r\n\r\n    // Convert to the formats we need\r\n    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };\r\n    if (flags & ImGuiColorEditFlags_HSV)\r\n        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);\r\n    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };\r\n\r\n    bool value_changed = false;\r\n    bool value_changed_as_float = false;\r\n\r\n    if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)\r\n    {\r\n        // RGB/HSV 0..255 Sliders\r\n        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));\r\n        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));\r\n\r\n        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? \"M:0.000\" : \"M:000\").x);\r\n        const char* ids[4] = { \"##X\", \"##Y\", \"##Z\", \"##W\" };\r\n        const char* fmt_table_int[3][4] =\r\n        {\r\n            {   \"%3d\",   \"%3d\",   \"%3d\",   \"%3d\" }, // Short display\r\n            { \"R:%3d\", \"G:%3d\", \"B:%3d\", \"A:%3d\" }, // Long display for RGBA\r\n            { \"H:%3d\", \"S:%3d\", \"V:%3d\", \"A:%3d\" }  // Long display for HSVA\r\n        };\r\n        const char* fmt_table_float[3][4] =\r\n        {\r\n            {   \"%0.3f\",   \"%0.3f\",   \"%0.3f\",   \"%0.3f\" }, // Short display\r\n            { \"R:%0.3f\", \"G:%0.3f\", \"B:%0.3f\", \"A:%0.3f\" }, // Long display for RGBA\r\n            { \"H:%0.3f\", \"S:%0.3f\", \"V:%0.3f\", \"A:%0.3f\" }  // Long display for HSVA\r\n        };\r\n        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;\r\n\r\n        PushItemWidth(w_item_one);\r\n        for (int n = 0; n < components; n++)\r\n        {\r\n            if (n > 0)\r\n                SameLine(0, style.ItemInnerSpacing.x);\r\n            if (n + 1 == components)\r\n                PushItemWidth(w_item_last);\r\n            if (flags & ImGuiColorEditFlags_Float)\r\n                value_changed = value_changed_as_float = value_changed | DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);\r\n            else\r\n                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);\r\n            if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n                OpenPopupOnItemClick(\"context\");\r\n        }\r\n        PopItemWidth();\r\n        PopItemWidth();\r\n    }\r\n    else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)\r\n    {\r\n        // RGB Hexadecimal Input\r\n        char buf[64];\r\n        if (alpha)\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X%02X\", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));\r\n        else\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X\", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));\r\n        PushItemWidth(w_items_all);\r\n        if (InputText(\"##Text\", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))\r\n        {\r\n            value_changed = true;\r\n            char* p = buf;\r\n            while (*p == '#' || ImCharIsBlankA(*p))\r\n                p++;\r\n            i[0] = i[1] = i[2] = i[3] = 0;\r\n            if (alpha)\r\n                sscanf(p, \"%02X%02X%02X%02X\", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)\r\n            else\r\n                sscanf(p, \"%02X%02X%02X\", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n        PopItemWidth();\r\n    }\r\n\r\n    ImGuiWindow* picker_active_window = NULL;\r\n    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))\r\n    {\r\n        if (!(flags & ImGuiColorEditFlags_NoInputs))\r\n            SameLine(0, style.ItemInnerSpacing.x);\r\n\r\n        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);\r\n        if (ColorButton(\"##ColorButton\", col_v4, flags))\r\n        {\r\n            if (!(flags & ImGuiColorEditFlags_NoPicker))\r\n            {\r\n                // Store current color and open a picker\r\n                g.ColorPickerRef = col_v4;\r\n                OpenPopup(\"picker\");\r\n                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));\r\n            }\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n\r\n        if (BeginPopup(\"picker\"))\r\n        {\r\n            picker_active_window = g.CurrentWindow;\r\n            if (label != label_display_end)\r\n            {\r\n                TextUnformatted(label, label_display_end);\r\n                Spacing();\r\n            }\r\n            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;\r\n            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;\r\n            PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?\r\n            value_changed |= ColorPicker4(\"##picker\", col, picker_flags, &g.ColorPickerRef.x);\r\n            PopItemWidth();\r\n            EndPopup();\r\n        }\r\n    }\r\n\r\n    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))\r\n    {\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        TextUnformatted(label, label_display_end);\r\n    }\r\n\r\n    // Convert back\r\n    if (picker_active_window == NULL)\r\n    {\r\n        if (!value_changed_as_float)\r\n            for (int n = 0; n < 4; n++)\r\n                f[n] = i[n] / 255.0f;\r\n        if (flags & ImGuiColorEditFlags_HSV)\r\n            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);\r\n        if (value_changed)\r\n        {\r\n            col[0] = f[0];\r\n            col[1] = f[1];\r\n            col[2] = f[2];\r\n            if (alpha)\r\n                col[3] = f[3];\r\n        }\r\n    }\r\n\r\n    PopID();\r\n    EndGroup();\r\n\r\n    // Drag and Drop Target\r\n    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.\r\n    if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())\r\n    {\r\n        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))\r\n        {\r\n            memcpy((float*)col, payload->Data, sizeof(float) * 3);\r\n            value_changed = true;\r\n        }\r\n        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))\r\n        {\r\n            memcpy((float*)col, payload->Data, sizeof(float) * components);\r\n            value_changed = true;\r\n        }\r\n        EndDragDropTarget();\r\n    }\r\n\r\n    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().\r\n    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)\r\n        window->DC.LastItemId = g.ActiveId;\r\n\r\n    if (value_changed)\r\n        MarkItemEdited(window->DC.LastItemId);\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)\r\n{\r\n    float col4[4] = { col[0], col[1], col[2], 1.0f };\r\n    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))\r\n        return false;\r\n    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];\r\n    return true;\r\n}\r\n\r\nstatic inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)\r\n{\r\n    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;\r\n    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);\r\n    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);\r\n    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);\r\n    return IM_COL32(r, g, b, 0xFF);\r\n}\r\n\r\n// Helper for ColorPicker4()\r\n// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.\r\n// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.\r\nvoid ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)\r\n    {\r\n        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));\r\n        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));\r\n        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);\r\n\r\n        int yi = 0;\r\n        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)\r\n        {\r\n            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);\r\n            if (y2 <= y1)\r\n                continue;\r\n            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)\r\n            {\r\n                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);\r\n                if (x2 <= x1)\r\n                    continue;\r\n                int rounding_corners_flags_cell = 0;\r\n                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }\r\n                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }\r\n                rounding_corners_flags_cell &= rounding_corners_flags;\r\n                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);\r\n    }\r\n}\r\n\r\n// Helper for ColorPicker4()\r\nstatic void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)\r\n{\r\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);\r\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);\r\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);\r\n    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);\r\n}\r\n\r\n// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\r\n// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)\r\nbool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    ImDrawList* draw_list = window->DrawList;\r\n\r\n    ImGuiStyle& style = g.Style;\r\n    ImGuiIO& io = g.IO;\r\n\r\n    PushID(label);\r\n    BeginGroup();\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\r\n        flags |= ImGuiColorEditFlags_NoSmallPreview;\r\n\r\n    // Context menu: display and store options.\r\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n        ColorPickerOptionsPopup(col, flags);\r\n\r\n    // Read stored options\r\n    if (!(flags & ImGuiColorEditFlags__PickerMask))\r\n        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected\r\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);\r\n\r\n    // Setup\r\n    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;\r\n    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);\r\n    ImVec2 picker_pos = window->DC.CursorPos;\r\n    float square_sz = GetFrameHeight();\r\n    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars\r\n    float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box\r\n    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;\r\n    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;\r\n    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);\r\n\r\n    float backup_initial_col[4];\r\n    memcpy(backup_initial_col, col, components * sizeof(float));\r\n\r\n    float wheel_thickness = sv_picker_size * 0.08f;\r\n    float wheel_r_outer = sv_picker_size * 0.50f;\r\n    float wheel_r_inner = wheel_r_outer - wheel_thickness;\r\n    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);\r\n\r\n    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.\r\n    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);\r\n    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.\r\n    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.\r\n    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.\r\n\r\n    float H,S,V;\r\n    ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);\r\n\r\n    bool value_changed = false, value_changed_h = false, value_changed_sv = false;\r\n\r\n    PushItemFlag(ImGuiItemFlags_NoNav, true);\r\n    if (flags & ImGuiColorEditFlags_PickerHueWheel)\r\n    {\r\n        // Hue wheel + SV triangle logic\r\n        InvisibleButton(\"hsv\", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;\r\n            ImVec2 current_off = g.IO.MousePos - wheel_center;\r\n            float initial_dist2 = ImLengthSqr(initial_off);\r\n            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))\r\n            {\r\n                // Interactive with Hue wheel\r\n                H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;\r\n                if (H < 0.0f)\r\n                    H += 1.0f;\r\n                value_changed = value_changed_h = true;\r\n            }\r\n            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);\r\n            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);\r\n            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))\r\n            {\r\n                // Interacting with SV triangle\r\n                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);\r\n                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))\r\n                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);\r\n                float uu, vv, ww;\r\n                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);\r\n                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);\r\n                S = ImClamp(uu / V, 0.0001f, 1.0f);\r\n                value_changed = value_changed_sv = true;\r\n            }\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n    }\r\n    else if (flags & ImGuiColorEditFlags_PickerHueBar)\r\n    {\r\n        // SV rectangle logic\r\n        InvisibleButton(\"sv\", ImVec2(sv_picker_size, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));\r\n            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));\r\n            value_changed = value_changed_sv = true;\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n\r\n        // Hue bar logic\r\n        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));\r\n        InvisibleButton(\"hue\", ImVec2(bars_width, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));\r\n            value_changed = value_changed_h = true;\r\n        }\r\n    }\r\n\r\n    // Alpha bar logic\r\n    if (alpha_bar)\r\n    {\r\n        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));\r\n        InvisibleButton(\"alpha\", ImVec2(bars_width, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));\r\n            value_changed = true;\r\n        }\r\n    }\r\n    PopItemFlag(); // ImGuiItemFlags_NoNav\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\r\n    {\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        BeginGroup();\r\n    }\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoLabel))\r\n    {\r\n        const char* label_display_end = FindRenderedTextEnd(label);\r\n        if (label != label_display_end)\r\n        {\r\n            if ((flags & ImGuiColorEditFlags_NoSidePreview))\r\n                SameLine(0, style.ItemInnerSpacing.x);\r\n            TextUnformatted(label, label_display_end);\r\n        }\r\n    }\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\r\n    {\r\n        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);\r\n        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\r\n        if ((flags & ImGuiColorEditFlags_NoLabel))\r\n            Text(\"Current\");\r\n        ColorButton(\"##current\", col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2));\r\n        if (ref_col != NULL)\r\n        {\r\n            Text(\"Original\");\r\n            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);\r\n            if (ColorButton(\"##original\", ref_col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2)))\r\n            {\r\n                memcpy(col, ref_col, components * sizeof(float));\r\n                value_changed = true;\r\n            }\r\n        }\r\n        PopItemFlag();\r\n        EndGroup();\r\n    }\r\n\r\n    // Convert back color to RGB\r\n    if (value_changed_h || value_changed_sv)\r\n        ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);\r\n\r\n    // R,G,B and H,S,V slider color editor\r\n    bool value_changed_fix_hue_wrap = false;\r\n    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)\r\n    {\r\n        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);\r\n        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;\r\n        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;\r\n        if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n            if (ColorEdit4(\"##rgb\", col, sub_flags | ImGuiColorEditFlags_RGB))\r\n            {\r\n                // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.\r\n                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)\r\n                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);\r\n                value_changed = true;\r\n            }\r\n        if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n            value_changed |= ColorEdit4(\"##hsv\", col, sub_flags | ImGuiColorEditFlags_HSV);\r\n        if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n            value_changed |= ColorEdit4(\"##hex\", col, sub_flags | ImGuiColorEditFlags_HEX);\r\n        PopItemWidth();\r\n    }\r\n\r\n    // Try to cancel hue wrap (after ColorEdit4 call), if any\r\n    if (value_changed_fix_hue_wrap)\r\n    {\r\n        float new_H, new_S, new_V;\r\n        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);\r\n        if (new_H <= 0 && H > 0)\r\n        {\r\n            if (new_V <= 0 && V != new_V)\r\n                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);\r\n            else if (new_S <= 0)\r\n                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);\r\n        }\r\n    }\r\n\r\n    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);\r\n    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);\r\n    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));\r\n\r\n    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };\r\n    ImVec2 sv_cursor_pos;\r\n\r\n    if (flags & ImGuiColorEditFlags_PickerHueWheel)\r\n    {\r\n        // Render Hue Wheel\r\n        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).\r\n        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);\r\n        for (int n = 0; n < 6; n++)\r\n        {\r\n            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;\r\n            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;\r\n            const int vert_start_idx = draw_list->VtxBuffer.Size;\r\n            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);\r\n            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);\r\n            const int vert_end_idx = draw_list->VtxBuffer.Size;\r\n\r\n            // Paint colors over existing vertices\r\n            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);\r\n            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);\r\n            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);\r\n        }\r\n\r\n        // Render Cursor + preview on Hue Wheel\r\n        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);\r\n        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);\r\n        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);\r\n        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;\r\n        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);\r\n        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);\r\n        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);\r\n        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);\r\n\r\n        // Render SV triangle (rotated according to hue)\r\n        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);\r\n        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);\r\n        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);\r\n        ImVec2 uv_white = GetFontTexUvWhitePixel();\r\n        draw_list->PrimReserve(6, 6);\r\n        draw_list->PrimVtx(tra, uv_white, hue_color32);\r\n        draw_list->PrimVtx(trb, uv_white, hue_color32);\r\n        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);\r\n        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);\r\n        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);\r\n        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);\r\n        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);\r\n        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));\r\n    }\r\n    else if (flags & ImGuiColorEditFlags_PickerHueBar)\r\n    {\r\n        // Render SV Square\r\n        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);\r\n        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);\r\n        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);\r\n        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much\r\n        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);\r\n\r\n        // Render Hue Bar\r\n        for (int i = 0; i < 6; ++i)\r\n            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);\r\n        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);\r\n        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);\r\n        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);\r\n    }\r\n\r\n    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)\r\n    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;\r\n    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);\r\n    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);\r\n    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);\r\n\r\n    // Render alpha bar\r\n    if (alpha_bar)\r\n    {\r\n        float alpha = ImSaturate(col[3]);\r\n        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);\r\n        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));\r\n        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);\r\n        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);\r\n        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);\r\n        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);\r\n    }\r\n\r\n    EndGroup();\r\n\r\n    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)\r\n        value_changed = false;\r\n    if (value_changed)\r\n        MarkItemEdited(window->DC.LastItemId);\r\n\r\n    PopID();\r\n\r\n    return value_changed;\r\n}\r\n\r\n// A little colored square. Return true when clicked.\r\n// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.\r\n// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.\r\nbool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiID id = window->GetID(desc_id);\r\n    float default_size = GetFrameHeight();\r\n    if (size.x == 0.0f)\r\n        size.x = default_size;\r\n    if (size.y == 0.0f)\r\n        size.y = default_size;\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    if (flags & ImGuiColorEditFlags_NoAlpha)\r\n        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);\r\n\r\n    ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);\r\n    float grid_step = ImMin(size.x, size.y) / 2.99f;\r\n    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);\r\n    ImRect bb_inner = bb;\r\n    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.\r\n    bb_inner.Expand(off);\r\n    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)\r\n    {\r\n        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);\r\n        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);\r\n        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);\r\n    }\r\n    else\r\n    {\r\n        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha\r\n        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;\r\n        if (col_source.w < 1.0f)\r\n            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);\r\n        else\r\n            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);\r\n    }\r\n    RenderNavHighlight(bb, id);\r\n    if (g.Style.FrameBorderSize > 0.0f)\r\n        RenderFrameBorder(bb.Min, bb.Max, rounding);\r\n    else\r\n        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border\r\n\r\n    // Drag and Drop Source\r\n    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.\r\n    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())\r\n    {\r\n        if (flags & ImGuiColorEditFlags_NoAlpha)\r\n            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);\r\n        else\r\n            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);\r\n        ColorButton(desc_id, col, flags);\r\n        SameLine();\r\n        TextUnformatted(\"Color\");\r\n        EndDragDropSource();\r\n    }\r\n\r\n    // Tooltip\r\n    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)\r\n        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));\r\n\r\n    if (pressed)\r\n        MarkItemEdited(id);\r\n\r\n    return pressed;\r\n}\r\n\r\nvoid ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if ((flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;\r\n    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)\r\n        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;\r\n    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)\r\n        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected\r\n    g.ColorEditOptions = flags;\r\n}\r\n\r\n// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\r\nvoid ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);\r\n    BeginTooltipEx(0, true);\r\n\r\n    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;\r\n    if (text_end > text)\r\n    {\r\n        TextUnformatted(text, text_end);\r\n        Separator();\r\n    }\r\n\r\n    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);\r\n    ColorButton(\"##preview\", ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);\r\n    SameLine();\r\n    if (flags & ImGuiColorEditFlags_NoAlpha)\r\n        Text(\"#%02X%02X%02X\\nR: %d, G: %d, B: %d\\n(%.3f, %.3f, %.3f)\", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);\r\n    else\r\n        Text(\"#%02X%02X%02X%02X\\nR:%d, G:%d, B:%d, A:%d\\n(%.3f, %.3f, %.3f, %.3f)\", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);\r\n    EndTooltip();\r\n}\r\n\r\nvoid ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)\r\n{\r\n    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);\r\n    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);\r\n    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup(\"context\"))\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiColorEditFlags opts = g.ColorEditOptions;\r\n    if (allow_opt_inputs)\r\n    {\r\n        if (RadioButton(\"RGB\", (opts & ImGuiColorEditFlags_RGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;\r\n        if (RadioButton(\"HSV\", (opts & ImGuiColorEditFlags_HSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;\r\n        if (RadioButton(\"HEX\", (opts & ImGuiColorEditFlags_HEX) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;\r\n    }\r\n    if (allow_opt_datatype)\r\n    {\r\n        if (allow_opt_inputs) Separator();\r\n        if (RadioButton(\"0..255\",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;\r\n        if (RadioButton(\"0.00..1.00\", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;\r\n    }\r\n\r\n    if (allow_opt_inputs || allow_opt_datatype)\r\n        Separator();\r\n    if (Button(\"Copy as..\", ImVec2(-1,0)))\r\n        OpenPopup(\"Copy\");\r\n    if (BeginPopup(\"Copy\"))\r\n    {\r\n        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);\r\n        char buf[64];\r\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"(%.3ff, %.3ff, %.3ff, %.3ff)\", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\r\n        if (Selectable(buf))\r\n            SetClipboardText(buf);\r\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"(%d,%d,%d,%d)\", cr, cg, cb, ca);\r\n        if (Selectable(buf))\r\n            SetClipboardText(buf);\r\n        if (flags & ImGuiColorEditFlags_NoAlpha)\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"0x%02X%02X%02X\", cr, cg, cb);\r\n        else\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"0x%02X%02X%02X%02X\", cr, cg, cb, ca);\r\n        if (Selectable(buf))\r\n            SetClipboardText(buf);\r\n        EndPopup();\r\n    }\r\n\r\n    g.ColorEditOptions = opts;\r\n    EndPopup();\r\n}\r\n\r\nvoid ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)\r\n{\r\n    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);\r\n    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);\r\n    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup(\"context\"))\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n    if (allow_opt_picker)\r\n    {\r\n        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function\r\n        PushItemWidth(picker_size.x);\r\n        for (int picker_type = 0; picker_type < 2; picker_type++)\r\n        {\r\n            // Draw small/thumbnail version of each picker type (over an invisible button for selection)\r\n            if (picker_type > 0) Separator();\r\n            PushID(picker_type);\r\n            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);\r\n            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;\r\n            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;\r\n            ImVec2 backup_pos = GetCursorScreenPos();\r\n            if (Selectable(\"##selectable\", false, 0, picker_size)) // By default, Selectable() is closing popup\r\n                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);\r\n            SetCursorScreenPos(backup_pos);\r\n            ImVec4 dummy_ref_col;\r\n            memcpy(&dummy_ref_col.x, ref_col, sizeof(float) * (picker_flags & ImGuiColorEditFlags_NoAlpha ? 3 : 4));\r\n            ColorPicker4(\"##dummypicker\", &dummy_ref_col.x, picker_flags);\r\n            PopID();\r\n        }\r\n        PopItemWidth();\r\n    }\r\n    if (allow_opt_alpha_bar)\r\n    {\r\n        if (allow_opt_picker) Separator();\r\n        CheckboxFlags(\"Alpha Bar\", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);\r\n    }\r\n    EndPopup();\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\r\n//-------------------------------------------------------------------------\r\n// - TreeNode()\r\n// - TreeNodeV()\r\n// - TreeNodeEx()\r\n// - TreeNodeExV()\r\n// - TreeNodeBehavior() [Internal]  \r\n// - TreePush()\r\n// - TreePop()\r\n// - TreeAdvanceToLabelPos()\r\n// - GetTreeNodeToLabelSpacing()\r\n// - SetNextTreeNodeOpen()\r\n// - CollapsingHeader()\r\n//-------------------------------------------------------------------------\r\n\r\nbool ImGui::TreeNode(const char* str_id, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(str_id, 0, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNode(const char* label)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);\r\n}\r\n\r\nbool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)\r\n{\r\n    return TreeNodeExV(str_id, 0, fmt, args);\r\n}\r\n\r\nbool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)\r\n{\r\n    return TreeNodeExV(ptr_id, 0, fmt, args);\r\n}\r\n\r\nbool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);\r\n}\r\n\r\nbool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(str_id, flags, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);\r\n}\r\n\r\nbool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);\r\n}\r\n\r\nbool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)\r\n{\r\n    if (flags & ImGuiTreeNodeFlags_Leaf)\r\n        return true;\r\n\r\n    // We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    ImGuiStorage* storage = window->DC.StateStorage;\r\n\r\n    bool is_open;\r\n    if (g.NextTreeNodeOpenCond != 0)\r\n    {\r\n        if (g.NextTreeNodeOpenCond & ImGuiCond_Always)\r\n        {\r\n            is_open = g.NextTreeNodeOpenVal;\r\n            storage->SetInt(id, is_open);\r\n        }\r\n        else\r\n        {\r\n            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.\r\n            const int stored_value = storage->GetInt(id, -1);\r\n            if (stored_value == -1)\r\n            {\r\n                is_open = g.NextTreeNodeOpenVal;\r\n                storage->SetInt(id, is_open);\r\n            }\r\n            else\r\n            {\r\n                is_open = stored_value != 0;\r\n            }\r\n        }\r\n        g.NextTreeNodeOpenCond = 0;\r\n    }\r\n    else\r\n    {\r\n        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;\r\n    }\r\n\r\n    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).\r\n    // NB- If we are above max depth we still allow manually opened nodes to be logged.\r\n    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)\r\n        is_open = true;\r\n\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;\r\n    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);\r\n\r\n    if (!label_end)\r\n        label_end = FindRenderedTextEnd(label);\r\n    const ImVec2 label_size = CalcTextSize(label, label_end, false);\r\n\r\n    // We vertically grow up to current line height up the typical widget height.\r\n    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it\r\n    const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);\r\n    ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));\r\n    if (display_frame)\r\n    {\r\n        // Framed header expand a little outside the default padding\r\n        frame_bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;\r\n        frame_bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;\r\n    }\r\n\r\n    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing\r\n    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser\r\n    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);\r\n\r\n    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing\r\n    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)\r\n    const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x*2, frame_bb.Max.y);\r\n    bool is_open = TreeNodeBehaviorIsOpen(id, flags);\r\n\r\n    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.\r\n    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().\r\n    // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.\r\n    if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\r\n        window->DC.TreeDepthMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);\r\n\r\n    bool item_add = ItemAdd(interact_bb, id);\r\n    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;\r\n    window->DC.LastItemDisplayRect = frame_bb;\r\n\r\n    if (!item_add)\r\n    {\r\n        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\r\n            TreePushRawID(id);\r\n        return is_open;\r\n    }\r\n\r\n    // Flags that affects opening behavior:\r\n    // - 0(default) ..................... single-click anywhere to open\r\n    // - OpenOnDoubleClick .............. double-click anywhere to open\r\n    // - OpenOnArrow .................... single-click on arrow to open\r\n    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open\r\n    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers | ((flags & ImGuiTreeNodeFlags_AllowItemOverlap) ? ImGuiButtonFlags_AllowItemOverlap : 0);\r\n    if (!(flags & ImGuiTreeNodeFlags_Leaf))\r\n        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;\r\n    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)\r\n        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);\r\n\r\n    bool hovered, held, pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);\r\n    if (!(flags & ImGuiTreeNodeFlags_Leaf))\r\n    {\r\n        bool toggled = false;\r\n        if (pressed)\r\n        {\r\n            toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);\r\n            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)\r\n                toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);\r\n            if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)\r\n                toggled |= g.IO.MouseDoubleClicked[0];\r\n            if (g.DragDropActive && is_open) // When using Drag and Drop \"hold to open\" we keep the node highlighted after opening, but never close it again.\r\n                toggled = false;\r\n        }\r\n\r\n        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)\r\n        {\r\n            toggled = true;\r\n            NavMoveRequestCancel();\r\n        }\r\n        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?\r\n        {\r\n            toggled = true;\r\n            NavMoveRequestCancel();\r\n        }\r\n\r\n        if (toggled)\r\n        {\r\n            is_open = !is_open;\r\n            window->DC.StateStorage->SetInt(id, is_open);\r\n        }\r\n    }\r\n    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)\r\n        SetItemAllowOverlap();\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\r\n    const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);\r\n    if (display_frame)\r\n    {\r\n        // Framed type\r\n        RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);\r\n        RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);\r\n        RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);\r\n        if (g.LogEnabled)\r\n        {\r\n            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.\r\n            const char log_prefix[] = \"\\n##\";\r\n            const char log_suffix[] = \"##\";\r\n            LogRenderedText(&text_pos, log_prefix, log_prefix+3);\r\n            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);\r\n            LogRenderedText(&text_pos, log_suffix+1, log_suffix+3);\r\n        }\r\n        else\r\n        {\r\n            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Unframed typed for tree nodes\r\n        if (hovered || (flags & ImGuiTreeNodeFlags_Selected))\r\n        {\r\n            RenderFrame(frame_bb.Min, frame_bb.Max, col, false);\r\n            RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);\r\n        }\r\n\r\n        if (flags & ImGuiTreeNodeFlags_Bullet)\r\n            RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));\r\n        else if (!(flags & ImGuiTreeNodeFlags_Leaf))\r\n            RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);\r\n        if (g.LogEnabled)\r\n            LogRenderedText(&text_pos, \">\");\r\n        RenderText(text_pos, label, label_end, false);\r\n    }\r\n\r\n    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\r\n        TreePushRawID(id);\r\n    return is_open;\r\n}\r\n\r\nvoid ImGui::TreePush(const char* str_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Indent();\r\n    window->DC.TreeDepth++;\r\n    PushID(str_id ? str_id : \"#TreePush\");\r\n}\r\n\r\nvoid ImGui::TreePush(const void* ptr_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Indent();\r\n    window->DC.TreeDepth++;\r\n    PushID(ptr_id ? ptr_id : (const void*)\"#TreePush\");\r\n}\r\n\r\nvoid ImGui::TreePushRawID(ImGuiID id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Indent();\r\n    window->DC.TreeDepth++;\r\n    window->IDStack.push_back(id);\r\n}\r\n\r\nvoid ImGui::TreePop()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    Unindent();\r\n\r\n    window->DC.TreeDepth--;\r\n    if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())\r\n        if (g.NavIdIsAlive && (window->DC.TreeDepthMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))\r\n        {\r\n            SetNavID(window->IDStack.back(), g.NavLayer);\r\n            NavMoveRequestCancel();\r\n        }\r\n    window->DC.TreeDepthMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;\r\n\r\n    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.\r\n    PopID();\r\n}\r\n\r\nvoid ImGui::TreeAdvanceToLabelPos()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();\r\n}\r\n\r\n// Horizontal distance preceding label when using TreeNode() or Bullet()\r\nfloat ImGui::GetTreeNodeToLabelSpacing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + (g.Style.FramePadding.x * 2.0f);\r\n}\r\n\r\nvoid ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.CurrentWindow->SkipItems)\r\n        return;\r\n    g.NextTreeNodeOpenVal = is_open;\r\n    g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\n// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).\r\n// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().\r\nbool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);\r\n}\r\n\r\nbool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    if (p_open && !*p_open)\r\n        return false;\r\n\r\n    ImGuiID id = window->GetID(label);\r\n    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);\r\n    if (p_open)\r\n    {\r\n        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.\r\n        ImGuiContext& g = *GImGui;\r\n        ImGuiItemHoveredDataBackup last_item_backup;\r\n        float button_radius = g.FontSize * 0.5f;\r\n        ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);\r\n        if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), button_center, button_radius))\r\n            *p_open = false;\r\n        last_item_backup.Restore();\r\n    }\r\n\r\n    return is_open;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: Selectable\r\n//-------------------------------------------------------------------------\r\n// - Selectable()\r\n//-------------------------------------------------------------------------\r\n\r\n// Tip: pass a non-visible label (e.g. \"##dummy\") then you can use the space to draw other text or image.\r\n// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.\r\nbool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.\r\n        PopClipRect();\r\n\r\n    ImGuiID id = window->GetID(label);\r\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    pos.y += window->DC.CurrentLineTextBaseOffset;\r\n    ImRect bb_inner(pos, pos + size);\r\n    ItemSize(bb_inner);\r\n\r\n    // Fill horizontal space.\r\n    ImVec2 window_padding = window->WindowPadding;\r\n    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;\r\n    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - window->DC.CursorPos.x);\r\n    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);\r\n    ImRect bb(pos, pos + size_draw);\r\n    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))\r\n        bb.Max.x += window_padding.x;\r\n\r\n    // Selectables are tightly packed together, we extend the box to cover spacing between selectable.\r\n    float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);\r\n    float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);\r\n    float spacing_R = style.ItemSpacing.x - spacing_L;\r\n    float spacing_D = style.ItemSpacing.y - spacing_U;\r\n    bb.Min.x -= spacing_L;\r\n    bb.Min.y -= spacing_U;\r\n    bb.Max.x += spacing_R;\r\n    bb.Max.y += spacing_D;\r\n    if (!ItemAdd(bb, (flags & ImGuiSelectableFlags_Disabled) ? 0 : id))\r\n    {\r\n        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)\r\n            PushColumnClipRect();\r\n        return false;\r\n    }\r\n\r\n    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries\r\n    ImGuiButtonFlags button_flags = 0;\r\n    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;\r\n    if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;\r\n    if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;\r\n    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;\r\n    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);\r\n    if (flags & ImGuiSelectableFlags_Disabled)\r\n        selected = false;\r\n\r\n    // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)\r\n    if (pressed || hovered)\r\n        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)\r\n        {\r\n            g.NavDisableHighlight = true;\r\n            SetNavID(id, window->DC.NavLayerCurrent);\r\n        }\r\n    if (pressed)\r\n        MarkItemEdited(id);\r\n\r\n    // Render\r\n    if (hovered || selected)\r\n    {\r\n        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\r\n        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);\r\n        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);\r\n    }\r\n\r\n    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)\r\n    {\r\n        PushColumnClipRect();\r\n        bb.Max.x -= (GetContentRegionMax().x - max_x);\r\n    }\r\n\r\n    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\r\n    RenderTextClipped(bb_inner.Min, bb.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));\r\n    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();\r\n\r\n    // Automatically close popups\r\n    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))\r\n        CloseCurrentPopup();\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)\r\n{\r\n    if (Selectable(label, *p_selected, flags, size_arg))\r\n    {\r\n        *p_selected = !*p_selected;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: ListBox\r\n//-------------------------------------------------------------------------\r\n// - ListBox()\r\n// - ListBoxHeader()\r\n// - ListBoxFooter()\r\n//-------------------------------------------------------------------------\r\n\r\n// FIXME: In principle this function should be called BeginListBox(). We should rename it after re-evaluating if we want to keep the same signature.\r\n// Helper to calculate the size of a listbox and display a label on the right.\r\n// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an non-visible label e.g. \"##empty\"\r\nbool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    const ImGuiStyle& style = GetStyle();\r\n    const ImGuiID id = GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.\r\n    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);\r\n    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));\r\n    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);\r\n    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n    window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.\r\n\r\n    BeginGroup();\r\n    if (label_size.x > 0)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    BeginChildFrame(id, frame_bb.GetSize());\r\n    return true;\r\n}\r\n\r\n// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.\r\nbool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)\r\n{\r\n    // Size default to hold ~7.25 items.\r\n    // We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.\r\n    // We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.\r\n    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.\r\n    if (height_in_items < 0)\r\n        height_in_items = ImMin(items_count, 7);\r\n    const ImGuiStyle& style = GetStyle();\r\n    float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);\r\n\r\n    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().\r\n    ImVec2 size;\r\n    size.x = 0.0f;\r\n    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f;\r\n    return ListBoxHeader(label, size);\r\n}\r\n\r\n// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.\r\nvoid ImGui::ListBoxFooter()\r\n{\r\n    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;\r\n    const ImRect bb = parent_window->DC.LastItemRect;\r\n    const ImGuiStyle& style = GetStyle();\r\n\r\n    EndChildFrame();\r\n\r\n    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)\r\n    // We call SameLine() to restore DC.CurrentLine* data\r\n    SameLine();\r\n    parent_window->DC.CursorPos = bb.Min;\r\n    ItemSize(bb, style.FramePadding.y);\r\n    EndGroup();\r\n}\r\n\r\nbool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)\r\n{\r\n    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)\r\n{\r\n    if (!ListBoxHeader(label, items_count, height_in_items))\r\n        return false;\r\n\r\n    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.\r\n    while (clipper.Step())\r\n        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n        {\r\n            const bool item_selected = (i == *current_item);\r\n            const char* item_text;\r\n            if (!items_getter(data, i, &item_text))\r\n                item_text = \"*Unknown item*\";\r\n\r\n            PushID(i);\r\n            if (Selectable(item_text, item_selected))\r\n            {\r\n                *current_item = i;\r\n                value_changed = true;\r\n            }\r\n            if (item_selected)\r\n                SetItemDefaultFocus();\r\n            PopID();\r\n        }\r\n    ListBoxFooter();\r\n    if (value_changed)\r\n        MarkItemEdited(g.CurrentWindow->DC.LastItemId);\r\n\r\n    return value_changed;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: PlotLines, PlotHistogram\r\n//-------------------------------------------------------------------------\r\n// - PlotEx() [Internal]\r\n// - PlotLines()\r\n// - PlotHistogram()\r\n//-------------------------------------------------------------------------\r\n\r\nvoid ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    if (graph_size.x == 0.0f)\r\n        graph_size.x = CalcItemWidth();\r\n    if (graph_size.y == 0.0f)\r\n        graph_size.y = label_size.y + (style.FramePadding.y * 2);\r\n\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(graph_size.x, graph_size.y));\r\n    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    if (!ItemAdd(total_bb, 0, &frame_bb))\r\n        return;\r\n    const bool hovered = ItemHoverable(inner_bb, 0);\r\n\r\n    // Determine scale from values if not specified\r\n    if (scale_min == FLT_MAX || scale_max == FLT_MAX)\r\n    {\r\n        float v_min = FLT_MAX;\r\n        float v_max = -FLT_MAX;\r\n        for (int i = 0; i < values_count; i++)\r\n        {\r\n            const float v = values_getter(data, i);\r\n            v_min = ImMin(v_min, v);\r\n            v_max = ImMax(v_max, v);\r\n        }\r\n        if (scale_min == FLT_MAX)\r\n            scale_min = v_min;\r\n        if (scale_max == FLT_MAX)\r\n            scale_max = v_max;\r\n    }\r\n\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n\r\n    if (values_count > 0)\r\n    {\r\n        int res_w = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);\r\n        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);\r\n\r\n        // Tooltip on hover\r\n        int v_hovered = -1;\r\n        if (hovered)\r\n        {\r\n            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);\r\n            const int v_idx = (int)(t * item_count);\r\n            IM_ASSERT(v_idx >= 0 && v_idx < values_count);\r\n\r\n            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);\r\n            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);\r\n            if (plot_type == ImGuiPlotType_Lines)\r\n                SetTooltip(\"%d: %8.4g\\n%d: %8.4g\", v_idx, v0, v_idx+1, v1);\r\n            else if (plot_type == ImGuiPlotType_Histogram)\r\n                SetTooltip(\"%d: %8.4g\", v_idx, v0);\r\n            v_hovered = v_idx;\r\n        }\r\n\r\n        const float t_step = 1.0f / (float)res_w;\r\n        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));\r\n\r\n        float v0 = values_getter(data, (0 + values_offset) % values_count);\r\n        float t0 = 0.0f;\r\n        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle\r\n        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands\r\n\r\n        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);\r\n        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);\r\n\r\n        for (int n = 0; n < res_w; n++)\r\n        {\r\n            const float t1 = t0 + t_step;\r\n            const int v1_idx = (int)(t0 * item_count + 0.5f);\r\n            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);\r\n            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);\r\n            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );\r\n\r\n            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.\r\n            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);\r\n            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));\r\n            if (plot_type == ImGuiPlotType_Lines)\r\n            {\r\n                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);\r\n            }\r\n            else if (plot_type == ImGuiPlotType_Histogram)\r\n            {\r\n                if (pos1.x >= pos0.x + 2.0f)\r\n                    pos1.x -= 1.0f;\r\n                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);\r\n            }\r\n\r\n            t0 = t1;\r\n            tp0 = tp1;\r\n        }\r\n    }\r\n\r\n    // Text overlay\r\n    if (overlay_text)\r\n        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));\r\n\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);\r\n}\r\n\r\nstruct ImGuiPlotArrayGetterData\r\n{\r\n    const float* Values;\r\n    int Stride;\r\n\r\n    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }\r\n};\r\n\r\nstatic float Plot_ArrayGetter(void* data, int idx)\r\n{\r\n    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;\r\n    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);\r\n    return v;\r\n}\r\n\r\nvoid ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)\r\n{\r\n    ImGuiPlotArrayGetterData data(values, stride);\r\n    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\nvoid ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\r\n{\r\n    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\nvoid ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)\r\n{\r\n    ImGuiPlotArrayGetterData data(values, stride);\r\n    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\nvoid ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\r\n{\r\n    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] Widgets: Value helpers\r\n// Those is not very useful, legacy API.\r\n//-------------------------------------------------------------------------\r\n// - Value()\r\n//-------------------------------------------------------------------------\r\n\r\nvoid ImGui::Value(const char* prefix, bool b)\r\n{\r\n    Text(\"%s: %s\", prefix, (b ? \"true\" : \"false\"));\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, int v)\r\n{\r\n    Text(\"%s: %d\", prefix, v);\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, unsigned int v)\r\n{\r\n    Text(\"%s: %d\", prefix, v);\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, float v, const char* float_format)\r\n{\r\n    if (float_format)\r\n    {\r\n        char fmt[64];\r\n        ImFormatString(fmt, IM_ARRAYSIZE(fmt), \"%%s: %s\", float_format);\r\n        Text(fmt, prefix, v);\r\n    }\r\n    else\r\n    {\r\n        Text(\"%s: %.3f\", prefix, v);\r\n    }\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] MenuItem, BeginMenu, EndMenu, etc.\r\n//-------------------------------------------------------------------------\r\n// - ImGuiMenuColumns [Internal]\r\n// - BeginMainMenuBar()\r\n// - EndMainMenuBar()\r\n// - BeginMenuBar()\r\n// - EndMenuBar()\r\n// - BeginMenu()\r\n// - EndMenu()\r\n// - MenuItem()\r\n//-------------------------------------------------------------------------\r\n\r\n// Helpers for internal use\r\nImGuiMenuColumns::ImGuiMenuColumns()\r\n{\r\n    Count = 0;\r\n    Spacing = Width = NextWidth = 0.0f;\r\n    memset(Pos, 0, sizeof(Pos));\r\n    memset(NextWidths, 0, sizeof(NextWidths));\r\n}\r\n\r\nvoid ImGuiMenuColumns::Update(int count, float spacing, bool clear)\r\n{\r\n    IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));\r\n    Count = count;\r\n    Width = NextWidth = 0.0f;\r\n    Spacing = spacing;\r\n    if (clear) memset(NextWidths, 0, sizeof(NextWidths));\r\n    for (int i = 0; i < Count; i++)\r\n    {\r\n        if (i > 0 && NextWidths[i] > 0.0f)\r\n            Width += Spacing;\r\n        Pos[i] = (float)(int)Width;\r\n        Width += NextWidths[i];\r\n        NextWidths[i] = 0.0f;\r\n    }\r\n}\r\n\r\nfloat ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double\r\n{\r\n    NextWidth = 0.0f;\r\n    NextWidths[0] = ImMax(NextWidths[0], w0);\r\n    NextWidths[1] = ImMax(NextWidths[1], w1);\r\n    NextWidths[2] = ImMax(NextWidths[2], w2);\r\n    for (int i = 0; i < 3; i++)\r\n        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);\r\n    return ImMax(Width, NextWidth);\r\n}\r\n\r\nfloat ImGuiMenuColumns::CalcExtraSpace(float avail_w)\r\n{\r\n    return ImMax(0.0f, avail_w - Width);\r\n}\r\n\r\n// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.\r\nbool ImGui::BeginMainMenuBar()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));\r\n    SetNextWindowPos(ImVec2(0.0f, 0.0f));\r\n    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));\r\n    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);\r\n    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));\r\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;\r\n    bool is_open = Begin(\"##MainMenuBar\", NULL, window_flags) && BeginMenuBar();\r\n    PopStyleVar(2);\r\n    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);\r\n    if (!is_open)\r\n    {\r\n        End();\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid ImGui::EndMainMenuBar()\r\n{\r\n    EndMenuBar();\r\n\r\n    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)\r\n        FocusPreviousWindowIgnoringOne(g.NavWindow);\r\n\r\n    End();\r\n}\r\n\r\nbool ImGui::BeginMenuBar()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n    if (!(window->Flags & ImGuiWindowFlags_MenuBar))\r\n        return false;\r\n\r\n    IM_ASSERT(!window->DC.MenuBarAppending);\r\n    BeginGroup(); // Backup position on layer 0\r\n    PushID(\"##menubar\");\r\n\r\n    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.\r\n    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.\r\n    ImRect bar_rect = window->MenuBarRect();\r\n    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));\r\n    clip_rect.ClipWith(window->OuterRectClipped);\r\n    PushClipRect(clip_rect.Min, clip_rect.Max, false);\r\n\r\n    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);\r\n    window->DC.LayoutType = ImGuiLayoutType_Horizontal;\r\n    window->DC.NavLayerCurrent++;\r\n    window->DC.NavLayerCurrentMask <<= 1;\r\n    window->DC.MenuBarAppending = true;\r\n    AlignTextToFramePadding();\r\n    return true;\r\n}\r\n\r\nvoid ImGui::EndMenuBar()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.\r\n    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))\r\n    {\r\n        ImGuiWindow* nav_earliest_child = g.NavWindow;\r\n        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))\r\n            nav_earliest_child = nav_earliest_child->ParentWindow;\r\n        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)\r\n        {\r\n            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.\r\n            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)\r\n            IM_ASSERT(window->DC.NavLayerActiveMaskNext & 0x02); // Sanity check\r\n            FocusWindow(window);\r\n            SetNavIDWithRectRel(window->NavLastIds[1], 1, window->NavRectRel[1]);\r\n            g.NavLayer = 1;\r\n            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.\r\n            g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;\r\n            NavMoveRequestCancel();\r\n        }\r\n    }\r\n\r\n    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);\r\n    IM_ASSERT(window->DC.MenuBarAppending);\r\n    PopClipRect();\r\n    PopID();\r\n    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.\r\n    window->DC.GroupStack.back().AdvanceCursor = false;\r\n    EndGroup(); // Restore position on layer 0\r\n    window->DC.LayoutType = ImGuiLayoutType_Vertical;\r\n    window->DC.NavLayerCurrent--;\r\n    window->DC.NavLayerCurrentMask >>= 1;\r\n    window->DC.MenuBarAppending = false;\r\n}\r\n\r\nbool ImGui::BeginMenu(const char* label, bool enabled)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n\r\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    bool pressed;\r\n    bool menu_is_open = IsPopupOpen(id);\r\n    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].OpenParentId == window->IDStack.back());\r\n    ImGuiWindow* backed_nav_window = g.NavWindow;\r\n    if (menuset_is_open)\r\n        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)\r\n\r\n    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu (using FindBestWindowPosForPopup).\r\n    ImVec2 popup_pos, pos = window->DC.CursorPos;\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\r\n    {\r\n        // Menu inside an horizontal menu bar\r\n        // Selectable extend their highlight by half ItemSpacing in each direction.\r\n        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()\r\n        popup_pos = ImVec2(pos.x - 1.0f - (float)(int)(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);\r\n        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);\r\n        float w = label_size.x;\r\n        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));\r\n        PopStyleVar();\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().\r\n    }\r\n    else\r\n    {\r\n        // Menu inside a menu\r\n        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);\r\n        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame\r\n        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);\r\n        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));\r\n        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\r\n        RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);\r\n        if (!enabled) PopStyleColor();\r\n    }\r\n\r\n    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);\r\n    if (menuset_is_open)\r\n        g.NavWindow = backed_nav_window;\r\n\r\n    bool want_open = false, want_close = false;\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))\r\n    {\r\n        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.\r\n        bool moving_within_opened_triangle = false;\r\n        if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))\r\n        {\r\n            if (ImGuiWindow* next_window = g.OpenPopupStack[g.CurrentPopupStack.Size].Window)\r\n            {\r\n                ImRect next_window_rect = next_window->Rect();\r\n                ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;\r\n                ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();\r\n                ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();\r\n                float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.\r\n                ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;   // to avoid numerical issues\r\n                tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);            // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?\r\n                tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);\r\n                moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);\r\n                //window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug\r\n            }\r\n        }\r\n\r\n        want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);\r\n        want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);\r\n\r\n        if (g.NavActivateId == id)\r\n        {\r\n            want_close = menu_is_open;\r\n            want_open = !menu_is_open;\r\n        }\r\n        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open\r\n        {\r\n            want_open = true;\r\n            NavMoveRequestCancel();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Menu bar\r\n        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it\r\n        {\r\n            want_close = true;\r\n            want_open = menu_is_open = false;\r\n        }\r\n        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others\r\n        {\r\n            want_open = true;\r\n        }\r\n        else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open\r\n        {\r\n            want_open = true;\r\n            NavMoveRequestCancel();\r\n        }\r\n    }\r\n\r\n    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu(\"options\", has_object)) { ..use object.. }'\r\n        want_close = true;\r\n    if (want_close && IsPopupOpen(id))\r\n        ClosePopupToLevel(g.CurrentPopupStack.Size);\r\n\r\n    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.CurrentPopupStack.Size)\r\n    {\r\n        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.\r\n        OpenPopup(label);\r\n        return false;\r\n    }\r\n\r\n    menu_is_open |= want_open;\r\n    if (want_open)\r\n        OpenPopup(label);\r\n\r\n    if (menu_is_open)\r\n    {\r\n        // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)\r\n        SetNextWindowPos(popup_pos, ImGuiCond_Always);\r\n        ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;\r\n        if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))\r\n            flags |= ImGuiWindowFlags_ChildWindow;\r\n        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)\r\n    }\r\n\r\n    return menu_is_open;\r\n}\r\n\r\nvoid ImGui::EndMenu()\r\n{\r\n    // Nav: When a left move request _within our child menu_ failed, close the menu.\r\n    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.\r\n    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)\r\n    {\r\n        ClosePopupToLevel(g.OpenPopupStack.Size - 1);\r\n        NavMoveRequestCancel();\r\n    }\r\n\r\n    EndPopup();\r\n}\r\n\r\nbool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiStyle& style = g.Style;\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);\r\n    bool pressed;\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\r\n    {\r\n        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful\r\n        // Note that in this situation we render neither the shortcut neither the selected tick mark\r\n        float w = label_size.x;\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);\r\n        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);\r\n        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));\r\n        PopStyleVar();\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().\r\n    }\r\n    else\r\n    {\r\n        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);\r\n        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame\r\n        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);\r\n        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));\r\n        if (shortcut_size.x > 0.0f)\r\n        {\r\n            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\r\n            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);\r\n            PopStyleColor();\r\n        }\r\n        if (selected)\r\n            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);\r\n    }\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)\r\n{\r\n    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))\r\n    {\r\n        if (p_selected)\r\n            *p_selected = !*p_selected;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n","// [ImGui] this is a slightly modified version of stb_textedit.h 1.12. Those changes would need to be pushed into nothings/stb\r\n// [ImGui] - 2018-06: fixed undo/redo after pasting large amount of text (over 32 kb). Redo will still fail when undo buffers are exhausted, but text won't be corrupted (see nothings/stb issue #620)\r\n// [ImGui] - 2018-06: fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)\r\n// [ImGui] - fixed some minor warnings\r\n\r\n// stb_textedit.h - v1.12  - public domain - Sean Barrett\r\n// Development of this library was sponsored by RAD Game Tools\r\n//\r\n// This C header file implements the guts of a multi-line text-editing\r\n// widget; you implement display, word-wrapping, and low-level string\r\n// insertion/deletion, and stb_textedit will map user inputs into\r\n// insertions & deletions, plus updates to the cursor position,\r\n// selection state, and undo state.\r\n//\r\n// It is intended for use in games and other systems that need to build\r\n// their own custom widgets and which do not have heavy text-editing\r\n// requirements (this library is not recommended for use for editing large\r\n// texts, as its performance does not scale and it has limited undo).\r\n//\r\n// Non-trivial behaviors are modelled after Windows text controls.\r\n// \r\n//\r\n// LICENSE\r\n//\r\n// See end of file for license information.\r\n//\r\n//\r\n// DEPENDENCIES\r\n//\r\n// Uses the C runtime function 'memmove', which you can override\r\n// by defining STB_TEXTEDIT_memmove before the implementation.\r\n// Uses no other functions. Performs no runtime allocations.\r\n//\r\n//\r\n// VERSION HISTORY\r\n//\r\n//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash\r\n//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield\r\n//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual\r\n//   1.9  (2016-08-27) customizable move-by-word\r\n//   1.8  (2016-04-02) better keyboard handling when mouse button is down\r\n//   1.7  (2015-09-13) change y range handling in case baseline is non-0\r\n//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove\r\n//   1.5  (2014-09-10) add support for secondary keys for OS X\r\n//   1.4  (2014-08-17) fix signed/unsigned warnings\r\n//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary\r\n//   1.2  (2014-05-27) fix some RAD types that had crept into the new code\r\n//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )\r\n//   1.0  (2012-07-26) improve documentation, initial public release\r\n//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode\r\n//   0.2  (2011-11-28) fixes to undo/redo\r\n//   0.1  (2010-07-08) initial version\r\n//\r\n// ADDITIONAL CONTRIBUTORS\r\n//\r\n//   Ulf Winklemann: move-by-word in 1.1\r\n//   Fabian Giesen: secondary key inputs in 1.5\r\n//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6\r\n//\r\n//   Bugfixes:\r\n//      Scott Graham\r\n//      Daniel Keller\r\n//      Omar Cornut\r\n//      Dan Thompson\r\n//\r\n// USAGE\r\n//\r\n// This file behaves differently depending on what symbols you define\r\n// before including it.\r\n//\r\n//\r\n// Header-file mode:\r\n//\r\n//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,\r\n//   it will operate in \"header file\" mode. In this mode, it declares a\r\n//   single public symbol, STB_TexteditState, which encapsulates the current\r\n//   state of a text widget (except for the string, which you will store\r\n//   separately).\r\n//\r\n//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a\r\n//   primitive type that defines a single character (e.g. char, wchar_t, etc).\r\n//\r\n//   To save space or increase undo-ability, you can optionally define the\r\n//   following things that are used by the undo system:\r\n//\r\n//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position\r\n//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow\r\n//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer\r\n//\r\n//   If you don't define these, they are set to permissive types and\r\n//   moderate sizes. The undo system does no memory allocations, so\r\n//   it grows STB_TexteditState by the worst-case storage which is (in bytes):\r\n//\r\n//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT\r\n//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT\r\n//\r\n//\r\n// Implementation mode:\r\n//\r\n//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it\r\n//   will compile the implementation of the text edit widget, depending\r\n//   on a large number of symbols which must be defined before the include.\r\n//\r\n//   The implementation is defined only as static functions. You will then\r\n//   need to provide your own APIs in the same file which will access the\r\n//   static functions.\r\n//\r\n//   The basic concept is that you provide a \"string\" object which\r\n//   behaves like an array of characters. stb_textedit uses indices to\r\n//   refer to positions in the string, implicitly representing positions\r\n//   in the displayed textedit. This is true for both plain text and\r\n//   rich text; even with rich text stb_truetype interacts with your\r\n//   code as if there was an array of all the displayed characters.\r\n//\r\n// Symbols that must be the same in header-file and implementation mode:\r\n//\r\n//     STB_TEXTEDIT_CHARTYPE             the character type\r\n//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position\r\n//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow\r\n//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer\r\n//\r\n// Symbols you must define for implementation mode:\r\n//\r\n//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,\r\n//                                      typically this is a wrapper object with other data you need\r\n//\r\n//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))\r\n//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters\r\n//                                        starting from character #n (see discussion below)\r\n//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character\r\n//                                        to the xpos of the i+1'th char for a line of characters\r\n//                                        starting at character #n (i.e. accounts for kerning\r\n//                                        with previous char)\r\n//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character\r\n//                                        (return type is int, -1 means not valid to insert)\r\n//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based\r\n//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize\r\n//                                        as manually wordwrapping for end-of-line positioning\r\n//\r\n//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i\r\n//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)\r\n//\r\n//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key\r\n//\r\n//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left\r\n//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right\r\n//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up\r\n//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down\r\n//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME\r\n//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END\r\n//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME\r\n//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END\r\n//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor\r\n//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor\r\n//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo\r\n//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo\r\n//\r\n// Optional:\r\n//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode\r\n//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),\r\n//                                          required for default WORDLEFT/WORDRIGHT handlers\r\n//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to\r\n//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to\r\n//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT\r\n//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT\r\n//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line\r\n//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line\r\n//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text\r\n//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text\r\n//\r\n// Todo:\r\n//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page\r\n//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page\r\n//\r\n// Keyboard input must be encoded as a single integer value; e.g. a character code\r\n// and some bitflags that represent shift states. to simplify the interface, SHIFT must\r\n// be a bitflag, so we can test the shifted state of cursor movements to allow selection,\r\n// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.\r\n//\r\n// You can encode other things, such as CONTROL or ALT, in additional bits, and\r\n// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,\r\n// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN\r\n// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,\r\n// and I pass both WM_KEYDOWN and WM_CHAR events to the \"key\" function in the\r\n// API below. The control keys will only match WM_KEYDOWN events because of the\r\n// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN\r\n// bit so it only decodes WM_CHAR events.\r\n//\r\n// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed\r\n// row of characters assuming they start on the i'th character--the width and\r\n// the height and the number of characters consumed. This allows this library\r\n// to traverse the entire layout incrementally. You need to compute word-wrapping\r\n// here.\r\n//\r\n// Each textfield keeps its own insert mode state, which is not how normal\r\n// applications work. To keep an app-wide insert mode, update/copy the\r\n// \"insert_mode\" field of STB_TexteditState before/after calling API functions.\r\n//\r\n// API\r\n//\r\n//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)\r\n//\r\n//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\r\n//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\r\n//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)\r\n//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)\r\n//\r\n//    Each of these functions potentially updates the string and updates the\r\n//    state.\r\n//\r\n//      initialize_state:\r\n//          set the textedit state to a known good default state when initially\r\n//          constructing the textedit.\r\n//\r\n//      click:\r\n//          call this with the mouse x,y on a mouse down; it will update the cursor\r\n//          and reset the selection start/end to the cursor point. the x,y must\r\n//          be relative to the text widget, with (0,0) being the top left.\r\n//     \r\n//      drag:\r\n//          call this with the mouse x,y on a mouse drag/up; it will update the\r\n//          cursor and the selection end point\r\n//     \r\n//      cut:\r\n//          call this to delete the current selection; returns true if there was\r\n//          one. you should FIRST copy the current selection to the system paste buffer.\r\n//          (To copy, just copy the current selection out of the string yourself.)\r\n//     \r\n//      paste:\r\n//          call this to paste text at the current cursor point or over the current\r\n//          selection if there is one.\r\n//     \r\n//      key:\r\n//          call this for keyboard inputs sent to the textfield. you can use it\r\n//          for \"key down\" events or for \"translated\" key events. if you need to\r\n//          do both (as in Win32), or distinguish Unicode characters from control\r\n//          inputs, set a high bit to distinguish the two; then you can define the\r\n//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit\r\n//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is\r\n//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to\r\n//          anything other type you wante before including.\r\n//\r\n//     \r\n//   When rendering, you can read the cursor position and selection state from\r\n//   the STB_TexteditState.\r\n//\r\n//\r\n// Notes:\r\n//\r\n// This is designed to be usable in IMGUI, so it allows for the possibility of\r\n// running in an IMGUI that has NOT cached the multi-line layout. For this\r\n// reason, it provides an interface that is compatible with computing the\r\n// layout incrementally--we try to make sure we make as few passes through\r\n// as possible. (For example, to locate the mouse pointer in the text, we\r\n// could define functions that return the X and Y positions of characters\r\n// and binary search Y and then X, but if we're doing dynamic layout this\r\n// will run the layout algorithm many times, so instead we manually search\r\n// forward in one pass. Similar logic applies to e.g. up-arrow and\r\n// down-arrow movement.)\r\n//\r\n// If it's run in a widget that *has* cached the layout, then this is less\r\n// efficient, but it's not horrible on modern computers. But you wouldn't\r\n// want to edit million-line files with it.\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   Header-file mode\r\n////\r\n////\r\n\r\n#ifndef INCLUDE_STB_TEXTEDIT_H\r\n#define INCLUDE_STB_TEXTEDIT_H\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n//\r\n//     STB_TexteditState\r\n//\r\n// Definition of STB_TexteditState which you should store\r\n// per-textfield; it includes cursor position, selection state,\r\n// and undo state.\r\n//\r\n\r\n#ifndef STB_TEXTEDIT_UNDOSTATECOUNT\r\n#define STB_TEXTEDIT_UNDOSTATECOUNT   99\r\n#endif\r\n#ifndef STB_TEXTEDIT_UNDOCHARCOUNT\r\n#define STB_TEXTEDIT_UNDOCHARCOUNT   999\r\n#endif\r\n#ifndef STB_TEXTEDIT_CHARTYPE\r\n#define STB_TEXTEDIT_CHARTYPE        int\r\n#endif\r\n#ifndef STB_TEXTEDIT_POSITIONTYPE\r\n#define STB_TEXTEDIT_POSITIONTYPE    int\r\n#endif\r\n\r\ntypedef struct\r\n{\r\n   // private data\r\n   STB_TEXTEDIT_POSITIONTYPE  where;\r\n   STB_TEXTEDIT_POSITIONTYPE  insert_length;\r\n   STB_TEXTEDIT_POSITIONTYPE  delete_length;\r\n   int                        char_storage;\r\n} StbUndoRecord;\r\n\r\ntypedef struct\r\n{\r\n   // private data\r\n   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];\r\n   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];\r\n   short undo_point, redo_point;\r\n   int undo_char_point, redo_char_point;\r\n} StbUndoState;\r\n\r\ntypedef struct\r\n{\r\n   /////////////////////\r\n   //\r\n   // public data\r\n   //\r\n\r\n   int cursor;\r\n   // position of the text cursor within the string\r\n\r\n   int select_start;          // selection start point\r\n   int select_end;\r\n   // selection start and end point in characters; if equal, no selection.\r\n   // note that start may be less than or greater than end (e.g. when\r\n   // dragging the mouse, start is where the initial click was, and you\r\n   // can drag in either direction)\r\n\r\n   unsigned char insert_mode;\r\n   // each textfield keeps its own insert mode state. to keep an app-wide\r\n   // insert mode, copy this value in/out of the app state\r\n\r\n   /////////////////////\r\n   //\r\n   // private data\r\n   //\r\n   unsigned char cursor_at_end_of_line; // not implemented yet\r\n   unsigned char initialized;\r\n   unsigned char has_preferred_x;\r\n   unsigned char single_line;\r\n   unsigned char padding1, padding2, padding3;\r\n   float preferred_x; // this determines where the cursor up/down tries to seek to along x\r\n   StbUndoState undostate;\r\n} STB_TexteditState;\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n//\r\n//     StbTexteditRow\r\n//\r\n// Result of layout query, used by stb_textedit to determine where\r\n// the text in each row is.\r\n\r\n// result of layout query\r\ntypedef struct\r\n{\r\n   float x0,x1;             // starting x location, end x location (allows for align=right, etc)\r\n   float baseline_y_delta;  // position of baseline relative to previous row's baseline\r\n   float ymin,ymax;         // height of row above and below baseline\r\n   int num_chars;\r\n} StbTexteditRow;\r\n#endif //INCLUDE_STB_TEXTEDIT_H\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   Implementation mode\r\n////\r\n////\r\n\r\n\r\n// implementation isn't include-guarded, since it might have indirectly\r\n// included just the \"header\" portion\r\n#ifdef STB_TEXTEDIT_IMPLEMENTATION\r\n\r\n#ifndef STB_TEXTEDIT_memmove\r\n#include <string.h>\r\n#define STB_TEXTEDIT_memmove memmove\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n//      Mouse input handling\r\n//\r\n\r\n// traverse the layout to locate the nearest character to a display position\r\nstatic int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)\r\n{\r\n   StbTexteditRow r;\r\n   int n = STB_TEXTEDIT_STRINGLEN(str);\r\n   float base_y = 0, prev_x;\r\n   int i=0, k;\r\n\r\n   r.x0 = r.x1 = 0;\r\n   r.ymin = r.ymax = 0;\r\n   r.num_chars = 0;\r\n\r\n   // search rows to find one that straddles 'y'\r\n   while (i < n) {\r\n      STB_TEXTEDIT_LAYOUTROW(&r, str, i);\r\n      if (r.num_chars <= 0)\r\n         return n;\r\n\r\n      if (i==0 && y < base_y + r.ymin)\r\n         return 0;\r\n\r\n      if (y < base_y + r.ymax)\r\n         break;\r\n\r\n      i += r.num_chars;\r\n      base_y += r.baseline_y_delta;\r\n   }\r\n\r\n   // below all text, return 'after' last character\r\n   if (i >= n)\r\n      return n;\r\n\r\n   // check if it's before the beginning of the line\r\n   if (x < r.x0)\r\n      return i;\r\n\r\n   // check if it's before the end of the line\r\n   if (x < r.x1) {\r\n      // search characters in row for one that straddles 'x'\r\n      prev_x = r.x0;\r\n      for (k=0; k < r.num_chars; ++k) {\r\n         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);\r\n         if (x < prev_x+w) {\r\n            if (x < prev_x+w/2)\r\n               return k+i;\r\n            else\r\n               return k+i+1;\r\n         }\r\n         prev_x += w;\r\n      }\r\n      // shouldn't happen, but if it does, fall through to end-of-line case\r\n   }\r\n\r\n   // if the last character is a newline, return that. otherwise return 'after' the last character\r\n   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)\r\n      return i+r.num_chars-1;\r\n   else\r\n      return i+r.num_chars;\r\n}\r\n\r\n// API click: on mouse down, move the cursor to the clicked location, and reset the selection\r\nstatic void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\r\n{\r\n   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse\r\n   // goes off the top or bottom of the text\r\n   if( state->single_line )\r\n   {\r\n      StbTexteditRow r;\r\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\r\n      y = r.ymin;\r\n   }\r\n\r\n   state->cursor = stb_text_locate_coord(str, x, y);\r\n   state->select_start = state->cursor;\r\n   state->select_end = state->cursor;\r\n   state->has_preferred_x = 0;\r\n}\r\n\r\n// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location\r\nstatic void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)\r\n{\r\n   int p = 0;\r\n\r\n   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse\r\n   // goes off the top or bottom of the text\r\n   if( state->single_line )\r\n   {\r\n      StbTexteditRow r;\r\n      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\r\n      y = r.ymin;\r\n   }\r\n\r\n   if (state->select_start == state->select_end)\r\n      state->select_start = state->cursor;\r\n\r\n   p = stb_text_locate_coord(str, x, y);\r\n   state->cursor = state->select_end = p;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n//      Keyboard input handling\r\n//\r\n\r\n// forward declarations\r\nstatic void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);\r\nstatic void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);\r\nstatic void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);\r\nstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);\r\nstatic void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);\r\n\r\ntypedef struct\r\n{\r\n   float x,y;    // position of n'th character\r\n   float height; // height of line\r\n   int first_char, length; // first char of row, and length\r\n   int prev_first;  // first char of previous row\r\n} StbFindState;\r\n\r\n// find the x/y location of a character, and remember info about the previous row in\r\n// case we get a move-up event (for page up, we'll have to rescan)\r\nstatic void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)\r\n{\r\n   StbTexteditRow r;\r\n   int prev_start = 0;\r\n   int z = STB_TEXTEDIT_STRINGLEN(str);\r\n   int i=0, first;\r\n\r\n   if (n == z) {\r\n      // if it's at the end, then find the last line -- simpler than trying to\r\n      // explicitly handle this case in the regular code\r\n      if (single_line) {\r\n         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);\r\n         find->y = 0;\r\n         find->first_char = 0;\r\n         find->length = z;\r\n         find->height = r.ymax - r.ymin;\r\n         find->x = r.x1;\r\n      } else {\r\n         find->y = 0;\r\n         find->x = 0;\r\n         find->height = 1;\r\n         while (i < z) {\r\n            STB_TEXTEDIT_LAYOUTROW(&r, str, i);\r\n            prev_start = i;\r\n            i += r.num_chars;\r\n         }\r\n         find->first_char = i;\r\n         find->length = 0;\r\n         find->prev_first = prev_start;\r\n      }\r\n      return;\r\n   }\r\n\r\n   // search rows to find the one that straddles character n\r\n   find->y = 0;\r\n\r\n   for(;;) {\r\n      STB_TEXTEDIT_LAYOUTROW(&r, str, i);\r\n      if (n < i + r.num_chars)\r\n         break;\r\n      prev_start = i;\r\n      i += r.num_chars;\r\n      find->y += r.baseline_y_delta;\r\n   }\r\n\r\n   find->first_char = first = i;\r\n   find->length = r.num_chars;\r\n   find->height = r.ymax - r.ymin;\r\n   find->prev_first = prev_start;\r\n\r\n   // now scan to find xpos\r\n   find->x = r.x0;\r\n   i = 0;\r\n   for (i=0; first+i < n; ++i)\r\n      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);\r\n}\r\n\r\n#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)\r\n\r\n// make the selection/cursor state valid if client altered the string\r\nstatic void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n{\r\n   int n = STB_TEXTEDIT_STRINGLEN(str);\r\n   if (STB_TEXT_HAS_SELECTION(state)) {\r\n      if (state->select_start > n) state->select_start = n;\r\n      if (state->select_end   > n) state->select_end = n;\r\n      // if clamping forced them to be equal, move the cursor to match\r\n      if (state->select_start == state->select_end)\r\n         state->cursor = state->select_start;\r\n   }\r\n   if (state->cursor > n) state->cursor = n;\r\n}\r\n\r\n// delete characters while updating undo\r\nstatic void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)\r\n{\r\n   stb_text_makeundo_delete(str, state, where, len);\r\n   STB_TEXTEDIT_DELETECHARS(str, where, len);\r\n   state->has_preferred_x = 0;\r\n}\r\n\r\n// delete the section\r\nstatic void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n{\r\n   stb_textedit_clamp(str, state);\r\n   if (STB_TEXT_HAS_SELECTION(state)) {\r\n      if (state->select_start < state->select_end) {\r\n         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);\r\n         state->select_end = state->cursor = state->select_start;\r\n      } else {\r\n         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);\r\n         state->select_start = state->cursor = state->select_end;\r\n      }\r\n      state->has_preferred_x = 0;\r\n   }\r\n}\r\n\r\n// canoncialize the selection so start <= end\r\nstatic void stb_textedit_sortselection(STB_TexteditState *state)\r\n{\r\n   if (state->select_end < state->select_start) {\r\n      int temp = state->select_end;\r\n      state->select_end = state->select_start;\r\n      state->select_start = temp;\r\n   }\r\n}\r\n\r\n// move cursor to first character of selection\r\nstatic void stb_textedit_move_to_first(STB_TexteditState *state)\r\n{\r\n   if (STB_TEXT_HAS_SELECTION(state)) {\r\n      stb_textedit_sortselection(state);\r\n      state->cursor = state->select_start;\r\n      state->select_end = state->select_start;\r\n      state->has_preferred_x = 0;\r\n   }\r\n}\r\n\r\n// move cursor to last character of selection\r\nstatic void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n{\r\n   if (STB_TEXT_HAS_SELECTION(state)) {\r\n      stb_textedit_sortselection(state);\r\n      stb_textedit_clamp(str, state);\r\n      state->cursor = state->select_end;\r\n      state->select_start = state->select_end;\r\n      state->has_preferred_x = 0;\r\n   }\r\n}\r\n\r\n#ifdef STB_TEXTEDIT_IS_SPACE\r\nstatic int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )\r\n{\r\n   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;\r\n}\r\n\r\n#ifndef STB_TEXTEDIT_MOVEWORDLEFT\r\nstatic int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )\r\n{\r\n   --c; // always move at least one character\r\n   while( c >= 0 && !is_word_boundary( str, c ) )\r\n      --c;\r\n\r\n   if( c < 0 )\r\n      c = 0;\r\n\r\n   return c;\r\n}\r\n#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous\r\n#endif\r\n\r\n#ifndef STB_TEXTEDIT_MOVEWORDRIGHT\r\nstatic int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )\r\n{\r\n   const int len = STB_TEXTEDIT_STRINGLEN(str);\r\n   ++c; // always move at least one character\r\n   while( c < len && !is_word_boundary( str, c ) )\r\n      ++c;\r\n\r\n   if( c > len )\r\n      c = len;\r\n\r\n   return c;\r\n}\r\n#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next\r\n#endif\r\n\r\n#endif\r\n\r\n// update selection and cursor to match each other\r\nstatic void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)\r\n{\r\n   if (!STB_TEXT_HAS_SELECTION(state))\r\n      state->select_start = state->select_end = state->cursor;\r\n   else\r\n      state->cursor = state->select_end;\r\n}\r\n\r\n// API cut: delete selection\r\nstatic int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n{\r\n   if (STB_TEXT_HAS_SELECTION(state)) {\r\n      stb_textedit_delete_selection(str,state); // implicity clamps\r\n      state->has_preferred_x = 0;\r\n      return 1;\r\n   }\r\n   return 0;\r\n}\r\n\r\n// API paste: replace existing selection with passed-in text\r\nstatic int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)\r\n{\r\n   // if there's a selection, the paste should delete it\r\n   stb_textedit_clamp(str, state);\r\n   stb_textedit_delete_selection(str,state);\r\n   // try to insert the characters\r\n   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {\r\n      stb_text_makeundo_insert(state, state->cursor, len);\r\n      state->cursor += len;\r\n      state->has_preferred_x = 0;\r\n      return 1;\r\n   }\r\n   // remove the undo since we didn't actually insert the characters\r\n   if (state->undostate.undo_point)\r\n      --state->undostate.undo_point;\r\n   return 0;\r\n}\r\n\r\n#ifndef STB_TEXTEDIT_KEYTYPE\r\n#define STB_TEXTEDIT_KEYTYPE int\r\n#endif\r\n\r\n// API key: process a keyboard input\r\nstatic void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)\r\n{\r\nretry:\r\n   switch (key) {\r\n      default: {\r\n         int c = STB_TEXTEDIT_KEYTOTEXT(key);\r\n         if (c > 0) {\r\n            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;\r\n\r\n            // can't add newline in single-line mode\r\n            if (c == '\\n' && state->single_line)\r\n               break;\r\n\r\n            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {\r\n               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);\r\n               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);\r\n               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {\r\n                  ++state->cursor;\r\n                  state->has_preferred_x = 0;\r\n               }\r\n            } else {\r\n               stb_textedit_delete_selection(str,state); // implicity clamps\r\n               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {\r\n                  stb_text_makeundo_insert(state, state->cursor, 1);\r\n                  ++state->cursor;\r\n                  state->has_preferred_x = 0;\r\n               }\r\n            }\r\n         }\r\n         break;\r\n      }\r\n\r\n#ifdef STB_TEXTEDIT_K_INSERT\r\n      case STB_TEXTEDIT_K_INSERT:\r\n         state->insert_mode = !state->insert_mode;\r\n         break;\r\n#endif\r\n         \r\n      case STB_TEXTEDIT_K_UNDO:\r\n         stb_text_undo(str, state);\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_REDO:\r\n         stb_text_redo(str, state);\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_LEFT:\r\n         // if currently there's a selection, move cursor to start of selection\r\n         if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_move_to_first(state);\r\n         else \r\n            if (state->cursor > 0)\r\n               --state->cursor;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_RIGHT:\r\n         // if currently there's a selection, move cursor to end of selection\r\n         if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_move_to_last(str, state);\r\n         else\r\n            ++state->cursor;\r\n         stb_textedit_clamp(str, state);\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_prep_selection_at_cursor(state);\r\n         // move selection left\r\n         if (state->select_end > 0)\r\n            --state->select_end;\r\n         state->cursor = state->select_end;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n#ifdef STB_TEXTEDIT_MOVEWORDLEFT\r\n      case STB_TEXTEDIT_K_WORDLEFT:\r\n         if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_move_to_first(state);\r\n         else {\r\n            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);\r\n            stb_textedit_clamp( str, state );\r\n         }\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:\r\n         if( !STB_TEXT_HAS_SELECTION( state ) )\r\n            stb_textedit_prep_selection_at_cursor(state);\r\n\r\n         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);\r\n         state->select_end = state->cursor;\r\n\r\n         stb_textedit_clamp( str, state );\r\n         break;\r\n#endif\r\n\r\n#ifdef STB_TEXTEDIT_MOVEWORDRIGHT\r\n      case STB_TEXTEDIT_K_WORDRIGHT:\r\n         if (STB_TEXT_HAS_SELECTION(state)) \r\n            stb_textedit_move_to_last(str, state);\r\n         else {\r\n            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);\r\n            stb_textedit_clamp( str, state );\r\n         }\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:\r\n         if( !STB_TEXT_HAS_SELECTION( state ) )\r\n            stb_textedit_prep_selection_at_cursor(state);\r\n\r\n         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);\r\n         state->select_end = state->cursor;\r\n\r\n         stb_textedit_clamp( str, state );\r\n         break;\r\n#endif\r\n\r\n      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:\r\n         stb_textedit_prep_selection_at_cursor(state);\r\n         // move selection right\r\n         ++state->select_end;\r\n         stb_textedit_clamp(str, state);\r\n         state->cursor = state->select_end;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_DOWN:\r\n      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {\r\n         StbFindState find;\r\n         StbTexteditRow row;\r\n         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;\r\n\r\n         if (state->single_line) {\r\n            // on windows, up&down in single-line behave like left&right\r\n            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);\r\n            goto retry;\r\n         }\r\n\r\n         if (sel)\r\n            stb_textedit_prep_selection_at_cursor(state);\r\n         else if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_move_to_last(str,state);\r\n\r\n         // compute current position of cursor point\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);\r\n\r\n         // now find character position down a row\r\n         if (find.length) {\r\n            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;\r\n            float x;\r\n            int start = find.first_char + find.length;\r\n            state->cursor = start;\r\n            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);\r\n            x = row.x0;\r\n            for (i=0; i < row.num_chars; ++i) {\r\n               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);\r\n               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE\r\n               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)\r\n                  break;\r\n               #endif\r\n               x += dx;\r\n               if (x > goal_x)\r\n                  break;\r\n               ++state->cursor;\r\n            }\r\n            stb_textedit_clamp(str, state);\r\n\r\n            state->has_preferred_x = 1;\r\n            state->preferred_x = goal_x;\r\n\r\n            if (sel)\r\n               state->select_end = state->cursor;\r\n         }\r\n         break;\r\n      }\r\n         \r\n      case STB_TEXTEDIT_K_UP:\r\n      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {\r\n         StbFindState find;\r\n         StbTexteditRow row;\r\n         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;\r\n\r\n         if (state->single_line) {\r\n            // on windows, up&down become left&right\r\n            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);\r\n            goto retry;\r\n         }\r\n\r\n         if (sel)\r\n            stb_textedit_prep_selection_at_cursor(state);\r\n         else if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_move_to_first(state);\r\n\r\n         // compute current position of cursor point\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);\r\n\r\n         // can only go up if there's a previous row\r\n         if (find.prev_first != find.first_char) {\r\n            // now find character position up a row\r\n            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;\r\n            float x;\r\n            state->cursor = find.prev_first;\r\n            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);\r\n            x = row.x0;\r\n            for (i=0; i < row.num_chars; ++i) {\r\n               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);\r\n               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE\r\n               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)\r\n                  break;\r\n               #endif\r\n               x += dx;\r\n               if (x > goal_x)\r\n                  break;\r\n               ++state->cursor;\r\n            }\r\n            stb_textedit_clamp(str, state);\r\n\r\n            state->has_preferred_x = 1;\r\n            state->preferred_x = goal_x;\r\n\r\n            if (sel)\r\n               state->select_end = state->cursor;\r\n         }\r\n         break;\r\n      }\r\n\r\n      case STB_TEXTEDIT_K_DELETE:\r\n      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:\r\n         if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_delete_selection(str, state);\r\n         else {\r\n            int n = STB_TEXTEDIT_STRINGLEN(str);\r\n            if (state->cursor < n)\r\n               stb_textedit_delete(str, state, state->cursor, 1);\r\n         }\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n      case STB_TEXTEDIT_K_BACKSPACE:\r\n      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:\r\n         if (STB_TEXT_HAS_SELECTION(state))\r\n            stb_textedit_delete_selection(str, state);\r\n         else {\r\n            stb_textedit_clamp(str, state);\r\n            if (state->cursor > 0) {\r\n               stb_textedit_delete(str, state, state->cursor-1, 1);\r\n               --state->cursor;\r\n            }\r\n         }\r\n         state->has_preferred_x = 0;\r\n         break;\r\n         \r\n#ifdef STB_TEXTEDIT_K_TEXTSTART2\r\n      case STB_TEXTEDIT_K_TEXTSTART2:\r\n#endif\r\n      case STB_TEXTEDIT_K_TEXTSTART:\r\n         state->cursor = state->select_start = state->select_end = 0;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n#ifdef STB_TEXTEDIT_K_TEXTEND2\r\n      case STB_TEXTEDIT_K_TEXTEND2:\r\n#endif\r\n      case STB_TEXTEDIT_K_TEXTEND:\r\n         state->cursor = STB_TEXTEDIT_STRINGLEN(str);\r\n         state->select_start = state->select_end = 0;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n        \r\n#ifdef STB_TEXTEDIT_K_TEXTSTART2\r\n      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:\r\n#endif\r\n      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:\r\n         stb_textedit_prep_selection_at_cursor(state);\r\n         state->cursor = state->select_end = 0;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n#ifdef STB_TEXTEDIT_K_TEXTEND2\r\n      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:\r\n#endif\r\n      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:\r\n         stb_textedit_prep_selection_at_cursor(state);\r\n         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n\r\n#ifdef STB_TEXTEDIT_K_LINESTART2\r\n      case STB_TEXTEDIT_K_LINESTART2:\r\n#endif\r\n      case STB_TEXTEDIT_K_LINESTART:\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_move_to_first(state);\r\n         if (state->single_line)\r\n            state->cursor = 0;\r\n         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)\r\n            --state->cursor;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n#ifdef STB_TEXTEDIT_K_LINEEND2\r\n      case STB_TEXTEDIT_K_LINEEND2:\r\n#endif\r\n      case STB_TEXTEDIT_K_LINEEND: {\r\n         int n = STB_TEXTEDIT_STRINGLEN(str);\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_move_to_first(state);\r\n         if (state->single_line)\r\n             state->cursor = n;\r\n         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)\r\n             ++state->cursor;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n      }\r\n\r\n#ifdef STB_TEXTEDIT_K_LINESTART2\r\n      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:\r\n#endif\r\n      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_prep_selection_at_cursor(state);\r\n         if (state->single_line)\r\n            state->cursor = 0;\r\n         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)\r\n            --state->cursor;\r\n         state->select_end = state->cursor;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n\r\n#ifdef STB_TEXTEDIT_K_LINEEND2\r\n      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:\r\n#endif\r\n      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {\r\n         int n = STB_TEXTEDIT_STRINGLEN(str);\r\n         stb_textedit_clamp(str, state);\r\n         stb_textedit_prep_selection_at_cursor(state);\r\n         if (state->single_line)\r\n             state->cursor = n;\r\n         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)\r\n            ++state->cursor;\r\n         state->select_end = state->cursor;\r\n         state->has_preferred_x = 0;\r\n         break;\r\n      }\r\n\r\n// @TODO:\r\n//    STB_TEXTEDIT_K_PGUP      - move cursor up a page\r\n//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page\r\n   }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n//      Undo processing\r\n//\r\n// @OPTIMIZE: the undo/redo buffer should be circular\r\n\r\nstatic void stb_textedit_flush_redo(StbUndoState *state)\r\n{\r\n   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;\r\n   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;\r\n}\r\n\r\n// discard the oldest entry in the undo list\r\nstatic void stb_textedit_discard_undo(StbUndoState *state)\r\n{\r\n   if (state->undo_point > 0) {\r\n      // if the 0th undo state has characters, clean those up\r\n      if (state->undo_rec[0].char_storage >= 0) {\r\n         int n = state->undo_rec[0].insert_length, i;\r\n         // delete n characters from all other records\r\n         state->undo_char_point -= n;\r\n         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));\r\n         for (i=0; i < state->undo_point; ++i)\r\n            if (state->undo_rec[i].char_storage >= 0)\r\n               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it\r\n      }\r\n      --state->undo_point;\r\n      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));\r\n   }\r\n}\r\n\r\n// discard the oldest entry in the redo list--it's bad if this\r\n// ever happens, but because undo & redo have to store the actual\r\n// characters in different cases, the redo character buffer can\r\n// fill up even though the undo buffer didn't\r\nstatic void stb_textedit_discard_redo(StbUndoState *state)\r\n{\r\n   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;\r\n\r\n   if (state->redo_point <= k) {\r\n      // if the k'th undo state has characters, clean those up\r\n      if (state->undo_rec[k].char_storage >= 0) {\r\n         int n = state->undo_rec[k].insert_length, i;\r\n         // move the remaining redo character data to the end of the buffer\r\n         state->redo_char_point += n;\r\n         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));\r\n         // adjust the position of all the other records to account for above memmove\r\n         for (i=state->redo_point; i < k; ++i)\r\n            if (state->undo_rec[i].char_storage >= 0)\r\n               state->undo_rec[i].char_storage += n;\r\n      }\r\n      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'\r\n      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, (size_t) ((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point)*sizeof(state->undo_rec[0])));\r\n      // now move redo_point to point to the new one\r\n      ++state->redo_point;\r\n   }\r\n}\r\n\r\nstatic StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)\r\n{\r\n   // any time we create a new undo record, we discard redo\r\n   stb_textedit_flush_redo(state);\r\n\r\n   // if we have no free records, we have to make room, by sliding the\r\n   // existing records down\r\n   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)\r\n      stb_textedit_discard_undo(state);\r\n\r\n   // if the characters to store won't possibly fit in the buffer, we can't undo\r\n   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {\r\n      state->undo_point = 0;\r\n      state->undo_char_point = 0;\r\n      return NULL;\r\n   }\r\n\r\n   // if we don't have enough free characters in the buffer, we have to make room\r\n   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)\r\n      stb_textedit_discard_undo(state);\r\n\r\n   return &state->undo_rec[state->undo_point++];\r\n}\r\n\r\nstatic STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)\r\n{\r\n   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);\r\n   if (r == NULL)\r\n      return NULL;\r\n\r\n   r->where = pos;\r\n   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;\r\n   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;\r\n\r\n   if (insert_len == 0) {\r\n      r->char_storage = -1;\r\n      return NULL;\r\n   } else {\r\n      r->char_storage = state->undo_char_point;\r\n      state->undo_char_point += insert_len;\r\n      return &state->undo_char[r->char_storage];\r\n   }\r\n}\r\n\r\nstatic void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n{\r\n   StbUndoState *s = &state->undostate;\r\n   StbUndoRecord u, *r;\r\n   if (s->undo_point == 0)\r\n      return;\r\n\r\n   // we need to do two things: apply the undo record, and create a redo record\r\n   u = s->undo_rec[s->undo_point-1];\r\n   r = &s->undo_rec[s->redo_point-1];\r\n   r->char_storage = -1;\r\n\r\n   r->insert_length = u.delete_length;\r\n   r->delete_length = u.insert_length;\r\n   r->where = u.where;\r\n\r\n   if (u.delete_length) {\r\n      // if the undo record says to delete characters, then the redo record will\r\n      // need to re-insert the characters that get deleted, so we need to store\r\n      // them.\r\n\r\n      // there are three cases:\r\n      //    there's enough room to store the characters\r\n      //    characters stored for *redoing* don't leave room for redo\r\n      //    characters stored for *undoing* don't leave room for redo\r\n      // if the last is true, we have to bail\r\n\r\n      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {\r\n         // the undo records take up too much character space; there's no space to store the redo characters\r\n         r->insert_length = 0;\r\n      } else {\r\n         int i;\r\n\r\n         // there's definitely room to store the characters eventually\r\n         while (s->undo_char_point + u.delete_length > s->redo_char_point) {\r\n            // should never happen:\r\n            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)\r\n               return;\r\n            // there's currently not enough room, so discard a redo record\r\n            stb_textedit_discard_redo(s);\r\n         }\r\n         r = &s->undo_rec[s->redo_point-1];\r\n\r\n         r->char_storage = s->redo_char_point - u.delete_length;\r\n         s->redo_char_point = s->redo_char_point - u.delete_length;\r\n\r\n         // now save the characters\r\n         for (i=0; i < u.delete_length; ++i)\r\n            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);\r\n      }\r\n\r\n      // now we can carry out the deletion\r\n      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);\r\n   }\r\n\r\n   // check type of recorded action:\r\n   if (u.insert_length) {\r\n      // easy case: was a deletion, so we need to insert n characters\r\n      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);\r\n      s->undo_char_point -= u.insert_length;\r\n   }\r\n\r\n   state->cursor = u.where + u.insert_length;\r\n\r\n   s->undo_point--;\r\n   s->redo_point--;\r\n}\r\n\r\nstatic void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)\r\n{\r\n   StbUndoState *s = &state->undostate;\r\n   StbUndoRecord *u, r;\r\n   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)\r\n      return;\r\n\r\n   // we need to do two things: apply the redo record, and create an undo record\r\n   u = &s->undo_rec[s->undo_point];\r\n   r = s->undo_rec[s->redo_point];\r\n\r\n   // we KNOW there must be room for the undo record, because the redo record\r\n   // was derived from an undo record\r\n\r\n   u->delete_length = r.insert_length;\r\n   u->insert_length = r.delete_length;\r\n   u->where = r.where;\r\n   u->char_storage = -1;\r\n\r\n   if (r.delete_length) {\r\n      // the redo record requires us to delete characters, so the undo record\r\n      // needs to store the characters\r\n\r\n      if (s->undo_char_point + u->insert_length > s->redo_char_point) {\r\n         u->insert_length = 0;\r\n         u->delete_length = 0;\r\n      } else {\r\n         int i;\r\n         u->char_storage = s->undo_char_point;\r\n         s->undo_char_point = s->undo_char_point + u->insert_length;\r\n\r\n         // now save the characters\r\n         for (i=0; i < u->insert_length; ++i)\r\n            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);\r\n      }\r\n\r\n      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);\r\n   }\r\n\r\n   if (r.insert_length) {\r\n      // easy case: need to insert n characters\r\n      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);\r\n      s->redo_char_point += r.insert_length;\r\n   }\r\n\r\n   state->cursor = r.where + r.insert_length;\r\n\r\n   s->undo_point++;\r\n   s->redo_point++;\r\n}\r\n\r\nstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)\r\n{\r\n   stb_text_createundo(&state->undostate, where, 0, length);\r\n}\r\n\r\nstatic void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)\r\n{\r\n   int i;\r\n   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);\r\n   if (p) {\r\n      for (i=0; i < length; ++i)\r\n         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);\r\n   }\r\n}\r\n\r\nstatic void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)\r\n{\r\n   int i;\r\n   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);\r\n   if (p) {\r\n      for (i=0; i < old_length; ++i)\r\n         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);\r\n   }\r\n}\r\n\r\n// reset the state to default\r\nstatic void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)\r\n{\r\n   state->undostate.undo_point = 0;\r\n   state->undostate.undo_char_point = 0;\r\n   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;\r\n   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;\r\n   state->select_end = state->select_start = 0;\r\n   state->cursor = 0;\r\n   state->has_preferred_x = 0;\r\n   state->preferred_x = 0;\r\n   state->cursor_at_end_of_line = 0;\r\n   state->initialized = 1;\r\n   state->single_line = (unsigned char) is_single_line;\r\n   state->insert_mode = 0;\r\n}\r\n\r\n// API initialize\r\nstatic void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)\r\n{\r\n   stb_textedit_clear_state(state, is_single_line);\r\n}\r\n\r\n#if defined(__GNUC__) || defined(__clang__)\r\n#pragma GCC diagnostic push\r\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\r\n#endif\r\n\r\nstatic int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)\r\n{\r\n   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);\r\n}\r\n\r\n#if defined(__GNUC__) || defined(__clang__)\r\n#pragma GCC diagnostic pop\r\n#endif\r\n\r\n#endif//STB_TEXTEDIT_IMPLEMENTATION\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \r\nsoftware, either in source code form or as a compiled binary, for any purpose, \r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this \r\nsoftware dedicate any and all copyright interest in the software to the public \r\ndomain. We make this dedication for the benefit of the public at large and to \r\nthe detriment of our heirs and successors. We intend this dedication to be an \r\novert act of relinquishment in perpetuity of all present and future rights to \r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/\r\n","// dear imgui, v1.67 WIP\r\n// (drawing and font code)\r\n\r\n/*\r\n\r\nIndex of this file:\r\n\r\n// [SECTION] STB libraries implementation\r\n// [SECTION] Style functions\r\n// [SECTION] ImDrawList\r\n// [SECTION] ImDrawData\r\n// [SECTION] Helpers ShadeVertsXXX functions\r\n// [SECTION] ImFontConfig\r\n// [SECTION] ImFontAtlas\r\n// [SECTION] ImFontAtlas glyph ranges helpers + GlyphRangesBuilder\r\n// [SECTION] ImFont\r\n// [SECTION] Internal Render Helpers\r\n// [SECTION] Decompression code\r\n// [SECTION] Default font data (ProggyClean.ttf)\r\n\r\n*/\r\n\r\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include \"imgui.h\"\r\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\r\n#define IMGUI_DEFINE_MATH_OPERATORS\r\n#endif\r\n#include \"imgui_internal.h\"\r\n\r\n#include <stdio.h>      // vsnprintf, sscanf, printf\r\n#if !defined(alloca)\r\n#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__)\r\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\r\n#elif defined(_WIN32)\r\n#include <malloc.h>     // alloca\r\n#if !defined(alloca)\r\n#define alloca _alloca  // for clang with MS Codegen\r\n#endif\r\n#else\r\n#include <stdlib.h>     // alloca\r\n#endif\r\n#endif\r\n\r\n// Visual Studio warnings\r\n#ifdef _MSC_VER\r\n#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)\r\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\r\n#endif\r\n\r\n// Clang/GCC warnings with -Weverything\r\n#ifdef __clang__\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\r\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.\r\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.\r\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\r\n#if __has_warning(\"-Wcomma\")\r\n#pragma clang diagnostic ignored \"-Wcomma\"                  // warning : possible misuse of comma operator here             //\r\n#endif\r\n#if __has_warning(\"-Wreserved-id-macro\")\r\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"      // warning : macro name is a reserved identifier                //\r\n#endif\r\n#if __has_warning(\"-Wdouble-promotion\")\r\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"       // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#endif\r\n#elif defined(__GNUC__)\r\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\r\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\r\n#if __GNUC__ >= 8\r\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\r\n#endif\r\n#endif\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] STB libraries implementation\r\n//-------------------------------------------------------------------------\r\n\r\n// Compile time options:\r\n//#define IMGUI_STB_NAMESPACE           ImGuiStb\r\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\r\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack.h\"\r\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\r\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\r\n\r\n#ifdef IMGUI_STB_NAMESPACE\r\nnamespace IMGUI_STB_NAMESPACE\r\n{\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (push)\r\n#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wunused-function\"\r\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\r\n#pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\r\n#pragma clang diagnostic ignored \"-Wcast-qual\"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //\r\n#endif\r\n\r\n#ifdef __GNUC__\r\n#pragma GCC diagnostic push\r\n#pragma GCC diagnostic ignored \"-Wtype-limits\"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]\r\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers\r\n#endif\r\n\r\n#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)\r\n#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\r\n#define STBRP_STATIC\r\n#define STBRP_ASSERT(x)     IM_ASSERT(x)\r\n#define STBRP_SORT          ImQsort\r\n#define STB_RECT_PACK_IMPLEMENTATION\r\n#endif\r\n#ifdef IMGUI_STB_RECT_PACK_FILENAME\r\n#include IMGUI_STB_RECT_PACK_FILENAME\r\n#else\r\n#include \"imstb_rectpack.h\"\r\n#endif\r\n#endif\r\n\r\n#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)\r\n#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\r\n#define STBTT_malloc(x,u)   ((void)(u), ImGui::MemAlloc(x))\r\n#define STBTT_free(x,u)     ((void)(u), ImGui::MemFree(x))\r\n#define STBTT_assert(x)     IM_ASSERT(x)\r\n#define STBTT_fmod(x,y)     ImFmod(x,y)\r\n#define STBTT_sqrt(x)       ImSqrt(x)\r\n#define STBTT_pow(x,y)      ImPow(x,y)\r\n#define STBTT_fabs(x)       ImFabs(x)\r\n#define STBTT_ifloor(x)     ((int)ImFloorStd(x))\r\n#define STBTT_iceil(x)      ((int)ImCeil(x))\r\n#define STBTT_STATIC\r\n#define STB_TRUETYPE_IMPLEMENTATION\r\n#else\r\n#define STBTT_DEF extern\r\n#endif\r\n#ifdef IMGUI_STB_TRUETYPE_FILENAME\r\n#include IMGUI_STB_TRUETYPE_FILENAME\r\n#else\r\n#include \"imstb_truetype.h\"\r\n#endif\r\n#endif\r\n\r\n#ifdef __GNUC__\r\n#pragma GCC diagnostic pop\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (pop)\r\n#endif\r\n\r\n#ifdef IMGUI_STB_NAMESPACE\r\n} // namespace ImGuiStb\r\nusing namespace IMGUI_STB_NAMESPACE;\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Style functions\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::StyleColorsDark(ImGuiStyle* dst)\r\n{\r\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\r\n    ImVec4* colors = style->Colors;\r\n\r\n    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);\r\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);\r\n    colors[ImGuiCol_ChildBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.00f);\r\n    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);\r\n    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);\r\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);\r\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);\r\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);\r\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);\r\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);\r\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);\r\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);\r\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);\r\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);\r\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];\r\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);\r\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);\r\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);\r\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\r\n    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);\r\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);\r\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);\r\n    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);\r\n    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);\r\n    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);\r\n}\r\n\r\nvoid ImGui::StyleColorsClassic(ImGuiStyle* dst)\r\n{\r\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\r\n    ImVec4* colors = style->Colors;\r\n\r\n    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\r\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);\r\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);\r\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);\r\n    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);\r\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);\r\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);\r\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);\r\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);\r\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);\r\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);\r\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);\r\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);\r\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);\r\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);\r\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);\r\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);\r\n    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);\r\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);\r\n    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);\r\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);\r\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);\r\n    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);\r\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);\r\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);\r\n    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);\r\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);\r\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);\r\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);\r\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);\r\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);\r\n    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);\r\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);\r\n    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];\r\n    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);\r\n    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);\r\n    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);\r\n}\r\n\r\n// Those light colors are better suited with a thicker font than the default one + FrameBorder\r\nvoid ImGui::StyleColorsLight(ImGuiStyle* dst)\r\n{\r\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\r\n    ImVec4* colors = style->Colors;\r\n\r\n    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);\r\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);\r\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);\r\n    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);\r\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);\r\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);\r\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);\r\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);\r\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);\r\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);\r\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);\r\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);\r\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);\r\n    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);\r\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);\r\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);\r\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);\r\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);\r\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);\r\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\r\n    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);\r\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);\r\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\r\n    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];\r\n    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);\r\n    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);\r\n    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImDrawList\r\n//-----------------------------------------------------------------------------\r\n\r\nImDrawListSharedData::ImDrawListSharedData()\r\n{\r\n    Font = NULL;\r\n    FontSize = 0.0f;\r\n    CurveTessellationTol = 0.0f;\r\n    ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);\r\n\r\n    // Const data\r\n    for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)\r\n    {\r\n        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);\r\n        CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));\r\n    }\r\n}\r\n\r\nvoid ImDrawList::Clear()\r\n{\r\n    CmdBuffer.resize(0);\r\n    IdxBuffer.resize(0);\r\n    VtxBuffer.resize(0);\r\n    Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;\r\n    _VtxCurrentIdx = 0;\r\n    _VtxWritePtr = NULL;\r\n    _IdxWritePtr = NULL;\r\n    _ClipRectStack.resize(0);\r\n    _TextureIdStack.resize(0);\r\n    _Path.resize(0);\r\n    _ChannelsCurrent = 0;\r\n    _ChannelsCount = 1;\r\n    // NB: Do not clear channels so our allocations are re-used after the first frame.\r\n}\r\n\r\nvoid ImDrawList::ClearFreeMemory()\r\n{\r\n    CmdBuffer.clear();\r\n    IdxBuffer.clear();\r\n    VtxBuffer.clear();\r\n    _VtxCurrentIdx = 0;\r\n    _VtxWritePtr = NULL;\r\n    _IdxWritePtr = NULL;\r\n    _ClipRectStack.clear();\r\n    _TextureIdStack.clear();\r\n    _Path.clear();\r\n    _ChannelsCurrent = 0;\r\n    _ChannelsCount = 1;\r\n    for (int i = 0; i < _Channels.Size; i++)\r\n    {\r\n        if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again\r\n        _Channels[i].CmdBuffer.clear();\r\n        _Channels[i].IdxBuffer.clear();\r\n    }\r\n    _Channels.clear();\r\n}\r\n\r\nImDrawList* ImDrawList::CloneOutput() const\r\n{\r\n    ImDrawList* dst = IM_NEW(ImDrawList(NULL));\r\n    dst->CmdBuffer = CmdBuffer;\r\n    dst->IdxBuffer = IdxBuffer;\r\n    dst->VtxBuffer = VtxBuffer;\r\n    dst->Flags = Flags;\r\n    return dst;\r\n}\r\n\r\n// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds\r\n#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)\r\n#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : NULL)\r\n\r\nvoid ImDrawList::AddDrawCmd()\r\n{\r\n    ImDrawCmd draw_cmd;\r\n    draw_cmd.ClipRect = GetCurrentClipRect();\r\n    draw_cmd.TextureId = GetCurrentTextureId();\r\n\r\n    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);\r\n    CmdBuffer.push_back(draw_cmd);\r\n}\r\n\r\nvoid ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)\r\n{\r\n    ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;\r\n    if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)\r\n    {\r\n        AddDrawCmd();\r\n        current_cmd = &CmdBuffer.back();\r\n    }\r\n    current_cmd->UserCallback = callback;\r\n    current_cmd->UserCallbackData = callback_data;\r\n\r\n    AddDrawCmd(); // Force a new command after us (see comment below)\r\n}\r\n\r\n// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.\r\n// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.\r\nvoid ImDrawList::UpdateClipRect()\r\n{\r\n    // If current command is used with different settings we need to add a new command\r\n    const ImVec4 curr_clip_rect = GetCurrentClipRect();\r\n    ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;\r\n    if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)\r\n    {\r\n        AddDrawCmd();\r\n        return;\r\n    }\r\n\r\n    // Try to merge with previous command if it matches, else use current command\r\n    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;\r\n    if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)\r\n        CmdBuffer.pop_back();\r\n    else\r\n        curr_cmd->ClipRect = curr_clip_rect;\r\n}\r\n\r\nvoid ImDrawList::UpdateTextureID()\r\n{\r\n    // If current command is used with different settings we need to add a new command\r\n    const ImTextureID curr_texture_id = GetCurrentTextureId();\r\n    ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;\r\n    if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)\r\n    {\r\n        AddDrawCmd();\r\n        return;\r\n    }\r\n\r\n    // Try to merge with previous command if it matches, else use current command\r\n    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;\r\n    if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)\r\n        CmdBuffer.pop_back();\r\n    else\r\n        curr_cmd->TextureId = curr_texture_id;\r\n}\r\n\r\n#undef GetCurrentClipRect\r\n#undef GetCurrentTextureId\r\n\r\n// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\r\nvoid ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)\r\n{\r\n    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);\r\n    if (intersect_with_current_clip_rect && _ClipRectStack.Size)\r\n    {\r\n        ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];\r\n        if (cr.x < current.x) cr.x = current.x;\r\n        if (cr.y < current.y) cr.y = current.y;\r\n        if (cr.z > current.z) cr.z = current.z;\r\n        if (cr.w > current.w) cr.w = current.w;\r\n    }\r\n    cr.z = ImMax(cr.x, cr.z);\r\n    cr.w = ImMax(cr.y, cr.w);\r\n\r\n    _ClipRectStack.push_back(cr);\r\n    UpdateClipRect();\r\n}\r\n\r\nvoid ImDrawList::PushClipRectFullScreen()\r\n{\r\n    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));\r\n}\r\n\r\nvoid ImDrawList::PopClipRect()\r\n{\r\n    IM_ASSERT(_ClipRectStack.Size > 0);\r\n    _ClipRectStack.pop_back();\r\n    UpdateClipRect();\r\n}\r\n\r\nvoid ImDrawList::PushTextureID(ImTextureID texture_id)\r\n{\r\n    _TextureIdStack.push_back(texture_id);\r\n    UpdateTextureID();\r\n}\r\n\r\nvoid ImDrawList::PopTextureID()\r\n{\r\n    IM_ASSERT(_TextureIdStack.Size > 0);\r\n    _TextureIdStack.pop_back();\r\n    UpdateTextureID();\r\n}\r\n\r\nvoid ImDrawList::ChannelsSplit(int channels_count)\r\n{\r\n    IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);\r\n    int old_channels_count = _Channels.Size;\r\n    if (old_channels_count < channels_count)\r\n        _Channels.resize(channels_count);\r\n    _ChannelsCount = channels_count;\r\n\r\n    // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer\r\n    // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.\r\n    // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer\r\n    memset(&_Channels[0], 0, sizeof(ImDrawChannel));\r\n    for (int i = 1; i < channels_count; i++)\r\n    {\r\n        if (i >= old_channels_count)\r\n        {\r\n            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();\r\n        }\r\n        else\r\n        {\r\n            _Channels[i].CmdBuffer.resize(0);\r\n            _Channels[i].IdxBuffer.resize(0);\r\n        }\r\n        if (_Channels[i].CmdBuffer.Size == 0)\r\n        {\r\n            ImDrawCmd draw_cmd;\r\n            draw_cmd.ClipRect = _ClipRectStack.back();\r\n            draw_cmd.TextureId = _TextureIdStack.back();\r\n            _Channels[i].CmdBuffer.push_back(draw_cmd);\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImDrawList::ChannelsMerge()\r\n{\r\n    // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.\r\n    if (_ChannelsCount <= 1)\r\n        return;\r\n\r\n    ChannelsSetCurrent(0);\r\n    if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)\r\n        CmdBuffer.pop_back();\r\n\r\n    int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;\r\n    for (int i = 1; i < _ChannelsCount; i++)\r\n    {\r\n        ImDrawChannel& ch = _Channels[i];\r\n        if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)\r\n            ch.CmdBuffer.pop_back();\r\n        new_cmd_buffer_count += ch.CmdBuffer.Size;\r\n        new_idx_buffer_count += ch.IdxBuffer.Size;\r\n    }\r\n    CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);\r\n    IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);\r\n\r\n    ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;\r\n    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;\r\n    for (int i = 1; i < _ChannelsCount; i++)\r\n    {\r\n        ImDrawChannel& ch = _Channels[i];\r\n        if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }\r\n        if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }\r\n    }\r\n    UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.\r\n    _ChannelsCount = 1;\r\n}\r\n\r\nvoid ImDrawList::ChannelsSetCurrent(int idx)\r\n{\r\n    IM_ASSERT(idx < _ChannelsCount);\r\n    if (_ChannelsCurrent == idx) return;\r\n    memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times\r\n    memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));\r\n    _ChannelsCurrent = idx;\r\n    memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));\r\n    memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));\r\n    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;\r\n}\r\n\r\n// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)\r\nvoid ImDrawList::PrimReserve(int idx_count, int vtx_count)\r\n{\r\n    ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];\r\n    draw_cmd.ElemCount += idx_count;\r\n\r\n    int vtx_buffer_old_size = VtxBuffer.Size;\r\n    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);\r\n    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;\r\n\r\n    int idx_buffer_old_size = IdxBuffer.Size;\r\n    IdxBuffer.resize(idx_buffer_old_size + idx_count);\r\n    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;\r\n}\r\n\r\n// Fully unrolled with inline call to keep our debug builds decently fast.\r\nvoid ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)\r\n{\r\n    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);\r\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\r\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\r\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\r\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\r\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\r\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;\r\n    _VtxWritePtr += 4;\r\n    _VtxCurrentIdx += 4;\r\n    _IdxWritePtr += 6;\r\n}\r\n\r\nvoid ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)\r\n{\r\n    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);\r\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\r\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\r\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\r\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;\r\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;\r\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;\r\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;\r\n    _VtxWritePtr += 4;\r\n    _VtxCurrentIdx += 4;\r\n    _IdxWritePtr += 6;\r\n}\r\n\r\nvoid ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)\r\n{\r\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\r\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\r\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\r\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;\r\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;\r\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;\r\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;\r\n    _VtxWritePtr += 4;\r\n    _VtxCurrentIdx += 4;\r\n    _IdxWritePtr += 6;\r\n}\r\n\r\n// TODO: Thickness anti-aliased lines cap are missing their AA fringe.\r\nvoid ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)\r\n{\r\n    if (points_count < 2)\r\n        return;\r\n\r\n    const ImVec2 uv = _Data->TexUvWhitePixel;\r\n\r\n    int count = points_count;\r\n    if (!closed)\r\n        count = points_count-1;\r\n\r\n    const bool thick_line = thickness > 1.0f;\r\n    if (Flags & ImDrawListFlags_AntiAliasedLines)\r\n    {\r\n        // Anti-aliased stroke\r\n        const float AA_SIZE = 1.0f;\r\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\r\n\r\n        const int idx_count = thick_line ? count*18 : count*12;\r\n        const int vtx_count = thick_line ? points_count*4 : points_count*3;\r\n        PrimReserve(idx_count, vtx_count);\r\n\r\n        // Temporary buffer\r\n        ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));\r\n        ImVec2* temp_points = temp_normals + points_count;\r\n\r\n        for (int i1 = 0; i1 < count; i1++)\r\n        {\r\n            const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n            ImVec2 diff = points[i2] - points[i1];\r\n            diff *= ImInvLength(diff, 1.0f);\r\n            temp_normals[i1].x = diff.y;\r\n            temp_normals[i1].y = -diff.x;\r\n        }\r\n        if (!closed)\r\n            temp_normals[points_count-1] = temp_normals[points_count-2];\r\n\r\n        if (!thick_line)\r\n        {\r\n            if (!closed)\r\n            {\r\n                temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;\r\n                temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;\r\n                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;\r\n                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;\r\n            }\r\n\r\n            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.\r\n            unsigned int idx1 = _VtxCurrentIdx;\r\n            for (int i1 = 0; i1 < count; i1++)\r\n            {\r\n                const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;\r\n\r\n                // Average normals\r\n                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;\r\n                float dmr2 = dm.x*dm.x + dm.y*dm.y;\r\n                if (dmr2 > 0.000001f)\r\n                {\r\n                    float scale = 1.0f / dmr2;\r\n                    if (scale > 100.0f) scale = 100.0f;\r\n                    dm *= scale;\r\n                }\r\n                dm *= AA_SIZE;\r\n                temp_points[i2*2+0] = points[i2] + dm;\r\n                temp_points[i2*2+1] = points[i2] - dm;\r\n\r\n                // Add indexes\r\n                _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);\r\n                _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);\r\n                _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);\r\n                _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);\r\n                _IdxWritePtr += 12;\r\n\r\n                idx1 = idx2;\r\n            }\r\n\r\n            // Add vertexes\r\n            for (int i = 0; i < points_count; i++)\r\n            {\r\n                _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n                _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;\r\n                _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;\r\n                _VtxWritePtr += 3;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;\r\n            if (!closed)\r\n            {\r\n                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);\r\n                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);\r\n                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);\r\n                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);\r\n                temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);\r\n                temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);\r\n                temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);\r\n                temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);\r\n            }\r\n\r\n            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.\r\n            unsigned int idx1 = _VtxCurrentIdx;\r\n            for (int i1 = 0; i1 < count; i1++)\r\n            {\r\n                const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;\r\n\r\n                // Average normals\r\n                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;\r\n                float dmr2 = dm.x*dm.x + dm.y*dm.y;\r\n                if (dmr2 > 0.000001f)\r\n                {\r\n                    float scale = 1.0f / dmr2;\r\n                    if (scale > 100.0f) scale = 100.0f;\r\n                    dm *= scale;\r\n                }\r\n                ImVec2 dm_out = dm * (half_inner_thickness + AA_SIZE);\r\n                ImVec2 dm_in = dm * half_inner_thickness;\r\n                temp_points[i2*4+0] = points[i2] + dm_out;\r\n                temp_points[i2*4+1] = points[i2] + dm_in;\r\n                temp_points[i2*4+2] = points[i2] - dm_in;\r\n                temp_points[i2*4+3] = points[i2] - dm_out;\r\n\r\n                // Add indexes\r\n                _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);\r\n                _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);\r\n                _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);\r\n                _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);\r\n                _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);\r\n                _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);\r\n                _IdxWritePtr += 18;\r\n\r\n                idx1 = idx2;\r\n            }\r\n\r\n            // Add vertexes\r\n            for (int i = 0; i < points_count; i++)\r\n            {\r\n                _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;\r\n                _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\r\n                _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\r\n                _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;\r\n                _VtxWritePtr += 4;\r\n            }\r\n        }\r\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\r\n    }\r\n    else\r\n    {\r\n        // Non Anti-aliased Stroke\r\n        const int idx_count = count*6;\r\n        const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges\r\n        PrimReserve(idx_count, vtx_count);\r\n\r\n        for (int i1 = 0; i1 < count; i1++)\r\n        {\r\n            const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n            const ImVec2& p1 = points[i1];\r\n            const ImVec2& p2 = points[i2];\r\n            ImVec2 diff = p2 - p1;\r\n            diff *= ImInvLength(diff, 1.0f);\r\n\r\n            const float dx = diff.x * (thickness * 0.5f);\r\n            const float dy = diff.y * (thickness * 0.5f);\r\n            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\r\n            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\r\n            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;\r\n            _VtxWritePtr += 4;\r\n\r\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);\r\n            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);\r\n            _IdxWritePtr += 6;\r\n            _VtxCurrentIdx += 4;\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)\r\n{\r\n    if (points_count < 3)\r\n        return;\r\n\r\n    const ImVec2 uv = _Data->TexUvWhitePixel;\r\n\r\n    if (Flags & ImDrawListFlags_AntiAliasedFill)\r\n    {\r\n        // Anti-aliased Fill\r\n        const float AA_SIZE = 1.0f;\r\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\r\n        const int idx_count = (points_count-2)*3 + points_count*6;\r\n        const int vtx_count = (points_count*2);\r\n        PrimReserve(idx_count, vtx_count);\r\n\r\n        // Add indexes for fill\r\n        unsigned int vtx_inner_idx = _VtxCurrentIdx;\r\n        unsigned int vtx_outer_idx = _VtxCurrentIdx+1;\r\n        for (int i = 2; i < points_count; i++)\r\n        {\r\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));\r\n            _IdxWritePtr += 3;\r\n        }\r\n\r\n        // Compute normals\r\n        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2));\r\n        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)\r\n        {\r\n            const ImVec2& p0 = points[i0];\r\n            const ImVec2& p1 = points[i1];\r\n            ImVec2 diff = p1 - p0;\r\n            diff *= ImInvLength(diff, 1.0f);\r\n            temp_normals[i0].x = diff.y;\r\n            temp_normals[i0].y = -diff.x;\r\n        }\r\n\r\n        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)\r\n        {\r\n            // Average normals\r\n            const ImVec2& n0 = temp_normals[i0];\r\n            const ImVec2& n1 = temp_normals[i1];\r\n            ImVec2 dm = (n0 + n1) * 0.5f;\r\n            float dmr2 = dm.x*dm.x + dm.y*dm.y;\r\n            if (dmr2 > 0.000001f)\r\n            {\r\n                float scale = 1.0f / dmr2;\r\n                if (scale > 100.0f) scale = 100.0f;\r\n                dm *= scale;\r\n            }\r\n            dm *= AA_SIZE * 0.5f;\r\n\r\n            // Add vertices\r\n            _VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner\r\n            _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer\r\n            _VtxWritePtr += 2;\r\n\r\n            // Add indexes for fringes\r\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));\r\n            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));\r\n            _IdxWritePtr += 6;\r\n        }\r\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\r\n    }\r\n    else\r\n    {\r\n        // Non Anti-aliased Fill\r\n        const int idx_count = (points_count-2)*3;\r\n        const int vtx_count = points_count;\r\n        PrimReserve(idx_count, vtx_count);\r\n        for (int i = 0; i < vtx_count; i++)\r\n        {\r\n            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n            _VtxWritePtr++;\r\n        }\r\n        for (int i = 2; i < points_count; i++)\r\n        {\r\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);\r\n            _IdxWritePtr += 3;\r\n        }\r\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)\r\n{\r\n    if (radius == 0.0f || a_min_of_12 > a_max_of_12)\r\n    {\r\n        _Path.push_back(centre);\r\n        return;\r\n    }\r\n    _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));\r\n    for (int a = a_min_of_12; a <= a_max_of_12; a++)\r\n    {\r\n        const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];\r\n        _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)\r\n{\r\n    if (radius == 0.0f)\r\n    {\r\n        _Path.push_back(centre);\r\n        return;\r\n    }\r\n    _Path.reserve(_Path.Size + (num_segments + 1));\r\n    for (int i = 0; i <= num_segments; i++)\r\n    {\r\n        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);\r\n        _Path.push_back(ImVec2(centre.x + ImCos(a) * radius, centre.y + ImSin(a) * radius));\r\n    }\r\n}\r\n\r\nstatic void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)\r\n{\r\n    float dx = x4 - x1;\r\n    float dy = y4 - y1;\r\n    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);\r\n    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);\r\n    d2 = (d2 >= 0) ? d2 : -d2;\r\n    d3 = (d3 >= 0) ? d3 : -d3;\r\n    if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))\r\n    {\r\n        path->push_back(ImVec2(x4, y4));\r\n    }\r\n    else if (level < 10)\r\n    {\r\n        float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;\r\n        float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;\r\n        float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;\r\n        float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;\r\n        float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;\r\n        float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;\r\n\r\n        PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);\r\n        PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)\r\n{\r\n    ImVec2 p1 = _Path.back();\r\n    if (num_segments == 0)\r\n    {\r\n        // Auto-tessellated\r\n        PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);\r\n    }\r\n    else\r\n    {\r\n        float t_step = 1.0f / (float)num_segments;\r\n        for (int i_step = 1; i_step <= num_segments; i_step++)\r\n        {\r\n            float t = t_step * i_step;\r\n            float u = 1.0f - t;\r\n            float w1 = u*u*u;\r\n            float w2 = 3*u*u*t;\r\n            float w3 = 3*u*t*t;\r\n            float w4 = t*t*t;\r\n            _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)\r\n{\r\n    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);\r\n    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);\r\n\r\n    if (rounding <= 0.0f || rounding_corners == 0)\r\n    {\r\n        PathLineTo(a);\r\n        PathLineTo(ImVec2(b.x, a.y));\r\n        PathLineTo(b);\r\n        PathLineTo(ImVec2(a.x, b.y));\r\n    }\r\n    else\r\n    {\r\n        const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;\r\n        const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;\r\n        const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;\r\n        const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;\r\n        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);\r\n        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);\r\n        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);\r\n        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);\r\n    }\r\n}\r\n\r\nvoid ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n    PathLineTo(a + ImVec2(0.5f,0.5f));\r\n    PathLineTo(b + ImVec2(0.5f,0.5f));\r\n    PathStroke(col, false, thickness);\r\n}\r\n\r\n// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.\r\nvoid ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n    if (Flags & ImDrawListFlags_AntiAliasedLines)\r\n        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.50f,0.50f), rounding, rounding_corners_flags);\r\n    else\r\n        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.49f,0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n    if (rounding > 0.0f)\r\n    {\r\n        PathRect(a, b, rounding, rounding_corners_flags);\r\n        PathFillConvex(col);\r\n    }\r\n    else\r\n    {\r\n        PrimReserve(6, 4);\r\n        PrimRect(a, b, col);\r\n    }\r\n}\r\n\r\nvoid ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)\r\n{\r\n    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const ImVec2 uv = _Data->TexUvWhitePixel;\r\n    PrimReserve(6, 4);\r\n    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));\r\n    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));\r\n    PrimWriteVtx(a, uv, col_upr_left);\r\n    PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);\r\n    PrimWriteVtx(c, uv, col_bot_right);\r\n    PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);\r\n}\r\n\r\nvoid ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathLineTo(d);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathLineTo(d);\r\n    PathFillConvex(col);\r\n}\r\n\r\nvoid ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathFillConvex(col);\r\n}\r\n\r\nvoid ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;\r\n    PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;\r\n    PathArcTo(centre, radius, 0.0f, a_max, num_segments);\r\n    PathFillConvex(col);\r\n}\r\n\r\nvoid ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(pos0);\r\n    PathBezierCurveTo(cp0, cp1, pos1, num_segments);\r\n    PathStroke(col, false, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    if (text_end == NULL)\r\n        text_end = text_begin + strlen(text_begin);\r\n    if (text_begin == text_end)\r\n        return;\r\n\r\n    // Pull default font/size from the shared ImDrawListSharedData instance\r\n    if (font == NULL)\r\n        font = _Data->Font;\r\n    if (font_size == 0.0f)\r\n        font_size = _Data->FontSize;\r\n\r\n    IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.\r\n\r\n    ImVec4 clip_rect = _ClipRectStack.back();\r\n    if (cpu_fine_clip_rect)\r\n    {\r\n        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);\r\n        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);\r\n        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);\r\n        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);\r\n    }\r\n    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);\r\n}\r\n\r\nvoid ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)\r\n{\r\n    AddText(NULL, 0.0f, pos, col, text_begin, text_end);\r\n}\r\n\r\nvoid ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();\r\n    if (push_texture_id)\r\n        PushTextureID(user_texture_id);\r\n\r\n    PrimReserve(6, 4);\r\n    PrimRectUV(a, b, uv_a, uv_b, col);\r\n\r\n    if (push_texture_id)\r\n        PopTextureID();\r\n}\r\n\r\nvoid ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();\r\n    if (push_texture_id)\r\n        PushTextureID(user_texture_id);\r\n\r\n    PrimReserve(6, 4);\r\n    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);\r\n\r\n    if (push_texture_id)\r\n        PopTextureID();\r\n}\r\n\r\nvoid ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)\r\n    {\r\n        AddImage(user_texture_id, a, b, uv_a, uv_b, col);\r\n        return;\r\n    }\r\n\r\n    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();\r\n    if (push_texture_id)\r\n        PushTextureID(user_texture_id);\r\n\r\n    int vert_start_idx = VtxBuffer.Size;\r\n    PathRect(a, b, rounding, rounding_corners);\r\n    PathFillConvex(col);\r\n    int vert_end_idx = VtxBuffer.Size;\r\n    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, true);\r\n\r\n    if (push_texture_id)\r\n        PopTextureID();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImDrawData\r\n//-----------------------------------------------------------------------------\r\n\r\n// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\r\nvoid ImDrawData::DeIndexAllBuffers()\r\n{\r\n    ImVector<ImDrawVert> new_vtx_buffer;\r\n    TotalVtxCount = TotalIdxCount = 0;\r\n    for (int i = 0; i < CmdListsCount; i++)\r\n    {\r\n        ImDrawList* cmd_list = CmdLists[i];\r\n        if (cmd_list->IdxBuffer.empty())\r\n            continue;\r\n        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);\r\n        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)\r\n            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];\r\n        cmd_list->VtxBuffer.swap(new_vtx_buffer);\r\n        cmd_list->IdxBuffer.resize(0);\r\n        TotalVtxCount += cmd_list->VtxBuffer.Size;\r\n    }\r\n}\r\n\r\n// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\r\nvoid ImDrawData::ScaleClipRects(const ImVec2& scale)\r\n{\r\n    for (int i = 0; i < CmdListsCount; i++)\r\n    {\r\n        ImDrawList* cmd_list = CmdLists[i];\r\n        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)\r\n        {\r\n            ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];\r\n            cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Helpers ShadeVertsXXX functions\r\n//-----------------------------------------------------------------------------\r\n\r\n// Generic linear color gradient, write to RGB fields, leave A untouched.\r\nvoid ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)\r\n{\r\n    ImVec2 gradient_extent = gradient_p1 - gradient_p0;\r\n    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);\r\n    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;\r\n    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;\r\n    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)\r\n    {\r\n        float d = ImDot(vert->pos - gradient_p0, gradient_extent);\r\n        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);\r\n        int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);\r\n        int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);\r\n        int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);\r\n        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);\r\n    }\r\n}\r\n\r\n// Distribute UV over (a, b) rectangle\r\nvoid ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)\r\n{\r\n    const ImVec2 size = b - a;\r\n    const ImVec2 uv_size = uv_b - uv_a;\r\n    const ImVec2 scale = ImVec2(\r\n        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,\r\n        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);\r\n\r\n    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;\r\n    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;\r\n    if (clamp)\r\n    {\r\n        const ImVec2 min = ImMin(uv_a, uv_b);\r\n        const ImVec2 max = ImMax(uv_a, uv_b);\r\n        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\r\n            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);\r\n    }\r\n    else\r\n    {\r\n        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\r\n            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImFontConfig\r\n//-----------------------------------------------------------------------------\r\n\r\nImFontConfig::ImFontConfig()\r\n{\r\n    FontData = NULL;\r\n    FontDataSize = 0;\r\n    FontDataOwnedByAtlas = true;\r\n    FontNo = 0;\r\n    SizePixels = 0.0f;\r\n    OversampleH = 3;\r\n    OversampleV = 1;\r\n    PixelSnapH = false;\r\n    GlyphExtraSpacing = ImVec2(0.0f, 0.0f);\r\n    GlyphOffset = ImVec2(0.0f, 0.0f);\r\n    GlyphRanges = NULL;\r\n    GlyphMinAdvanceX = 0.0f;\r\n    GlyphMaxAdvanceX = FLT_MAX;\r\n    MergeMode = false;\r\n    RasterizerFlags = 0x00;\r\n    RasterizerMultiply = 1.0f;\r\n    memset(Name, 0, sizeof(Name));\r\n    DstFont = NULL;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImFontAtlas\r\n//-----------------------------------------------------------------------------\r\n\r\n// A work of art lies ahead! (. = white layer, X = black layer, others are blank)\r\n// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.\r\nconst int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;\r\nconst int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;\r\nconst unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;\r\nstatic const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =\r\n{\r\n    \"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          \"\r\n    \"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         \"\r\n    \"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         \"\r\n    \"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         \"\r\n    \"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         \"\r\n    \"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       \"\r\n    \"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    \"\r\n    \"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  \"\r\n    \"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X \"\r\n    \"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X\"\r\n    \"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X\"\r\n    \"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X\"\r\n    \"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X\"\r\n    \"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X\"\r\n    \"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X\"\r\n    \"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X\"\r\n    \"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X \"\r\n    \"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X \"\r\n    \"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X \"\r\n    \"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  \"\r\n    \"      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  \"\r\n    \"       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  \"\r\n    \"------------        -    X    -           X           -X.....................X-           ------------------\"\r\n    \"                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             \"\r\n    \"                                                      -  X..X           X..X  -                             \"\r\n    \"                                                      -   X.X           X.X   -                             \"\r\n    \"                                                      -    XX           XX    -                             \"\r\n};\r\n\r\nstatic const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =\r\n{\r\n    // Pos ........ Size ......... Offset ......\r\n    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow\r\n    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput\r\n    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll\r\n    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS\r\n    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW\r\n    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW\r\n    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE\r\n    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand\r\n};\r\n\r\nImFontAtlas::ImFontAtlas()\r\n{\r\n    Locked = false;\r\n    Flags = ImFontAtlasFlags_None;\r\n    TexID = (ImTextureID)NULL;\r\n    TexDesiredWidth = 0;\r\n    TexGlyphPadding = 1;\r\n\r\n    TexPixelsAlpha8 = NULL;\r\n    TexPixelsRGBA32 = NULL;\r\n    TexWidth = TexHeight = 0;\r\n    TexUvScale = ImVec2(0.0f, 0.0f);\r\n    TexUvWhitePixel = ImVec2(0.0f, 0.0f);\r\n    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)\r\n        CustomRectIds[n] = -1;\r\n}\r\n\r\nImFontAtlas::~ImFontAtlas()\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    Clear();\r\n}\r\n\r\nvoid    ImFontAtlas::ClearInputData()\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    for (int i = 0; i < ConfigData.Size; i++)\r\n        if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)\r\n        {\r\n            ImGui::MemFree(ConfigData[i].FontData);\r\n            ConfigData[i].FontData = NULL;\r\n        }\r\n\r\n    // When clearing this we lose access to the font name and other information used to build the font.\r\n    for (int i = 0; i < Fonts.Size; i++)\r\n        if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)\r\n        {\r\n            Fonts[i]->ConfigData = NULL;\r\n            Fonts[i]->ConfigDataCount = 0;\r\n        }\r\n    ConfigData.clear();\r\n    CustomRects.clear();\r\n    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)\r\n        CustomRectIds[n] = -1;\r\n}\r\n\r\nvoid    ImFontAtlas::ClearTexData()\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    if (TexPixelsAlpha8)\r\n        ImGui::MemFree(TexPixelsAlpha8);\r\n    if (TexPixelsRGBA32)\r\n        ImGui::MemFree(TexPixelsRGBA32);\r\n    TexPixelsAlpha8 = NULL;\r\n    TexPixelsRGBA32 = NULL;\r\n}\r\n\r\nvoid    ImFontAtlas::ClearFonts()\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    for (int i = 0; i < Fonts.Size; i++)\r\n        IM_DELETE(Fonts[i]);\r\n    Fonts.clear();\r\n}\r\n\r\nvoid    ImFontAtlas::Clear()\r\n{\r\n    ClearInputData();\r\n    ClearTexData();\r\n    ClearFonts();\r\n}\r\n\r\nvoid    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)\r\n{\r\n    // Build atlas on demand\r\n    if (TexPixelsAlpha8 == NULL)\r\n    {\r\n        if (ConfigData.empty())\r\n            AddFontDefault();\r\n        Build();\r\n    }\r\n\r\n    *out_pixels = TexPixelsAlpha8;\r\n    if (out_width) *out_width = TexWidth;\r\n    if (out_height) *out_height = TexHeight;\r\n    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;\r\n}\r\n\r\nvoid    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)\r\n{\r\n    // Convert to RGBA32 format on demand\r\n    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp\r\n    if (!TexPixelsRGBA32)\r\n    {\r\n        unsigned char* pixels = NULL;\r\n        GetTexDataAsAlpha8(&pixels, NULL, NULL);\r\n        if (pixels)\r\n        {\r\n            TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)(TexWidth * TexHeight * 4));\r\n            const unsigned char* src = pixels;\r\n            unsigned int* dst = TexPixelsRGBA32;\r\n            for (int n = TexWidth * TexHeight; n > 0; n--)\r\n                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));\r\n        }\r\n    }\r\n\r\n    *out_pixels = (unsigned char*)TexPixelsRGBA32;\r\n    if (out_width) *out_width = TexWidth;\r\n    if (out_height) *out_height = TexHeight;\r\n    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;\r\n}\r\n\r\nImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);\r\n    IM_ASSERT(font_cfg->SizePixels > 0.0f);\r\n\r\n    // Create new font\r\n    if (!font_cfg->MergeMode)\r\n        Fonts.push_back(IM_NEW(ImFont));\r\n    else\r\n        IM_ASSERT(!Fonts.empty()); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.\r\n\r\n    ConfigData.push_back(*font_cfg);\r\n    ImFontConfig& new_font_cfg = ConfigData.back();\r\n    if (!new_font_cfg.DstFont)\r\n        new_font_cfg.DstFont = Fonts.back();\r\n    if (!new_font_cfg.FontDataOwnedByAtlas)\r\n    {\r\n        new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);\r\n        new_font_cfg.FontDataOwnedByAtlas = true;\r\n        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);\r\n    }\r\n\r\n    // Invalidate texture\r\n    ClearTexData();\r\n    return new_font_cfg.DstFont;\r\n}\r\n\r\n// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)\r\nstatic unsigned int stb_decompress_length(const unsigned char *input);\r\nstatic unsigned int stb_decompress(unsigned char *output, const unsigned char *input, unsigned int length);\r\nstatic const char*  GetDefaultCompressedFontDataTTFBase85();\r\nstatic unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }\r\nstatic void         Decode85(const unsigned char* src, unsigned char* dst)\r\n{\r\n    while (*src)\r\n    {\r\n        unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));\r\n        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.\r\n        src += 5;\r\n        dst += 4;\r\n    }\r\n}\r\n\r\n// Load embedded ProggyClean.ttf at size 13, disable oversampling\r\nImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)\r\n{\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    if (!font_cfg_template)\r\n    {\r\n        font_cfg.OversampleH = font_cfg.OversampleV = 1;\r\n        font_cfg.PixelSnapH = true;\r\n    }\r\n    if (font_cfg.Name[0] == '\\0') strcpy(font_cfg.Name, \"ProggyClean.ttf, 13px\");\r\n    if (font_cfg.SizePixels <= 0.0f) font_cfg.SizePixels = 13.0f;\r\n\r\n    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();\r\n    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();\r\n    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);\r\n    font->DisplayOffset.y = 1.0f;\r\n    return font;\r\n}\r\n\r\nImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    size_t data_size = 0;\r\n    void* data = ImFileLoadToMemory(filename, \"rb\", &data_size, 0);\r\n    if (!data)\r\n    {\r\n        IM_ASSERT(0); // Could not load file.\r\n        return NULL;\r\n    }\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    if (font_cfg.Name[0] == '\\0')\r\n    {\r\n        // Store a short copy of filename into into the font name for convenience\r\n        const char* p;\r\n        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\\\'; p--) {}\r\n        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), \"%s, %.0fpx\", p, size_pixels);\r\n    }\r\n    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);\r\n}\r\n\r\n// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().\r\nImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    IM_ASSERT(font_cfg.FontData == NULL);\r\n    font_cfg.FontData = ttf_data;\r\n    font_cfg.FontDataSize = ttf_size;\r\n    font_cfg.SizePixels = size_pixels;\r\n    if (glyph_ranges)\r\n        font_cfg.GlyphRanges = glyph_ranges;\r\n    return AddFont(&font_cfg);\r\n}\r\n\r\nImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\r\n{\r\n    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);\r\n    unsigned char* buf_decompressed_data = (unsigned char *)ImGui::MemAlloc(buf_decompressed_size);\r\n    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);\r\n\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    IM_ASSERT(font_cfg.FontData == NULL);\r\n    font_cfg.FontDataOwnedByAtlas = true;\r\n    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);\r\n}\r\n\r\nImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)\r\n{\r\n    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;\r\n    void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);\r\n    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);\r\n    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);\r\n    ImGui::MemFree(compressed_ttf);\r\n    return font;\r\n}\r\n\r\nint ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)\r\n{\r\n    IM_ASSERT(id >= 0x10000);\r\n    IM_ASSERT(width > 0 && width <= 0xFFFF);\r\n    IM_ASSERT(height > 0 && height <= 0xFFFF);\r\n    CustomRect r;\r\n    r.ID = id;\r\n    r.Width = (unsigned short)width;\r\n    r.Height = (unsigned short)height;\r\n    CustomRects.push_back(r);\r\n    return CustomRects.Size - 1; // Return index\r\n}\r\n\r\nint ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)\r\n{\r\n    IM_ASSERT(font != NULL);\r\n    IM_ASSERT(width > 0 && width <= 0xFFFF);\r\n    IM_ASSERT(height > 0 && height <= 0xFFFF);\r\n    CustomRect r;\r\n    r.ID = id;\r\n    r.Width = (unsigned short)width;\r\n    r.Height = (unsigned short)height;\r\n    r.GlyphAdvanceX = advance_x;\r\n    r.GlyphOffset = offset;\r\n    r.Font = font;\r\n    CustomRects.push_back(r);\r\n    return CustomRects.Size - 1; // Return index\r\n}\r\n\r\nvoid ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)\r\n{\r\n    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates\r\n    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed\r\n    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);\r\n    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);\r\n}\r\n\r\nbool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])\r\n{\r\n    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)\r\n        return false;\r\n    if (Flags & ImFontAtlasFlags_NoMouseCursors)\r\n        return false;\r\n\r\n    IM_ASSERT(CustomRectIds[0] != -1);\r\n    ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];\r\n    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);\r\n    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);\r\n    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];\r\n    *out_size = size;\r\n    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];\r\n    out_uv_border[0] = (pos) * TexUvScale;\r\n    out_uv_border[1] = (pos + size) * TexUvScale;\r\n    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;\r\n    out_uv_fill[0] = (pos) * TexUvScale;\r\n    out_uv_fill[1] = (pos + size) * TexUvScale;\r\n    return true;\r\n}\r\n\r\nbool    ImFontAtlas::Build()\r\n{\r\n    IM_ASSERT(!Locked && \"Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!\");\r\n    return ImFontAtlasBuildWithStbTruetype(this);\r\n}\r\n\r\nvoid    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)\r\n{\r\n    for (unsigned int i = 0; i < 256; i++)\r\n    {\r\n        unsigned int value = (unsigned int)(i * in_brighten_factor);\r\n        out_table[i] = value > 255 ? 255 : (value & 0xFF);\r\n    }\r\n}\r\n\r\nvoid    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)\r\n{\r\n    unsigned char* data = pixels + x + y * stride;\r\n    for (int j = h; j > 0; j--, data += stride)\r\n        for (int i = 0; i < w; i++)\r\n            data[i] = table[data[i]];\r\n}\r\n\r\nbool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)\r\n{\r\n    IM_ASSERT(atlas->ConfigData.Size > 0);\r\n\r\n    ImFontAtlasBuildRegisterDefaultCustomRects(atlas);\r\n\r\n    atlas->TexID = (ImTextureID)NULL;\r\n    atlas->TexWidth = atlas->TexHeight = 0;\r\n    atlas->TexUvScale = ImVec2(0.0f, 0.0f);\r\n    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);\r\n    atlas->ClearTexData();\r\n\r\n    // Count glyphs/ranges\r\n    int total_glyphs_count = 0;\r\n    int total_ranges_count = 0;\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        if (!cfg.GlyphRanges)\r\n            cfg.GlyphRanges = atlas->GetGlyphRangesDefault();\r\n        for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, total_ranges_count++)\r\n            total_glyphs_count += (in_range[1] - in_range[0]) + 1;\r\n    }\r\n\r\n    // We need a width for the skyline algorithm. Using a dumb heuristic here to decide of width. User can override TexDesiredWidth and TexGlyphPadding if they wish.\r\n    // Width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.\r\n    atlas->TexWidth = (atlas->TexDesiredWidth > 0) ? atlas->TexDesiredWidth : (total_glyphs_count > 4000) ? 4096 : (total_glyphs_count > 2000) ? 2048 : (total_glyphs_count > 1000) ? 1024 : 512;\r\n    atlas->TexHeight = 0;\r\n\r\n    // Start packing\r\n    const int max_tex_height = 1024*32;\r\n    stbtt_pack_context spc = {};\r\n    if (!stbtt_PackBegin(&spc, NULL, atlas->TexWidth, max_tex_height, 0, atlas->TexGlyphPadding, NULL))\r\n        return false;\r\n    stbtt_PackSetOversampling(&spc, 1, 1);\r\n\r\n    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).\r\n    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);\r\n\r\n    // Initialize font information (so we can error without any cleanup)\r\n    struct ImFontTempBuildData\r\n    {\r\n        stbtt_fontinfo      FontInfo;\r\n        stbrp_rect*         Rects;\r\n        int                 RectsCount;\r\n        stbtt_pack_range*   Ranges;\r\n        int                 RangesCount;\r\n    };\r\n    ImFontTempBuildData* tmp_array = (ImFontTempBuildData*)ImGui::MemAlloc((size_t)atlas->ConfigData.Size * sizeof(ImFontTempBuildData));\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));\r\n\r\n        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);\r\n        IM_ASSERT(font_offset >= 0 && \"FontData is incorrect, or FontNo cannot be found.\");\r\n        if (!stbtt_InitFont(&tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))\r\n        {\r\n            atlas->TexWidth = atlas->TexHeight = 0; // Reset output on failure\r\n            ImGui::MemFree(tmp_array);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)\r\n    int buf_packedchars_n = 0, buf_rects_n = 0, buf_ranges_n = 0;\r\n    stbtt_packedchar* buf_packedchars = (stbtt_packedchar*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbtt_packedchar));\r\n    stbrp_rect* buf_rects = (stbrp_rect*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbrp_rect));\r\n    stbtt_pack_range* buf_ranges = (stbtt_pack_range*)ImGui::MemAlloc(total_ranges_count * sizeof(stbtt_pack_range));\r\n    memset(buf_packedchars, 0, total_glyphs_count * sizeof(stbtt_packedchar));\r\n    memset(buf_rects, 0, total_glyphs_count * sizeof(stbrp_rect));              // Unnecessary but let's clear this for the sake of sanity.\r\n    memset(buf_ranges, 0, total_ranges_count * sizeof(stbtt_pack_range));\r\n\r\n    // First font pass: pack all glyphs (no rendering at this point, we are working with rectangles in an infinitely tall texture at this point)\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n\r\n        // Setup ranges\r\n        int font_glyphs_count = 0;\r\n        int font_ranges_count = 0;\r\n        for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, font_ranges_count++)\r\n            font_glyphs_count += (in_range[1] - in_range[0]) + 1;\r\n        tmp.Ranges = buf_ranges + buf_ranges_n;\r\n        tmp.RangesCount = font_ranges_count;\r\n        buf_ranges_n += font_ranges_count;\r\n        for (int i = 0; i < font_ranges_count; i++)\r\n        {\r\n            const ImWchar* in_range = &cfg.GlyphRanges[i * 2];\r\n            stbtt_pack_range& range = tmp.Ranges[i];\r\n            range.font_size = cfg.SizePixels;\r\n            range.first_unicode_codepoint_in_range = in_range[0];\r\n            range.num_chars = (in_range[1] - in_range[0]) + 1;\r\n            range.chardata_for_range = buf_packedchars + buf_packedchars_n;\r\n            buf_packedchars_n += range.num_chars;\r\n        }\r\n\r\n        // Gather the sizes of all rectangle we need\r\n        tmp.Rects = buf_rects + buf_rects_n;\r\n        tmp.RectsCount = font_glyphs_count;\r\n        buf_rects_n += font_glyphs_count;\r\n        stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);\r\n        int n = stbtt_PackFontRangesGatherRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);\r\n        IM_ASSERT(n == font_glyphs_count);\r\n\r\n        // Detect missing glyphs and replace them with a zero-sized box instead of relying on the default glyphs\r\n        // This allows us merging overlapping icon fonts more easily.\r\n        int rect_i = 0;\r\n        for (int range_i = 0; range_i < tmp.RangesCount; range_i++)\r\n            for (int char_i = 0; char_i < tmp.Ranges[range_i].num_chars; char_i++, rect_i++)\r\n                if (stbtt_FindGlyphIndex(&tmp.FontInfo, tmp.Ranges[range_i].first_unicode_codepoint_in_range + char_i) == 0)\r\n                    tmp.Rects[rect_i].w = tmp.Rects[rect_i].h = 0;\r\n\r\n        // Pack\r\n        stbrp_pack_rects((stbrp_context*)spc.pack_info, tmp.Rects, n);\r\n\r\n        // Extend texture height\r\n        // Also mark missing glyphs as non-packed so we don't attempt to render into them\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (tmp.Rects[i].w == 0 && tmp.Rects[i].h == 0)\r\n                tmp.Rects[i].was_packed = 0;\r\n            if (tmp.Rects[i].was_packed)\r\n                atlas->TexHeight = ImMax(atlas->TexHeight, tmp.Rects[i].y + tmp.Rects[i].h);\r\n        }\r\n    }\r\n    IM_ASSERT(buf_rects_n == total_glyphs_count);\r\n    IM_ASSERT(buf_packedchars_n == total_glyphs_count);\r\n    IM_ASSERT(buf_ranges_n == total_ranges_count);\r\n\r\n    // Create texture\r\n    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);\r\n    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);\r\n    atlas->TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(atlas->TexWidth * atlas->TexHeight);\r\n    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);\r\n    spc.pixels = atlas->TexPixelsAlpha8;\r\n    spc.height = atlas->TexHeight;\r\n\r\n    // Second pass: render font characters\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n        stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);\r\n        stbtt_PackFontRangesRenderIntoRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);\r\n        if (cfg.RasterizerMultiply != 1.0f)\r\n        {\r\n            unsigned char multiply_table[256];\r\n            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);\r\n            for (const stbrp_rect* r = tmp.Rects; r != tmp.Rects + tmp.RectsCount; r++)\r\n                if (r->was_packed)\r\n                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, spc.pixels, r->x, r->y, r->w, r->h, spc.stride_in_bytes);\r\n        }\r\n        tmp.Rects = NULL;\r\n    }\r\n\r\n    // End packing\r\n    stbtt_PackEnd(&spc);\r\n    ImGui::MemFree(buf_rects);\r\n    buf_rects = NULL;\r\n\r\n    // Third pass: setup ImFont and glyphs for runtime\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n        ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)\r\n        if (cfg.MergeMode)\r\n            dst_font->BuildLookupTable();\r\n\r\n        const float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);\r\n        int unscaled_ascent, unscaled_descent, unscaled_line_gap;\r\n        stbtt_GetFontVMetrics(&tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);\r\n\r\n        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));\r\n        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));\r\n        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);\r\n        const float font_off_x = cfg.GlyphOffset.x;\r\n        const float font_off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);\r\n\r\n        for (int i = 0; i < tmp.RangesCount; i++)\r\n        {\r\n            stbtt_pack_range& range = tmp.Ranges[i];\r\n            for (int char_idx = 0; char_idx < range.num_chars; char_idx += 1)\r\n            {\r\n                const stbtt_packedchar& pc = range.chardata_for_range[char_idx];\r\n                if (!pc.x0 && !pc.x1 && !pc.y0 && !pc.y1)\r\n                    continue;\r\n\r\n                const int codepoint = range.first_unicode_codepoint_in_range + char_idx;\r\n                if (cfg.MergeMode && dst_font->FindGlyphNoFallback((ImWchar)codepoint))\r\n                    continue;\r\n\r\n                float char_advance_x_org = pc.xadvance;\r\n                float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);\r\n                float char_off_x = font_off_x;\r\n                if (char_advance_x_org != char_advance_x_mod)\r\n                    char_off_x += cfg.PixelSnapH ? (float)(int)((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;\r\n\r\n                stbtt_aligned_quad q;\r\n                float dummy_x = 0.0f, dummy_y = 0.0f;\r\n                stbtt_GetPackedQuad(range.chardata_for_range, atlas->TexWidth, atlas->TexHeight, char_idx, &dummy_x, &dummy_y, &q, 0);\r\n                dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cleanup temporaries\r\n    ImGui::MemFree(buf_packedchars);\r\n    ImGui::MemFree(buf_ranges);\r\n    ImGui::MemFree(tmp_array);\r\n\r\n    ImFontAtlasBuildFinish(atlas);\r\n\r\n    return true;\r\n}\r\n\r\nvoid ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)\r\n{\r\n    if (atlas->CustomRectIds[0] >= 0)\r\n        return;\r\n    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))\r\n        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);\r\n    else\r\n        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);\r\n}\r\n\r\nvoid ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)\r\n{\r\n    if (!font_config->MergeMode)\r\n    {\r\n        font->ClearOutputData();\r\n        font->FontSize = font_config->SizePixels;\r\n        font->ConfigData = font_config;\r\n        font->ContainerAtlas = atlas;\r\n        font->Ascent = ascent;\r\n        font->Descent = descent;\r\n    }\r\n    font->ConfigDataCount++;\r\n}\r\n\r\nvoid ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* pack_context_opaque)\r\n{\r\n    stbrp_context* pack_context = (stbrp_context*)pack_context_opaque;\r\n\r\n    ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;\r\n    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.\r\n\r\n    ImVector<stbrp_rect> pack_rects;\r\n    pack_rects.resize(user_rects.Size);\r\n    memset(pack_rects.Data, 0, sizeof(stbrp_rect) * user_rects.Size);\r\n    for (int i = 0; i < user_rects.Size; i++)\r\n    {\r\n        pack_rects[i].w = user_rects[i].Width;\r\n        pack_rects[i].h = user_rects[i].Height;\r\n    }\r\n    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);\r\n    for (int i = 0; i < pack_rects.Size; i++)\r\n        if (pack_rects[i].was_packed)\r\n        {\r\n            user_rects[i].X = pack_rects[i].x;\r\n            user_rects[i].Y = pack_rects[i].y;\r\n            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);\r\n            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);\r\n        }\r\n}\r\n\r\nstatic void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)\r\n{\r\n    IM_ASSERT(atlas->CustomRectIds[0] >= 0);\r\n    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);\r\n    ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];\r\n    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);\r\n    IM_ASSERT(r.IsPacked());\r\n\r\n    const int w = atlas->TexWidth;\r\n    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))\r\n    {\r\n        // Render/copy pixels\r\n        IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);\r\n        for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)\r\n            for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)\r\n            {\r\n                const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;\r\n                const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;\r\n                atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;\r\n                atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;\r\n            }\r\n    }\r\n    else\r\n    {\r\n        IM_ASSERT(r.Width == 2 && r.Height == 2);\r\n        const int offset = (int)(r.X) + (int)(r.Y) * w;\r\n        atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;\r\n    }\r\n    atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);\r\n}\r\n\r\nvoid ImFontAtlasBuildFinish(ImFontAtlas* atlas)\r\n{\r\n    // Render into our custom data block\r\n    ImFontAtlasBuildRenderDefaultTexData(atlas);\r\n\r\n    // Register custom rectangle glyphs\r\n    for (int i = 0; i < atlas->CustomRects.Size; i++)\r\n    {\r\n        const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];\r\n        if (r.Font == NULL || r.ID > 0x10000)\r\n            continue;\r\n\r\n        IM_ASSERT(r.Font->ContainerAtlas == atlas);\r\n        ImVec2 uv0, uv1;\r\n        atlas->CalcCustomRectUV(&r, &uv0, &uv1);\r\n        r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);\r\n    }\r\n\r\n    // Build all fonts lookup tables\r\n    for (int i = 0; i < atlas->Fonts.Size; i++)\r\n        if (atlas->Fonts[i]->DirtyLookupTables)\r\n            atlas->Fonts[i]->BuildLookupTable();\r\n}\r\n\r\n// Retrieve list of range (2 int per range, values are inclusive)\r\nconst ImWchar*   ImFontAtlas::GetGlyphRangesDefault()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesKorean()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3131, 0x3163, // Korean alphabets\r\n        0xAC00, 0xD79D, // Korean characters\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana\r\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\r\n        0xFF00, 0xFFEF, // Half-width characters\r\n        0x4e00, 0x9FAF, // CJK Ideograms\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nstatic void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)\r\n{\r\n    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)\r\n    {\r\n        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);\r\n        base_codepoint += accumulative_offsets[n];\r\n    }\r\n    out_ranges[0] = 0;\r\n}\r\n\r\n//-------------------------------------------------------------------------\r\n// [SECTION] ImFontAtlas glyph ranges helpers + GlyphRangesBuilder\r\n//-------------------------------------------------------------------------\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()\r\n{\r\n    // Store 2500 regularly used characters for Simplified Chinese.\r\n    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8\r\n    // This table covers 97.97% of all characters used during the month in July, 1987.\r\n    // You can use ImFontAtlas::GlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.\r\n    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)\r\n    static const short accumulative_offsets_from_0x4E00[] =\r\n    {\r\n        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,\r\n        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,\r\n        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,\r\n        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,\r\n        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,\r\n        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,\r\n        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,\r\n        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,\r\n        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,\r\n        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,\r\n        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,\r\n        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,\r\n        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,\r\n        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,\r\n        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,\r\n        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,\r\n        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,\r\n        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,\r\n        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,\r\n        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,\r\n        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,\r\n        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,\r\n        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,\r\n        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,\r\n        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,\r\n        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,\r\n        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,\r\n        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,\r\n        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,\r\n        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,\r\n        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,\r\n        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,\r\n        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,\r\n        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,\r\n        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,\r\n        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,\r\n        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,\r\n        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,\r\n        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,\r\n        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6\r\n    };\r\n    static ImWchar base_ranges[] = // not zero-terminated\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana\r\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\r\n        0xFF00, 0xFFEF, // Half-width characters\r\n    };\r\n    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };\r\n    if (!full_ranges[0])\r\n    {\r\n        memcpy(full_ranges, base_ranges, sizeof(base_ranges));\r\n        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));\r\n    }\r\n    return &full_ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()\r\n{\r\n    // 1946 common ideograms code points for Japanese\r\n    // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering\r\n    // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.\r\n    // You can use ImFontAtlas::GlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.\r\n    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)\r\n    static const short accumulative_offsets_from_0x4E00[] =\r\n    {\r\n        0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,\r\n        5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,\r\n        2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,\r\n        2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,\r\n        20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,\r\n        4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,\r\n        3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,\r\n        8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,\r\n        3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,\r\n        15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,\r\n        1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,\r\n        12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,\r\n        22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,\r\n        5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,\r\n        1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,\r\n        1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,\r\n        11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,\r\n        15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,\r\n        5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,\r\n        3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,\r\n        18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,\r\n        27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,\r\n        1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,\r\n        1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,\r\n        10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,\r\n        179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,\r\n        3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,\r\n        3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,\r\n        3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,\r\n        4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,\r\n        1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,\r\n        51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39, \r\n    };\r\n    static ImWchar base_ranges[] = // not zero-terminated\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana\r\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\r\n        0xFF00, 0xFFEF, // Half-width characters\r\n    };\r\n    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };\r\n    if (!full_ranges[0])\r\n    {\r\n        memcpy(full_ranges, base_ranges, sizeof(base_ranges));\r\n        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));\r\n    }\r\n    return &full_ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement\r\n        0x2DE0, 0x2DFF, // Cyrillic Extended-A\r\n        0xA640, 0xA69F, // Cyrillic Extended-B\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesThai()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin\r\n        0x2010, 0x205E, // Punctuations\r\n        0x0E00, 0x0E7F, // Thai\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nvoid ImFontAtlas::GlyphRangesBuilder::AddText(const char* text, const char* text_end)\r\n{\r\n    while (text_end ? (text < text_end) : *text)\r\n    {\r\n        unsigned int c = 0;\r\n        int c_len = ImTextCharFromUtf8(&c, text, text_end);\r\n        text += c_len;\r\n        if (c_len == 0)\r\n            break;\r\n        if (c < 0x10000)\r\n            AddChar((ImWchar)c);\r\n    }\r\n}\r\n\r\nvoid ImFontAtlas::GlyphRangesBuilder::AddRanges(const ImWchar* ranges)\r\n{\r\n    for (; ranges[0]; ranges += 2)\r\n        for (ImWchar c = ranges[0]; c <= ranges[1]; c++)\r\n            AddChar(c);\r\n}\r\n\r\nvoid ImFontAtlas::GlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)\r\n{\r\n    for (int n = 0; n < 0x10000; n++)\r\n        if (GetBit(n))\r\n        {\r\n            out_ranges->push_back((ImWchar)n);\r\n            while (n < 0x10000 && GetBit(n + 1))\r\n                n++;\r\n            out_ranges->push_back((ImWchar)n);\r\n        }\r\n    out_ranges->push_back(0);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] ImFont\r\n//-----------------------------------------------------------------------------\r\n\r\nImFont::ImFont()\r\n{\r\n    Scale = 1.0f;\r\n    FallbackChar = (ImWchar)'?';\r\n    DisplayOffset = ImVec2(0.0f, 0.0f);\r\n    ClearOutputData();\r\n}\r\n\r\nImFont::~ImFont()\r\n{\r\n    // Invalidate active font so that the user gets a clear crash instead of a dangling pointer.\r\n    // If you want to delete fonts you need to do it between Render() and NewFrame().\r\n    // FIXME-CLEANUP\r\n    /*\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.Font == this)\r\n        g.Font = NULL;\r\n    */\r\n    ClearOutputData();\r\n}\r\n\r\nvoid    ImFont::ClearOutputData()\r\n{\r\n    FontSize = 0.0f;\r\n    Glyphs.clear();\r\n    IndexAdvanceX.clear();\r\n    IndexLookup.clear();\r\n    FallbackGlyph = NULL;\r\n    FallbackAdvanceX = 0.0f;\r\n    ConfigDataCount = 0;\r\n    ConfigData = NULL;\r\n    ContainerAtlas = NULL;\r\n    Ascent = Descent = 0.0f;\r\n    DirtyLookupTables = true;\r\n    MetricsTotalSurface = 0;\r\n}\r\n\r\nvoid ImFont::BuildLookupTable()\r\n{\r\n    int max_codepoint = 0;\r\n    for (int i = 0; i != Glyphs.Size; i++)\r\n        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);\r\n\r\n    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved\r\n    IndexAdvanceX.clear();\r\n    IndexLookup.clear();\r\n    DirtyLookupTables = false;\r\n    GrowIndex(max_codepoint + 1);\r\n    for (int i = 0; i < Glyphs.Size; i++)\r\n    {\r\n        int codepoint = (int)Glyphs[i].Codepoint;\r\n        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;\r\n        IndexLookup[codepoint] = (ImWchar)i;\r\n    }\r\n\r\n    // Create a glyph to handle TAB\r\n    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at \"column 0\" ?)\r\n    if (FindGlyph((ImWchar)' '))\r\n    {\r\n        if (Glyphs.back().Codepoint != '\\t')   // So we can call this function multiple times\r\n            Glyphs.resize(Glyphs.Size + 1);\r\n        ImFontGlyph& tab_glyph = Glyphs.back();\r\n        tab_glyph = *FindGlyph((ImWchar)' ');\r\n        tab_glyph.Codepoint = '\\t';\r\n        tab_glyph.AdvanceX *= 4;\r\n        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;\r\n        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size-1);\r\n    }\r\n\r\n    FallbackGlyph = FindGlyphNoFallback(FallbackChar);\r\n    FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;\r\n    for (int i = 0; i < max_codepoint + 1; i++)\r\n        if (IndexAdvanceX[i] < 0.0f)\r\n            IndexAdvanceX[i] = FallbackAdvanceX;\r\n}\r\n\r\nvoid ImFont::SetFallbackChar(ImWchar c)\r\n{\r\n    FallbackChar = c;\r\n    BuildLookupTable();\r\n}\r\n\r\nvoid ImFont::GrowIndex(int new_size)\r\n{\r\n    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);\r\n    if (new_size <= IndexLookup.Size)\r\n        return;\r\n    IndexAdvanceX.resize(new_size, -1.0f);\r\n    IndexLookup.resize(new_size, (ImWchar)-1);\r\n}\r\n\r\n// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.\r\n// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).\r\nvoid ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)\r\n{\r\n    Glyphs.resize(Glyphs.Size + 1);\r\n    ImFontGlyph& glyph = Glyphs.back();\r\n    glyph.Codepoint = (ImWchar)codepoint;\r\n    glyph.X0 = x0;\r\n    glyph.Y0 = y0;\r\n    glyph.X1 = x1;\r\n    glyph.Y1 = y1;\r\n    glyph.U0 = u0;\r\n    glyph.V0 = v0;\r\n    glyph.U1 = u1;\r\n    glyph.V1 = v1;\r\n    glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX\r\n\r\n    if (ConfigData->PixelSnapH)\r\n        glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);\r\n\r\n    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)\r\n    DirtyLookupTables = true;\r\n    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);\r\n}\r\n\r\nvoid ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)\r\n{\r\n    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.\r\n    int index_size = IndexLookup.Size;\r\n\r\n    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists\r\n        return;\r\n    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op\r\n        return;\r\n\r\n    GrowIndex(dst + 1);\r\n    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;\r\n    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;\r\n}\r\n\r\nconst ImFontGlyph* ImFont::FindGlyph(ImWchar c) const\r\n{\r\n    if (c >= IndexLookup.Size)\r\n        return FallbackGlyph;\r\n    const ImWchar i = IndexLookup[c];\r\n    if (i == (ImWchar)-1)\r\n        return FallbackGlyph;\r\n    return &Glyphs.Data[i];\r\n}\r\n\r\nconst ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const\r\n{\r\n    if (c >= IndexLookup.Size)\r\n        return NULL;\r\n    const ImWchar i = IndexLookup[c];\r\n    if (i == (ImWchar)-1)\r\n        return NULL;\r\n    return &Glyphs.Data[i];\r\n}\r\n\r\nconst char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const\r\n{\r\n    // Simple word-wrapping for English, not full-featured. Please submit failing cases!\r\n    // FIXME: Much possible improvements (don't cut things like \"word !\", \"word!!!\" but cut within \"word,,,,\", more sensible support for punctuations, support for Unicode punctuations, etc.)\r\n\r\n    // For references, possible wrap point marked with ^\r\n    //  \"aaa bbb, ccc,ddd. eee   fff. ggg!\"\r\n    //      ^    ^    ^   ^   ^__    ^    ^\r\n\r\n    // List of hardcoded separators: .,;!?'\"\r\n\r\n    // Skip extra blanks after a line returns (that includes not counting them in width computation)\r\n    // e.g. \"Hello    world\" --> \"Hello\" \"World\"\r\n\r\n    // Cut words that cannot possibly fit within one line.\r\n    // e.g.: \"The tropical fish\" with ~5 characters worth of width --> \"The tr\" \"opical\" \"fish\"\r\n\r\n    float line_width = 0.0f;\r\n    float word_width = 0.0f;\r\n    float blank_width = 0.0f;\r\n    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters\r\n\r\n    const char* word_end = text;\r\n    const char* prev_word_end = NULL;\r\n    bool inside_word = true;\r\n\r\n    const char* s = text;\r\n    while (s < text_end)\r\n    {\r\n        unsigned int c = (unsigned int)*s;\r\n        const char* next_s;\r\n        if (c < 0x80)\r\n            next_s = s + 1;\r\n        else\r\n            next_s = s + ImTextCharFromUtf8(&c, s, text_end);\r\n        if (c == 0)\r\n            break;\r\n\r\n        if (c < 32)\r\n        {\r\n            if (c == '\\n')\r\n            {\r\n                line_width = word_width = blank_width = 0.0f;\r\n                inside_word = true;\r\n                s = next_s;\r\n                continue;\r\n            }\r\n            if (c == '\\r')\r\n            {\r\n                s = next_s;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX);\r\n        if (ImCharIsBlankW(c))\r\n        {\r\n            if (inside_word)\r\n            {\r\n                line_width += blank_width;\r\n                blank_width = 0.0f;\r\n                word_end = s;\r\n            }\r\n            blank_width += char_width;\r\n            inside_word = false;\r\n        }\r\n        else\r\n        {\r\n            word_width += char_width;\r\n            if (inside_word)\r\n            {\r\n                word_end = next_s;\r\n            }\r\n            else\r\n            {\r\n                prev_word_end = word_end;\r\n                line_width += word_width + blank_width;\r\n                word_width = blank_width = 0.0f;\r\n            }\r\n\r\n            // Allow wrapping after punctuation.\r\n            inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\\\"');\r\n        }\r\n\r\n        // We ignore blank width at the end of the line (they can be skipped)\r\n        if (line_width + word_width >= wrap_width)\r\n        {\r\n            // Words that cannot possibly fit within an entire line will be cut anywhere.\r\n            if (word_width < wrap_width)\r\n                s = prev_word_end ? prev_word_end : word_end;\r\n            break;\r\n        }\r\n\r\n        s = next_s;\r\n    }\r\n\r\n    return s;\r\n}\r\n\r\nImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const\r\n{\r\n    if (!text_end)\r\n        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.\r\n\r\n    const float line_height = size;\r\n    const float scale = size / FontSize;\r\n\r\n    ImVec2 text_size = ImVec2(0,0);\r\n    float line_width = 0.0f;\r\n\r\n    const bool word_wrap_enabled = (wrap_width > 0.0f);\r\n    const char* word_wrap_eol = NULL;\r\n\r\n    const char* s = text_begin;\r\n    while (s < text_end)\r\n    {\r\n        if (word_wrap_enabled)\r\n        {\r\n            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.\r\n            if (!word_wrap_eol)\r\n            {\r\n                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);\r\n                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.\r\n                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below\r\n            }\r\n\r\n            if (s >= word_wrap_eol)\r\n            {\r\n                if (text_size.x < line_width)\r\n                    text_size.x = line_width;\r\n                text_size.y += line_height;\r\n                line_width = 0.0f;\r\n                word_wrap_eol = NULL;\r\n\r\n                // Wrapping skips upcoming blanks\r\n                while (s < text_end)\r\n                {\r\n                    const char c = *s;\r\n                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\\n') { s++; break; } else { break; }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Decode and advance source\r\n        const char* prev_s = s;\r\n        unsigned int c = (unsigned int)*s;\r\n        if (c < 0x80)\r\n        {\r\n            s += 1;\r\n        }\r\n        else\r\n        {\r\n            s += ImTextCharFromUtf8(&c, s, text_end);\r\n            if (c == 0) // Malformed UTF-8?\r\n                break;\r\n        }\r\n\r\n        if (c < 32)\r\n        {\r\n            if (c == '\\n')\r\n            {\r\n                text_size.x = ImMax(text_size.x, line_width);\r\n                text_size.y += line_height;\r\n                line_width = 0.0f;\r\n                continue;\r\n            }\r\n            if (c == '\\r')\r\n                continue;\r\n        }\r\n\r\n        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX) * scale;\r\n        if (line_width + char_width >= max_width)\r\n        {\r\n            s = prev_s;\r\n            break;\r\n        }\r\n\r\n        line_width += char_width;\r\n    }\r\n\r\n    if (text_size.x < line_width)\r\n        text_size.x = line_width;\r\n\r\n    if (line_width > 0 || text_size.y == 0.0f)\r\n        text_size.y += line_height;\r\n\r\n    if (remaining)\r\n        *remaining = s;\r\n\r\n    return text_size;\r\n}\r\n\r\nvoid ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const\r\n{\r\n    if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.\r\n        return;\r\n    if (const ImFontGlyph* glyph = FindGlyph(c))\r\n    {\r\n        float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;\r\n        pos.x = (float)(int)pos.x + DisplayOffset.x;\r\n        pos.y = (float)(int)pos.y + DisplayOffset.y;\r\n        draw_list->PrimReserve(6, 4);\r\n        draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);\r\n    }\r\n}\r\n\r\nvoid ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const\r\n{\r\n    if (!text_end)\r\n        text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.\r\n\r\n    // Align to be pixel perfect\r\n    pos.x = (float)(int)pos.x + DisplayOffset.x;\r\n    pos.y = (float)(int)pos.y + DisplayOffset.y;\r\n    float x = pos.x;\r\n    float y = pos.y;\r\n    if (y > clip_rect.w)\r\n        return;\r\n\r\n    const float scale = size / FontSize;\r\n    const float line_height = FontSize * scale;\r\n    const bool word_wrap_enabled = (wrap_width > 0.0f);\r\n    const char* word_wrap_eol = NULL;\r\n\r\n    // Fast-forward to first visible line\r\n    const char* s = text_begin;\r\n    if (y + line_height < clip_rect.y && !word_wrap_enabled)\r\n        while (y + line_height < clip_rect.y && s < text_end)\r\n        {\r\n            s = (const char*)memchr(s, '\\n', text_end - s);\r\n            s = s ? s + 1 : text_end;\r\n            y += line_height;\r\n        }\r\n\r\n    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()\r\n    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)\r\n    if (text_end - s > 10000 && !word_wrap_enabled)\r\n    {\r\n        const char* s_end = s;\r\n        float y_end = y;\r\n        while (y_end < clip_rect.w && s_end < text_end)\r\n        {\r\n            s_end = (const char*)memchr(s_end, '\\n', text_end - s_end);\r\n            s_end = s_end ? s_end + 1 : text_end;\r\n            y_end += line_height;\r\n        }\r\n        text_end = s_end;\r\n    }\r\n    if (s == text_end)\r\n        return;\r\n\r\n    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)\r\n    const int vtx_count_max = (int)(text_end - s) * 4;\r\n    const int idx_count_max = (int)(text_end - s) * 6;\r\n    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;\r\n    draw_list->PrimReserve(idx_count_max, vtx_count_max);\r\n\r\n    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;\r\n    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;\r\n    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;\r\n\r\n    while (s < text_end)\r\n    {\r\n        if (word_wrap_enabled)\r\n        {\r\n            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.\r\n            if (!word_wrap_eol)\r\n            {\r\n                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));\r\n                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.\r\n                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below\r\n            }\r\n\r\n            if (s >= word_wrap_eol)\r\n            {\r\n                x = pos.x;\r\n                y += line_height;\r\n                word_wrap_eol = NULL;\r\n\r\n                // Wrapping skips upcoming blanks\r\n                while (s < text_end)\r\n                {\r\n                    const char c = *s;\r\n                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\\n') { s++; break; } else { break; }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Decode and advance source\r\n        unsigned int c = (unsigned int)*s;\r\n        if (c < 0x80)\r\n        {\r\n            s += 1;\r\n        }\r\n        else\r\n        {\r\n            s += ImTextCharFromUtf8(&c, s, text_end);\r\n            if (c == 0) // Malformed UTF-8?\r\n                break;\r\n        }\r\n\r\n        if (c < 32)\r\n        {\r\n            if (c == '\\n')\r\n            {\r\n                x = pos.x;\r\n                y += line_height;\r\n                if (y > clip_rect.w)\r\n                    break; // break out of main loop\r\n                continue;\r\n            }\r\n            if (c == '\\r')\r\n                continue;\r\n        }\r\n\r\n        float char_width = 0.0f;\r\n        if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))\r\n        {\r\n            char_width = glyph->AdvanceX * scale;\r\n\r\n            // Arbitrarily assume that both space and tabs are empty glyphs as an optimization\r\n            if (c != ' ' && c != '\\t')\r\n            {\r\n                // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w\r\n                float x1 = x + glyph->X0 * scale;\r\n                float x2 = x + glyph->X1 * scale;\r\n                float y1 = y + glyph->Y0 * scale;\r\n                float y2 = y + glyph->Y1 * scale;\r\n                if (x1 <= clip_rect.z && x2 >= clip_rect.x)\r\n                {\r\n                    // Render a character\r\n                    float u1 = glyph->U0;\r\n                    float v1 = glyph->V0;\r\n                    float u2 = glyph->U1;\r\n                    float v2 = glyph->V1;\r\n\r\n                    // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.\r\n                    if (cpu_fine_clip)\r\n                    {\r\n                        if (x1 < clip_rect.x)\r\n                        {\r\n                            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);\r\n                            x1 = clip_rect.x;\r\n                        }\r\n                        if (y1 < clip_rect.y)\r\n                        {\r\n                            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);\r\n                            y1 = clip_rect.y;\r\n                        }\r\n                        if (x2 > clip_rect.z)\r\n                        {\r\n                            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);\r\n                            x2 = clip_rect.z;\r\n                        }\r\n                        if (y2 > clip_rect.w)\r\n                        {\r\n                            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);\r\n                            y2 = clip_rect.w;\r\n                        }\r\n                        if (y1 >= y2)\r\n                        {\r\n                            x += char_width;\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:\r\n                    {\r\n                        idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);\r\n                        idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);\r\n                        vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;\r\n                        vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;\r\n                        vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;\r\n                        vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;\r\n                        vtx_write += 4;\r\n                        vtx_current_idx += 4;\r\n                        idx_write += 6;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        x += char_width;\r\n    }\r\n\r\n    // Give back unused vertices\r\n    draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));\r\n    draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));\r\n    draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);\r\n    draw_list->_VtxWritePtr = vtx_write;\r\n    draw_list->_IdxWritePtr = idx_write;\r\n    draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Internal Render Helpers\r\n// (progressively moved from imgui.cpp to here when they are redesigned to stop accessing ImGui global state)\r\n//-----------------------------------------------------------------------------\r\n// - RenderMouseCursor()\r\n// - RenderArrowPointingAt()\r\n// - RenderRectFilledRangeH()\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor)\r\n{\r\n    if (mouse_cursor == ImGuiMouseCursor_None)\r\n        return;\r\n    IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);\r\n\r\n    const ImU32 col_shadow = IM_COL32(0, 0, 0, 48);\r\n    const ImU32 col_border = IM_COL32(0, 0, 0, 255);          // Black\r\n    const ImU32 col_fill   = IM_COL32(255, 255, 255, 255);    // White\r\n\r\n    ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;\r\n    ImVec2 offset, size, uv[4];\r\n    if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))\r\n    {\r\n        pos -= offset;\r\n        const ImTextureID tex_id = font_atlas->TexID;\r\n        draw_list->PushTextureID(tex_id);\r\n        draw_list->AddImage(tex_id, pos + ImVec2(1,0)*scale, pos + ImVec2(1,0)*scale + size*scale, uv[2], uv[3], col_shadow);\r\n        draw_list->AddImage(tex_id, pos + ImVec2(2,0)*scale, pos + ImVec2(2,0)*scale + size*scale, uv[2], uv[3], col_shadow);\r\n        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[2], uv[3], col_border);\r\n        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[0], uv[1], col_fill);\r\n        draw_list->PopTextureID();\r\n    }\r\n}\r\n\r\n// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.\r\nvoid ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)\r\n{\r\n    switch (direction)\r\n    {\r\n    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;\r\n    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;\r\n    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;\r\n    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;\r\n    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings\r\n    }\r\n}\r\n\r\nstatic inline float ImAcos01(float x)\r\n{\r\n    if (x <= 0.0f) return IM_PI * 0.5f;\r\n    if (x >= 1.0f) return 0.0f;\r\n    return ImAcos(x);\r\n    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.\r\n}\r\n\r\n// FIXME: Cleanup and move code to ImDrawList.\r\nvoid ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)\r\n{\r\n    if (x_end_norm == x_start_norm)\r\n        return;\r\n    if (x_start_norm > x_end_norm)\r\n        ImSwap(x_start_norm, x_end_norm);\r\n\r\n    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);\r\n    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);\r\n    if (rounding == 0.0f)\r\n    {\r\n        draw_list->AddRectFilled(p0, p1, col, 0.0f);\r\n        return;\r\n    }\r\n\r\n    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);\r\n    const float inv_rounding = 1.0f / rounding;\r\n    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);\r\n    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);\r\n    const float x0 = ImMax(p0.x, rect.Min.x + rounding);\r\n    if (arc0_b == arc0_e)\r\n    {\r\n        draw_list->PathLineTo(ImVec2(x0, p1.y));\r\n        draw_list->PathLineTo(ImVec2(x0, p0.y));\r\n    }\r\n    else if (arc0_b == 0.0f && arc0_e == IM_PI*0.5f)\r\n    {\r\n        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL\r\n        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR\r\n    }\r\n    else\r\n    {\r\n        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL\r\n        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR\r\n    }\r\n    if (p1.x > rect.Min.x + rounding)\r\n    {\r\n        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);\r\n        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);\r\n        const float x1 = ImMin(p1.x, rect.Max.x - rounding);\r\n        if (arc1_b == arc1_e)\r\n        {\r\n            draw_list->PathLineTo(ImVec2(x1, p0.y));\r\n            draw_list->PathLineTo(ImVec2(x1, p1.y));\r\n        }\r\n        else if (arc1_b == 0.0f && arc1_e == IM_PI*0.5f)\r\n        {\r\n            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR\r\n            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR\r\n        }\r\n        else\r\n        {\r\n            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR\r\n            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR\r\n        }\r\n    }\r\n    draw_list->PathFillConvex(col);\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Decompression code\r\n//-----------------------------------------------------------------------------\r\n// Compressed with stb_compress() then converted to a C array and encoded as base85.\r\n// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.\r\n// The purpose of encoding as base85 instead of \"0x00,0x01,...\" style is only save on _source code_ size.\r\n// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic unsigned int stb_decompress_length(const unsigned char *input)\r\n{\r\n    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];\r\n}\r\n\r\nstatic unsigned char *stb__barrier_out_e, *stb__barrier_out_b;\r\nstatic const unsigned char *stb__barrier_in_b;\r\nstatic unsigned char *stb__dout;\r\nstatic void stb__match(const unsigned char *data, unsigned int length)\r\n{\r\n    // INVERSE of memmove... write each byte before copying the next...\r\n    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);\r\n    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }\r\n    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }\r\n    while (length--) *stb__dout++ = *data++;\r\n}\r\n\r\nstatic void stb__lit(const unsigned char *data, unsigned int length)\r\n{\r\n    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);\r\n    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }\r\n    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }\r\n    memcpy(stb__dout, data, length);\r\n    stb__dout += length;\r\n}\r\n\r\n#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])\r\n#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))\r\n#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))\r\n\r\nstatic const unsigned char *stb_decompress_token(const unsigned char *i)\r\n{\r\n    if (*i >= 0x20) { // use fewer if's for cases that expand small\r\n        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;\r\n        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;\r\n        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);\r\n    } else { // more ifs for cases that expand large, since overhead is amortized\r\n        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;\r\n        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;\r\n        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);\r\n        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);\r\n        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;\r\n        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;\r\n    }\r\n    return i;\r\n}\r\n\r\nstatic unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)\r\n{\r\n    const unsigned long ADLER_MOD = 65521;\r\n    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;\r\n    unsigned long blocklen, i;\r\n\r\n    blocklen = buflen % 5552;\r\n    while (buflen) {\r\n        for (i=0; i + 7 < blocklen; i += 8) {\r\n            s1 += buffer[0], s2 += s1;\r\n            s1 += buffer[1], s2 += s1;\r\n            s1 += buffer[2], s2 += s1;\r\n            s1 += buffer[3], s2 += s1;\r\n            s1 += buffer[4], s2 += s1;\r\n            s1 += buffer[5], s2 += s1;\r\n            s1 += buffer[6], s2 += s1;\r\n            s1 += buffer[7], s2 += s1;\r\n\r\n            buffer += 8;\r\n        }\r\n\r\n        for (; i < blocklen; ++i)\r\n            s1 += *buffer++, s2 += s1;\r\n\r\n        s1 %= ADLER_MOD, s2 %= ADLER_MOD;\r\n        buflen -= blocklen;\r\n        blocklen = 5552;\r\n    }\r\n    return (unsigned int)(s2 << 16) + (unsigned int)s1;\r\n}\r\n\r\nstatic unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)\r\n{\r\n    unsigned int olen;\r\n    if (stb__in4(0) != 0x57bC0000) return 0;\r\n    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB\r\n    olen = stb_decompress_length(i);\r\n    stb__barrier_in_b = i;\r\n    stb__barrier_out_e = output + olen;\r\n    stb__barrier_out_b = output;\r\n    i += 16;\r\n\r\n    stb__dout = output;\r\n    for (;;) {\r\n        const unsigned char *old_i = i;\r\n        i = stb_decompress_token(i);\r\n        if (i == old_i) {\r\n            if (*i == 0x05 && i[1] == 0xfa) {\r\n                IM_ASSERT(stb__dout == output + olen);\r\n                if (stb__dout != output + olen) return 0;\r\n                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))\r\n                    return 0;\r\n                return olen;\r\n            } else {\r\n                IM_ASSERT(0); /* NOTREACHED */\r\n                return 0;\r\n            }\r\n        }\r\n        IM_ASSERT(stb__dout <= output + olen);\r\n        if (stb__dout > output + olen)\r\n            return 0;\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Default font data (ProggyClean.ttf)\r\n//-----------------------------------------------------------------------------\r\n// ProggyClean.ttf\r\n// Copyright (c) 2004, 2005 Tristan Grimmer\r\n// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)\r\n// Download and more information at http://upperbounds.net\r\n//-----------------------------------------------------------------------------\r\n// File: 'ProggyClean.ttf' (41208 bytes)\r\n// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).\r\n// The purpose of encoding as base85 instead of \"0x00,0x01,...\" style is only save on _source code_ size.\r\n//-----------------------------------------------------------------------------\r\nstatic const char proggy_clean_ttf_compressed_data_base85[11980+1] =\r\n    \"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/\"\r\n    \"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#\"\r\n    \"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL\"\r\n    \"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N\"\r\n    \"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N\"\r\n    \"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)\"\r\n    \"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX\"\r\n    \"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc.\"\r\n    \"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G\"\r\n    \"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)\"\r\n    \"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#\"\r\n    \"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM\"\r\n    \"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu\"\r\n    \"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/\"\r\n    \"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L\"\r\n    \"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#\"\r\n    \"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)(\"\r\n    \"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h\"\r\n    \"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO\"\r\n    \"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-\"\r\n    \"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-\"\r\n    \"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO\"\r\n    \"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%\"\r\n    \"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]\"\r\n    \"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et\"\r\n    \"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:\"\r\n    \"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL(\"\r\n    \"$/V,;(kXZejWO`<[5?\\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<\"\r\n    \"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?\"\r\n    \"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;\"\r\n    \")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M\"\r\n    \"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX(\"\r\n    \"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs\"\r\n    \"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q\"\r\n    \"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-\"\r\n    \"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i\"\r\n    \"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7\"\r\n    \".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@\"\r\n    \"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*\"\r\n    \"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u\"\r\n    \"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#\"\r\n    \"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#\"\r\n    \"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0\"\r\n    \"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8\"\r\n    \"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#\"\r\n    \"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD\"\r\n    \":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+\"\r\n    \"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*\"\r\n    \"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7\"\r\n    \":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A\"\r\n    \"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7\"\r\n    \"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT\"\r\n    \"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M\"\r\n    \":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>\"\r\n    \"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%\"\r\n    \"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;\"\r\n    \"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:\"\r\n    \"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%\"\r\n    \"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-\"\r\n    \"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*\"\r\n    \"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY\"\r\n    \"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-\"\r\n    \"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`\"\r\n    \"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/\"\r\n    \"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj\"\r\n    \"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V\"\r\n    \"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK\"\r\n    \"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa\"\r\n    \">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>\"\r\n    \"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I\"\r\n    \"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#\"\r\n    \"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$\"\r\n    \"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)\"\r\n    \"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo\"\r\n    \"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P\"\r\n    \"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO\"\r\n    \"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#\"\r\n    \";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>\"\r\n    \"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#\"\r\n    \"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4\"\r\n    \"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#\"\r\n    \"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#\"\r\n    \"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#\"\r\n    \"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP\"\r\n    \"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp\"\r\n    \"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#\";\r\n\r\nstatic const char* GetDefaultCompressedFontDataTTFBase85()\r\n{\r\n    return proggy_clean_ttf_compressed_data_base85;\r\n}\r\n","// stb_truetype.h - v1.19 - public domain\r\n// authored from 2009-2016 by Sean Barrett / RAD Game Tools\r\n//\r\n//   This library processes TrueType files:\r\n//        parse files\r\n//        extract glyph metrics\r\n//        extract glyph shapes\r\n//        render glyphs to one-channel bitmaps with antialiasing (box filter)\r\n//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)\r\n//\r\n//   Todo:\r\n//        non-MS cmaps\r\n//        crashproof on bad data\r\n//        hinting? (no longer patented)\r\n//        cleartype-style AA?\r\n//        optimize: use simple memory allocator for intermediates\r\n//        optimize: build edge-list directly from curves\r\n//        optimize: rasterize directly from curves?\r\n//\r\n// ADDITIONAL CONTRIBUTORS\r\n//\r\n//   Mikko Mononen: compound shape support, more cmap formats\r\n//   Tor Andersson: kerning, subpixel rendering\r\n//   Dougall Johnson: OpenType / Type 2 font handling\r\n//   Daniel Ribeiro Maciel: basic GPOS-based kerning\r\n//\r\n//   Misc other:\r\n//       Ryan Gordon\r\n//       Simon Glass\r\n//       github:IntellectualKitty\r\n//       Imanol Celaya\r\n//       Daniel Ribeiro Maciel\r\n//\r\n//   Bug/warning reports/fixes:\r\n//       \"Zer\" on mollyrocket       Fabian \"ryg\" Giesen\r\n//       Cass Everitt               Martins Mozeiko\r\n//       stoiko (Haemimont Games)   Cap Petschulat\r\n//       Brian Hook                 Omar Cornut\r\n//       Walter van Niftrik         github:aloucks\r\n//       David Gow                  Peter LaValle\r\n//       David Given                Sergey Popov\r\n//       Ivan-Assen Ivanov          Giumo X. Clanjor\r\n//       Anthony Pesch              Higor Euripedes\r\n//       Johan Duparc               Thomas Fields\r\n//       Hou Qiming                 Derek Vinyard\r\n//       Rob Loach                  Cort Stratton\r\n//       Kenney Phillis Jr.         github:oyvindjam\r\n//       Brian Costabile            github:vassvik\r\n//       \r\n// VERSION HISTORY\r\n//\r\n//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod\r\n//   1.18 (2018-01-29) add missing function\r\n//   1.17 (2017-07-23) make more arguments const; doc fix\r\n//   1.16 (2017-07-12) SDF support\r\n//   1.15 (2017-03-03) make more arguments const\r\n//   1.14 (2017-01-16) num-fonts-in-TTC function\r\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\r\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\r\n//   1.11 (2016-04-02) fix unused-variable warning\r\n//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef\r\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly\r\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\r\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\r\n//                     variant PackFontRanges to pack and render in separate phases;\r\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\r\n//                     fixed an assert() bug in the new rasterizer\r\n//                     replace assert() with STBTT_assert() in new rasterizer\r\n//\r\n//   Full history can be found at the end of this file.\r\n//\r\n// LICENSE\r\n//\r\n//   See end of file for license information.\r\n//\r\n// USAGE\r\n//\r\n//   Include this file in whatever places neeed to refer to it. In ONE C/C++\r\n//   file, write:\r\n//      #define STB_TRUETYPE_IMPLEMENTATION\r\n//   before the #include of this file. This expands out the actual\r\n//   implementation into that C/C++ file.\r\n//\r\n//   To make the implementation private to the file that generates the implementation,\r\n//      #define STBTT_STATIC\r\n//\r\n//   Simple 3D API (don't ship this, but it's fine for tools and quick start)\r\n//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture\r\n//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char\r\n//\r\n//   Improved 3D API (more shippable):\r\n//           #include \"stb_rect_pack.h\"           -- optional, but you really want it\r\n//           stbtt_PackBegin()\r\n//           stbtt_PackSetOversampling()          -- for improved quality on small fonts\r\n//           stbtt_PackFontRanges()               -- pack and renders\r\n//           stbtt_PackEnd()\r\n//           stbtt_GetPackedQuad()\r\n//\r\n//   \"Load\" a font file from a memory buffer (you have to keep the buffer loaded)\r\n//           stbtt_InitFont()\r\n//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections\r\n//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections\r\n//\r\n//   Render a unicode codepoint to a bitmap\r\n//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap\r\n//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide\r\n//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be\r\n//\r\n//   Character advance/positioning\r\n//           stbtt_GetCodepointHMetrics()\r\n//           stbtt_GetFontVMetrics()\r\n//           stbtt_GetFontVMetricsOS2()\r\n//           stbtt_GetCodepointKernAdvance()\r\n//\r\n//   Starting with version 1.06, the rasterizer was replaced with a new,\r\n//   faster and generally-more-precise rasterizer. The new rasterizer more\r\n//   accurately measures pixel coverage for anti-aliasing, except in the case\r\n//   where multiple shapes overlap, in which case it overestimates the AA pixel\r\n//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If\r\n//   this turns out to be a problem, you can re-enable the old rasterizer with\r\n//        #define STBTT_RASTERIZER_VERSION 1\r\n//   which will incur about a 15% speed hit.\r\n//\r\n// ADDITIONAL DOCUMENTATION\r\n//\r\n//   Immediately after this block comment are a series of sample programs.\r\n//\r\n//   After the sample programs is the \"header file\" section. This section\r\n//   includes documentation for each API function.\r\n//\r\n//   Some important concepts to understand to use this library:\r\n//\r\n//      Codepoint\r\n//         Characters are defined by unicode codepoints, e.g. 65 is\r\n//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is\r\n//         the hiragana for \"ma\".\r\n//\r\n//      Glyph\r\n//         A visual character shape (every codepoint is rendered as\r\n//         some glyph)\r\n//\r\n//      Glyph index\r\n//         A font-specific integer ID representing a glyph\r\n//\r\n//      Baseline\r\n//         Glyph shapes are defined relative to a baseline, which is the\r\n//         bottom of uppercase characters. Characters extend both above\r\n//         and below the baseline.\r\n//\r\n//      Current Point\r\n//         As you draw text to the screen, you keep track of a \"current point\"\r\n//         which is the origin of each character. The current point's vertical\r\n//         position is the baseline. Even \"baked fonts\" use this model.\r\n//\r\n//      Vertical Font Metrics\r\n//         The vertical qualities of the font, used to vertically position\r\n//         and space the characters. See docs for stbtt_GetFontVMetrics.\r\n//\r\n//      Font Size in Pixels or Points\r\n//         The preferred interface for specifying font sizes in stb_truetype\r\n//         is to specify how tall the font's vertical extent should be in pixels.\r\n//         If that sounds good enough, skip the next paragraph.\r\n//\r\n//         Most font APIs instead use \"points\", which are a common typographic\r\n//         measurement for describing font size, defined as 72 points per inch.\r\n//         stb_truetype provides a point API for compatibility. However, true\r\n//         \"per inch\" conventions don't make much sense on computer displays\r\n//         since different monitors have different number of pixels per\r\n//         inch. For example, Windows traditionally uses a convention that\r\n//         there are 96 pixels per inch, thus making 'inch' measurements have\r\n//         nothing to do with inches, and thus effectively defining a point to\r\n//         be 1.333 pixels. Additionally, the TrueType font data provides\r\n//         an explicit scale factor to scale a given font's glyphs to points,\r\n//         but the author has observed that this scale factor is often wrong\r\n//         for non-commercial fonts, thus making fonts scaled in points\r\n//         according to the TrueType spec incoherently sized in practice.\r\n//\r\n// DETAILED USAGE:\r\n//\r\n//  Scale:\r\n//    Select how high you want the font to be, in points or pixels.\r\n//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute\r\n//    a scale factor SF that will be used by all other functions.\r\n//\r\n//  Baseline:\r\n//    You need to select a y-coordinate that is the baseline of where\r\n//    your text will appear. Call GetFontBoundingBox to get the baseline-relative\r\n//    bounding box for all characters. SF*-y0 will be the distance in pixels\r\n//    that the worst-case character could extend above the baseline, so if\r\n//    you want the top edge of characters to appear at the top of the\r\n//    screen where y=0, then you would set the baseline to SF*-y0.\r\n//\r\n//  Current point:\r\n//    Set the current point where the first character will appear. The\r\n//    first character could extend left of the current point; this is font\r\n//    dependent. You can either choose a current point that is the leftmost\r\n//    point and hope, or add some padding, or check the bounding box or\r\n//    left-side-bearing of the first character to be displayed and set\r\n//    the current point based on that.\r\n//\r\n//  Displaying a character:\r\n//    Compute the bounding box of the character. It will contain signed values\r\n//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,\r\n//    then the character should be displayed in the rectangle from\r\n//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).\r\n//\r\n//  Advancing for the next character:\r\n//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.\r\n// \r\n//\r\n// ADVANCED USAGE\r\n//\r\n//   Quality:\r\n//\r\n//    - Use the functions with Subpixel at the end to allow your characters\r\n//      to have subpixel positioning. Since the font is anti-aliased, not\r\n//      hinted, this is very import for quality. (This is not possible with\r\n//      baked fonts.)\r\n//\r\n//    - Kerning is now supported, and if you're supporting subpixel rendering\r\n//      then kerning is worth using to give your text a polished look.\r\n//\r\n//   Performance:\r\n//\r\n//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;\r\n//      if you don't do this, stb_truetype is forced to do the conversion on\r\n//      every call.\r\n//\r\n//    - There are a lot of memory allocations. We should modify it to take\r\n//      a temp buffer and allocate from the temp buffer (without freeing),\r\n//      should help performance a lot.\r\n//\r\n// NOTES\r\n//\r\n//   The system uses the raw data found in the .ttf file without changing it\r\n//   and without building auxiliary data structures. This is a bit inefficient\r\n//   on little-endian systems (the data is big-endian), but assuming you're\r\n//   caching the bitmaps or glyph shapes this shouldn't be a big deal.\r\n//\r\n//   It appears to be very hard to programmatically determine what font a\r\n//   given file is in a general way. I provide an API for this, but I don't\r\n//   recommend it.\r\n//\r\n//\r\n// SOURCE STATISTICS (based on v0.6c, 2050 LOC)\r\n//\r\n//   Documentation & header file        520 LOC  \\___ 660 LOC documentation\r\n//   Sample code                        140 LOC  /\r\n//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType\r\n//   Software rasterization             240 LOC  \\                           .\r\n//   Curve tesselation                  120 LOC   \\__ 550 LOC Bitmap creation\r\n//   Bitmap management                  100 LOC   /\r\n//   Baked bitmap interface              70 LOC  /\r\n//   Font name matching & access        150 LOC  ---- 150 \r\n//   C runtime library abstraction       60 LOC  ----  60\r\n//\r\n//\r\n// PERFORMANCE MEASUREMENTS FOR 1.06:\r\n//\r\n//                      32-bit     64-bit\r\n//   Previous release:  8.83 s     7.68 s\r\n//   Pool allocations:  7.72 s     6.34 s\r\n//   Inline sort     :  6.54 s     5.65 s\r\n//   New rasterizer  :  5.63 s     5.00 s\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n////\r\n////  SAMPLE PROGRAMS\r\n////\r\n//\r\n//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless\r\n//\r\n#if 0\r\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\r\n#include \"stb_truetype.h\"\r\n\r\nunsigned char ttf_buffer[1<<20];\r\nunsigned char temp_bitmap[512*512];\r\n\r\nstbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs\r\nGLuint ftex;\r\n\r\nvoid my_stbtt_initfont(void)\r\n{\r\n   fread(ttf_buffer, 1, 1<<20, fopen(\"c:/windows/fonts/times.ttf\", \"rb\"));\r\n   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!\r\n   // can free ttf_buffer at this point\r\n   glGenTextures(1, &ftex);\r\n   glBindTexture(GL_TEXTURE_2D, ftex);\r\n   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);\r\n   // can free temp_bitmap at this point\r\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n}\r\n\r\nvoid my_stbtt_print(float x, float y, char *text)\r\n{\r\n   // assume orthographic projection with units = screen pixels, origin at top left\r\n   glEnable(GL_TEXTURE_2D);\r\n   glBindTexture(GL_TEXTURE_2D, ftex);\r\n   glBegin(GL_QUADS);\r\n   while (*text) {\r\n      if (*text >= 32 && *text < 128) {\r\n         stbtt_aligned_quad q;\r\n         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9\r\n         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);\r\n         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);\r\n         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);\r\n         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);\r\n      }\r\n      ++text;\r\n   }\r\n   glEnd();\r\n}\r\n#endif\r\n//\r\n//\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Complete program (this compiles): get a single bitmap, print as ASCII art\r\n//\r\n#if 0\r\n#include <stdio.h>\r\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\r\n#include \"stb_truetype.h\"\r\n\r\nchar ttf_buffer[1<<25];\r\n\r\nint main(int argc, char **argv)\r\n{\r\n   stbtt_fontinfo font;\r\n   unsigned char *bitmap;\r\n   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);\r\n\r\n   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : \"c:/windows/fonts/arialbd.ttf\", \"rb\"));\r\n\r\n   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));\r\n   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);\r\n\r\n   for (j=0; j < h; ++j) {\r\n      for (i=0; i < w; ++i)\r\n         putchar(\" .:ioVM@\"[bitmap[j*w+i]>>5]);\r\n      putchar('\\n');\r\n   }\r\n   return 0;\r\n}\r\n#endif \r\n//\r\n// Output:\r\n//\r\n//     .ii.\r\n//    @@@@@@.\r\n//   V@Mio@@o\r\n//   :i.  V@V\r\n//     :oM@@M\r\n//   :@@@MM@M\r\n//   @@o  o@M\r\n//  :@@.  M@M\r\n//   @@@o@@@@\r\n//   :M@@V:@@.\r\n//  \r\n//////////////////////////////////////////////////////////////////////////////\r\n// \r\n// Complete program: print \"Hello World!\" banner, with bugs\r\n//\r\n#if 0\r\nchar buffer[24<<20];\r\nunsigned char screen[20][79];\r\n\r\nint main(int arg, char **argv)\r\n{\r\n   stbtt_fontinfo font;\r\n   int i,j,ascent,baseline,ch=0;\r\n   float scale, xpos=2; // leave a little padding in case the character extends left\r\n   char *text = \"Heljo World!\"; // intentionally misspelled to show 'lj' brokenness\r\n\r\n   fread(buffer, 1, 1000000, fopen(\"c:/windows/fonts/arialbd.ttf\", \"rb\"));\r\n   stbtt_InitFont(&font, buffer, 0);\r\n\r\n   scale = stbtt_ScaleForPixelHeight(&font, 15);\r\n   stbtt_GetFontVMetrics(&font, &ascent,0,0);\r\n   baseline = (int) (ascent*scale);\r\n\r\n   while (text[ch]) {\r\n      int advance,lsb,x0,y0,x1,y1;\r\n      float x_shift = xpos - (float) floor(xpos);\r\n      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);\r\n      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);\r\n      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);\r\n      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong\r\n      // because this API is really for baking character bitmaps into textures. if you want to render\r\n      // a sequence of characters, you really need to render each bitmap to a temp buffer, then\r\n      // \"alpha blend\" that into the working buffer\r\n      xpos += (advance * scale);\r\n      if (text[ch+1])\r\n         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);\r\n      ++ch;\r\n   }\r\n\r\n   for (j=0; j < 20; ++j) {\r\n      for (i=0; i < 78; ++i)\r\n         putchar(\" .:ioVM@\"[screen[j][i]>>5]);\r\n      putchar('\\n');\r\n   }\r\n\r\n   return 0;\r\n}\r\n#endif\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   INTEGRATION WITH YOUR CODEBASE\r\n////\r\n////   The following sections allow you to supply alternate definitions\r\n////   of C library functions used by stb_truetype, e.g. if you don't\r\n////   link with the C runtime library.\r\n\r\n#ifdef STB_TRUETYPE_IMPLEMENTATION\r\n   // #define your own (u)stbtt_int8/16/32 before including to override this\r\n   #ifndef stbtt_uint8\r\n   typedef unsigned char   stbtt_uint8;\r\n   typedef signed   char   stbtt_int8;\r\n   typedef unsigned short  stbtt_uint16;\r\n   typedef signed   short  stbtt_int16;\r\n   typedef unsigned int    stbtt_uint32;\r\n   typedef signed   int    stbtt_int32;\r\n   #endif\r\n\r\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\r\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\r\n\r\n   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h\r\n   #ifndef STBTT_ifloor\r\n   #include <math.h>\r\n   #define STBTT_ifloor(x)   ((int) floor(x))\r\n   #define STBTT_iceil(x)    ((int) ceil(x))\r\n   #endif\r\n\r\n   #ifndef STBTT_sqrt\r\n   #include <math.h>\r\n   #define STBTT_sqrt(x)      sqrt(x)\r\n   #define STBTT_pow(x,y)     pow(x,y)\r\n   #endif\r\n\r\n   #ifndef STBTT_fmod\r\n   #include <math.h>\r\n   #define STBTT_fmod(x,y)    fmod(x,y)\r\n   #endif\r\n\r\n   #ifndef STBTT_cos\r\n   #include <math.h>\r\n   #define STBTT_cos(x)       cos(x)\r\n   #define STBTT_acos(x)      acos(x)\r\n   #endif\r\n\r\n   #ifndef STBTT_fabs\r\n   #include <math.h>\r\n   #define STBTT_fabs(x)      fabs(x)\r\n   #endif\r\n\r\n   // #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h\r\n   #ifndef STBTT_malloc\r\n   #include <stdlib.h>\r\n   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))\r\n   #define STBTT_free(x,u)    ((void)(u),free(x))\r\n   #endif\r\n\r\n   #ifndef STBTT_assert\r\n   #include <assert.h>\r\n   #define STBTT_assert(x)    assert(x)\r\n   #endif\r\n\r\n   #ifndef STBTT_strlen\r\n   #include <string.h>\r\n   #define STBTT_strlen(x)    strlen(x)\r\n   #endif\r\n\r\n   #ifndef STBTT_memcpy\r\n   #include <string.h>\r\n   #define STBTT_memcpy       memcpy\r\n   #define STBTT_memset       memset\r\n   #endif\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   INTERFACE\r\n////\r\n////\r\n\r\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\r\n#define __STB_INCLUDE_STB_TRUETYPE_H__\r\n\r\n#ifdef STBTT_STATIC\r\n#define STBTT_DEF static\r\n#else\r\n#define STBTT_DEF extern\r\n#endif\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n// private structure\r\ntypedef struct\r\n{\r\n   unsigned char *data;\r\n   int cursor;\r\n   int size;\r\n} stbtt__buf;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTURE BAKING API\r\n//\r\n// If you use this API, you only have to call two functions ever.\r\n//\r\n\r\ntypedef struct\r\n{\r\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\r\n   float xoff,yoff,xadvance;\r\n} stbtt_bakedchar;\r\n\r\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\r\n                                float pixel_height,                     // height of font in pixels\r\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\r\n                                int first_char, int num_chars,          // characters to bake\r\n                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long\r\n// if return is positive, the first unused row of the bitmap\r\n// if return is negative, returns the negative of the number of characters that fit\r\n// if return is 0, no characters fit and no rows were used\r\n// This uses a very crappy packing.\r\n\r\ntypedef struct\r\n{\r\n   float x0,y0,s0,t0; // top-left\r\n   float x1,y1,s1,t1; // bottom-right\r\n} stbtt_aligned_quad;\r\n\r\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above\r\n                               int char_index,             // character to display\r\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\r\n                               stbtt_aligned_quad *q,      // output: quad to draw\r\n                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier\r\n// Call GetBakedQuad with char_index = 'character - first_char', and it\r\n// creates the quad you need to draw and advances the current position.\r\n//\r\n// The coordinate system used assumes y increases downwards.\r\n//\r\n// Characters will extend both above and below the current position;\r\n// see discussion of \"BASELINE\" above.\r\n//\r\n// It's inefficient; you might want to c&p it and optimize it.\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// NEW TEXTURE BAKING API\r\n//\r\n// This provides options for packing multiple fonts into one atlas, not\r\n// perfectly but better than nothing.\r\n\r\ntypedef struct\r\n{\r\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\r\n   float xoff,yoff,xadvance;\r\n   float xoff2,yoff2;\r\n} stbtt_packedchar;\r\n\r\ntypedef struct stbtt_pack_context stbtt_pack_context;\r\ntypedef struct stbtt_fontinfo stbtt_fontinfo;\r\n#ifndef STB_RECT_PACK_VERSION\r\ntypedef struct stbrp_rect stbrp_rect;\r\n#endif\r\n\r\nSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);\r\n// Initializes a packing context stored in the passed-in stbtt_pack_context.\r\n// Future calls using this context will pack characters into the bitmap passed\r\n// in here: a 1-channel bitmap that is width * height. stride_in_bytes is\r\n// the distance from one row to the next (or 0 to mean they are packed tightly\r\n// together). \"padding\" is the amount of padding to leave between each\r\n// character (normally you want '1' for bitmaps you'll use as textures with\r\n// bilinear filtering).\r\n//\r\n// Returns 0 on failure, 1 on success.\r\n\r\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);\r\n// Cleans up the packing context and frees all memory.\r\n\r\n#define STBTT_POINT_SIZE(x)   (-(x))\r\n\r\nSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\r\n                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);\r\n// Creates character bitmaps from the font_index'th font found in fontdata (use\r\n// font_index=0 if you don't know what that is). It creates num_chars_in_range\r\n// bitmaps for characters with unicode values starting at first_unicode_char_in_range\r\n// and increasing. Data for how to render them is stored in chardata_for_range;\r\n// pass these to stbtt_GetPackedQuad to get back renderable quads.\r\n//\r\n// font_size is the full height of the character from ascender to descender,\r\n// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed\r\n// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()\r\n// and pass that result as 'font_size':\r\n//       ...,                  20 , ... // font max minus min y is 20 pixels tall\r\n//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall\r\n\r\ntypedef struct\r\n{\r\n   float font_size;\r\n   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint\r\n   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints\r\n   int num_chars;\r\n   stbtt_packedchar *chardata_for_range; // output\r\n   unsigned char h_oversample, v_oversample; // don't set these, they're used internally\r\n} stbtt_pack_range;\r\n\r\nSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);\r\n// Creates character bitmaps from multiple ranges of characters stored in\r\n// ranges. This will usually create a better-packed bitmap than multiple\r\n// calls to stbtt_PackFontRange. Note that you can call this multiple\r\n// times within a single PackBegin/PackEnd.\r\n\r\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);\r\n// Oversampling a font increases the quality by allowing higher-quality subpixel\r\n// positioning, and is especially valuable at smaller text sizes.\r\n//\r\n// This function sets the amount of oversampling for all following calls to\r\n// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given\r\n// pack context. The default (no oversampling) is achieved by h_oversample=1\r\n// and v_oversample=1. The total number of pixels required is\r\n// h_oversample*v_oversample larger than the default; for example, 2x2\r\n// oversampling requires 4x the storage of 1x1. For best results, render\r\n// oversampled textures with bilinear filtering. Look at the readme in\r\n// stb/tests/oversample for information about oversampled fonts\r\n//\r\n// To use with PackFontRangesGather etc., you must set it before calls\r\n// call to PackFontRangesGatherRects.\r\n\r\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above\r\n                               int char_index,             // character to display\r\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\r\n                               stbtt_aligned_quad *q,      // output: quad to draw\r\n                               int align_to_integer);\r\n\r\nSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\r\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);\r\nSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\r\n// Calling these functions in sequence is roughly equivalent to calling\r\n// stbtt_PackFontRanges(). If you more control over the packing of multiple\r\n// fonts, or if you want to pack custom data into a font texture, take a look\r\n// at the source to of stbtt_PackFontRanges() and create a custom version \r\n// using these functions, e.g. call GatherRects multiple times,\r\n// building up a single array of rects, then call PackRects once,\r\n// then call RenderIntoRects repeatedly. This may result in a\r\n// better packing than calling PackFontRanges multiple times\r\n// (or it may not).\r\n\r\n// this is an opaque structure that you shouldn't mess with which holds\r\n// all the context needed from PackBegin to PackEnd.\r\nstruct stbtt_pack_context {\r\n   void *user_allocator_context;\r\n   void *pack_info;\r\n   int   width;\r\n   int   height;\r\n   int   stride_in_bytes;\r\n   int   padding;\r\n   unsigned int   h_oversample, v_oversample;\r\n   unsigned char *pixels;\r\n   void  *nodes;\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// FONT LOADING\r\n//\r\n//\r\n\r\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);\r\n// This function will determine the number of fonts in a font file.  TrueType\r\n// collection (.ttc) files may contain multiple fonts, while TrueType font\r\n// (.ttf) files only contain one font. The number of fonts can be used for\r\n// indexing with the previous function where the index is between zero and one\r\n// less than the total fonts. If an error occurs, -1 is returned.\r\n\r\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\r\n// Each .ttf/.ttc file may have more than one font. Each font has a sequential\r\n// index number starting from 0. Call this function to get the font offset for\r\n// a given index; it returns -1 if the index is out of range. A regular .ttf\r\n// file will only define one font and it always be at offset 0, so it will\r\n// return '0' for index 0, and -1 for all other indices.\r\n\r\n// The following structure is defined publically so you can declare one on\r\n// the stack or as a global or etc, but you should treat it as opaque.\r\nstruct stbtt_fontinfo\r\n{\r\n   void           * userdata;\r\n   unsigned char  * data;              // pointer to .ttf file\r\n   int              fontstart;         // offset of start of font\r\n\r\n   int numGlyphs;                     // number of glyphs, needed for range checking\r\n\r\n   int loca,head,glyf,hhea,hmtx,kern,gpos; // table locations as offset from start of .ttf\r\n   int index_map;                     // a cmap mapping for our chosen character encoding\r\n   int indexToLocFormat;              // format needed to map from glyph index to glyph\r\n\r\n   stbtt__buf cff;                    // cff font data\r\n   stbtt__buf charstrings;            // the charstring index\r\n   stbtt__buf gsubrs;                 // global charstring subroutines index\r\n   stbtt__buf subrs;                  // private charstring subroutines index\r\n   stbtt__buf fontdicts;              // array of font dicts\r\n   stbtt__buf fdselect;               // map from glyph to fontdict\r\n};\r\n\r\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\r\n// Given an offset into the file that defines a font, this function builds\r\n// the necessary cached info for the rest of the system. You must allocate\r\n// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't\r\n// need to do anything special to free it, because the contents are pure\r\n// value data with no additional data structures. Returns 0 on failure.\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// CHARACTER TO GLYPH-INDEX CONVERSIOn\r\n\r\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\r\n// If you're going to perform multiple operations on the same character\r\n// and you want a speed-up, call this function with the character you're\r\n// going to process, then use glyph-based functions instead of the\r\n// codepoint-based functions.\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// CHARACTER PROPERTIES\r\n//\r\n\r\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\r\n// computes a scale factor to produce a font whose \"height\" is 'pixels' tall.\r\n// Height is measured as the distance from the highest ascender to the lowest\r\n// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics\r\n// and computing:\r\n//       scale = pixels / (ascent - descent)\r\n// so if you prefer to measure height by the ascent only, use a similar calculation.\r\n\r\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\r\n// computes a scale factor to produce a font whose EM size is mapped to\r\n// 'pixels' tall. This is probably what traditional APIs compute, but\r\n// I'm not positive.\r\n\r\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\r\n// ascent is the coordinate above the baseline the font extends; descent\r\n// is the coordinate below the baseline the font extends (i.e. it is typically negative)\r\n// lineGap is the spacing between one row's descent and the next row's ascent...\r\n// so you should advance the vertical position by \"*ascent - *descent + *lineGap\"\r\n//   these are expressed in unscaled coordinates, so you must multiply by\r\n//   the scale factor for a given size\r\n\r\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);\r\n// analogous to GetFontVMetrics, but returns the \"typographic\" values from the OS/2\r\n// table (specific to MS/Windows TTF files).\r\n//\r\n// Returns 1 on success (table present), 0 on failure.\r\n\r\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\r\n// the bounding box around all possible characters\r\n\r\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\r\n// leftSideBearing is the offset from the current horizontal position to the left edge of the character\r\n// advanceWidth is the offset from the current horizontal position to the next horizontal position\r\n//   these are expressed in unscaled coordinates\r\n\r\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\r\n// an additional amount to add to the 'advance' value between ch1 and ch2\r\n\r\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\r\n// Gets the bounding box of the visible part of the glyph, in unscaled coordinates\r\n\r\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\r\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\r\nSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\r\n// as above, but takes one or more glyph indices for greater efficiency\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// GLYPH SHAPES (you probably don't need these, but they have to go before\r\n// the bitmaps for C declaration-order reasons)\r\n//\r\n\r\n#ifndef STBTT_vmove // you can predefine these to use different values (but why?)\r\n   enum {\r\n      STBTT_vmove=1,\r\n      STBTT_vline,\r\n      STBTT_vcurve,\r\n      STBTT_vcubic\r\n   };\r\n#endif\r\n\r\n#ifndef stbtt_vertex // you can predefine this to use different values\r\n                   // (we share this with other code at RAD)\r\n   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file\r\n   typedef struct\r\n   {\r\n      stbtt_vertex_type x,y,cx,cy,cx1,cy1;\r\n      unsigned char type,padding;\r\n   } stbtt_vertex;\r\n#endif\r\n\r\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\r\n// returns non-zero if nothing is drawn for this glyph\r\n\r\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\r\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\r\n// returns # of vertices and fills *vertices with the pointer to them\r\n//   these are expressed in \"unscaled\" coordinates\r\n//\r\n// The shape is a series of countours. Each one starts with\r\n// a STBTT_moveto, then consists of a series of mixed\r\n// STBTT_lineto and STBTT_curveto segments. A lineto\r\n// draws a line from previous endpoint to its x,y; a curveto\r\n// draws a quadratic bezier from previous endpoint to\r\n// its x,y, using cx,cy as the bezier control point.\r\n\r\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\r\n// frees the data allocated above\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// BITMAP RENDERING\r\n//\r\n\r\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\r\n// frees the bitmap allocated below\r\n\r\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\r\n// allocates a large-enough single-channel 8bpp bitmap and renders the\r\n// specified character/glyph at the specified scale into it, with\r\n// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).\r\n// *width & *height are filled out with the width & height of the bitmap,\r\n// which is stored left-to-right, top-to-bottom.\r\n//\r\n// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap\r\n\r\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\r\n// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel\r\n// shift for the character\r\n\r\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\r\n// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap\r\n// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap\r\n// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the\r\n// width and height and positioning info for it first.\r\n\r\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\r\n// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel\r\n// shift for the character\r\n\r\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);\r\n// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering\r\n// is performed (see stbtt_PackSetOversampling)\r\n\r\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\n// get the bbox of the bitmap centered around the glyph origin; so the\r\n// bitmap width is ix1-ix0, height is iy1-iy0, and location to place\r\n// the bitmap top left is (leftSideBearing*scale,iy0).\r\n// (Note that the bitmap uses y-increases-down, but the shape uses\r\n// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)\r\n\r\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\n// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel\r\n// shift for the character\r\n\r\n// the following functions are equivalent to the above functions, but operate\r\n// on glyph indices instead of Unicode codepoints (for efficiency)\r\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\r\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\r\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\r\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\r\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);\r\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\n\r\n\r\n// @TODO: don't expose this structure\r\ntypedef struct\r\n{\r\n   int w,h,stride;\r\n   unsigned char *pixels;\r\n} stbtt__bitmap;\r\n\r\n// rasterize a shape with quadratic beziers into a bitmap\r\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into\r\n                               float flatness_in_pixels,     // allowable error of curve in pixels\r\n                               stbtt_vertex *vertices,       // array of vertices defining shape\r\n                               int num_verts,                // number of vertices in above array\r\n                               float scale_x, float scale_y, // scale applied to input vertices\r\n                               float shift_x, float shift_y, // translation applied to input vertices\r\n                               int x_off, int y_off,         // another translation applied to input\r\n                               int invert,                   // if non-zero, vertically flip shape\r\n                               void *userdata);              // context for to STBTT_MALLOC\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Signed Distance Function (or Field) rendering\r\n\r\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);\r\n// frees the SDF bitmap allocated below\r\n\r\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\r\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\r\n// These functions compute a discretized SDF field for a single character, suitable for storing\r\n// in a single-channel texture, sampling with bilinear filtering, and testing against\r\n// larger than some threshhold to produce scalable fonts.\r\n//        info              --  the font\r\n//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap\r\n//        glyph/codepoint   --  the character to generate the SDF for\r\n//        padding           --  extra \"pixels\" around the character which are filled with the distance to the character (not 0),\r\n//                                 which allows effects like bit outlines\r\n//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)\r\n//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF \"pixel\" away from the edge (on the 0..255 scale)\r\n//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside\r\n//        width,height      --  output height & width of the SDF bitmap (including padding)\r\n//        xoff,yoff         --  output origin of the character\r\n//        return value      --  a 2D array of bytes 0..255, width*height in size\r\n//\r\n// pixel_dist_scale & onedge_value are a scale & bias that allows you to make\r\n// optimal use of the limited 0..255 for your application, trading off precision\r\n// and special effects. SDF values outside the range 0..255 are clamped to 0..255.\r\n//\r\n// Example:\r\n//      scale = stbtt_ScaleForPixelHeight(22)\r\n//      padding = 5\r\n//      onedge_value = 180\r\n//      pixel_dist_scale = 180/5.0 = 36.0\r\n//\r\n//      This will create an SDF bitmap in which the character is about 22 pixels\r\n//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled\r\n//      shape, sample the SDF at each pixel and fill the pixel if the SDF value\r\n//      is greater than or equal to 180/255. (You'll actually want to antialias,\r\n//      which is beyond the scope of this example.) Additionally, you can compute\r\n//      offset outlines (e.g. to stroke the character border inside & outside,\r\n//      or only outside). For example, to fill outside the character up to 3 SDF\r\n//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above\r\n//      choice of variables maps a range from 5 pixels outside the shape to\r\n//      2 pixels inside the shape to 0..255; this is intended primarily for apply\r\n//      outside effects only (the interior range is needed to allow proper\r\n//      antialiasing of the font at *smaller* sizes)\r\n//\r\n// The function computes the SDF analytically at each SDF pixel, not by e.g.\r\n// building a higher-res bitmap and approximating it. In theory the quality\r\n// should be as high as possible for an SDF of this size & representation, but\r\n// unclear if this is true in practice (perhaps building a higher-res bitmap\r\n// and computing from that can allow drop-out prevention).\r\n//\r\n// The algorithm has not been optimized at all, so expect it to be slow\r\n// if computing lots of characters or very large sizes. \r\n\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Finding the right font...\r\n//\r\n// You should really just solve this offline, keep your own tables\r\n// of what font is what, and don't try to get it out of the .ttf file.\r\n// That's because getting it out of the .ttf file is really hard, because\r\n// the names in the file can appear in many possible encodings, in many\r\n// possible languages, and e.g. if you need a case-insensitive comparison,\r\n// the details of that depend on the encoding & language in a complex way\r\n// (actually underspecified in truetype, but also gigantic).\r\n//\r\n// But you can use the provided functions in two possible ways:\r\n//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on\r\n//             unicode-encoded names to try to find the font you want;\r\n//             you can run this before calling stbtt_InitFont()\r\n//\r\n//     stbtt_GetFontNameString() lets you get any of the various strings\r\n//             from the file yourself and do your own comparisons on them.\r\n//             You have to have called stbtt_InitFont() first.\r\n\r\n\r\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\r\n// returns the offset (not index) of the font that matches, or -1 if none\r\n//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\".\r\n//   if you use any other flag, use a font name like \"Arial\"; this checks\r\n//     the 'macStyle' header field; i don't know if fonts set this consistently\r\n#define STBTT_MACSTYLE_DONTCARE     0\r\n#define STBTT_MACSTYLE_BOLD         1\r\n#define STBTT_MACSTYLE_ITALIC       2\r\n#define STBTT_MACSTYLE_UNDERSCORE   4\r\n#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0\r\n\r\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\r\n// returns 1/0 whether the first string interpreted as utf8 is identical to\r\n// the second string interpreted as big-endian utf16... useful for strings from next func\r\n\r\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\r\n// returns the string (which may be big-endian double byte, e.g. for unicode)\r\n// and puts the length in bytes in *length.\r\n//\r\n// some of the values for the IDs are below; for more see the truetype spec:\r\n//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html\r\n//     http://www.microsoft.com/typography/otspec/name.htm\r\n\r\nenum { // platformID\r\n   STBTT_PLATFORM_ID_UNICODE   =0,\r\n   STBTT_PLATFORM_ID_MAC       =1,\r\n   STBTT_PLATFORM_ID_ISO       =2,\r\n   STBTT_PLATFORM_ID_MICROSOFT =3\r\n};\r\n\r\nenum { // encodingID for STBTT_PLATFORM_ID_UNICODE\r\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\r\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\r\n   STBTT_UNICODE_EID_ISO_10646      =2,\r\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\r\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\r\n};\r\n\r\nenum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT\r\n   STBTT_MS_EID_SYMBOL        =0,\r\n   STBTT_MS_EID_UNICODE_BMP   =1,\r\n   STBTT_MS_EID_SHIFTJIS      =2,\r\n   STBTT_MS_EID_UNICODE_FULL  =10\r\n};\r\n\r\nenum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes\r\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\r\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\r\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\r\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\r\n};\r\n\r\nenum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...\r\n       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs\r\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\r\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\r\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\r\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\r\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\r\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\r\n};\r\n\r\nenum { // languageID for STBTT_PLATFORM_ID_MAC\r\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\r\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\r\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\r\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\r\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\r\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\r\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\r\n};\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif // __STB_INCLUDE_STB_TRUETYPE_H__\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   IMPLEMENTATION\r\n////\r\n////\r\n\r\n#ifdef STB_TRUETYPE_IMPLEMENTATION\r\n\r\n#ifndef STBTT_MAX_OVERSAMPLE\r\n#define STBTT_MAX_OVERSAMPLE   8\r\n#endif\r\n\r\n#if STBTT_MAX_OVERSAMPLE > 255\r\n#error \"STBTT_MAX_OVERSAMPLE cannot be > 255\"\r\n#endif\r\n\r\ntypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];\r\n\r\n#ifndef STBTT_RASTERIZER_VERSION\r\n#define STBTT_RASTERIZER_VERSION 2\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#define STBTT__NOTUSED(v)  (void)(v)\r\n#else\r\n#define STBTT__NOTUSED(v)  (void)sizeof(v)\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n//\r\n// stbtt__buf helpers to parse data from file\r\n//\r\n\r\nstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\r\n{\r\n   if (b->cursor >= b->size)\r\n      return 0;\r\n   return b->data[b->cursor++];\r\n}\r\n\r\nstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\r\n{\r\n   if (b->cursor >= b->size)\r\n      return 0;\r\n   return b->data[b->cursor];\r\n}\r\n\r\nstatic void stbtt__buf_seek(stbtt__buf *b, int o)\r\n{\r\n   STBTT_assert(!(o > b->size || o < 0));\r\n   b->cursor = (o > b->size || o < 0) ? b->size : o;\r\n}\r\n\r\nstatic void stbtt__buf_skip(stbtt__buf *b, int o)\r\n{\r\n   stbtt__buf_seek(b, b->cursor + o);\r\n}\r\n\r\nstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\r\n{\r\n   stbtt_uint32 v = 0;\r\n   int i;\r\n   STBTT_assert(n >= 1 && n <= 4);\r\n   for (i = 0; i < n; i++)\r\n      v = (v << 8) | stbtt__buf_get8(b);\r\n   return v;\r\n}\r\n\r\nstatic stbtt__buf stbtt__new_buf(const void *p, size_t size)\r\n{\r\n   stbtt__buf r;\r\n   STBTT_assert(size < 0x40000000);\r\n   r.data = (stbtt_uint8*) p;\r\n   r.size = (int) size;\r\n   r.cursor = 0;\r\n   return r;\r\n}\r\n\r\n#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)\r\n#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)\r\n\r\nstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\r\n{\r\n   stbtt__buf r = stbtt__new_buf(NULL, 0);\r\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\r\n   r.data = b->data + o;\r\n   r.size = s;\r\n   return r;\r\n}\r\n\r\nstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)\r\n{\r\n   int count, start, offsize;\r\n   start = b->cursor;\r\n   count = stbtt__buf_get16(b);\r\n   if (count) {\r\n      offsize = stbtt__buf_get8(b);\r\n      STBTT_assert(offsize >= 1 && offsize <= 4);\r\n      stbtt__buf_skip(b, offsize * count);\r\n      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);\r\n   }\r\n   return stbtt__buf_range(b, start, b->cursor - start);\r\n}\r\n\r\nstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)\r\n{\r\n   int b0 = stbtt__buf_get8(b);\r\n   if (b0 >= 32 && b0 <= 246)       return b0 - 139;\r\n   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;\r\n   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;\r\n   else if (b0 == 28)               return stbtt__buf_get16(b);\r\n   else if (b0 == 29)               return stbtt__buf_get32(b);\r\n   STBTT_assert(0);\r\n   return 0;\r\n}\r\n\r\nstatic void stbtt__cff_skip_operand(stbtt__buf *b) {\r\n   int v, b0 = stbtt__buf_peek8(b);\r\n   STBTT_assert(b0 >= 28);\r\n   if (b0 == 30) {\r\n      stbtt__buf_skip(b, 1);\r\n      while (b->cursor < b->size) {\r\n         v = stbtt__buf_get8(b);\r\n         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)\r\n            break;\r\n      }\r\n   } else {\r\n      stbtt__cff_int(b);\r\n   }\r\n}\r\n\r\nstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)\r\n{\r\n   stbtt__buf_seek(b, 0);\r\n   while (b->cursor < b->size) {\r\n      int start = b->cursor, end, op;\r\n      while (stbtt__buf_peek8(b) >= 28)\r\n         stbtt__cff_skip_operand(b);\r\n      end = b->cursor;\r\n      op = stbtt__buf_get8(b);\r\n      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;\r\n      if (op == key) return stbtt__buf_range(b, start, end-start);\r\n   }\r\n   return stbtt__buf_range(b, 0, 0);\r\n}\r\n\r\nstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)\r\n{\r\n   int i;\r\n   stbtt__buf operands = stbtt__dict_get(b, key);\r\n   for (i = 0; i < outcount && operands.cursor < operands.size; i++)\r\n      out[i] = stbtt__cff_int(&operands);\r\n}\r\n\r\nstatic int stbtt__cff_index_count(stbtt__buf *b)\r\n{\r\n   stbtt__buf_seek(b, 0);\r\n   return stbtt__buf_get16(b);\r\n}\r\n\r\nstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)\r\n{\r\n   int count, offsize, start, end;\r\n   stbtt__buf_seek(&b, 0);\r\n   count = stbtt__buf_get16(&b);\r\n   offsize = stbtt__buf_get8(&b);\r\n   STBTT_assert(i >= 0 && i < count);\r\n   STBTT_assert(offsize >= 1 && offsize <= 4);\r\n   stbtt__buf_skip(&b, i*offsize);\r\n   start = stbtt__buf_get(&b, offsize);\r\n   end = stbtt__buf_get(&b, offsize);\r\n   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n//\r\n// accessors to parse data from file\r\n//\r\n\r\n// on platforms that don't allow misaligned reads, if we want to allow\r\n// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE\r\n\r\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\r\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\r\n#define ttFixed(p)    ttLONG(p)\r\n\r\nstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }\r\nstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\r\nstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\r\nstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\r\n\r\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\r\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\r\n\r\nstatic int stbtt__isfont(stbtt_uint8 *font)\r\n{\r\n   // check the version number\r\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1\r\n   if (stbtt_tag(font, \"typ1\"))   return 1; // TrueType with type 1 font -- we don't support this!\r\n   if (stbtt_tag(font, \"OTTO\"))   return 1; // OpenType with CFF\r\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0\r\n   if (stbtt_tag(font, \"true\"))   return 1; // Apple specification for TrueType fonts\r\n   return 0;\r\n}\r\n\r\n// @OPTIMIZE: binary search\r\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\r\n{\r\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\r\n   stbtt_uint32 tabledir = fontstart + 12;\r\n   stbtt_int32 i;\r\n   for (i=0; i < num_tables; ++i) {\r\n      stbtt_uint32 loc = tabledir + 16*i;\r\n      if (stbtt_tag(data+loc+0, tag))\r\n         return ttULONG(data+loc+8);\r\n   }\r\n   return 0;\r\n}\r\n\r\nstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)\r\n{\r\n   // if it's just a font, there's only one valid index\r\n   if (stbtt__isfont(font_collection))\r\n      return index == 0 ? 0 : -1;\r\n\r\n   // check if it's a TTC\r\n   if (stbtt_tag(font_collection, \"ttcf\")) {\r\n      // version 1?\r\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\r\n         stbtt_int32 n = ttLONG(font_collection+8);\r\n         if (index >= n)\r\n            return -1;\r\n         return ttULONG(font_collection+12+index*4);\r\n      }\r\n   }\r\n   return -1;\r\n}\r\n\r\nstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)\r\n{\r\n   // if it's just a font, there's only one valid font\r\n   if (stbtt__isfont(font_collection))\r\n      return 1;\r\n\r\n   // check if it's a TTC\r\n   if (stbtt_tag(font_collection, \"ttcf\")) {\r\n      // version 1?\r\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\r\n         return ttLONG(font_collection+8);\r\n      }\r\n   }\r\n   return 0;\r\n}\r\n\r\nstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)\r\n{\r\n   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };\r\n   stbtt__buf pdict;\r\n   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);\r\n   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);\r\n   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);\r\n   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);\r\n   if (!subrsoff) return stbtt__new_buf(NULL, 0);\r\n   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);\r\n   return stbtt__cff_get_index(&cff);\r\n}\r\n\r\nstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)\r\n{\r\n   stbtt_uint32 cmap, t;\r\n   stbtt_int32 i,numTables;\r\n\r\n   info->data = data;\r\n   info->fontstart = fontstart;\r\n   info->cff = stbtt__new_buf(NULL, 0);\r\n\r\n   cmap = stbtt__find_table(data, fontstart, \"cmap\");       // required\r\n   info->loca = stbtt__find_table(data, fontstart, \"loca\"); // required\r\n   info->head = stbtt__find_table(data, fontstart, \"head\"); // required\r\n   info->glyf = stbtt__find_table(data, fontstart, \"glyf\"); // required\r\n   info->hhea = stbtt__find_table(data, fontstart, \"hhea\"); // required\r\n   info->hmtx = stbtt__find_table(data, fontstart, \"hmtx\"); // required\r\n   info->kern = stbtt__find_table(data, fontstart, \"kern\"); // not required\r\n   info->gpos = stbtt__find_table(data, fontstart, \"GPOS\"); // not required\r\n\r\n   if (!cmap || !info->head || !info->hhea || !info->hmtx)\r\n      return 0;\r\n   if (info->glyf) {\r\n      // required for truetype\r\n      if (!info->loca) return 0;\r\n   } else {\r\n      // initialization for CFF / Type2 fonts (OTF)\r\n      stbtt__buf b, topdict, topdictidx;\r\n      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;\r\n      stbtt_uint32 cff;\r\n\r\n      cff = stbtt__find_table(data, fontstart, \"CFF \");\r\n      if (!cff) return 0;\r\n\r\n      info->fontdicts = stbtt__new_buf(NULL, 0);\r\n      info->fdselect = stbtt__new_buf(NULL, 0);\r\n\r\n      // @TODO this should use size from table (not 512MB)\r\n      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);\r\n      b = info->cff;\r\n\r\n      // read the header\r\n      stbtt__buf_skip(&b, 2);\r\n      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize\r\n\r\n      // @TODO the name INDEX could list multiple fonts,\r\n      // but we just use the first one.\r\n      stbtt__cff_get_index(&b);  // name INDEX\r\n      topdictidx = stbtt__cff_get_index(&b);\r\n      topdict = stbtt__cff_index_get(topdictidx, 0);\r\n      stbtt__cff_get_index(&b);  // string INDEX\r\n      info->gsubrs = stbtt__cff_get_index(&b);\r\n\r\n      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);\r\n      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);\r\n      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);\r\n      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);\r\n      info->subrs = stbtt__get_subrs(b, topdict);\r\n\r\n      // we only support Type 2 charstrings\r\n      if (cstype != 2) return 0;\r\n      if (charstrings == 0) return 0;\r\n\r\n      if (fdarrayoff) {\r\n         // looks like a CID font\r\n         if (!fdselectoff) return 0;\r\n         stbtt__buf_seek(&b, fdarrayoff);\r\n         info->fontdicts = stbtt__cff_get_index(&b);\r\n         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);\r\n      }\r\n\r\n      stbtt__buf_seek(&b, charstrings);\r\n      info->charstrings = stbtt__cff_get_index(&b);\r\n   }\r\n\r\n   t = stbtt__find_table(data, fontstart, \"maxp\");\r\n   if (t)\r\n      info->numGlyphs = ttUSHORT(data+t+4);\r\n   else\r\n      info->numGlyphs = 0xffff;\r\n\r\n   // find a cmap encoding table we understand *now* to avoid searching\r\n   // later. (todo: could make this installable)\r\n   // the same regardless of glyph.\r\n   numTables = ttUSHORT(data + cmap + 2);\r\n   info->index_map = 0;\r\n   for (i=0; i < numTables; ++i) {\r\n      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;\r\n      // find an encoding we understand:\r\n      switch(ttUSHORT(data+encoding_record)) {\r\n         case STBTT_PLATFORM_ID_MICROSOFT:\r\n            switch (ttUSHORT(data+encoding_record+2)) {\r\n               case STBTT_MS_EID_UNICODE_BMP:\r\n               case STBTT_MS_EID_UNICODE_FULL:\r\n                  // MS/Unicode\r\n                  info->index_map = cmap + ttULONG(data+encoding_record+4);\r\n                  break;\r\n            }\r\n            break;\r\n        case STBTT_PLATFORM_ID_UNICODE:\r\n            // Mac/iOS has these\r\n            // all the encodingIDs are unicode, so we don't bother to check it\r\n            info->index_map = cmap + ttULONG(data+encoding_record+4);\r\n            break;\r\n      }\r\n   }\r\n   if (info->index_map == 0)\r\n      return 0;\r\n\r\n   info->indexToLocFormat = ttUSHORT(data+info->head + 50);\r\n   return 1;\r\n}\r\n\r\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)\r\n{\r\n   stbtt_uint8 *data = info->data;\r\n   stbtt_uint32 index_map = info->index_map;\r\n\r\n   stbtt_uint16 format = ttUSHORT(data + index_map + 0);\r\n   if (format == 0) { // apple byte encoding\r\n      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);\r\n      if (unicode_codepoint < bytes-6)\r\n         return ttBYTE(data + index_map + 6 + unicode_codepoint);\r\n      return 0;\r\n   } else if (format == 6) {\r\n      stbtt_uint32 first = ttUSHORT(data + index_map + 6);\r\n      stbtt_uint32 count = ttUSHORT(data + index_map + 8);\r\n      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)\r\n         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);\r\n      return 0;\r\n   } else if (format == 2) {\r\n      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean\r\n      return 0;\r\n   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges\r\n      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;\r\n      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;\r\n      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);\r\n      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;\r\n\r\n      // do a binary search of the segments\r\n      stbtt_uint32 endCount = index_map + 14;\r\n      stbtt_uint32 search = endCount;\r\n\r\n      if (unicode_codepoint > 0xffff)\r\n         return 0;\r\n\r\n      // they lie from endCount .. endCount + segCount\r\n      // but searchRange is the nearest power of two, so...\r\n      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))\r\n         search += rangeShift*2;\r\n\r\n      // now decrement to bias correctly to find smallest\r\n      search -= 2;\r\n      while (entrySelector) {\r\n         stbtt_uint16 end;\r\n         searchRange >>= 1;\r\n         end = ttUSHORT(data + search + searchRange*2);\r\n         if (unicode_codepoint > end)\r\n            search += searchRange*2;\r\n         --entrySelector;\r\n      }\r\n      search += 2;\r\n\r\n      {\r\n         stbtt_uint16 offset, start;\r\n         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);\r\n\r\n         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));\r\n         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);\r\n         if (unicode_codepoint < start)\r\n            return 0;\r\n\r\n         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);\r\n         if (offset == 0)\r\n            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));\r\n\r\n         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);\r\n      }\r\n   } else if (format == 12 || format == 13) {\r\n      stbtt_uint32 ngroups = ttULONG(data+index_map+12);\r\n      stbtt_int32 low,high;\r\n      low = 0; high = (stbtt_int32)ngroups;\r\n      // Binary search the right group.\r\n      while (low < high) {\r\n         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high\r\n         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);\r\n         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);\r\n         if ((stbtt_uint32) unicode_codepoint < start_char)\r\n            high = mid;\r\n         else if ((stbtt_uint32) unicode_codepoint > end_char)\r\n            low = mid+1;\r\n         else {\r\n            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);\r\n            if (format == 12)\r\n               return start_glyph + unicode_codepoint-start_char;\r\n            else // format == 13\r\n               return start_glyph;\r\n         }\r\n      }\r\n      return 0; // not found\r\n   }\r\n   // @TODO\r\n   STBTT_assert(0);\r\n   return 0;\r\n}\r\n\r\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\r\n{\r\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\r\n}\r\n\r\nstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\r\n{\r\n   v->type = type;\r\n   v->x = (stbtt_int16) x;\r\n   v->y = (stbtt_int16) y;\r\n   v->cx = (stbtt_int16) cx;\r\n   v->cy = (stbtt_int16) cy;\r\n}\r\n\r\nstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)\r\n{\r\n   int g1,g2;\r\n\r\n   STBTT_assert(!info->cff.size);\r\n\r\n   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range\r\n   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format\r\n\r\n   if (info->indexToLocFormat == 0) {\r\n      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;\r\n      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;\r\n   } else {\r\n      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);\r\n      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);\r\n   }\r\n\r\n   return g1==g2 ? -1 : g1; // if length is 0, return -1\r\n}\r\n\r\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\r\n\r\nSTBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   if (info->cff.size) {\r\n      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);\r\n   } else {\r\n      int g = stbtt__GetGlyfOffset(info, glyph_index);\r\n      if (g < 0) return 0;\r\n\r\n      if (x0) *x0 = ttSHORT(info->data + g + 2);\r\n      if (y0) *y0 = ttSHORT(info->data + g + 4);\r\n      if (x1) *x1 = ttSHORT(info->data + g + 6);\r\n      if (y1) *y1 = ttSHORT(info->data + g + 8);\r\n   }\r\n   return 1;\r\n}\r\n\r\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\r\n}\r\n\r\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)\r\n{\r\n   stbtt_int16 numberOfContours;\r\n   int g;\r\n   if (info->cff.size)\r\n      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;\r\n   g = stbtt__GetGlyfOffset(info, glyph_index);\r\n   if (g < 0) return 1;\r\n   numberOfContours = ttSHORT(info->data + g);\r\n   return numberOfContours == 0;\r\n}\r\n\r\nstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,\r\n    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)\r\n{\r\n   if (start_off) {\r\n      if (was_off)\r\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);\r\n      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);\r\n   } else {\r\n      if (was_off)\r\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);\r\n      else\r\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);\r\n   }\r\n   return num_vertices;\r\n}\r\n\r\nstatic int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\r\n{\r\n   stbtt_int16 numberOfContours;\r\n   stbtt_uint8 *endPtsOfContours;\r\n   stbtt_uint8 *data = info->data;\r\n   stbtt_vertex *vertices=0;\r\n   int num_vertices=0;\r\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\r\n\r\n   *pvertices = NULL;\r\n\r\n   if (g < 0) return 0;\r\n\r\n   numberOfContours = ttSHORT(data + g);\r\n\r\n   if (numberOfContours > 0) {\r\n      stbtt_uint8 flags=0,flagcount;\r\n      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;\r\n      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;\r\n      stbtt_uint8 *points;\r\n      endPtsOfContours = (data + g + 10);\r\n      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);\r\n      points = data + g + 10 + numberOfContours * 2 + 2 + ins;\r\n\r\n      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);\r\n\r\n      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need\r\n      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);\r\n      if (vertices == 0)\r\n         return 0;\r\n\r\n      next_move = 0;\r\n      flagcount=0;\r\n\r\n      // in first pass, we load uninterpreted data into the allocated array\r\n      // above, shifted to the end of the array so we won't overwrite it when\r\n      // we create our final data starting from the front\r\n\r\n      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated\r\n\r\n      // first load flags\r\n\r\n      for (i=0; i < n; ++i) {\r\n         if (flagcount == 0) {\r\n            flags = *points++;\r\n            if (flags & 8)\r\n               flagcount = *points++;\r\n         } else\r\n            --flagcount;\r\n         vertices[off+i].type = flags;\r\n      }\r\n\r\n      // now load x coordinates\r\n      x=0;\r\n      for (i=0; i < n; ++i) {\r\n         flags = vertices[off+i].type;\r\n         if (flags & 2) {\r\n            stbtt_int16 dx = *points++;\r\n            x += (flags & 16) ? dx : -dx; // ???\r\n         } else {\r\n            if (!(flags & 16)) {\r\n               x = x + (stbtt_int16) (points[0]*256 + points[1]);\r\n               points += 2;\r\n            }\r\n         }\r\n         vertices[off+i].x = (stbtt_int16) x;\r\n      }\r\n\r\n      // now load y coordinates\r\n      y=0;\r\n      for (i=0; i < n; ++i) {\r\n         flags = vertices[off+i].type;\r\n         if (flags & 4) {\r\n            stbtt_int16 dy = *points++;\r\n            y += (flags & 32) ? dy : -dy; // ???\r\n         } else {\r\n            if (!(flags & 32)) {\r\n               y = y + (stbtt_int16) (points[0]*256 + points[1]);\r\n               points += 2;\r\n            }\r\n         }\r\n         vertices[off+i].y = (stbtt_int16) y;\r\n      }\r\n\r\n      // now convert them to our format\r\n      num_vertices=0;\r\n      sx = sy = cx = cy = scx = scy = 0;\r\n      for (i=0; i < n; ++i) {\r\n         flags = vertices[off+i].type;\r\n         x     = (stbtt_int16) vertices[off+i].x;\r\n         y     = (stbtt_int16) vertices[off+i].y;\r\n\r\n         if (next_move == i) {\r\n            if (i != 0)\r\n               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\r\n\r\n            // now start the new one               \r\n            start_off = !(flags & 1);\r\n            if (start_off) {\r\n               // if we start off with an off-curve point, then when we need to find a point on the curve\r\n               // where we can start, and we need to save some state for when we wraparound.\r\n               scx = x;\r\n               scy = y;\r\n               if (!(vertices[off+i+1].type & 1)) {\r\n                  // next point is also a curve point, so interpolate an on-point curve\r\n                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\r\n                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\r\n               } else {\r\n                  // otherwise just use the next point as our start point\r\n                  sx = (stbtt_int32) vertices[off+i+1].x;\r\n                  sy = (stbtt_int32) vertices[off+i+1].y;\r\n                  ++i; // we're using point i+1 as the starting point, so skip it\r\n               }\r\n            } else {\r\n               sx = x;\r\n               sy = y;\r\n            }\r\n            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);\r\n            was_off = 0;\r\n            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);\r\n            ++j;\r\n         } else {\r\n            if (!(flags & 1)) { // if it's a curve\r\n               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\r\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\r\n               cx = x;\r\n               cy = y;\r\n               was_off = 1;\r\n            } else {\r\n               if (was_off)\r\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);\r\n               else\r\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);\r\n               was_off = 0;\r\n            }\r\n         }\r\n      }\r\n      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\r\n   } else if (numberOfContours == -1) {\r\n      // Compound shapes.\r\n      int more = 1;\r\n      stbtt_uint8 *comp = data + g + 10;\r\n      num_vertices = 0;\r\n      vertices = 0;\r\n      while (more) {\r\n         stbtt_uint16 flags, gidx;\r\n         int comp_num_verts = 0, i;\r\n         stbtt_vertex *comp_verts = 0, *tmp = 0;\r\n         float mtx[6] = {1,0,0,1,0,0}, m, n;\r\n         \r\n         flags = ttSHORT(comp); comp+=2;\r\n         gidx = ttSHORT(comp); comp+=2;\r\n\r\n         if (flags & 2) { // XY values\r\n            if (flags & 1) { // shorts\r\n               mtx[4] = ttSHORT(comp); comp+=2;\r\n               mtx[5] = ttSHORT(comp); comp+=2;\r\n            } else {\r\n               mtx[4] = ttCHAR(comp); comp+=1;\r\n               mtx[5] = ttCHAR(comp); comp+=1;\r\n            }\r\n         }\r\n         else {\r\n            // @TODO handle matching point\r\n            STBTT_assert(0);\r\n         }\r\n         if (flags & (1<<3)) { // WE_HAVE_A_SCALE\r\n            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[1] = mtx[2] = 0;\r\n         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE\r\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[1] = mtx[2] = 0;\r\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\r\n         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO\r\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\r\n         }\r\n         \r\n         // Find transformation scales.\r\n         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);\r\n         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);\r\n\r\n         // Get indexed glyph.\r\n         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);\r\n         if (comp_num_verts > 0) {\r\n            // Transform vertices.\r\n            for (i = 0; i < comp_num_verts; ++i) {\r\n               stbtt_vertex* v = &comp_verts[i];\r\n               stbtt_vertex_type x,y;\r\n               x=v->x; y=v->y;\r\n               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\r\n               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\r\n               x=v->cx; y=v->cy;\r\n               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\r\n               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\r\n            }\r\n            // Append vertices.\r\n            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);\r\n            if (!tmp) {\r\n               if (vertices) STBTT_free(vertices, info->userdata);\r\n               if (comp_verts) STBTT_free(comp_verts, info->userdata);\r\n               return 0;\r\n            }\r\n            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));\r\n            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));\r\n            if (vertices) STBTT_free(vertices, info->userdata);\r\n            vertices = tmp;\r\n            STBTT_free(comp_verts, info->userdata);\r\n            num_vertices += comp_num_verts;\r\n         }\r\n         // More components ?\r\n         more = flags & (1<<5);\r\n      }\r\n   } else if (numberOfContours < 0) {\r\n      // @TODO other compound variations?\r\n      STBTT_assert(0);\r\n   } else {\r\n      // numberOfCounters == 0, do nothing\r\n   }\r\n\r\n   *pvertices = vertices;\r\n   return num_vertices;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   int bounds;\r\n   int started;\r\n   float first_x, first_y;\r\n   float x, y;\r\n   stbtt_int32 min_x, max_x, min_y, max_y;\r\n\r\n   stbtt_vertex *pvertices;\r\n   int num_vertices;\r\n} stbtt__csctx;\r\n\r\n#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}\r\n\r\nstatic void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)\r\n{\r\n   if (x > c->max_x || !c->started) c->max_x = x;\r\n   if (y > c->max_y || !c->started) c->max_y = y;\r\n   if (x < c->min_x || !c->started) c->min_x = x;\r\n   if (y < c->min_y || !c->started) c->min_y = y;\r\n   c->started = 1;\r\n}\r\n\r\nstatic void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)\r\n{\r\n   if (c->bounds) {\r\n      stbtt__track_vertex(c, x, y);\r\n      if (type == STBTT_vcubic) {\r\n         stbtt__track_vertex(c, cx, cy);\r\n         stbtt__track_vertex(c, cx1, cy1);\r\n      }\r\n   } else {\r\n      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);\r\n      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;\r\n      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;\r\n   }\r\n   c->num_vertices++;\r\n}\r\n\r\nstatic void stbtt__csctx_close_shape(stbtt__csctx *ctx)\r\n{\r\n   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)\r\n      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);\r\n}\r\n\r\nstatic void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\r\n{\r\n   stbtt__csctx_close_shape(ctx);\r\n   ctx->first_x = ctx->x = ctx->x + dx;\r\n   ctx->first_y = ctx->y = ctx->y + dy;\r\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\r\n}\r\n\r\nstatic void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\r\n{\r\n   ctx->x += dx;\r\n   ctx->y += dy;\r\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\r\n}\r\n\r\nstatic void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)\r\n{\r\n   float cx1 = ctx->x + dx1;\r\n   float cy1 = ctx->y + dy1;\r\n   float cx2 = cx1 + dx2;\r\n   float cy2 = cy1 + dy2;\r\n   ctx->x = cx2 + dx3;\r\n   ctx->y = cy2 + dy3;\r\n   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);\r\n}\r\n\r\nstatic stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)\r\n{\r\n   int count = stbtt__cff_index_count(&idx);\r\n   int bias = 107;\r\n   if (count >= 33900)\r\n      bias = 32768;\r\n   else if (count >= 1240)\r\n      bias = 1131;\r\n   n += bias;\r\n   if (n < 0 || n >= count)\r\n      return stbtt__new_buf(NULL, 0);\r\n   return stbtt__cff_index_get(idx, n);\r\n}\r\n\r\nstatic stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)\r\n{\r\n   stbtt__buf fdselect = info->fdselect;\r\n   int nranges, start, end, v, fmt, fdselector = -1, i;\r\n\r\n   stbtt__buf_seek(&fdselect, 0);\r\n   fmt = stbtt__buf_get8(&fdselect);\r\n   if (fmt == 0) {\r\n      // untested\r\n      stbtt__buf_skip(&fdselect, glyph_index);\r\n      fdselector = stbtt__buf_get8(&fdselect);\r\n   } else if (fmt == 3) {\r\n      nranges = stbtt__buf_get16(&fdselect);\r\n      start = stbtt__buf_get16(&fdselect);\r\n      for (i = 0; i < nranges; i++) {\r\n         v = stbtt__buf_get8(&fdselect);\r\n         end = stbtt__buf_get16(&fdselect);\r\n         if (glyph_index >= start && glyph_index < end) {\r\n            fdselector = v;\r\n            break;\r\n         }\r\n         start = end;\r\n      }\r\n   }\r\n   if (fdselector == -1) stbtt__new_buf(NULL, 0);\r\n   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));\r\n}\r\n\r\nstatic int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)\r\n{\r\n   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;\r\n   int has_subrs = 0, clear_stack;\r\n   float s[48];\r\n   stbtt__buf subr_stack[10], subrs = info->subrs, b;\r\n   float f;\r\n\r\n#define STBTT__CSERR(s) (0)\r\n\r\n   // this currently ignores the initial width value, which isn't needed if we have hmtx\r\n   b = stbtt__cff_index_get(info->charstrings, glyph_index);\r\n   while (b.cursor < b.size) {\r\n      i = 0;\r\n      clear_stack = 1;\r\n      b0 = stbtt__buf_get8(&b);\r\n      switch (b0) {\r\n      // @TODO implement hinting\r\n      case 0x13: // hintmask\r\n      case 0x14: // cntrmask\r\n         if (in_header)\r\n            maskbits += (sp / 2); // implicit \"vstem\"\r\n         in_header = 0;\r\n         stbtt__buf_skip(&b, (maskbits + 7) / 8);\r\n         break;\r\n\r\n      case 0x01: // hstem\r\n      case 0x03: // vstem\r\n      case 0x12: // hstemhm\r\n      case 0x17: // vstemhm\r\n         maskbits += (sp / 2);\r\n         break;\r\n\r\n      case 0x15: // rmoveto\r\n         in_header = 0;\r\n         if (sp < 2) return STBTT__CSERR(\"rmoveto stack\");\r\n         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);\r\n         break;\r\n      case 0x04: // vmoveto\r\n         in_header = 0;\r\n         if (sp < 1) return STBTT__CSERR(\"vmoveto stack\");\r\n         stbtt__csctx_rmove_to(c, 0, s[sp-1]);\r\n         break;\r\n      case 0x16: // hmoveto\r\n         in_header = 0;\r\n         if (sp < 1) return STBTT__CSERR(\"hmoveto stack\");\r\n         stbtt__csctx_rmove_to(c, s[sp-1], 0);\r\n         break;\r\n\r\n      case 0x05: // rlineto\r\n         if (sp < 2) return STBTT__CSERR(\"rlineto stack\");\r\n         for (; i + 1 < sp; i += 2)\r\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\r\n         break;\r\n\r\n      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical\r\n      // starting from a different place.\r\n\r\n      case 0x07: // vlineto\r\n         if (sp < 1) return STBTT__CSERR(\"vlineto stack\");\r\n         goto vlineto;\r\n      case 0x06: // hlineto\r\n         if (sp < 1) return STBTT__CSERR(\"hlineto stack\");\r\n         for (;;) {\r\n            if (i >= sp) break;\r\n            stbtt__csctx_rline_to(c, s[i], 0);\r\n            i++;\r\n      vlineto:\r\n            if (i >= sp) break;\r\n            stbtt__csctx_rline_to(c, 0, s[i]);\r\n            i++;\r\n         }\r\n         break;\r\n\r\n      case 0x1F: // hvcurveto\r\n         if (sp < 4) return STBTT__CSERR(\"hvcurveto stack\");\r\n         goto hvcurveto;\r\n      case 0x1E: // vhcurveto\r\n         if (sp < 4) return STBTT__CSERR(\"vhcurveto stack\");\r\n         for (;;) {\r\n            if (i + 3 >= sp) break;\r\n            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);\r\n            i += 4;\r\n      hvcurveto:\r\n            if (i + 3 >= sp) break;\r\n            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);\r\n            i += 4;\r\n         }\r\n         break;\r\n\r\n      case 0x08: // rrcurveto\r\n         if (sp < 6) return STBTT__CSERR(\"rcurveline stack\");\r\n         for (; i + 5 < sp; i += 6)\r\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\r\n         break;\r\n\r\n      case 0x18: // rcurveline\r\n         if (sp < 8) return STBTT__CSERR(\"rcurveline stack\");\r\n         for (; i + 5 < sp - 2; i += 6)\r\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\r\n         if (i + 1 >= sp) return STBTT__CSERR(\"rcurveline stack\");\r\n         stbtt__csctx_rline_to(c, s[i], s[i+1]);\r\n         break;\r\n\r\n      case 0x19: // rlinecurve\r\n         if (sp < 8) return STBTT__CSERR(\"rlinecurve stack\");\r\n         for (; i + 1 < sp - 6; i += 2)\r\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\r\n         if (i + 5 >= sp) return STBTT__CSERR(\"rlinecurve stack\");\r\n         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\r\n         break;\r\n\r\n      case 0x1A: // vvcurveto\r\n      case 0x1B: // hhcurveto\r\n         if (sp < 4) return STBTT__CSERR(\"(vv|hh)curveto stack\");\r\n         f = 0.0;\r\n         if (sp & 1) { f = s[i]; i++; }\r\n         for (; i + 3 < sp; i += 4) {\r\n            if (b0 == 0x1B)\r\n               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);\r\n            else\r\n               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);\r\n            f = 0.0;\r\n         }\r\n         break;\r\n\r\n      case 0x0A: // callsubr\r\n         if (!has_subrs) {\r\n            if (info->fdselect.size)\r\n               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);\r\n            has_subrs = 1;\r\n         }\r\n         // fallthrough\r\n      case 0x1D: // callgsubr\r\n         if (sp < 1) return STBTT__CSERR(\"call(g|)subr stack\");\r\n         v = (int) s[--sp];\r\n         if (subr_stack_height >= 10) return STBTT__CSERR(\"recursion limit\");\r\n         subr_stack[subr_stack_height++] = b;\r\n         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);\r\n         if (b.size == 0) return STBTT__CSERR(\"subr not found\");\r\n         b.cursor = 0;\r\n         clear_stack = 0;\r\n         break;\r\n\r\n      case 0x0B: // return\r\n         if (subr_stack_height <= 0) return STBTT__CSERR(\"return outside subr\");\r\n         b = subr_stack[--subr_stack_height];\r\n         clear_stack = 0;\r\n         break;\r\n\r\n      case 0x0E: // endchar\r\n         stbtt__csctx_close_shape(c);\r\n         return 1;\r\n\r\n      case 0x0C: { // two-byte escape\r\n         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;\r\n         float dx, dy;\r\n         int b1 = stbtt__buf_get8(&b);\r\n         switch (b1) {\r\n         // @TODO These \"flex\" implementations ignore the flex-depth and resolution,\r\n         // and always draw beziers.\r\n         case 0x22: // hflex\r\n            if (sp < 7) return STBTT__CSERR(\"hflex stack\");\r\n            dx1 = s[0];\r\n            dx2 = s[1];\r\n            dy2 = s[2];\r\n            dx3 = s[3];\r\n            dx4 = s[4];\r\n            dx5 = s[5];\r\n            dx6 = s[6];\r\n            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);\r\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);\r\n            break;\r\n\r\n         case 0x23: // flex\r\n            if (sp < 13) return STBTT__CSERR(\"flex stack\");\r\n            dx1 = s[0];\r\n            dy1 = s[1];\r\n            dx2 = s[2];\r\n            dy2 = s[3];\r\n            dx3 = s[4];\r\n            dy3 = s[5];\r\n            dx4 = s[6];\r\n            dy4 = s[7];\r\n            dx5 = s[8];\r\n            dy5 = s[9];\r\n            dx6 = s[10];\r\n            dy6 = s[11];\r\n            //fd is s[12]\r\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\r\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\r\n            break;\r\n\r\n         case 0x24: // hflex1\r\n            if (sp < 9) return STBTT__CSERR(\"hflex1 stack\");\r\n            dx1 = s[0];\r\n            dy1 = s[1];\r\n            dx2 = s[2];\r\n            dy2 = s[3];\r\n            dx3 = s[4];\r\n            dx4 = s[5];\r\n            dx5 = s[6];\r\n            dy5 = s[7];\r\n            dx6 = s[8];\r\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);\r\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));\r\n            break;\r\n\r\n         case 0x25: // flex1\r\n            if (sp < 11) return STBTT__CSERR(\"flex1 stack\");\r\n            dx1 = s[0];\r\n            dy1 = s[1];\r\n            dx2 = s[2];\r\n            dy2 = s[3];\r\n            dx3 = s[4];\r\n            dy3 = s[5];\r\n            dx4 = s[6];\r\n            dy4 = s[7];\r\n            dx5 = s[8];\r\n            dy5 = s[9];\r\n            dx6 = dy6 = s[10];\r\n            dx = dx1+dx2+dx3+dx4+dx5;\r\n            dy = dy1+dy2+dy3+dy4+dy5;\r\n            if (STBTT_fabs(dx) > STBTT_fabs(dy))\r\n               dy6 = -dy;\r\n            else\r\n               dx6 = -dx;\r\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\r\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\r\n            break;\r\n\r\n         default:\r\n            return STBTT__CSERR(\"unimplemented\");\r\n         }\r\n      } break;\r\n\r\n      default:\r\n         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))\r\n            return STBTT__CSERR(\"reserved operator\");\r\n\r\n         // push immediate\r\n         if (b0 == 255) {\r\n            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;\r\n         } else {\r\n            stbtt__buf_skip(&b, -1);\r\n            f = (float)(stbtt_int16)stbtt__cff_int(&b);\r\n         }\r\n         if (sp >= 48) return STBTT__CSERR(\"push stack overflow\");\r\n         s[sp++] = f;\r\n         clear_stack = 0;\r\n         break;\r\n      }\r\n      if (clear_stack) sp = 0;\r\n   }\r\n   return STBTT__CSERR(\"no endchar\");\r\n\r\n#undef STBTT__CSERR\r\n}\r\n\r\nstatic int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\r\n{\r\n   // runs the charstring twice, once to count and once to output (to avoid realloc)\r\n   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);\r\n   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);\r\n   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {\r\n      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);\r\n      output_ctx.pvertices = *pvertices;\r\n      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {\r\n         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);\r\n         return output_ctx.num_vertices;\r\n      }\r\n   }\r\n   *pvertices = NULL;\r\n   return 0;\r\n}\r\n\r\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   stbtt__csctx c = STBTT__CSCTX_INIT(1);\r\n   int r = stbtt__run_charstring(info, glyph_index, &c);\r\n   if (x0)  *x0 = r ? c.min_x : 0;\r\n   if (y0)  *y0 = r ? c.min_y : 0;\r\n   if (x1)  *x1 = r ? c.max_x : 0;\r\n   if (y1)  *y1 = r ? c.max_y : 0;\r\n   return r ? c.num_vertices : 0;\r\n}\r\n\r\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\r\n{\r\n   if (!info->cff.size)\r\n      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);\r\n   else\r\n      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)\r\n{\r\n   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);\r\n   if (glyph_index < numOfLongHorMetrics) {\r\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);\r\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);\r\n   } else {\r\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));\r\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));\r\n   }\r\n}\r\n\r\nstatic int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\r\n{\r\n   stbtt_uint8 *data = info->data + info->kern;\r\n   stbtt_uint32 needle, straw;\r\n   int l, r, m;\r\n\r\n   // we only look at the first table. it must be 'horizontal' and format 0.\r\n   if (!info->kern)\r\n      return 0;\r\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\r\n      return 0;\r\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\r\n      return 0;\r\n\r\n   l = 0;\r\n   r = ttUSHORT(data+10) - 1;\r\n   needle = glyph1 << 16 | glyph2;\r\n   while (l <= r) {\r\n      m = (l + r) >> 1;\r\n      straw = ttULONG(data+18+(m*6)); // note: unaligned read\r\n      if (needle < straw)\r\n         r = m - 1;\r\n      else if (needle > straw)\r\n         l = m + 1;\r\n      else\r\n         return ttSHORT(data+22+(m*6));\r\n   }\r\n   return 0;\r\n}\r\n\r\nstatic stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)\r\n{\r\n    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);\r\n    switch(coverageFormat) {\r\n        case 1: {\r\n            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);\r\n\r\n            // Binary search.\r\n            stbtt_int32 l=0, r=glyphCount-1, m;\r\n            int straw, needle=glyph;\r\n            while (l <= r) {\r\n                stbtt_uint8 *glyphArray = coverageTable + 4;\r\n                stbtt_uint16 glyphID;\r\n                m = (l + r) >> 1;\r\n                glyphID = ttUSHORT(glyphArray + 2 * m);\r\n                straw = glyphID;\r\n                if (needle < straw)\r\n                    r = m - 1;\r\n                else if (needle > straw)\r\n                    l = m + 1;\r\n                else {\r\n                     return m;\r\n                }\r\n            }\r\n        } break;\r\n\r\n        case 2: {\r\n            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);\r\n            stbtt_uint8 *rangeArray = coverageTable + 4;\r\n\r\n            // Binary search.\r\n            stbtt_int32 l=0, r=rangeCount-1, m;\r\n            int strawStart, strawEnd, needle=glyph;\r\n            while (l <= r) {\r\n                stbtt_uint8 *rangeRecord;\r\n                m = (l + r) >> 1;\r\n                rangeRecord = rangeArray + 6 * m;\r\n                strawStart = ttUSHORT(rangeRecord);\r\n                strawEnd = ttUSHORT(rangeRecord + 2);\r\n                if (needle < strawStart)\r\n                    r = m - 1;\r\n                else if (needle > strawEnd)\r\n                    l = m + 1;\r\n                else {\r\n                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);\r\n                    return startCoverageIndex + glyph - strawStart;\r\n                }\r\n            }\r\n        } break;\r\n\r\n        default: {\r\n            // There are no other cases.\r\n            STBTT_assert(0);\r\n        } break;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nstatic stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)\r\n{\r\n    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);\r\n    switch(classDefFormat)\r\n    {\r\n        case 1: {\r\n            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);\r\n            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);\r\n            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;\r\n\r\n            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)\r\n                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));\r\n\r\n            classDefTable = classDef1ValueArray + 2 * glyphCount;\r\n        } break;\r\n\r\n        case 2: {\r\n            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);\r\n            stbtt_uint8 *classRangeRecords = classDefTable + 4;\r\n\r\n            // Binary search.\r\n            stbtt_int32 l=0, r=classRangeCount-1, m;\r\n            int strawStart, strawEnd, needle=glyph;\r\n            while (l <= r) {\r\n                stbtt_uint8 *classRangeRecord;\r\n                m = (l + r) >> 1;\r\n                classRangeRecord = classRangeRecords + 6 * m;\r\n                strawStart = ttUSHORT(classRangeRecord);\r\n                strawEnd = ttUSHORT(classRangeRecord + 2);\r\n                if (needle < strawStart)\r\n                    r = m - 1;\r\n                else if (needle > strawEnd)\r\n                    l = m + 1;\r\n                else\r\n                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);\r\n            }\r\n\r\n            classDefTable = classRangeRecords + 6 * classRangeCount;\r\n        } break;\r\n\r\n        default: {\r\n            // There are no other cases.\r\n            STBTT_assert(0);\r\n        } break;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n// Define to STBTT_assert(x) if you want to break on unimplemented formats.\r\n#define STBTT_GPOS_TODO_assert(x)\r\n\r\nstatic stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\r\n{\r\n    stbtt_uint16 lookupListOffset;\r\n    stbtt_uint8 *lookupList;\r\n    stbtt_uint16 lookupCount;\r\n    stbtt_uint8 *data;\r\n    stbtt_int32 i;\r\n\r\n    if (!info->gpos) return 0;\r\n\r\n    data = info->data + info->gpos;\r\n\r\n    if (ttUSHORT(data+0) != 1) return 0; // Major version 1\r\n    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0\r\n\r\n    lookupListOffset = ttUSHORT(data+8);\r\n    lookupList = data + lookupListOffset;\r\n    lookupCount = ttUSHORT(lookupList);\r\n\r\n    for (i=0; i<lookupCount; ++i) {\r\n        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);\r\n        stbtt_uint8 *lookupTable = lookupList + lookupOffset;\r\n\r\n        stbtt_uint16 lookupType = ttUSHORT(lookupTable);\r\n        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);\r\n        stbtt_uint8 *subTableOffsets = lookupTable + 6;\r\n        switch(lookupType) {\r\n            case 2: { // Pair Adjustment Positioning Subtable\r\n                stbtt_int32 sti;\r\n                for (sti=0; sti<subTableCount; sti++) {\r\n                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);\r\n                    stbtt_uint8 *table = lookupTable + subtableOffset;\r\n                    stbtt_uint16 posFormat = ttUSHORT(table);\r\n                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);\r\n                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);\r\n                    if (coverageIndex == -1) continue;\r\n\r\n                    switch (posFormat) {\r\n                        case 1: {\r\n                            stbtt_int32 l, r, m;\r\n                            int straw, needle;\r\n                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\r\n                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\r\n                            stbtt_int32 valueRecordPairSizeInBytes = 2;\r\n                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);\r\n                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);\r\n                            stbtt_uint8 *pairValueTable = table + pairPosOffset;\r\n                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);\r\n                            stbtt_uint8 *pairValueArray = pairValueTable + 2;\r\n                            // TODO: Support more formats.\r\n                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);\r\n                            if (valueFormat1 != 4) return 0;\r\n                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);\r\n                            if (valueFormat2 != 0) return 0;\r\n\r\n                            STBTT_assert(coverageIndex < pairSetCount);\r\n                            STBTT__NOTUSED(pairSetCount);\r\n\r\n                            needle=glyph2;\r\n                            r=pairValueCount-1;\r\n                            l=0;\r\n\r\n                            // Binary search.\r\n                            while (l <= r) {\r\n                                stbtt_uint16 secondGlyph;\r\n                                stbtt_uint8 *pairValue;\r\n                                m = (l + r) >> 1;\r\n                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;\r\n                                secondGlyph = ttUSHORT(pairValue);\r\n                                straw = secondGlyph;\r\n                                if (needle < straw)\r\n                                    r = m - 1;\r\n                                else if (needle > straw)\r\n                                    l = m + 1;\r\n                                else {\r\n                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);\r\n                                    return xAdvance;\r\n                                }\r\n                            }\r\n                        } break;\r\n\r\n                        case 2: {\r\n                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\r\n                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\r\n\r\n                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);\r\n                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);\r\n                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);\r\n                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);\r\n\r\n                            stbtt_uint16 class1Count = ttUSHORT(table + 12);\r\n                            stbtt_uint16 class2Count = ttUSHORT(table + 14);\r\n                            STBTT_assert(glyph1class < class1Count);\r\n                            STBTT_assert(glyph2class < class2Count);\r\n\r\n                            // TODO: Support more formats.\r\n                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);\r\n                            if (valueFormat1 != 4) return 0;\r\n                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);\r\n                            if (valueFormat2 != 0) return 0;\r\n\r\n                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {\r\n                                stbtt_uint8 *class1Records = table + 16;\r\n                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);\r\n                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);\r\n                                return xAdvance;\r\n                            }\r\n                        } break;\r\n\r\n                        default: {\r\n                            // There are no other cases.\r\n                            STBTT_assert(0);\r\n                            break;\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            };\r\n\r\n            default:\r\n                // TODO: Implement other stuff.\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\r\n{\r\n   int xAdvance = 0;\r\n\r\n   if (info->gpos)\r\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\r\n\r\n   if (info->kern)\r\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\r\n\r\n   return xAdvance;\r\n}\r\n\r\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\r\n{\r\n   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs\r\n      return 0;\r\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\r\n{\r\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\r\n{\r\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\r\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\r\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\r\n}\r\n\r\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\r\n{\r\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS/2\");\r\n   if (!tab)\r\n      return 0;\r\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\r\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\r\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\r\n   return 1;\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   *x0 = ttSHORT(info->data + info->head + 36);\r\n   *y0 = ttSHORT(info->data + info->head + 38);\r\n   *x1 = ttSHORT(info->data + info->head + 40);\r\n   *y1 = ttSHORT(info->data + info->head + 42);\r\n}\r\n\r\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)\r\n{\r\n   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);\r\n   return (float) height / fheight;\r\n}\r\n\r\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)\r\n{\r\n   int unitsPerEm = ttUSHORT(info->data + info->head + 18);\r\n   return pixels / unitsPerEm;\r\n}\r\n\r\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)\r\n{\r\n   STBTT_free(v, info->userdata);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// antialiasing software rasterizer\r\n//\r\n\r\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning\r\n   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {\r\n      // e.g. space character\r\n      if (ix0) *ix0 = 0;\r\n      if (iy0) *iy0 = 0;\r\n      if (ix1) *ix1 = 0;\r\n      if (iy1) *iy1 = 0;\r\n   } else {\r\n      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?\r\n      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);\r\n      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);\r\n      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);\r\n      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);\r\n   }\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  Rasterizer\r\n\r\ntypedef struct stbtt__hheap_chunk\r\n{\r\n   struct stbtt__hheap_chunk *next;\r\n} stbtt__hheap_chunk;\r\n\r\ntypedef struct stbtt__hheap\r\n{\r\n   struct stbtt__hheap_chunk *head;\r\n   void   *first_free;\r\n   int    num_remaining_in_head_chunk;\r\n} stbtt__hheap;\r\n\r\nstatic void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)\r\n{\r\n   if (hh->first_free) {\r\n      void *p = hh->first_free;\r\n      hh->first_free = * (void **) p;\r\n      return p;\r\n   } else {\r\n      if (hh->num_remaining_in_head_chunk == 0) {\r\n         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);\r\n         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);\r\n         if (c == NULL)\r\n            return NULL;\r\n         c->next = hh->head;\r\n         hh->head = c;\r\n         hh->num_remaining_in_head_chunk = count;\r\n      }\r\n      --hh->num_remaining_in_head_chunk;\r\n      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;\r\n   }\r\n}\r\n\r\nstatic void stbtt__hheap_free(stbtt__hheap *hh, void *p)\r\n{\r\n   *(void **) p = hh->first_free;\r\n   hh->first_free = p;\r\n}\r\n\r\nstatic void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\r\n{\r\n   stbtt__hheap_chunk *c = hh->head;\r\n   while (c) {\r\n      stbtt__hheap_chunk *n = c->next;\r\n      STBTT_free(c, userdata);\r\n      c = n;\r\n   }\r\n}\r\n\r\ntypedef struct stbtt__edge {\r\n   float x0,y0, x1,y1;\r\n   int invert;\r\n} stbtt__edge;\r\n\r\n\r\ntypedef struct stbtt__active_edge\r\n{\r\n   struct stbtt__active_edge *next;\r\n   #if STBTT_RASTERIZER_VERSION==1\r\n   int x,dx;\r\n   float ey;\r\n   int direction;\r\n   #elif STBTT_RASTERIZER_VERSION==2\r\n   float fx,fdx,fdy;\r\n   float direction;\r\n   float sy;\r\n   float ey;\r\n   #else\r\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\r\n   #endif\r\n} stbtt__active_edge;\r\n\r\n#if STBTT_RASTERIZER_VERSION == 1\r\n#define STBTT_FIXSHIFT   10\r\n#define STBTT_FIX        (1 << STBTT_FIXSHIFT)\r\n#define STBTT_FIXMASK    (STBTT_FIX-1)\r\n\r\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\r\n{\r\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\r\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\r\n   STBTT_assert(z != NULL);\r\n   if (!z) return z;\r\n   \r\n   // round dx down to avoid overshooting\r\n   if (dxdy < 0)\r\n      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);\r\n   else\r\n      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);\r\n\r\n   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount\r\n   z->x -= off_x * STBTT_FIX;\r\n\r\n   z->ey = e->y1;\r\n   z->next = 0;\r\n   z->direction = e->invert ? 1 : -1;\r\n   return z;\r\n}\r\n#elif STBTT_RASTERIZER_VERSION == 2\r\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\r\n{\r\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\r\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\r\n   STBTT_assert(z != NULL);\r\n   //STBTT_assert(e->y0 <= start_point);\r\n   if (!z) return z;\r\n   z->fdx = dxdy;\r\n   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;\r\n   z->fx = e->x0 + dxdy * (start_point - e->y0);\r\n   z->fx -= off_x;\r\n   z->direction = e->invert ? 1.0f : -1.0f;\r\n   z->sy = e->y0;\r\n   z->ey = e->y1;\r\n   z->next = 0;\r\n   return z;\r\n}\r\n#else\r\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\r\n#endif\r\n\r\n#if STBTT_RASTERIZER_VERSION == 1\r\n// note: this routine clips fills that extend off the edges... ideally this\r\n// wouldn't happen, but it could happen if the truetype glyph bounding boxes\r\n// are wrong, or if the user supplies a too-small bitmap\r\nstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)\r\n{\r\n   // non-zero winding fill\r\n   int x0=0, w=0;\r\n\r\n   while (e) {\r\n      if (w == 0) {\r\n         // if we're currently at zero, we need to record the edge start point\r\n         x0 = e->x; w += e->direction;\r\n      } else {\r\n         int x1 = e->x; w += e->direction;\r\n         // if we went to zero, we need to draw\r\n         if (w == 0) {\r\n            int i = x0 >> STBTT_FIXSHIFT;\r\n            int j = x1 >> STBTT_FIXSHIFT;\r\n\r\n            if (i < len && j >= 0) {\r\n               if (i == j) {\r\n                  // x0,x1 are the same pixel, so compute combined coverage\r\n                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);\r\n               } else {\r\n                  if (i >= 0) // add antialiasing for x0\r\n                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);\r\n                  else\r\n                     i = -1; // clip\r\n\r\n                  if (j < len) // add antialiasing for x1\r\n                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);\r\n                  else\r\n                     j = len; // clip\r\n\r\n                  for (++i; i < j; ++i) // fill pixels between x0 and x1\r\n                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;\r\n               }\r\n            }\r\n         }\r\n      }\r\n      \r\n      e = e->next;\r\n   }\r\n}\r\n\r\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\r\n{\r\n   stbtt__hheap hh = { 0, 0, 0 };\r\n   stbtt__active_edge *active = NULL;\r\n   int y,j=0;\r\n   int max_weight = (255 / vsubsample);  // weight per vertical scanline\r\n   int s; // vertical subsample index\r\n   unsigned char scanline_data[512], *scanline;\r\n\r\n   if (result->w > 512)\r\n      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);\r\n   else\r\n      scanline = scanline_data;\r\n\r\n   y = off_y * vsubsample;\r\n   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;\r\n\r\n   while (j < result->h) {\r\n      STBTT_memset(scanline, 0, result->w);\r\n      for (s=0; s < vsubsample; ++s) {\r\n         // find center of pixel for this scanline\r\n         float scan_y = y + 0.5f;\r\n         stbtt__active_edge **step = &active;\r\n\r\n         // update all active edges;\r\n         // remove all active edges that terminate before the center of this scanline\r\n         while (*step) {\r\n            stbtt__active_edge * z = *step;\r\n            if (z->ey <= scan_y) {\r\n               *step = z->next; // delete from list\r\n               STBTT_assert(z->direction);\r\n               z->direction = 0;\r\n               stbtt__hheap_free(&hh, z);\r\n            } else {\r\n               z->x += z->dx; // advance to position for current scanline\r\n               step = &((*step)->next); // advance through list\r\n            }\r\n         }\r\n\r\n         // resort the list if needed\r\n         for(;;) {\r\n            int changed=0;\r\n            step = &active;\r\n            while (*step && (*step)->next) {\r\n               if ((*step)->x > (*step)->next->x) {\r\n                  stbtt__active_edge *t = *step;\r\n                  stbtt__active_edge *q = t->next;\r\n\r\n                  t->next = q->next;\r\n                  q->next = t;\r\n                  *step = q;\r\n                  changed = 1;\r\n               }\r\n               step = &(*step)->next;\r\n            }\r\n            if (!changed) break;\r\n         }\r\n\r\n         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline\r\n         while (e->y0 <= scan_y) {\r\n            if (e->y1 > scan_y) {\r\n               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);\r\n               if (z != NULL) {\r\n                  // find insertion point\r\n                  if (active == NULL)\r\n                     active = z;\r\n                  else if (z->x < active->x) {\r\n                     // insert at front\r\n                     z->next = active;\r\n                     active = z;\r\n                  } else {\r\n                     // find thing to insert AFTER\r\n                     stbtt__active_edge *p = active;\r\n                     while (p->next && p->next->x < z->x)\r\n                        p = p->next;\r\n                     // at this point, p->next->x is NOT < z->x\r\n                     z->next = p->next;\r\n                     p->next = z;\r\n                  }\r\n               }\r\n            }\r\n            ++e;\r\n         }\r\n\r\n         // now process all active edges in XOR fashion\r\n         if (active)\r\n            stbtt__fill_active_edges(scanline, result->w, active, max_weight);\r\n\r\n         ++y;\r\n      }\r\n      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);\r\n      ++j;\r\n   }\r\n\r\n   stbtt__hheap_cleanup(&hh, userdata);\r\n\r\n   if (scanline != scanline_data)\r\n      STBTT_free(scanline, userdata);\r\n}\r\n\r\n#elif STBTT_RASTERIZER_VERSION == 2\r\n\r\n// the edge passed in here does not cross the vertical line at x or the vertical line at x+1\r\n// (i.e. it has already been clipped to those)\r\nstatic void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)\r\n{\r\n   if (y0 == y1) return;\r\n   STBTT_assert(y0 < y1);\r\n   STBTT_assert(e->sy <= e->ey);\r\n   if (y0 > e->ey) return;\r\n   if (y1 < e->sy) return;\r\n   if (y0 < e->sy) {\r\n      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);\r\n      y0 = e->sy;\r\n   }\r\n   if (y1 > e->ey) {\r\n      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);\r\n      y1 = e->ey;\r\n   }\r\n\r\n   if (x0 == x)\r\n      STBTT_assert(x1 <= x+1);\r\n   else if (x0 == x+1)\r\n      STBTT_assert(x1 >= x);\r\n   else if (x0 <= x)\r\n      STBTT_assert(x1 <= x);\r\n   else if (x0 >= x+1)\r\n      STBTT_assert(x1 >= x+1);\r\n   else\r\n      STBTT_assert(x1 >= x && x1 <= x+1);\r\n\r\n   if (x0 <= x && x1 <= x)\r\n      scanline[x] += e->direction * (y1-y0);\r\n   else if (x0 >= x+1 && x1 >= x+1)\r\n      ;\r\n   else {\r\n      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);\r\n      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position\r\n   }\r\n}\r\n\r\nstatic void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)\r\n{\r\n   float y_bottom = y_top+1;\r\n\r\n   while (e) {\r\n      // brute force every pixel\r\n\r\n      // compute intersection points with top & bottom\r\n      STBTT_assert(e->ey >= y_top);\r\n\r\n      if (e->fdx == 0) {\r\n         float x0 = e->fx;\r\n         if (x0 < len) {\r\n            if (x0 >= 0) {\r\n               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);\r\n               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);\r\n            } else {\r\n               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);\r\n            }\r\n         }\r\n      } else {\r\n         float x0 = e->fx;\r\n         float dx = e->fdx;\r\n         float xb = x0 + dx;\r\n         float x_top, x_bottom;\r\n         float sy0,sy1;\r\n         float dy = e->fdy;\r\n         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);\r\n\r\n         // compute endpoints of line segment clipped to this scanline (if the\r\n         // line segment starts on this scanline. x0 is the intersection of the\r\n         // line with y_top, but that may be off the line segment.\r\n         if (e->sy > y_top) {\r\n            x_top = x0 + dx * (e->sy - y_top);\r\n            sy0 = e->sy;\r\n         } else {\r\n            x_top = x0;\r\n            sy0 = y_top;\r\n         }\r\n         if (e->ey < y_bottom) {\r\n            x_bottom = x0 + dx * (e->ey - y_top);\r\n            sy1 = e->ey;\r\n         } else {\r\n            x_bottom = xb;\r\n            sy1 = y_bottom;\r\n         }\r\n\r\n         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {\r\n            // from here on, we don't have to range check x values\r\n\r\n            if ((int) x_top == (int) x_bottom) {\r\n               float height;\r\n               // simple case, only spans one pixel\r\n               int x = (int) x_top;\r\n               height = sy1 - sy0;\r\n               STBTT_assert(x >= 0 && x < len);\r\n               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;\r\n               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled\r\n            } else {\r\n               int x,x1,x2;\r\n               float y_crossing, step, sign, area;\r\n               // covers 2+ pixels\r\n               if (x_top > x_bottom) {\r\n                  // flip scanline vertically; signed area is the same\r\n                  float t;\r\n                  sy0 = y_bottom - (sy0 - y_top);\r\n                  sy1 = y_bottom - (sy1 - y_top);\r\n                  t = sy0, sy0 = sy1, sy1 = t;\r\n                  t = x_bottom, x_bottom = x_top, x_top = t;\r\n                  dx = -dx;\r\n                  dy = -dy;\r\n                  t = x0, x0 = xb, xb = t;\r\n               }\r\n\r\n               x1 = (int) x_top;\r\n               x2 = (int) x_bottom;\r\n               // compute intersection with y axis at x1+1\r\n               y_crossing = (x1+1 - x0) * dy + y_top;\r\n\r\n               sign = e->direction;\r\n               // area of the rectangle covered from y0..y_crossing\r\n               area = sign * (y_crossing-sy0);\r\n               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)\r\n               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);\r\n\r\n               step = sign * dy;\r\n               for (x = x1+1; x < x2; ++x) {\r\n                  scanline[x] += area + step/2;\r\n                  area += step;\r\n               }\r\n               y_crossing += dy * (x2 - (x1+1));\r\n\r\n               STBTT_assert(STBTT_fabs(area) <= 1.01f);\r\n\r\n               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);\r\n\r\n               scanline_fill[x2] += sign * (sy1-sy0);\r\n            }\r\n         } else {\r\n            // if edge goes outside of box we're drawing, we require\r\n            // clipping logic. since this does not match the intended use\r\n            // of this library, we use a different, very slow brute\r\n            // force implementation\r\n            int x;\r\n            for (x=0; x < len; ++x) {\r\n               // cases:\r\n               //\r\n               // there can be up to two intersections with the pixel. any intersection\r\n               // with left or right edges can be handled by splitting into two (or three)\r\n               // regions. intersections with top & bottom do not necessitate case-wise logic.\r\n               //\r\n               // the old way of doing this found the intersections with the left & right edges,\r\n               // then used some simple logic to produce up to three segments in sorted order\r\n               // from top-to-bottom. however, this had a problem: if an x edge was epsilon\r\n               // across the x border, then the corresponding y position might not be distinct\r\n               // from the other y segment, and it might ignored as an empty segment. to avoid\r\n               // that, we need to explicitly produce segments based on x positions.\r\n\r\n               // rename variables to clearly-defined pairs\r\n               float y0 = y_top;\r\n               float x1 = (float) (x);\r\n               float x2 = (float) (x+1);\r\n               float x3 = xb;\r\n               float y3 = y_bottom;\r\n\r\n               // x = e->x + e->dx * (y-y_top)\r\n               // (y-y_top) = (x - e->x) / e->dx\r\n               // y = (x - e->x) / e->dx + y_top\r\n               float y1 = (x - x0) / dx + y_top;\r\n               float y2 = (x+1 - x0) / dx + y_top;\r\n\r\n               if (x0 < x1 && x3 > x2) {         // three segments descending down-right\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\r\n               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\r\n               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\r\n               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\r\n               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\r\n               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\r\n               } else {  // one segment\r\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);\r\n               }\r\n            }\r\n         }\r\n      }\r\n      e = e->next;\r\n   }\r\n}\r\n\r\n// directly AA rasterize edges w/o supersampling\r\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\r\n{\r\n   stbtt__hheap hh = { 0, 0, 0 };\r\n   stbtt__active_edge *active = NULL;\r\n   int y,j=0, i;\r\n   float scanline_data[129], *scanline, *scanline2;\r\n\r\n   STBTT__NOTUSED(vsubsample);\r\n\r\n   if (result->w > 64)\r\n      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);\r\n   else\r\n      scanline = scanline_data;\r\n\r\n   scanline2 = scanline + result->w;\r\n\r\n   y = off_y;\r\n   e[n].y0 = (float) (off_y + result->h) + 1;\r\n\r\n   while (j < result->h) {\r\n      // find center of pixel for this scanline\r\n      float scan_y_top    = y + 0.0f;\r\n      float scan_y_bottom = y + 1.0f;\r\n      stbtt__active_edge **step = &active;\r\n\r\n      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));\r\n      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));\r\n\r\n      // update all active edges;\r\n      // remove all active edges that terminate before the top of this scanline\r\n      while (*step) {\r\n         stbtt__active_edge * z = *step;\r\n         if (z->ey <= scan_y_top) {\r\n            *step = z->next; // delete from list\r\n            STBTT_assert(z->direction);\r\n            z->direction = 0;\r\n            stbtt__hheap_free(&hh, z);\r\n         } else {\r\n            step = &((*step)->next); // advance through list\r\n         }\r\n      }\r\n\r\n      // insert all edges that start before the bottom of this scanline\r\n      while (e->y0 <= scan_y_bottom) {\r\n         if (e->y0 != e->y1) {\r\n            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);\r\n            if (z != NULL) {\r\n               STBTT_assert(z->ey >= scan_y_top);\r\n               // insert at front\r\n               z->next = active;\r\n               active = z;\r\n            }\r\n         }\r\n         ++e;\r\n      }\r\n\r\n      // now process all active edges\r\n      if (active)\r\n         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);\r\n\r\n      {\r\n         float sum = 0;\r\n         for (i=0; i < result->w; ++i) {\r\n            float k;\r\n            int m;\r\n            sum += scanline2[i];\r\n            k = scanline[i] + sum;\r\n            k = (float) STBTT_fabs(k)*255 + 0.5f;\r\n            m = (int) k;\r\n            if (m > 255) m = 255;\r\n            result->pixels[j*result->stride + i] = (unsigned char) m;\r\n         }\r\n      }\r\n      // advance all the edges\r\n      step = &active;\r\n      while (*step) {\r\n         stbtt__active_edge *z = *step;\r\n         z->fx += z->fdx; // advance to position for current scanline\r\n         step = &((*step)->next); // advance through list\r\n      }\r\n\r\n      ++y;\r\n      ++j;\r\n   }\r\n\r\n   stbtt__hheap_cleanup(&hh, userdata);\r\n\r\n   if (scanline != scanline_data)\r\n      STBTT_free(scanline, userdata);\r\n}\r\n#else\r\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\r\n#endif\r\n\r\n#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)\r\n\r\nstatic void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)\r\n{\r\n   int i,j;\r\n   for (i=1; i < n; ++i) {\r\n      stbtt__edge t = p[i], *a = &t;\r\n      j = i;\r\n      while (j > 0) {\r\n         stbtt__edge *b = &p[j-1];\r\n         int c = STBTT__COMPARE(a,b);\r\n         if (!c) break;\r\n         p[j] = p[j-1];\r\n         --j;\r\n      }\r\n      if (i != j)\r\n         p[j] = t;\r\n   }\r\n}\r\n\r\nstatic void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)\r\n{\r\n   /* threshhold for transitioning to insertion sort */\r\n   while (n > 12) {\r\n      stbtt__edge t;\r\n      int c01,c12,c,m,i,j;\r\n\r\n      /* compute median of three */\r\n      m = n >> 1;\r\n      c01 = STBTT__COMPARE(&p[0],&p[m]);\r\n      c12 = STBTT__COMPARE(&p[m],&p[n-1]);\r\n      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */\r\n      if (c01 != c12) {\r\n         /* otherwise, we'll need to swap something else to middle */\r\n         int z;\r\n         c = STBTT__COMPARE(&p[0],&p[n-1]);\r\n         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */\r\n         /* 0<mid && mid>n:  0>n => 0; 0<n => n */\r\n         z = (c == c12) ? 0 : n-1;\r\n         t = p[z];\r\n         p[z] = p[m];\r\n         p[m] = t;\r\n      }\r\n      /* now p[m] is the median-of-three */\r\n      /* swap it to the beginning so it won't move around */\r\n      t = p[0];\r\n      p[0] = p[m];\r\n      p[m] = t;\r\n\r\n      /* partition loop */\r\n      i=1;\r\n      j=n-1;\r\n      for(;;) {\r\n         /* handling of equality is crucial here */\r\n         /* for sentinels & efficiency with duplicates */\r\n         for (;;++i) {\r\n            if (!STBTT__COMPARE(&p[i], &p[0])) break;\r\n         }\r\n         for (;;--j) {\r\n            if (!STBTT__COMPARE(&p[0], &p[j])) break;\r\n         }\r\n         /* make sure we haven't crossed */\r\n         if (i >= j) break;\r\n         t = p[i];\r\n         p[i] = p[j];\r\n         p[j] = t;\r\n\r\n         ++i;\r\n         --j;\r\n      }\r\n      /* recurse on smaller side, iterate on larger */\r\n      if (j < (n-i)) {\r\n         stbtt__sort_edges_quicksort(p,j);\r\n         p = p+i;\r\n         n = n-i;\r\n      } else {\r\n         stbtt__sort_edges_quicksort(p+i, n-i);\r\n         n = j;\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbtt__sort_edges(stbtt__edge *p, int n)\r\n{\r\n   stbtt__sort_edges_quicksort(p, n);\r\n   stbtt__sort_edges_ins_sort(p, n);\r\n}\r\n\r\ntypedef struct\r\n{\r\n   float x,y;\r\n} stbtt__point;\r\n\r\nstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)\r\n{\r\n   float y_scale_inv = invert ? -scale_y : scale_y;\r\n   stbtt__edge *e;\r\n   int n,i,j,k,m;\r\n#if STBTT_RASTERIZER_VERSION == 1\r\n   int vsubsample = result->h < 8 ? 15 : 5;\r\n#elif STBTT_RASTERIZER_VERSION == 2\r\n   int vsubsample = 1;\r\n#else\r\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\r\n#endif\r\n   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity\r\n\r\n   // now we have to blow out the windings into explicit edge lists\r\n   n = 0;\r\n   for (i=0; i < windings; ++i)\r\n      n += wcount[i];\r\n\r\n   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel\r\n   if (e == 0) return;\r\n   n = 0;\r\n\r\n   m=0;\r\n   for (i=0; i < windings; ++i) {\r\n      stbtt__point *p = pts + m;\r\n      m += wcount[i];\r\n      j = wcount[i]-1;\r\n      for (k=0; k < wcount[i]; j=k++) {\r\n         int a=k,b=j;\r\n         // skip the edge if horizontal\r\n         if (p[j].y == p[k].y)\r\n            continue;\r\n         // add edge from j to k to the list\r\n         e[n].invert = 0;\r\n         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {\r\n            e[n].invert = 1;\r\n            a=j,b=k;\r\n         }\r\n         e[n].x0 = p[a].x * scale_x + shift_x;\r\n         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;\r\n         e[n].x1 = p[b].x * scale_x + shift_x;\r\n         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;\r\n         ++n;\r\n      }\r\n   }\r\n\r\n   // now sort the edges by their highest point (should snap to integer, and then by x)\r\n   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);\r\n   stbtt__sort_edges(e, n);\r\n\r\n   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule\r\n   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);\r\n\r\n   STBTT_free(e, userdata);\r\n}\r\n\r\nstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)\r\n{\r\n   if (!points) return; // during first pass, it's unallocated\r\n   points[n].x = x;\r\n   points[n].y = y;\r\n}\r\n\r\n// tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching\r\nstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)\r\n{\r\n   // midpoint\r\n   float mx = (x0 + 2*x1 + x2)/4;\r\n   float my = (y0 + 2*y1 + y2)/4;\r\n   // versus directly drawn line\r\n   float dx = (x0+x2)/2 - mx;\r\n   float dy = (y0+y2)/2 - my;\r\n   if (n > 16) // 65536 segments on one curve better be enough!\r\n      return 1;\r\n   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA\r\n      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);\r\n      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);\r\n   } else {\r\n      stbtt__add_point(points, *num_points,x2,y2);\r\n      *num_points = *num_points+1;\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)\r\n{\r\n   // @TODO this \"flatness\" calculation is just made-up nonsense that seems to work well enough\r\n   float dx0 = x1-x0;\r\n   float dy0 = y1-y0;\r\n   float dx1 = x2-x1;\r\n   float dy1 = y2-y1;\r\n   float dx2 = x3-x2;\r\n   float dy2 = y3-y2;\r\n   float dx = x3-x0;\r\n   float dy = y3-y0;\r\n   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));\r\n   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);\r\n   float flatness_squared = longlen*longlen-shortlen*shortlen;\r\n\r\n   if (n > 16) // 65536 segments on one curve better be enough!\r\n      return;\r\n\r\n   if (flatness_squared > objspace_flatness_squared) {\r\n      float x01 = (x0+x1)/2;\r\n      float y01 = (y0+y1)/2;\r\n      float x12 = (x1+x2)/2;\r\n      float y12 = (y1+y2)/2;\r\n      float x23 = (x2+x3)/2;\r\n      float y23 = (y2+y3)/2;\r\n\r\n      float xa = (x01+x12)/2;\r\n      float ya = (y01+y12)/2;\r\n      float xb = (x12+x23)/2;\r\n      float yb = (y12+y23)/2;\r\n\r\n      float mx = (xa+xb)/2;\r\n      float my = (ya+yb)/2;\r\n\r\n      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);\r\n      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);\r\n   } else {\r\n      stbtt__add_point(points, *num_points,x3,y3);\r\n      *num_points = *num_points+1;\r\n   }\r\n}\r\n\r\n// returns number of contours\r\nstatic stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)\r\n{\r\n   stbtt__point *points=0;\r\n   int num_points=0;\r\n\r\n   float objspace_flatness_squared = objspace_flatness * objspace_flatness;\r\n   int i,n=0,start=0, pass;\r\n\r\n   // count how many \"moves\" there are to get the contour count\r\n   for (i=0; i < num_verts; ++i)\r\n      if (vertices[i].type == STBTT_vmove)\r\n         ++n;\r\n\r\n   *num_contours = n;\r\n   if (n == 0) return 0;\r\n\r\n   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);\r\n\r\n   if (*contour_lengths == 0) {\r\n      *num_contours = 0;\r\n      return 0;\r\n   }\r\n\r\n   // make two passes through the points so we don't need to realloc\r\n   for (pass=0; pass < 2; ++pass) {\r\n      float x=0,y=0;\r\n      if (pass == 1) {\r\n         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);\r\n         if (points == NULL) goto error;\r\n      }\r\n      num_points = 0;\r\n      n= -1;\r\n      for (i=0; i < num_verts; ++i) {\r\n         switch (vertices[i].type) {\r\n            case STBTT_vmove:\r\n               // start the next contour\r\n               if (n >= 0)\r\n                  (*contour_lengths)[n] = num_points - start;\r\n               ++n;\r\n               start = num_points;\r\n\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               stbtt__add_point(points, num_points++, x,y);\r\n               break;\r\n            case STBTT_vline:\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               stbtt__add_point(points, num_points++, x, y);\r\n               break;\r\n            case STBTT_vcurve:\r\n               stbtt__tesselate_curve(points, &num_points, x,y,\r\n                                        vertices[i].cx, vertices[i].cy,\r\n                                        vertices[i].x,  vertices[i].y,\r\n                                        objspace_flatness_squared, 0);\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               break;\r\n            case STBTT_vcubic:\r\n               stbtt__tesselate_cubic(points, &num_points, x,y,\r\n                                        vertices[i].cx, vertices[i].cy,\r\n                                        vertices[i].cx1, vertices[i].cy1,\r\n                                        vertices[i].x,  vertices[i].y,\r\n                                        objspace_flatness_squared, 0);\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               break;\r\n         }\r\n      }\r\n      (*contour_lengths)[n] = num_points - start;\r\n   }\r\n\r\n   return points;\r\nerror:\r\n   STBTT_free(points, userdata);\r\n   STBTT_free(*contour_lengths, userdata);\r\n   *contour_lengths = 0;\r\n   *num_contours = 0;\r\n   return NULL;\r\n}\r\n\r\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)\r\n{\r\n   float scale            = scale_x > scale_y ? scale_y : scale_x;\r\n   int winding_count      = 0;\r\n   int *winding_lengths   = NULL;\r\n   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);\r\n   if (windings) {\r\n      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);\r\n      STBTT_free(winding_lengths, userdata);\r\n      STBTT_free(windings, userdata);\r\n   }\r\n}\r\n\r\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\r\n{\r\n   STBTT_free(bitmap, userdata);\r\n}\r\n\r\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   int ix0,iy0,ix1,iy1;\r\n   stbtt__bitmap gbm;\r\n   stbtt_vertex *vertices;   \r\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\r\n\r\n   if (scale_x == 0) scale_x = scale_y;\r\n   if (scale_y == 0) {\r\n      if (scale_x == 0) {\r\n         STBTT_free(vertices, info->userdata);\r\n         return NULL;\r\n      }\r\n      scale_y = scale_x;\r\n   }\r\n\r\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);\r\n\r\n   // now we get the size\r\n   gbm.w = (ix1 - ix0);\r\n   gbm.h = (iy1 - iy0);\r\n   gbm.pixels = NULL; // in case we error\r\n\r\n   if (width ) *width  = gbm.w;\r\n   if (height) *height = gbm.h;\r\n   if (xoff  ) *xoff   = ix0;\r\n   if (yoff  ) *yoff   = iy0;\r\n   \r\n   if (gbm.w && gbm.h) {\r\n      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);\r\n      if (gbm.pixels) {\r\n         gbm.stride = gbm.w;\r\n\r\n         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);\r\n      }\r\n   }\r\n   STBTT_free(vertices, info->userdata);\r\n   return gbm.pixels;\r\n}   \r\n\r\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);\r\n}\r\n\r\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)\r\n{\r\n   int ix0,iy0;\r\n   stbtt_vertex *vertices;\r\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\r\n   stbtt__bitmap gbm;   \r\n\r\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);\r\n   gbm.pixels = output;\r\n   gbm.w = out_w;\r\n   gbm.h = out_h;\r\n   gbm.stride = out_stride;\r\n\r\n   if (gbm.w && gbm.h)\r\n      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);\r\n\r\n   STBTT_free(vertices, info->userdata);\r\n}\r\n\r\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\r\n{\r\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\r\n}\r\n\r\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);\r\n}   \r\n\r\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)\r\n{\r\n   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));\r\n}\r\n\r\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\r\n{\r\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\r\n}\r\n\r\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);\r\n}   \r\n\r\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)\r\n{\r\n   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// bitmap baking\r\n//\r\n// This is SUPER-CRAPPY packing to keep source code small\r\n\r\nstatic int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\r\n                                float pixel_height,                     // height of font in pixels\r\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\r\n                                int first_char, int num_chars,          // characters to bake\r\n                                stbtt_bakedchar *chardata)\r\n{\r\n   float scale;\r\n   int x,y,bottom_y, i;\r\n   stbtt_fontinfo f;\r\n   f.userdata = NULL;\r\n   if (!stbtt_InitFont(&f, data, offset))\r\n      return -1;\r\n   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\r\n   x=y=1;\r\n   bottom_y = 1;\r\n\r\n   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);\r\n\r\n   for (i=0; i < num_chars; ++i) {\r\n      int advance, lsb, x0,y0,x1,y1,gw,gh;\r\n      int g = stbtt_FindGlyphIndex(&f, first_char + i);\r\n      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);\r\n      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);\r\n      gw = x1-x0;\r\n      gh = y1-y0;\r\n      if (x + gw + 1 >= pw)\r\n         y = bottom_y, x = 1; // advance to next row\r\n      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row\r\n         return -i;\r\n      STBTT_assert(x+gw < pw);\r\n      STBTT_assert(y+gh < ph);\r\n      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);\r\n      chardata[i].x0 = (stbtt_int16) x;\r\n      chardata[i].y0 = (stbtt_int16) y;\r\n      chardata[i].x1 = (stbtt_int16) (x + gw);\r\n      chardata[i].y1 = (stbtt_int16) (y + gh);\r\n      chardata[i].xadvance = scale * advance;\r\n      chardata[i].xoff     = (float) x0;\r\n      chardata[i].yoff     = (float) y0;\r\n      x = x + gw + 1;\r\n      if (y+gh+1 > bottom_y)\r\n         bottom_y = y+gh+1;\r\n   }\r\n   return bottom_y;\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)\r\n{\r\n   float d3d_bias = opengl_fillrule ? 0 : -0.5f;\r\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\r\n   const stbtt_bakedchar *b = chardata + char_index;\r\n   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);\r\n   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);\r\n\r\n   q->x0 = round_x + d3d_bias;\r\n   q->y0 = round_y + d3d_bias;\r\n   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;\r\n   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;\r\n\r\n   q->s0 = b->x0 * ipw;\r\n   q->t0 = b->y0 * iph;\r\n   q->s1 = b->x1 * ipw;\r\n   q->t1 = b->y1 * iph;\r\n\r\n   *xpos += b->xadvance;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// rectangle packing replacement routines if you don't have stb_rect_pack.h\r\n//\r\n\r\n#ifndef STB_RECT_PACK_VERSION\r\n\r\ntypedef int stbrp_coord;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////\r\n//                                                                                //\r\n//                                                                                //\r\n// COMPILER WARNING ?!?!?                                                         //\r\n//                                                                                //\r\n//                                                                                //\r\n// if you get a compile warning due to these symbols being defined more than      //\r\n// once, move #include \"stb_rect_pack.h\" before #include \"stb_truetype.h\"         //\r\n//                                                                                //\r\n////////////////////////////////////////////////////////////////////////////////////\r\n\r\ntypedef struct\r\n{\r\n   int width,height;\r\n   int x,y,bottom_y;\r\n} stbrp_context;\r\n\r\ntypedef struct\r\n{\r\n   unsigned char x;\r\n} stbrp_node;\r\n\r\nstruct stbrp_rect\r\n{\r\n   stbrp_coord x,y;\r\n   int id,w,h,was_packed;\r\n};\r\n\r\nstatic void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\r\n{\r\n   con->width  = pw;\r\n   con->height = ph;\r\n   con->x = 0;\r\n   con->y = 0;\r\n   con->bottom_y = 0;\r\n   STBTT__NOTUSED(nodes);\r\n   STBTT__NOTUSED(num_nodes);   \r\n}\r\n\r\nstatic void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)\r\n{\r\n   int i;\r\n   for (i=0; i < num_rects; ++i) {\r\n      if (con->x + rects[i].w > con->width) {\r\n         con->x = 0;\r\n         con->y = con->bottom_y;\r\n      }\r\n      if (con->y + rects[i].h > con->height)\r\n         break;\r\n      rects[i].x = con->x;\r\n      rects[i].y = con->y;\r\n      rects[i].was_packed = 1;\r\n      con->x += rects[i].w;\r\n      if (con->y + rects[i].h > con->bottom_y)\r\n         con->bottom_y = con->y + rects[i].h;\r\n   }\r\n   for (   ; i < num_rects; ++i)\r\n      rects[i].was_packed = 0;\r\n}\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// bitmap baking\r\n//\r\n// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If\r\n// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.\r\n\r\nSTBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)\r\n{\r\n   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);\r\n   int            num_nodes = pw - padding;\r\n   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);\r\n\r\n   if (context == NULL || nodes == NULL) {\r\n      if (context != NULL) STBTT_free(context, alloc_context);\r\n      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);\r\n      return 0;\r\n   }\r\n\r\n   spc->user_allocator_context = alloc_context;\r\n   spc->width = pw;\r\n   spc->height = ph;\r\n   spc->pixels = pixels;\r\n   spc->pack_info = context;\r\n   spc->nodes = nodes;\r\n   spc->padding = padding;\r\n   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;\r\n   spc->h_oversample = 1;\r\n   spc->v_oversample = 1;\r\n\r\n   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);\r\n\r\n   if (pixels)\r\n      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\r\n\r\n   return 1;\r\n}\r\n\r\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)\r\n{\r\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\r\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\r\n}\r\n\r\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)\r\n{\r\n   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);\r\n   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);\r\n   if (h_oversample <= STBTT_MAX_OVERSAMPLE)\r\n      spc->h_oversample = h_oversample;\r\n   if (v_oversample <= STBTT_MAX_OVERSAMPLE)\r\n      spc->v_oversample = v_oversample;\r\n}\r\n\r\n#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)\r\n\r\nstatic void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\r\n{\r\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\r\n   int safe_w = w - kernel_width;\r\n   int j;\r\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\r\n   for (j=0; j < h; ++j) {\r\n      int i;\r\n      unsigned int total;\r\n      STBTT_memset(buffer, 0, kernel_width);\r\n\r\n      total = 0;\r\n\r\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\r\n      switch (kernel_width) {\r\n         case 2:\r\n            for (i=0; i <= safe_w; ++i) {\r\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\r\n               pixels[i] = (unsigned char) (total / 2);\r\n            }\r\n            break;\r\n         case 3:\r\n            for (i=0; i <= safe_w; ++i) {\r\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\r\n               pixels[i] = (unsigned char) (total / 3);\r\n            }\r\n            break;\r\n         case 4:\r\n            for (i=0; i <= safe_w; ++i) {\r\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\r\n               pixels[i] = (unsigned char) (total / 4);\r\n            }\r\n            break;\r\n         case 5:\r\n            for (i=0; i <= safe_w; ++i) {\r\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\r\n               pixels[i] = (unsigned char) (total / 5);\r\n            }\r\n            break;\r\n         default:\r\n            for (i=0; i <= safe_w; ++i) {\r\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\r\n               pixels[i] = (unsigned char) (total / kernel_width);\r\n            }\r\n            break;\r\n      }\r\n\r\n      for (; i < w; ++i) {\r\n         STBTT_assert(pixels[i] == 0);\r\n         total -= buffer[i & STBTT__OVER_MASK];\r\n         pixels[i] = (unsigned char) (total / kernel_width);\r\n      }\r\n\r\n      pixels += stride_in_bytes;\r\n   }\r\n}\r\n\r\nstatic void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\r\n{\r\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\r\n   int safe_h = h - kernel_width;\r\n   int j;\r\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\r\n   for (j=0; j < w; ++j) {\r\n      int i;\r\n      unsigned int total;\r\n      STBTT_memset(buffer, 0, kernel_width);\r\n\r\n      total = 0;\r\n\r\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\r\n      switch (kernel_width) {\r\n         case 2:\r\n            for (i=0; i <= safe_h; ++i) {\r\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\r\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);\r\n            }\r\n            break;\r\n         case 3:\r\n            for (i=0; i <= safe_h; ++i) {\r\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\r\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);\r\n            }\r\n            break;\r\n         case 4:\r\n            for (i=0; i <= safe_h; ++i) {\r\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\r\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);\r\n            }\r\n            break;\r\n         case 5:\r\n            for (i=0; i <= safe_h; ++i) {\r\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\r\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);\r\n            }\r\n            break;\r\n         default:\r\n            for (i=0; i <= safe_h; ++i) {\r\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\r\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\r\n               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\r\n            }\r\n            break;\r\n      }\r\n\r\n      for (; i < h; ++i) {\r\n         STBTT_assert(pixels[i*stride_in_bytes] == 0);\r\n         total -= buffer[i & STBTT__OVER_MASK];\r\n         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\r\n      }\r\n\r\n      pixels += 1;\r\n   }\r\n}\r\n\r\nstatic float stbtt__oversample_shift(int oversample)\r\n{\r\n   if (!oversample)\r\n      return 0.0f;\r\n\r\n   // The prefilter is a box filter of width \"oversample\",\r\n   // which shifts phase by (oversample - 1)/2 pixels in\r\n   // oversampled space. We want to shift in the opposite\r\n   // direction to counter this.\r\n   return (float)-(oversample - 1) / (2.0f * (float)oversample);\r\n}\r\n\r\n// rects array must be big enough to accommodate all characters in the given ranges\r\nSTBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\r\n{\r\n   int i,j,k;\r\n\r\n   k=0;\r\n   for (i=0; i < num_ranges; ++i) {\r\n      float fh = ranges[i].font_size;\r\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\r\n      ranges[i].h_oversample = (unsigned char) spc->h_oversample;\r\n      ranges[i].v_oversample = (unsigned char) spc->v_oversample;\r\n      for (j=0; j < ranges[i].num_chars; ++j) {\r\n         int x0,y0,x1,y1;\r\n         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\r\n         int glyph = stbtt_FindGlyphIndex(info, codepoint);\r\n         stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,\r\n                                         scale * spc->h_oversample,\r\n                                         scale * spc->v_oversample,\r\n                                         0,0,\r\n                                         &x0,&y0,&x1,&y1);\r\n         rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);\r\n         rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);\r\n         ++k;\r\n      }\r\n   }\r\n\r\n   return k;\r\n}\r\n\r\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)\r\n{\r\n   stbtt_MakeGlyphBitmapSubpixel(info,\r\n                                 output,\r\n                                 out_w - (prefilter_x - 1),\r\n                                 out_h - (prefilter_y - 1),\r\n                                 out_stride,\r\n                                 scale_x,\r\n                                 scale_y,\r\n                                 shift_x,\r\n                                 shift_y,\r\n                                 glyph);\r\n\r\n   if (prefilter_x > 1)\r\n      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);\r\n\r\n   if (prefilter_y > 1)\r\n      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);\r\n\r\n   *sub_x = stbtt__oversample_shift(prefilter_x);\r\n   *sub_y = stbtt__oversample_shift(prefilter_y);\r\n}\r\n\r\n// rects array must be big enough to accommodate all characters in the given ranges\r\nSTBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\r\n{\r\n   int i,j,k, return_value = 1;\r\n\r\n   // save current values\r\n   int old_h_over = spc->h_oversample;\r\n   int old_v_over = spc->v_oversample;\r\n\r\n   k = 0;\r\n   for (i=0; i < num_ranges; ++i) {\r\n      float fh = ranges[i].font_size;\r\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\r\n      float recip_h,recip_v,sub_x,sub_y;\r\n      spc->h_oversample = ranges[i].h_oversample;\r\n      spc->v_oversample = ranges[i].v_oversample;\r\n      recip_h = 1.0f / spc->h_oversample;\r\n      recip_v = 1.0f / spc->v_oversample;\r\n      sub_x = stbtt__oversample_shift(spc->h_oversample);\r\n      sub_y = stbtt__oversample_shift(spc->v_oversample);\r\n      for (j=0; j < ranges[i].num_chars; ++j) {\r\n         stbrp_rect *r = &rects[k];\r\n         if (r->was_packed) {\r\n            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];\r\n            int advance, lsb, x0,y0,x1,y1;\r\n            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\r\n            int glyph = stbtt_FindGlyphIndex(info, codepoint);\r\n            stbrp_coord pad = (stbrp_coord) spc->padding;\r\n\r\n            // pad on left and top\r\n            r->x += pad;\r\n            r->y += pad;\r\n            r->w -= pad;\r\n            r->h -= pad;\r\n            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);\r\n            stbtt_GetGlyphBitmapBox(info, glyph,\r\n                                    scale * spc->h_oversample,\r\n                                    scale * spc->v_oversample,\r\n                                    &x0,&y0,&x1,&y1);\r\n            stbtt_MakeGlyphBitmapSubpixel(info,\r\n                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,\r\n                                          r->w - spc->h_oversample+1,\r\n                                          r->h - spc->v_oversample+1,\r\n                                          spc->stride_in_bytes,\r\n                                          scale * spc->h_oversample,\r\n                                          scale * spc->v_oversample,\r\n                                          0,0,\r\n                                          glyph);\r\n\r\n            if (spc->h_oversample > 1)\r\n               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\r\n                                  r->w, r->h, spc->stride_in_bytes,\r\n                                  spc->h_oversample);\r\n\r\n            if (spc->v_oversample > 1)\r\n               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\r\n                                  r->w, r->h, spc->stride_in_bytes,\r\n                                  spc->v_oversample);\r\n\r\n            bc->x0       = (stbtt_int16)  r->x;\r\n            bc->y0       = (stbtt_int16)  r->y;\r\n            bc->x1       = (stbtt_int16) (r->x + r->w);\r\n            bc->y1       = (stbtt_int16) (r->y + r->h);\r\n            bc->xadvance =                scale * advance;\r\n            bc->xoff     =       (float)  x0 * recip_h + sub_x;\r\n            bc->yoff     =       (float)  y0 * recip_v + sub_y;\r\n            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;\r\n            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;\r\n         } else {\r\n            return_value = 0; // if any fail, report failure\r\n         }\r\n\r\n         ++k;\r\n      }\r\n   }\r\n\r\n   // restore original values\r\n   spc->h_oversample = old_h_over;\r\n   spc->v_oversample = old_v_over;\r\n\r\n   return return_value;\r\n}\r\n\r\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)\r\n{\r\n   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);\r\n}\r\n\r\nSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)\r\n{\r\n   stbtt_fontinfo info;\r\n   int i,j,n, return_value = 1;\r\n   //stbrp_context *context = (stbrp_context *) spc->pack_info;\r\n   stbrp_rect    *rects;\r\n\r\n   // flag all characters as NOT packed\r\n   for (i=0; i < num_ranges; ++i)\r\n      for (j=0; j < ranges[i].num_chars; ++j)\r\n         ranges[i].chardata_for_range[j].x0 =\r\n         ranges[i].chardata_for_range[j].y0 =\r\n         ranges[i].chardata_for_range[j].x1 =\r\n         ranges[i].chardata_for_range[j].y1 = 0;\r\n\r\n   n = 0;\r\n   for (i=0; i < num_ranges; ++i)\r\n      n += ranges[i].num_chars;\r\n         \r\n   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);\r\n   if (rects == NULL)\r\n      return 0;\r\n\r\n   info.userdata = spc->user_allocator_context;\r\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));\r\n\r\n   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);\r\n\r\n   stbtt_PackFontRangesPackRects(spc, rects, n);\r\n  \r\n   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);\r\n\r\n   STBTT_free(rects, spc->user_allocator_context);\r\n   return return_value;\r\n}\r\n\r\nSTBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\r\n            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)\r\n{\r\n   stbtt_pack_range range;\r\n   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;\r\n   range.array_of_unicode_codepoints = NULL;\r\n   range.num_chars                   = num_chars_in_range;\r\n   range.chardata_for_range          = chardata_for_range;\r\n   range.font_size                   = font_size;\r\n   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);\r\n}\r\n\r\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)\r\n{\r\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\r\n   const stbtt_packedchar *b = chardata + char_index;\r\n\r\n   if (align_to_integer) {\r\n      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);\r\n      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);\r\n      q->x0 = x;\r\n      q->y0 = y;\r\n      q->x1 = x + b->xoff2 - b->xoff;\r\n      q->y1 = y + b->yoff2 - b->yoff;\r\n   } else {\r\n      q->x0 = *xpos + b->xoff;\r\n      q->y0 = *ypos + b->yoff;\r\n      q->x1 = *xpos + b->xoff2;\r\n      q->y1 = *ypos + b->yoff2;\r\n   }\r\n\r\n   q->s0 = b->x0 * ipw;\r\n   q->t0 = b->y0 * iph;\r\n   q->s1 = b->x1 * ipw;\r\n   q->t1 = b->y1 * iph;\r\n\r\n   *xpos += b->xadvance;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// sdf computation\r\n//\r\n\r\n#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))\r\n#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))\r\n\r\nstatic int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])\r\n{\r\n   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];\r\n   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];\r\n   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];\r\n   float roperp = orig[1]*ray[0] - orig[0]*ray[1];\r\n\r\n   float a = q0perp - 2*q1perp + q2perp;\r\n   float b = q1perp - q0perp;\r\n   float c = q0perp - roperp;\r\n\r\n   float s0 = 0., s1 = 0.;\r\n   int num_s = 0;\r\n\r\n   if (a != 0.0) {\r\n      float discr = b*b - a*c;\r\n      if (discr > 0.0) {\r\n         float rcpna = -1 / a;\r\n         float d = (float) STBTT_sqrt(discr);\r\n         s0 = (b+d) * rcpna;\r\n         s1 = (b-d) * rcpna;\r\n         if (s0 >= 0.0 && s0 <= 1.0)\r\n            num_s = 1;\r\n         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {\r\n            if (num_s == 0) s0 = s1;\r\n            ++num_s;\r\n         }\r\n      }\r\n   } else {\r\n      // 2*b*s + c = 0\r\n      // s = -c / (2*b)\r\n      s0 = c / (-2 * b);\r\n      if (s0 >= 0.0 && s0 <= 1.0)\r\n         num_s = 1;\r\n   }\r\n\r\n   if (num_s == 0)\r\n      return 0;\r\n   else {\r\n      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);\r\n      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;\r\n\r\n      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;\r\n      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;\r\n      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;\r\n      float rod = orig[0]*rayn_x + orig[1]*rayn_y;\r\n\r\n      float q10d = q1d - q0d;\r\n      float q20d = q2d - q0d;\r\n      float q0rd = q0d - rod;\r\n\r\n      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;\r\n      hits[0][1] = a*s0+b;\r\n\r\n      if (num_s > 1) {\r\n         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;\r\n         hits[1][1] = a*s1+b;\r\n         return 2;\r\n      } else {\r\n         return 1;\r\n      }\r\n   }\r\n}\r\n\r\nstatic int equal(float *a, float *b)\r\n{\r\n   return (a[0] == b[0] && a[1] == b[1]);\r\n}\r\n\r\nstatic int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)\r\n{\r\n   int i;\r\n   float orig[2], ray[2] = { 1, 0 };\r\n   float y_frac;\r\n   int winding = 0;\r\n\r\n   orig[0] = x;\r\n   orig[1] = y;\r\n\r\n   // make sure y never passes through a vertex of the shape\r\n   y_frac = (float) STBTT_fmod(y, 1.0f);\r\n   if (y_frac < 0.01f)\r\n      y += 0.01f;\r\n   else if (y_frac > 0.99f)\r\n      y -= 0.01f;\r\n   orig[1] = y;\r\n\r\n   // test a ray from (-infinity,y) to (x,y)\r\n   for (i=0; i < nverts; ++i) {\r\n      if (verts[i].type == STBTT_vline) {\r\n         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;\r\n         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;\r\n         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\r\n            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\r\n            if (x_inter < x)  \r\n               winding += (y0 < y1) ? 1 : -1;\r\n         }\r\n      }\r\n      if (verts[i].type == STBTT_vcurve) {\r\n         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;\r\n         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;\r\n         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;\r\n         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));\r\n         int by = STBTT_max(y0,STBTT_max(y1,y2));\r\n         if (y > ay && y < by && x > ax) {\r\n            float q0[2],q1[2],q2[2];\r\n            float hits[2][2];\r\n            q0[0] = (float)x0;\r\n            q0[1] = (float)y0;\r\n            q1[0] = (float)x1;\r\n            q1[1] = (float)y1;\r\n            q2[0] = (float)x2;\r\n            q2[1] = (float)y2;\r\n            if (equal(q0,q1) || equal(q1,q2)) {\r\n               x0 = (int)verts[i-1].x;\r\n               y0 = (int)verts[i-1].y;\r\n               x1 = (int)verts[i  ].x;\r\n               y1 = (int)verts[i  ].y;\r\n               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\r\n                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\r\n                  if (x_inter < x)  \r\n                     winding += (y0 < y1) ? 1 : -1;\r\n               }\r\n            } else {\r\n               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);\r\n               if (num_hits >= 1)\r\n                  if (hits[0][0] < 0)\r\n                     winding += (hits[0][1] < 0 ? -1 : 1);\r\n               if (num_hits >= 2)\r\n                  if (hits[1][0] < 0)\r\n                     winding += (hits[1][1] < 0 ? -1 : 1);\r\n            }\r\n         } \r\n      }\r\n   }\r\n   return winding;\r\n}\r\n\r\nstatic float stbtt__cuberoot( float x )\r\n{\r\n   if (x<0)\r\n      return -(float) STBTT_pow(-x,1.0f/3.0f);\r\n   else\r\n      return  (float) STBTT_pow( x,1.0f/3.0f);\r\n}\r\n\r\n// x^3 + c*x^2 + b*x + a = 0\r\nstatic int stbtt__solve_cubic(float a, float b, float c, float* r)\r\n{\r\n\tfloat s = -a / 3;\r\n\tfloat p = b - a*a / 3;\r\n\tfloat q = a * (2*a*a - 9*b) / 27 + c;\r\n   float p3 = p*p*p;\r\n\tfloat d = q*q + 4*p3 / 27;\r\n\tif (d >= 0) {\r\n\t\tfloat z = (float) STBTT_sqrt(d);\r\n\t\tfloat u = (-q + z) / 2;\r\n\t\tfloat v = (-q - z) / 2;\r\n\t\tu = stbtt__cuberoot(u);\r\n\t\tv = stbtt__cuberoot(v);\r\n\t\tr[0] = s + u + v;\r\n\t\treturn 1;\r\n\t} else {\r\n\t   float u = (float) STBTT_sqrt(-p/3);\r\n\t   float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative\r\n\t   float m = (float) STBTT_cos(v);\r\n      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;\r\n\t   r[0] = s + u * 2 * m;\r\n\t   r[1] = s - u * (m + n);\r\n\t   r[2] = s - u * (m - n);\r\n\r\n      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?\r\n      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);\r\n      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);\r\n   \treturn 3;\r\n   }\r\n}\r\n\r\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   float scale_x = scale, scale_y = scale;\r\n   int ix0,iy0,ix1,iy1;\r\n   int w,h;\r\n   unsigned char *data;\r\n\r\n   // if one scale is 0, use same scale for both\r\n   if (scale_x == 0) scale_x = scale_y;\r\n   if (scale_y == 0) {\r\n      if (scale_x == 0) return NULL;  // if both scales are 0, return NULL\r\n      scale_y = scale_x;\r\n   }\r\n\r\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);\r\n\r\n   // if empty, return NULL\r\n   if (ix0 == ix1 || iy0 == iy1)\r\n      return NULL;\r\n\r\n   ix0 -= padding;\r\n   iy0 -= padding;\r\n   ix1 += padding;\r\n   iy1 += padding;\r\n\r\n   w = (ix1 - ix0);\r\n   h = (iy1 - iy0);\r\n\r\n   if (width ) *width  = w;\r\n   if (height) *height = h;\r\n   if (xoff  ) *xoff   = ix0;\r\n   if (yoff  ) *yoff   = iy0;\r\n\r\n   // invert for y-downwards bitmaps\r\n   scale_y = -scale_y;\r\n      \r\n   {\r\n      int x,y,i,j;\r\n      float *precompute;\r\n      stbtt_vertex *verts;\r\n      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);\r\n      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);\r\n      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);\r\n\r\n      for (i=0,j=num_verts-1; i < num_verts; j=i++) {\r\n         if (verts[i].type == STBTT_vline) {\r\n            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\r\n            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;\r\n            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));\r\n            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;\r\n         } else if (verts[i].type == STBTT_vcurve) {\r\n            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;\r\n            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;\r\n            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;\r\n            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\r\n            float len2 = bx*bx + by*by;\r\n            if (len2 != 0.0f)\r\n               precompute[i] = 1.0f / (bx*bx + by*by);\r\n            else\r\n               precompute[i] = 0.0f;\r\n         } else\r\n            precompute[i] = 0.0f;\r\n      }\r\n\r\n      for (y=iy0; y < iy1; ++y) {\r\n         for (x=ix0; x < ix1; ++x) {\r\n            float val;\r\n            float min_dist = 999999.0f;\r\n            float sx = (float) x + 0.5f;\r\n            float sy = (float) y + 0.5f;\r\n            float x_gspace = (sx / scale_x);\r\n            float y_gspace = (sy / scale_y);\r\n\r\n            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path\r\n\r\n            for (i=0; i < num_verts; ++i) {\r\n               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\r\n\r\n               // check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve\r\n               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\r\n               if (dist2 < min_dist*min_dist)\r\n                  min_dist = (float) STBTT_sqrt(dist2);\r\n\r\n               if (verts[i].type == STBTT_vline) {\r\n                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;\r\n\r\n                  // coarse culling against bbox\r\n                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&\r\n                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)\r\n                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];\r\n                  STBTT_assert(i != 0);\r\n                  if (dist < min_dist) {\r\n                     // check position along line\r\n                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)\r\n                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)\r\n                     float dx = x1-x0, dy = y1-y0;\r\n                     float px = x0-sx, py = y0-sy;\r\n                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy\r\n                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve\r\n                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);\r\n                     if (t >= 0.0f && t <= 1.0f)\r\n                        min_dist = dist;\r\n                  }\r\n               } else if (verts[i].type == STBTT_vcurve) {\r\n                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;\r\n                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;\r\n                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);\r\n                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);\r\n                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);\r\n                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);\r\n                  // coarse culling against bbox to avoid computing cubic unnecessarily\r\n                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {\r\n                     int num=0;\r\n                     float ax = x1-x0, ay = y1-y0;\r\n                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\r\n                     float mx = x0 - sx, my = y0 - sy;\r\n                     float res[3],px,py,t,it;\r\n                     float a_inv = precompute[i];\r\n                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula\r\n                        float a = 3*(ax*bx + ay*by);\r\n                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);\r\n                        float c = mx*ax+my*ay;\r\n                        if (a == 0.0) { // if a is 0, it's linear\r\n                           if (b != 0.0) {\r\n                              res[num++] = -c/b;\r\n                           }\r\n                        } else {\r\n                           float discriminant = b*b - 4*a*c;\r\n                           if (discriminant < 0)\r\n                              num = 0;\r\n                           else {\r\n                              float root = (float) STBTT_sqrt(discriminant);\r\n                              res[0] = (-b - root)/(2*a);\r\n                              res[1] = (-b + root)/(2*a);\r\n                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work\r\n                           }\r\n                        }\r\n                     } else {\r\n                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point\r\n                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;\r\n                        float d = (mx*ax+my*ay) * a_inv;\r\n                        num = stbtt__solve_cubic(b, c, d, res);\r\n                     }\r\n                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {\r\n                        t = res[0], it = 1.0f - t;\r\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\r\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\r\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\r\n                        if (dist2 < min_dist * min_dist)\r\n                           min_dist = (float) STBTT_sqrt(dist2);\r\n                     }\r\n                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {\r\n                        t = res[1], it = 1.0f - t;\r\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\r\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\r\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\r\n                        if (dist2 < min_dist * min_dist)\r\n                           min_dist = (float) STBTT_sqrt(dist2);\r\n                     }\r\n                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {\r\n                        t = res[2], it = 1.0f - t;\r\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\r\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\r\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\r\n                        if (dist2 < min_dist * min_dist)\r\n                           min_dist = (float) STBTT_sqrt(dist2);\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n            if (winding == 0)\r\n               min_dist = -min_dist;  // if outside the shape, value is negative\r\n            val = onedge_value + pixel_dist_scale * min_dist;\r\n            if (val < 0)\r\n               val = 0;\r\n            else if (val > 255)\r\n               val = 255;\r\n            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;\r\n         }\r\n      }\r\n      STBTT_free(precompute, info->userdata);\r\n      STBTT_free(verts, info->userdata);\r\n   }\r\n   return data;\r\n}   \r\n\r\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);\r\n}\r\n\r\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\r\n{\r\n   STBTT_free(bitmap, userdata);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// font name matching -- recommended not to use this\r\n//\r\n\r\n// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string\r\nstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) \r\n{\r\n   stbtt_int32 i=0;\r\n\r\n   // convert utf16 to utf8 and compare the results while converting\r\n   while (len2) {\r\n      stbtt_uint16 ch = s2[0]*256 + s2[1];\r\n      if (ch < 0x80) {\r\n         if (i >= len1) return -1;\r\n         if (s1[i++] != ch) return -1;\r\n      } else if (ch < 0x800) {\r\n         if (i+1 >= len1) return -1;\r\n         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;\r\n         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;\r\n      } else if (ch >= 0xd800 && ch < 0xdc00) {\r\n         stbtt_uint32 c;\r\n         stbtt_uint16 ch2 = s2[2]*256 + s2[3];\r\n         if (i+3 >= len1) return -1;\r\n         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;\r\n         if (s1[i++] != 0xf0 + (c >> 18)) return -1;\r\n         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;\r\n         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;\r\n         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;\r\n         s2 += 2; // plus another 2 below\r\n         len2 -= 2;\r\n      } else if (ch >= 0xdc00 && ch < 0xe000) {\r\n         return -1;\r\n      } else {\r\n         if (i+2 >= len1) return -1;\r\n         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;\r\n         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;\r\n         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;\r\n      }\r\n      s2 += 2;\r\n      len2 -= 2;\r\n   }\r\n   return i;\r\n}\r\n\r\nstatic int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) \r\n{\r\n   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);\r\n}\r\n\r\n// returns results in whatever encoding you request... but note that 2-byte encodings\r\n// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare\r\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)\r\n{\r\n   stbtt_int32 i,count,stringOffset;\r\n   stbtt_uint8 *fc = font->data;\r\n   stbtt_uint32 offset = font->fontstart;\r\n   stbtt_uint32 nm = stbtt__find_table(fc, offset, \"name\");\r\n   if (!nm) return NULL;\r\n\r\n   count = ttUSHORT(fc+nm+2);\r\n   stringOffset = nm + ttUSHORT(fc+nm+4);\r\n   for (i=0; i < count; ++i) {\r\n      stbtt_uint32 loc = nm + 6 + 12 * i;\r\n      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)\r\n          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {\r\n         *length = ttUSHORT(fc+loc+8);\r\n         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));\r\n      }\r\n   }\r\n   return NULL;\r\n}\r\n\r\nstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)\r\n{\r\n   stbtt_int32 i;\r\n   stbtt_int32 count = ttUSHORT(fc+nm+2);\r\n   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);\r\n\r\n   for (i=0; i < count; ++i) {\r\n      stbtt_uint32 loc = nm + 6 + 12 * i;\r\n      stbtt_int32 id = ttUSHORT(fc+loc+6);\r\n      if (id == target_id) {\r\n         // find the encoding\r\n         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);\r\n\r\n         // is this a Unicode encoding?\r\n         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {\r\n            stbtt_int32 slen = ttUSHORT(fc+loc+8);\r\n            stbtt_int32 off = ttUSHORT(fc+loc+10);\r\n\r\n            // check if there's a prefix match\r\n            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);\r\n            if (matchlen >= 0) {\r\n               // check for target_id+1 immediately following, with same encoding & language\r\n               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {\r\n                  slen = ttUSHORT(fc+loc+12+8);\r\n                  off = ttUSHORT(fc+loc+12+10);\r\n                  if (slen == 0) {\r\n                     if (matchlen == nlen)\r\n                        return 1;\r\n                  } else if (matchlen < nlen && name[matchlen] == ' ') {\r\n                     ++matchlen;\r\n                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))\r\n                        return 1;\r\n                  }\r\n               } else {\r\n                  // if nothing immediately following\r\n                  if (matchlen == nlen)\r\n                     return 1;\r\n               }\r\n            }\r\n         }\r\n\r\n         // @TODO handle other encodings\r\n      }\r\n   }\r\n   return 0;\r\n}\r\n\r\nstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)\r\n{\r\n   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);\r\n   stbtt_uint32 nm,hd;\r\n   if (!stbtt__isfont(fc+offset)) return 0;\r\n\r\n   // check italics/bold/underline flags in macStyle...\r\n   if (flags) {\r\n      hd = stbtt__find_table(fc, offset, \"head\");\r\n      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;\r\n   }\r\n\r\n   nm = stbtt__find_table(fc, offset, \"name\");\r\n   if (!nm) return 0;\r\n\r\n   if (flags) {\r\n      // if we checked the macStyle flags, then just check the family and ignore the subfamily\r\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\r\n   } else {\r\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\r\n   }\r\n\r\n   return 0;\r\n}\r\n\r\nstatic int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)\r\n{\r\n   stbtt_int32 i;\r\n   for (i=0;;++i) {\r\n      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);\r\n      if (off < 0) return off;\r\n      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))\r\n         return off;\r\n   }\r\n}\r\n\r\n#if defined(__GNUC__) || defined(__clang__)\r\n#pragma GCC diagnostic push\r\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\r\n#endif\r\n\r\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,\r\n                                float pixel_height, unsigned char *pixels, int pw, int ph,\r\n                                int first_char, int num_chars, stbtt_bakedchar *chardata)\r\n{\r\n   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);\r\n}\r\n\r\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\r\n{\r\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   \r\n}\r\n\r\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)\r\n{\r\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\r\n}\r\n\r\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\r\n{\r\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\r\n}\r\n\r\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)\r\n{\r\n   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);\r\n}\r\n\r\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)\r\n{\r\n   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);\r\n}\r\n\r\n#if defined(__GNUC__) || defined(__clang__)\r\n#pragma GCC diagnostic pop\r\n#endif\r\n\r\n#endif // STB_TRUETYPE_IMPLEMENTATION\r\n\r\n\r\n// FULL VERSION HISTORY\r\n//\r\n//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod\r\n//   1.18 (2018-01-29) add missing function\r\n//   1.17 (2017-07-23) make more arguments const; doc fix\r\n//   1.16 (2017-07-12) SDF support\r\n//   1.15 (2017-03-03) make more arguments const\r\n//   1.14 (2017-01-16) num-fonts-in-TTC function\r\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\r\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\r\n//   1.11 (2016-04-02) fix unused-variable warning\r\n//   1.10 (2016-04-02) allow user-defined fabs() replacement\r\n//                     fix memory leak if fontsize=0.0\r\n//                     fix warning from duplicate typedef\r\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges\r\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\r\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\r\n//                     allow PackFontRanges to pack and render in separate phases;\r\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\r\n//                     fixed an assert() bug in the new rasterizer\r\n//                     replace assert() with STBTT_assert() in new rasterizer\r\n//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)\r\n//                     also more precise AA rasterizer, except if shapes overlap\r\n//                     remove need for STBTT_sort\r\n//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC\r\n//   1.04 (2015-04-15) typo in example\r\n//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes\r\n//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++\r\n//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match\r\n//                        non-oversampled; STBTT_POINT_SIZE for packed case only\r\n//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling\r\n//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)\r\n//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID\r\n//   0.8b (2014-07-07) fix a warning\r\n//   0.8  (2014-05-25) fix a few more warnings\r\n//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back\r\n//   0.6c (2012-07-24) improve documentation\r\n//   0.6b (2012-07-20) fix a few more warnings\r\n//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,\r\n//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty\r\n//   0.5  (2011-12-09) bugfixes:\r\n//                        subpixel glyph renderer computed wrong bounding box\r\n//                        first vertex of shape can be off-curve (FreeSans)\r\n//   0.4b (2011-12-03) fixed an error in the font baking example\r\n//   0.4  (2011-12-01) kerning, subpixel rendering (tor)\r\n//                    bugfixes for:\r\n//                        codepoint-to-glyph conversion using table fmt=12\r\n//                        codepoint-to-glyph conversion using table fmt=4\r\n//                        stbtt_GetBakedQuad with non-square texture (Zer)\r\n//                    updated Hello World! sample to use kerning and subpixel\r\n//                    fixed some warnings\r\n//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)\r\n//                    userdata, malloc-from-userdata, non-zero fill (stb)\r\n//   0.2  (2009-03-11) Fix unsigned/signed char warnings\r\n//   0.1  (2009-03-09) First public release\r\n//\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \r\nsoftware, either in source code form or as a compiled binary, for any purpose, \r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this \r\nsoftware dedicate any and all copyright interest in the software to the public \r\ndomain. We make this dedication for the benefit of the public at large and to \r\nthe detriment of our heirs and successors. We intend this dedication to be an \r\novert act of relinquishment in perpetuity of all present and future rights to \r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/\r\n","// stb_rect_pack.h - v0.11 - public domain - rectangle packing\r\n// Sean Barrett 2014\r\n//\r\n// Useful for e.g. packing rectangular textures into an atlas.\r\n// Does not do rotation.\r\n//\r\n// Not necessarily the awesomest packing method, but better than\r\n// the totally naive one in stb_truetype (which is primarily what\r\n// this is meant to replace).\r\n//\r\n// Has only had a few tests run, may have issues.\r\n//\r\n// More docs to come.\r\n//\r\n// No memory allocations; uses qsort() and assert() from stdlib.\r\n// Can override those by defining STBRP_SORT and STBRP_ASSERT.\r\n//\r\n// This library currently uses the Skyline Bottom-Left algorithm.\r\n//\r\n// Please note: better rectangle packers are welcome! Please\r\n// implement them to the same API, but with a different init\r\n// function.\r\n//\r\n// Credits\r\n//\r\n//  Library\r\n//    Sean Barrett\r\n//  Minor features\r\n//    Martins Mozeiko\r\n//    github:IntellectualKitty\r\n//    \r\n//  Bugfixes / warning fixes\r\n//    Jeremy Jaussaud\r\n//\r\n// Version history:\r\n//\r\n//     0.11  (2017-03-03)  return packing success/fail result\r\n//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings\r\n//     0.09  (2016-08-27)  fix compiler warnings\r\n//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)\r\n//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)\r\n//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort\r\n//     0.05:  added STBRP_ASSERT to allow replacing assert\r\n//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support\r\n//     0.01:  initial release\r\n//\r\n// LICENSE\r\n//\r\n//   See end of file for license information.\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//       INCLUDE SECTION\r\n//\r\n\r\n#ifndef STB_INCLUDE_STB_RECT_PACK_H\r\n#define STB_INCLUDE_STB_RECT_PACK_H\r\n\r\n#define STB_RECT_PACK_VERSION  1\r\n\r\n#ifdef STBRP_STATIC\r\n#define STBRP_DEF static\r\n#else\r\n#define STBRP_DEF extern\r\n#endif\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\ntypedef struct stbrp_context stbrp_context;\r\ntypedef struct stbrp_node    stbrp_node;\r\ntypedef struct stbrp_rect    stbrp_rect;\r\n\r\n#ifdef STBRP_LARGE_RECTS\r\ntypedef int            stbrp_coord;\r\n#else\r\ntypedef unsigned short stbrp_coord;\r\n#endif\r\n\r\nSTBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);\r\n// Assign packed locations to rectangles. The rectangles are of type\r\n// 'stbrp_rect' defined below, stored in the array 'rects', and there\r\n// are 'num_rects' many of them.\r\n//\r\n// Rectangles which are successfully packed have the 'was_packed' flag\r\n// set to a non-zero value and 'x' and 'y' store the minimum location\r\n// on each axis (i.e. bottom-left in cartesian coordinates, top-left\r\n// if you imagine y increasing downwards). Rectangles which do not fit\r\n// have the 'was_packed' flag set to 0.\r\n//\r\n// You should not try to access the 'rects' array from another thread\r\n// while this function is running, as the function temporarily reorders\r\n// the array while it executes.\r\n//\r\n// To pack into another rectangle, you need to call stbrp_init_target\r\n// again. To continue packing into the same rectangle, you can call\r\n// this function again. Calling this multiple times with multiple rect\r\n// arrays will probably produce worse packing results than calling it\r\n// a single time with the full rectangle array, but the option is\r\n// available.\r\n//\r\n// The function returns 1 if all of the rectangles were successfully\r\n// packed and 0 otherwise.\r\n\r\nstruct stbrp_rect\r\n{\r\n   // reserved for your use:\r\n   int            id;\r\n\r\n   // input:\r\n   stbrp_coord    w, h;\r\n\r\n   // output:\r\n   stbrp_coord    x, y;\r\n   int            was_packed;  // non-zero if valid packing\r\n\r\n}; // 16 bytes, nominally\r\n\r\n\r\nSTBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);\r\n// Initialize a rectangle packer to:\r\n//    pack a rectangle that is 'width' by 'height' in dimensions\r\n//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long\r\n//\r\n// You must call this function every time you start packing into a new target.\r\n//\r\n// There is no \"shutdown\" function. The 'nodes' memory must stay valid for\r\n// the following stbrp_pack_rects() call (or calls), but can be freed after\r\n// the call (or calls) finish.\r\n//\r\n// Note: to guarantee best results, either:\r\n//       1. make sure 'num_nodes' >= 'width'\r\n//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'\r\n//\r\n// If you don't do either of the above things, widths will be quantized to multiples\r\n// of small integers to guarantee the algorithm doesn't run out of temporary storage.\r\n//\r\n// If you do #2, then the non-quantized algorithm will be used, but the algorithm\r\n// may run out of temporary storage and be unable to pack some rectangles.\r\n\r\nSTBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);\r\n// Optionally call this function after init but before doing any packing to\r\n// change the handling of the out-of-temp-memory scenario, described above.\r\n// If you call init again, this will be reset to the default (false).\r\n\r\n\r\nSTBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);\r\n// Optionally select which packing heuristic the library should use. Different\r\n// heuristics will produce better/worse results for different data sets.\r\n// If you call init again, this will be reset to the default.\r\n\r\nenum\r\n{\r\n   STBRP_HEURISTIC_Skyline_default=0,\r\n   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,\r\n   STBRP_HEURISTIC_Skyline_BF_sortHeight\r\n};\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// the details of the following structures don't matter to you, but they must\r\n// be visible so you can handle the memory allocations for them\r\n\r\nstruct stbrp_node\r\n{\r\n   stbrp_coord  x,y;\r\n   stbrp_node  *next;\r\n};\r\n\r\nstruct stbrp_context\r\n{\r\n   int width;\r\n   int height;\r\n   int align;\r\n   int init_mode;\r\n   int heuristic;\r\n   int num_nodes;\r\n   stbrp_node *active_head;\r\n   stbrp_node *free_head;\r\n   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'\r\n};\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//     IMPLEMENTATION SECTION\r\n//\r\n\r\n#ifdef STB_RECT_PACK_IMPLEMENTATION\r\n#ifndef STBRP_SORT\r\n#include <stdlib.h>\r\n#define STBRP_SORT qsort\r\n#endif\r\n\r\n#ifndef STBRP_ASSERT\r\n#include <assert.h>\r\n#define STBRP_ASSERT assert\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#define STBRP__NOTUSED(v)  (void)(v)\r\n#define STBRP__CDECL __cdecl\r\n#else\r\n#define STBRP__NOTUSED(v)  (void)sizeof(v)\r\n#define STBRP__CDECL\r\n#endif\r\n\r\nenum\r\n{\r\n   STBRP__INIT_skyline = 1\r\n};\r\n\r\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)\r\n{\r\n   switch (context->init_mode) {\r\n      case STBRP__INIT_skyline:\r\n         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);\r\n         context->heuristic = heuristic;\r\n         break;\r\n      default:\r\n         STBRP_ASSERT(0);\r\n   }\r\n}\r\n\r\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)\r\n{\r\n   if (allow_out_of_mem)\r\n      // if it's ok to run out of memory, then don't bother aligning them;\r\n      // this gives better packing, but may fail due to OOM (even though\r\n      // the rectangles easily fit). @TODO a smarter approach would be to only\r\n      // quantize once we've hit OOM, then we could get rid of this parameter.\r\n      context->align = 1;\r\n   else {\r\n      // if it's not ok to run out of memory, then quantize the widths\r\n      // so that num_nodes is always enough nodes.\r\n      //\r\n      // I.e. num_nodes * align >= width\r\n      //                  align >= width / num_nodes\r\n      //                  align = ceil(width/num_nodes)\r\n\r\n      context->align = (context->width + context->num_nodes-1) / context->num_nodes;\r\n   }\r\n}\r\n\r\nSTBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)\r\n{\r\n   int i;\r\n#ifndef STBRP_LARGE_RECTS\r\n   STBRP_ASSERT(width <= 0xffff && height <= 0xffff);\r\n#endif\r\n\r\n   for (i=0; i < num_nodes-1; ++i)\r\n      nodes[i].next = &nodes[i+1];\r\n   nodes[i].next = NULL;\r\n   context->init_mode = STBRP__INIT_skyline;\r\n   context->heuristic = STBRP_HEURISTIC_Skyline_default;\r\n   context->free_head = &nodes[0];\r\n   context->active_head = &context->extra[0];\r\n   context->width = width;\r\n   context->height = height;\r\n   context->num_nodes = num_nodes;\r\n   stbrp_setup_allow_out_of_mem(context, 0);\r\n\r\n   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)\r\n   context->extra[0].x = 0;\r\n   context->extra[0].y = 0;\r\n   context->extra[0].next = &context->extra[1];\r\n   context->extra[1].x = (stbrp_coord) width;\r\n#ifdef STBRP_LARGE_RECTS\r\n   context->extra[1].y = (1<<30);\r\n#else\r\n   context->extra[1].y = 65535;\r\n#endif\r\n   context->extra[1].next = NULL;\r\n}\r\n\r\n// find minimum y position if it starts at x1\r\nstatic int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)\r\n{\r\n   stbrp_node *node = first;\r\n   int x1 = x0 + width;\r\n   int min_y, visited_width, waste_area;\r\n\r\n   STBRP__NOTUSED(c);\r\n\r\n   STBRP_ASSERT(first->x <= x0);\r\n\r\n   #if 0\r\n   // skip in case we're past the node\r\n   while (node->next->x <= x0)\r\n      ++node;\r\n   #else\r\n   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency\r\n   #endif\r\n\r\n   STBRP_ASSERT(node->x <= x0);\r\n\r\n   min_y = 0;\r\n   waste_area = 0;\r\n   visited_width = 0;\r\n   while (node->x < x1) {\r\n      if (node->y > min_y) {\r\n         // raise min_y higher.\r\n         // we've accounted for all waste up to min_y,\r\n         // but we'll now add more waste for everything we've visted\r\n         waste_area += visited_width * (node->y - min_y);\r\n         min_y = node->y;\r\n         // the first time through, visited_width might be reduced\r\n         if (node->x < x0)\r\n            visited_width += node->next->x - x0;\r\n         else\r\n            visited_width += node->next->x - node->x;\r\n      } else {\r\n         // add waste area\r\n         int under_width = node->next->x - node->x;\r\n         if (under_width + visited_width > width)\r\n            under_width = width - visited_width;\r\n         waste_area += under_width * (min_y - node->y);\r\n         visited_width += under_width;\r\n      }\r\n      node = node->next;\r\n   }\r\n\r\n   *pwaste = waste_area;\r\n   return min_y;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   int x,y;\r\n   stbrp_node **prev_link;\r\n} stbrp__findresult;\r\n\r\nstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)\r\n{\r\n   int best_waste = (1<<30), best_x, best_y = (1 << 30);\r\n   stbrp__findresult fr;\r\n   stbrp_node **prev, *node, *tail, **best = NULL;\r\n\r\n   // align to multiple of c->align\r\n   width = (width + c->align - 1);\r\n   width -= width % c->align;\r\n   STBRP_ASSERT(width % c->align == 0);\r\n\r\n   node = c->active_head;\r\n   prev = &c->active_head;\r\n   while (node->x + width <= c->width) {\r\n      int y,waste;\r\n      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);\r\n      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL\r\n         // bottom left\r\n         if (y < best_y) {\r\n            best_y = y;\r\n            best = prev;\r\n         }\r\n      } else {\r\n         // best-fit\r\n         if (y + height <= c->height) {\r\n            // can only use it if it first vertically\r\n            if (y < best_y || (y == best_y && waste < best_waste)) {\r\n               best_y = y;\r\n               best_waste = waste;\r\n               best = prev;\r\n            }\r\n         }\r\n      }\r\n      prev = &node->next;\r\n      node = node->next;\r\n   }\r\n\r\n   best_x = (best == NULL) ? 0 : (*best)->x;\r\n\r\n   // if doing best-fit (BF), we also have to try aligning right edge to each node position\r\n   //\r\n   // e.g, if fitting\r\n   //\r\n   //     ____________________\r\n   //    |____________________|\r\n   //\r\n   //            into\r\n   //\r\n   //   |                         |\r\n   //   |             ____________|\r\n   //   |____________|\r\n   //\r\n   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned\r\n   //\r\n   // This makes BF take about 2x the time\r\n\r\n   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {\r\n      tail = c->active_head;\r\n      node = c->active_head;\r\n      prev = &c->active_head;\r\n      // find first node that's admissible\r\n      while (tail->x < width)\r\n         tail = tail->next;\r\n      while (tail) {\r\n         int xpos = tail->x - width;\r\n         int y,waste;\r\n         STBRP_ASSERT(xpos >= 0);\r\n         // find the left position that matches this\r\n         while (node->next->x <= xpos) {\r\n            prev = &node->next;\r\n            node = node->next;\r\n         }\r\n         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);\r\n         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);\r\n         if (y + height < c->height) {\r\n            if (y <= best_y) {\r\n               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {\r\n                  best_x = xpos;\r\n                  STBRP_ASSERT(y <= best_y);\r\n                  best_y = y;\r\n                  best_waste = waste;\r\n                  best = prev;\r\n               }\r\n            }\r\n         }\r\n         tail = tail->next;\r\n      }         \r\n   }\r\n\r\n   fr.prev_link = best;\r\n   fr.x = best_x;\r\n   fr.y = best_y;\r\n   return fr;\r\n}\r\n\r\nstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)\r\n{\r\n   // find best position according to heuristic\r\n   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);\r\n   stbrp_node *node, *cur;\r\n\r\n   // bail if:\r\n   //    1. it failed\r\n   //    2. the best node doesn't fit (we don't always check this)\r\n   //    3. we're out of memory\r\n   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {\r\n      res.prev_link = NULL;\r\n      return res;\r\n   }\r\n\r\n   // on success, create new node\r\n   node = context->free_head;\r\n   node->x = (stbrp_coord) res.x;\r\n   node->y = (stbrp_coord) (res.y + height);\r\n\r\n   context->free_head = node->next;\r\n\r\n   // insert the new node into the right starting point, and\r\n   // let 'cur' point to the remaining nodes needing to be\r\n   // stiched back in\r\n\r\n   cur = *res.prev_link;\r\n   if (cur->x < res.x) {\r\n      // preserve the existing one, so start testing with the next one\r\n      stbrp_node *next = cur->next;\r\n      cur->next = node;\r\n      cur = next;\r\n   } else {\r\n      *res.prev_link = node;\r\n   }\r\n\r\n   // from here, traverse cur and free the nodes, until we get to one\r\n   // that shouldn't be freed\r\n   while (cur->next && cur->next->x <= res.x + width) {\r\n      stbrp_node *next = cur->next;\r\n      // move the current node to the free list\r\n      cur->next = context->free_head;\r\n      context->free_head = cur;\r\n      cur = next;\r\n   }\r\n\r\n   // stitch the list back in\r\n   node->next = cur;\r\n\r\n   if (cur->x < res.x + width)\r\n      cur->x = (stbrp_coord) (res.x + width);\r\n\r\n#ifdef _DEBUG\r\n   cur = context->active_head;\r\n   while (cur->x < context->width) {\r\n      STBRP_ASSERT(cur->x < cur->next->x);\r\n      cur = cur->next;\r\n   }\r\n   STBRP_ASSERT(cur->next == NULL);\r\n\r\n   {\r\n      int count=0;\r\n      cur = context->active_head;\r\n      while (cur) {\r\n         cur = cur->next;\r\n         ++count;\r\n      }\r\n      cur = context->free_head;\r\n      while (cur) {\r\n         cur = cur->next;\r\n         ++count;\r\n      }\r\n      STBRP_ASSERT(count == context->num_nodes+2);\r\n   }\r\n#endif\r\n\r\n   return res;\r\n}\r\n\r\nstatic int STBRP__CDECL rect_height_compare(const void *a, const void *b)\r\n{\r\n   const stbrp_rect *p = (const stbrp_rect *) a;\r\n   const stbrp_rect *q = (const stbrp_rect *) b;\r\n   if (p->h > q->h)\r\n      return -1;\r\n   if (p->h < q->h)\r\n      return  1;\r\n   return (p->w > q->w) ? -1 : (p->w < q->w);\r\n}\r\n\r\nstatic int STBRP__CDECL rect_original_order(const void *a, const void *b)\r\n{\r\n   const stbrp_rect *p = (const stbrp_rect *) a;\r\n   const stbrp_rect *q = (const stbrp_rect *) b;\r\n   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);\r\n}\r\n\r\n#ifdef STBRP_LARGE_RECTS\r\n#define STBRP__MAXVAL  0xffffffff\r\n#else\r\n#define STBRP__MAXVAL  0xffff\r\n#endif\r\n\r\nSTBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)\r\n{\r\n   int i, all_rects_packed = 1;\r\n\r\n   // we use the 'was_packed' field internally to allow sorting/unsorting\r\n   for (i=0; i < num_rects; ++i) {\r\n      rects[i].was_packed = i;\r\n      #ifndef STBRP_LARGE_RECTS\r\n      STBRP_ASSERT(rects[i].w <= 0xffff && rects[i].h <= 0xffff);\r\n      #endif\r\n   }\r\n\r\n   // sort according to heuristic\r\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);\r\n\r\n   for (i=0; i < num_rects; ++i) {\r\n      if (rects[i].w == 0 || rects[i].h == 0) {\r\n         rects[i].x = rects[i].y = 0;  // empty rect needs no space\r\n      } else {\r\n         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);\r\n         if (fr.prev_link) {\r\n            rects[i].x = (stbrp_coord) fr.x;\r\n            rects[i].y = (stbrp_coord) fr.y;\r\n         } else {\r\n            rects[i].x = rects[i].y = STBRP__MAXVAL;\r\n         }\r\n      }\r\n   }\r\n\r\n   // unsort\r\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);\r\n\r\n   // set was_packed flags and all_rects_packed status\r\n   for (i=0; i < num_rects; ++i) {\r\n      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);\r\n      if (!rects[i].was_packed)\r\n         all_rects_packed = 0;\r\n   }\r\n\r\n   // return the all_rects_packed status\r\n   return all_rects_packed;\r\n}\r\n#endif\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \r\nsoftware, either in source code form or as a compiled binary, for any purpose, \r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this \r\nsoftware dedicate any and all copyright interest in the software to the public \r\ndomain. We make this dedication for the benefit of the public at large and to \r\nthe detriment of our heirs and successors. We intend this dedication to be an \r\novert act of relinquishment in perpetuity of all present and future rights to \r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/\r\n","// dear imgui, v1.67 WIP\r\n// (demo code)\r\n\r\n// Message to the person tempted to delete this file when integrating Dear ImGui into their code base:\r\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other coders\r\n// will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of \r\n// your game/app! Removing this file from your project is hindering access to documentation for everyone in your team, \r\n// likely leading you to poorer usage of the library.\r\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\r\n// If you want to link core Dear ImGui in your shipped builds but want an easy guarantee that the demo will not be linked, \r\n// you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\r\n// In other situation, whenever you have Dear ImGui available you probably want this to be available for reference.\r\n// Thank you,\r\n// -Your beloved friend, imgui_demo.cpp (that you won't delete)\r\n\r\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword: \r\n// In this demo code, we frequently we use 'static' variables inside functions. A static variable persist across calls, so it is \r\n// essentially like a global variable but declared inside the scope of the function. We do this as a way to gather code and data \r\n// in the same place, to make the demo source code faster to read, faster to write, and smaller in size.\r\n// It also happens to be a convenient way of storing simple UI related information as long as your function doesn't need to be reentrant\r\n// or used in threads. This might be a pattern you will want to use in your code, but most of the real data you would be editing is \r\n// likely going to be stored outside your functions.\r\n\r\n/*\r\n\r\nIndex of this file:\r\n\r\n// [SECTION] Forward Declarations, Helpers\r\n// [SECTION] Demo Window / ShowDemoWindow()\r\n// [SECTION] About Window / ShowAboutWindow()\r\n// [SECTION] Style Editor / ShowStyleEditor()\r\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\r\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\r\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\r\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\r\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\r\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\r\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\r\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\r\n// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()\r\n// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()\r\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\r\n\r\n*/\r\n\r\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include \"imgui.h\"\r\n#include <ctype.h>          // toupper, isprint\r\n#include <limits.h>         // INT_MIN, INT_MAX\r\n#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf\r\n#include <stdio.h>          // vsnprintf, sscanf, printf\r\n#include <stdlib.h>         // NULL, malloc, free, atoi\r\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\r\n#include <stddef.h>         // intptr_t\r\n#else\r\n#include <stdint.h>         // intptr_t\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\r\n#define vsnprintf _vsnprintf\r\n#endif\r\n#ifdef __clang__\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"             // warning : use of old-style cast                              // yes, they are more terse.\r\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"    // warning : 'xx' is deprecated: The POSIX name for this item.. // for strdup used in demo code (so user can copy & paste the code)\r\n#pragma clang diagnostic ignored \"-Wint-to-void-pointer-cast\"   // warning : cast to 'void *' from smaller integer type 'int'\r\n#pragma clang diagnostic ignored \"-Wformat-security\"            // warning : warning: format string is not a string literal\r\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"      // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.\r\n#if __has_warning(\"-Wreserved-id-macro\")\r\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"          // warning : macro name is a reserved identifier                //\r\n#endif\r\n#elif defined(__GNUC__)\r\n#pragma GCC diagnostic ignored \"-Wint-to-pointer-cast\"          // warning: cast to pointer from integer of different size\r\n#pragma GCC diagnostic ignored \"-Wformat-security\"              // warning : format string is not a string literal (potentially insecure)\r\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"             // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#pragma GCC diagnostic ignored \"-Wconversion\"                   // warning: conversion to 'xxxx' from 'xxxx' may alter its value\r\n#if (__GNUC__ >= 6)\r\n#pragma GCC diagnostic ignored \"-Wmisleading-indentation\"       // warning: this 'if' clause does not guard this statement      // GCC 6.0+ only. See #883 on GitHub.\r\n#endif\r\n#endif\r\n\r\n// Play it nice with Windows users. Notepad in 2017 still doesn't display text data with Unix-style \\n.\r\n#ifdef _WIN32\r\n#define IM_NEWLINE \"\\r\\n\"\r\n#else\r\n#define IM_NEWLINE \"\\n\"\r\n#endif\r\n\r\n#define IM_MAX(_A,_B)       (((_A) >= (_B)) ? (_A) : (_B))\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Forward Declarations, Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n#if !defined(IMGUI_DISABLE_OBSOLETE_FUNCTIONS) && defined(IMGUI_DISABLE_TEST_WINDOWS) && !defined(IMGUI_DISABLE_DEMO_WINDOWS)   // Obsolete name since 1.53, TEST->DEMO\r\n#define IMGUI_DISABLE_DEMO_WINDOWS\r\n#endif\r\n\r\n#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)\r\n\r\n// Forward Declarations\r\nstatic void ShowExampleAppMainMenuBar();\r\nstatic void ShowExampleAppConsole(bool* p_open);\r\nstatic void ShowExampleAppLog(bool* p_open);\r\nstatic void ShowExampleAppLayout(bool* p_open);\r\nstatic void ShowExampleAppPropertyEditor(bool* p_open);\r\nstatic void ShowExampleAppLongText(bool* p_open);\r\nstatic void ShowExampleAppAutoResize(bool* p_open);\r\nstatic void ShowExampleAppConstrainedResize(bool* p_open);\r\nstatic void ShowExampleAppSimpleOverlay(bool* p_open);\r\nstatic void ShowExampleAppWindowTitles(bool* p_open);\r\nstatic void ShowExampleAppCustomRendering(bool* p_open);\r\nstatic void ShowExampleMenuFile();\r\n\r\n// Helper to display a little (?) mark which shows a tooltip when hovered.\r\nstatic void ShowHelpMarker(const char* desc)\r\n{\r\n    ImGui::TextDisabled(\"(?)\");\r\n    if (ImGui::IsItemHovered())\r\n    {\r\n        ImGui::BeginTooltip();\r\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\r\n        ImGui::TextUnformatted(desc);\r\n        ImGui::PopTextWrapPos();\r\n        ImGui::EndTooltip();\r\n    }\r\n}\r\n\r\n// Helper to display basic user controls.\r\nvoid ImGui::ShowUserGuide()\r\n{\r\n    ImGui::BulletText(\"Double-click on title bar to collapse window.\");\r\n    ImGui::BulletText(\"Click and drag on lower right corner to resize window\\n(double-click to auto fit window to its contents).\");\r\n    ImGui::BulletText(\"Click and drag on any empty space to move window.\");\r\n    ImGui::BulletText(\"TAB/SHIFT+TAB to cycle through keyboard editable fields.\");\r\n    ImGui::BulletText(\"CTRL+Click on a slider or drag box to input value as text.\");\r\n    if (ImGui::GetIO().FontAllowUserScaling)\r\n        ImGui::BulletText(\"CTRL+Mouse Wheel to zoom window contents.\");\r\n    ImGui::BulletText(\"Mouse Wheel to scroll.\");\r\n    ImGui::BulletText(\"While editing text:\\n\");\r\n    ImGui::Indent();\r\n    ImGui::BulletText(\"Hold SHIFT or use mouse to select text.\");\r\n    ImGui::BulletText(\"CTRL+Left/Right to word jump.\");\r\n    ImGui::BulletText(\"CTRL+A or double-click to select all.\");\r\n    ImGui::BulletText(\"CTRL+X,CTRL+C,CTRL+V to use clipboard.\");\r\n    ImGui::BulletText(\"CTRL+Z,CTRL+Y to undo/redo.\");\r\n    ImGui::BulletText(\"ESCAPE to revert.\");\r\n    ImGui::BulletText(\"You can apply arithmetic operators +,*,/ on numerical values.\\nUse +- to subtract.\");\r\n    ImGui::Unindent();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Demo Window / ShowDemoWindow()\r\n//-----------------------------------------------------------------------------\r\n\r\n// We split the contents of the big ShowDemoWindow() function into smaller functions (because the link time of very large functions grow non-linearly)\r\nstatic void ShowDemoWindowWidgets();\r\nstatic void ShowDemoWindowLayout();\r\nstatic void ShowDemoWindowPopups();\r\nstatic void ShowDemoWindowColumns();\r\nstatic void ShowDemoWindowMisc();\r\n\r\n// Demonstrate most Dear ImGui features (this is big function!)\r\n// You may execute this function to experiment with the UI and understand what it does. You may then search for keywords in the code when you are interested by a specific feature.\r\nvoid ImGui::ShowDemoWindow(bool* p_open)\r\n{\r\n    // Examples Apps (accessible from the \"Examples\" menu)\r\n    static bool show_app_main_menu_bar = false;\r\n    static bool show_app_console = false;\r\n    static bool show_app_log = false;\r\n    static bool show_app_layout = false;\r\n    static bool show_app_property_editor = false;\r\n    static bool show_app_long_text = false;\r\n    static bool show_app_auto_resize = false;\r\n    static bool show_app_constrained_resize = false;\r\n    static bool show_app_simple_overlay = false;\r\n    static bool show_app_window_titles = false;\r\n    static bool show_app_custom_rendering = false;\r\n\r\n    if (show_app_main_menu_bar)       ShowExampleAppMainMenuBar();\r\n    if (show_app_console)             ShowExampleAppConsole(&show_app_console);\r\n    if (show_app_log)                 ShowExampleAppLog(&show_app_log);\r\n    if (show_app_layout)              ShowExampleAppLayout(&show_app_layout);\r\n    if (show_app_property_editor)     ShowExampleAppPropertyEditor(&show_app_property_editor);\r\n    if (show_app_long_text)           ShowExampleAppLongText(&show_app_long_text);\r\n    if (show_app_auto_resize)         ShowExampleAppAutoResize(&show_app_auto_resize);\r\n    if (show_app_constrained_resize)  ShowExampleAppConstrainedResize(&show_app_constrained_resize);\r\n    if (show_app_simple_overlay)      ShowExampleAppSimpleOverlay(&show_app_simple_overlay);\r\n    if (show_app_window_titles)       ShowExampleAppWindowTitles(&show_app_window_titles);\r\n    if (show_app_custom_rendering)    ShowExampleAppCustomRendering(&show_app_custom_rendering);\r\n\r\n    // Dear ImGui Apps (accessible from the \"Help\" menu)\r\n    static bool show_app_metrics = false;\r\n    static bool show_app_style_editor = false;\r\n    static bool show_app_about = false;\r\n\r\n    if (show_app_metrics)             { ImGui::ShowMetricsWindow(&show_app_metrics); }\r\n    if (show_app_style_editor)        { ImGui::Begin(\"Style Editor\", &show_app_style_editor); ImGui::ShowStyleEditor(); ImGui::End(); }\r\n    if (show_app_about)               { ShowAboutWindow(&show_app_about); }\r\n\r\n    // Demonstrate the various window flags. Typically you would just use the default!\r\n    static bool no_titlebar = false;\r\n    static bool no_scrollbar = false;\r\n    static bool no_menu = false;\r\n    static bool no_move = false;\r\n    static bool no_resize = false;\r\n    static bool no_collapse = false;\r\n    static bool no_close = false;\r\n    static bool no_nav = false;\r\n    static bool no_background = false;\r\n    static bool no_bring_to_front = false;\r\n\r\n    ImGuiWindowFlags window_flags = 0;\r\n    if (no_titlebar)        window_flags |= ImGuiWindowFlags_NoTitleBar;\r\n    if (no_scrollbar)       window_flags |= ImGuiWindowFlags_NoScrollbar;\r\n    if (!no_menu)           window_flags |= ImGuiWindowFlags_MenuBar;\r\n    if (no_move)            window_flags |= ImGuiWindowFlags_NoMove;\r\n    if (no_resize)          window_flags |= ImGuiWindowFlags_NoResize;\r\n    if (no_collapse)        window_flags |= ImGuiWindowFlags_NoCollapse;\r\n    if (no_nav)             window_flags |= ImGuiWindowFlags_NoNav;\r\n    if (no_background)      window_flags |= ImGuiWindowFlags_NoBackground;\r\n    if (no_bring_to_front)  window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus;\r\n    if (no_close)           p_open = NULL; // Don't pass our bool* to Begin\r\n\r\n    // We specify a default position/size in case there's no data in the .ini file. Typically this isn't required! We only do it to make the Demo applications a little more welcoming.\r\n    ImGui::SetNextWindowPos(ImVec2(650, 20), ImGuiCond_FirstUseEver);\r\n    ImGui::SetNextWindowSize(ImVec2(550, 680), ImGuiCond_FirstUseEver);\r\n\r\n    // Main body of the Demo window starts here.\r\n    if (!ImGui::Begin(\"ImGui Demo\", p_open, window_flags))\r\n    {\r\n        // Early out if the window is collapsed, as an optimization.\r\n        ImGui::End();\r\n        return;\r\n    }\r\n    ImGui::Text(\"dear imgui says hello. (%s)\", IMGUI_VERSION);\r\n\r\n    // Most \"big\" widgets share a common width settings by default.\r\n    //ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.65f);    // Use 2/3 of the space for widgets and 1/3 for labels (default)\r\n    ImGui::PushItemWidth(ImGui::GetFontSize() * -12);           // Use fixed width for labels (by passing a negative value), the rest goes to widgets. We choose a width proportional to our font size.\r\n\r\n    // Menu\r\n    if (ImGui::BeginMenuBar())\r\n    {\r\n        if (ImGui::BeginMenu(\"Menu\"))\r\n        {\r\n            ShowExampleMenuFile();\r\n            ImGui::EndMenu();\r\n        }\r\n        if (ImGui::BeginMenu(\"Examples\"))\r\n        {\r\n            ImGui::MenuItem(\"Main menu bar\", NULL, &show_app_main_menu_bar);\r\n            ImGui::MenuItem(\"Console\", NULL, &show_app_console);\r\n            ImGui::MenuItem(\"Log\", NULL, &show_app_log);\r\n            ImGui::MenuItem(\"Simple layout\", NULL, &show_app_layout);\r\n            ImGui::MenuItem(\"Property editor\", NULL, &show_app_property_editor);\r\n            ImGui::MenuItem(\"Long text display\", NULL, &show_app_long_text);\r\n            ImGui::MenuItem(\"Auto-resizing window\", NULL, &show_app_auto_resize);\r\n            ImGui::MenuItem(\"Constrained-resizing window\", NULL, &show_app_constrained_resize);\r\n            ImGui::MenuItem(\"Simple overlay\", NULL, &show_app_simple_overlay);\r\n            ImGui::MenuItem(\"Manipulating window titles\", NULL, &show_app_window_titles);\r\n            ImGui::MenuItem(\"Custom rendering\", NULL, &show_app_custom_rendering);\r\n            ImGui::EndMenu();\r\n        }\r\n        if (ImGui::BeginMenu(\"Help\"))\r\n        {\r\n            ImGui::MenuItem(\"Metrics\", NULL, &show_app_metrics);\r\n            ImGui::MenuItem(\"Style Editor\", NULL, &show_app_style_editor);\r\n            ImGui::MenuItem(\"About Dear ImGui\", NULL, &show_app_about);\r\n            ImGui::EndMenu();\r\n        }\r\n        ImGui::EndMenuBar();\r\n    }\r\n\r\n    ImGui::Spacing();\r\n    if (ImGui::CollapsingHeader(\"Help\"))\r\n    {\r\n        ImGui::Text(\"PROGRAMMER GUIDE:\");\r\n        ImGui::BulletText(\"Please see the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!\");\r\n        ImGui::BulletText(\"Please see the comments in imgui.cpp.\");\r\n        ImGui::BulletText(\"Please see the examples/ in application.\");\r\n        ImGui::BulletText(\"Enable 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.\");\r\n        ImGui::BulletText(\"Enable 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.\");\r\n        ImGui::Separator();\r\n\r\n        ImGui::Text(\"USER GUIDE:\");\r\n        ImGui::ShowUserGuide();\r\n    }\r\n\r\n    if (ImGui::CollapsingHeader(\"Configuration\"))\r\n    {\r\n        ImGuiIO& io = ImGui::GetIO();\r\n\r\n        if (ImGui::TreeNode(\"Configuration##2\"))\r\n        {\r\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NavEnableKeyboard\", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableKeyboard);\r\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NavEnableGamepad\", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableGamepad);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Required back-end to feed in gamepad inputs in io.NavInputs[] and set io.BackendFlags |= ImGuiBackendFlags_HasGamepad.\\n\\nRead instructions in imgui.cpp for details.\");\r\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NavEnableSetMousePos\", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableSetMousePos);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Instruct navigation to move the mouse cursor. See comment for ImGuiConfigFlags_NavEnableSetMousePos.\");\r\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NoMouse\", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouse);\r\n            if (io.ConfigFlags & ImGuiConfigFlags_NoMouse) // Create a way to restore this flag otherwise we could be stuck completely!\r\n            {\r\n                if (fmodf((float)ImGui::GetTime(), 0.40f) < 0.20f)\r\n                {\r\n                    ImGui::SameLine();\r\n                    ImGui::Text(\"<<PRESS SPACE TO DISABLE>>\");\r\n                }\r\n                if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Space)))\r\n                    io.ConfigFlags &= ~ImGuiConfigFlags_NoMouse;\r\n            }\r\n            ImGui::CheckboxFlags(\"io.ConfigFlags: NoMouseCursorChange\", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouseCursorChange);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Instruct back-end to not alter mouse cursor shape and visibility.\");\r\n            ImGui::Checkbox(\"io.ConfigInputTextCursorBlink\", &io.ConfigInputTextCursorBlink);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Set to false to disable blinking cursor, for users who consider it distracting\");\r\n            ImGui::Checkbox(\"io.ConfigResizeWindowsFromEdges [beta]\", &io.ConfigResizeWindowsFromEdges);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Enable resizing of windows from their edges and from the lower-left corner.\\nThis requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback.\");\r\n            ImGui::Checkbox(\"io.MouseDrawCursor\", &io.MouseDrawCursor);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Instruct Dear ImGui to render a mouse cursor for you. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\\n\\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).\");\r\n            ImGui::TreePop();\r\n            ImGui::Separator();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Backend Flags\"))\r\n        {\r\n            ImGuiBackendFlags backend_flags = io.BackendFlags; // Make a local copy to avoid modifying the back-end flags.\r\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasGamepad\", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasGamepad);\r\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasMouseCursors\", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasMouseCursors);\r\n            ImGui::CheckboxFlags(\"io.BackendFlags: HasSetMousePos\", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasSetMousePos);\r\n            ImGui::TreePop();\r\n            ImGui::Separator();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Style\"))\r\n        {\r\n            ImGui::ShowStyleEditor();\r\n            ImGui::TreePop();\r\n            ImGui::Separator();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Capture/Logging\"))\r\n        {\r\n            ImGui::TextWrapped(\"The logging API redirects all text output so you can easily capture the content of a window or a block. Tree nodes can be automatically expanded.\");\r\n            ShowHelpMarker(\"Try opening any of the contents below in this window and then click one of the \\\"Log To\\\" button.\");\r\n            ImGui::LogButtons();\r\n            ImGui::TextWrapped(\"You can also call ImGui::LogText() to output directly to the log without a visual output.\");\r\n            if (ImGui::Button(\"Copy \\\"Hello, world!\\\" to clipboard\"))\r\n            {\r\n                ImGui::LogToClipboard();\r\n                ImGui::LogText(\"Hello, world!\");\r\n                ImGui::LogFinish();\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n    }\r\n\r\n    if (ImGui::CollapsingHeader(\"Window options\"))\r\n    {\r\n        ImGui::Checkbox(\"No titlebar\", &no_titlebar); ImGui::SameLine(150);\r\n        ImGui::Checkbox(\"No scrollbar\", &no_scrollbar); ImGui::SameLine(300);\r\n        ImGui::Checkbox(\"No menu\", &no_menu);\r\n        ImGui::Checkbox(\"No move\", &no_move); ImGui::SameLine(150);\r\n        ImGui::Checkbox(\"No resize\", &no_resize); ImGui::SameLine(300);\r\n        ImGui::Checkbox(\"No collapse\", &no_collapse);\r\n        ImGui::Checkbox(\"No close\", &no_close); ImGui::SameLine(150);\r\n        ImGui::Checkbox(\"No nav\", &no_nav); ImGui::SameLine(300);\r\n        ImGui::Checkbox(\"No background\", &no_background);\r\n        ImGui::Checkbox(\"No bring to front\", &no_bring_to_front);\r\n    }\r\n\r\n    // All demo contents\r\n    ShowDemoWindowWidgets();\r\n    ShowDemoWindowLayout();\r\n    ShowDemoWindowPopups();\r\n    ShowDemoWindowColumns();\r\n    ShowDemoWindowMisc();\r\n\r\n    // End of ShowDemoWindow()\r\n    ImGui::End();\r\n}\r\n\r\nstatic void ShowDemoWindowWidgets()\r\n{\r\n    if (!ImGui::CollapsingHeader(\"Widgets\"))\r\n        return;\r\n\r\n    if (ImGui::TreeNode(\"Basic\"))\r\n    {\r\n        static int clicked = 0;\r\n        if (ImGui::Button(\"Button\"))\r\n            clicked++;\r\n        if (clicked & 1)\r\n        {\r\n            ImGui::SameLine();\r\n            ImGui::Text(\"Thanks for clicking me!\");\r\n        }\r\n\r\n        static bool check = true;\r\n        ImGui::Checkbox(\"checkbox\", &check);\r\n\r\n        static int e = 0;\r\n        ImGui::RadioButton(\"radio a\", &e, 0); ImGui::SameLine();\r\n        ImGui::RadioButton(\"radio b\", &e, 1); ImGui::SameLine();\r\n        ImGui::RadioButton(\"radio c\", &e, 2);\r\n\r\n        // Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.\r\n        for (int i = 0; i < 7; i++)\r\n        {\r\n            if (i > 0) \r\n                ImGui::SameLine();\r\n            ImGui::PushID(i);\r\n            ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.6f));\r\n            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.7f));\r\n            ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(i/7.0f, 0.8f, 0.8f));\r\n            ImGui::Button(\"Click\");\r\n            ImGui::PopStyleColor(3);\r\n            ImGui::PopID();\r\n        }\r\n\r\n        // Use AlignTextToFramePadding() to align text baseline to the baseline of framed elements (otherwise a Text+SameLine+Button sequence will have the text a little too high by default)\r\n        ImGui::AlignTextToFramePadding();\r\n        ImGui::Text(\"Hold to repeat:\");\r\n        ImGui::SameLine();\r\n\r\n        // Arrow buttons with Repeater\r\n        static int counter = 0;\r\n        float spacing = ImGui::GetStyle().ItemInnerSpacing.x;\r\n        ImGui::PushButtonRepeat(true);\r\n        if (ImGui::ArrowButton(\"##left\", ImGuiDir_Left)) { counter--; }\r\n        ImGui::SameLine(0.0f, spacing);\r\n        if (ImGui::ArrowButton(\"##right\", ImGuiDir_Right)) { counter++; }\r\n        ImGui::PopButtonRepeat();\r\n        ImGui::SameLine();\r\n        ImGui::Text(\"%d\", counter);\r\n\r\n        ImGui::Text(\"Hover over me\");\r\n        if (ImGui::IsItemHovered())\r\n            ImGui::SetTooltip(\"I am a tooltip\");\r\n\r\n        ImGui::SameLine();\r\n        ImGui::Text(\"- or me\");\r\n        if (ImGui::IsItemHovered())\r\n        {\r\n            ImGui::BeginTooltip();\r\n            ImGui::Text(\"I am a fancy tooltip\");\r\n            static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };\r\n            ImGui::PlotLines(\"Curve\", arr, IM_ARRAYSIZE(arr));\r\n            ImGui::EndTooltip();\r\n        }\r\n\r\n        ImGui::Separator();\r\n\r\n        ImGui::LabelText(\"label\", \"Value\");\r\n\r\n        {\r\n            // Using the _simplified_ one-liner Combo() api here\r\n            // See \"Combo\" section for examples of how to use the more complete BeginCombo()/EndCombo() api.\r\n            const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\", \"FFFF\", \"GGGG\", \"HHHH\", \"IIII\", \"JJJJ\", \"KKKK\", \"LLLLLLL\", \"MMMM\", \"OOOOOOO\" };\r\n            static int item_current = 0;\r\n            ImGui::Combo(\"combo\", &item_current, items, IM_ARRAYSIZE(items));\r\n            ImGui::SameLine(); ShowHelpMarker(\"Refer to the \\\"Combo\\\" section below for an explanation of the full BeginCombo/EndCombo API, and demonstration of various flags.\\n\");\r\n        }\r\n\r\n        {\r\n            static char str0[128] = \"Hello, world!\";\r\n            static int i0 = 123;\r\n            ImGui::InputText(\"input text\", str0, IM_ARRAYSIZE(str0));\r\n            ImGui::SameLine(); ShowHelpMarker(\"USER:\\nHold SHIFT or use mouse to select text.\\n\" \"CTRL+Left/Right to word jump.\\n\" \"CTRL+A or double-click to select all.\\n\" \"CTRL+X,CTRL+C,CTRL+V clipboard.\\n\" \"CTRL+Z,CTRL+Y undo/redo.\\n\" \"ESCAPE to revert.\\n\\nPROGRAMMER:\\nYou can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputText() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated in imgui_demo.cpp).\");\r\n\r\n            ImGui::InputInt(\"input int\", &i0);\r\n            ImGui::SameLine(); ShowHelpMarker(\"You can apply arithmetic operators +,*,/ on numerical values.\\n  e.g. [ 100 ], input \\'*2\\', result becomes [ 200 ]\\nUse +- to subtract.\\n\");\r\n\r\n            static float f0 = 0.001f;\r\n            ImGui::InputFloat(\"input float\", &f0, 0.01f, 1.0f);\r\n\r\n            static double d0 = 999999.00000001;\r\n            ImGui::InputDouble(\"input double\", &d0, 0.01f, 1.0f, \"%.8f\");\r\n\r\n            static float f1 = 1.e10f;\r\n            ImGui::InputFloat(\"input scientific\", &f1, 0.0f, 0.0f, \"%e\");\r\n            ImGui::SameLine(); ShowHelpMarker(\"You can input value using the scientific notation,\\n  e.g. \\\"1e+8\\\" becomes \\\"100000000\\\".\\n\");\r\n\r\n            static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };\r\n            ImGui::InputFloat3(\"input float3\", vec4a);\r\n        }\r\n\r\n        {\r\n            static int i1 = 50, i2 = 42;\r\n            ImGui::DragInt(\"drag int\", &i1, 1);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Click and drag to edit value.\\nHold SHIFT/ALT for faster/slower edit.\\nDouble-click or CTRL+click to input value.\");\r\n\r\n            ImGui::DragInt(\"drag int 0..100\", &i2, 1, 0, 100, \"%d%%\");\r\n\r\n            static float f1=1.00f, f2=0.0067f;\r\n            ImGui::DragFloat(\"drag float\", &f1, 0.005f);\r\n            ImGui::DragFloat(\"drag small float\", &f2, 0.0001f, 0.0f, 0.0f, \"%.06f ns\");\r\n        }\r\n\r\n        {\r\n            static int i1=0;\r\n            ImGui::SliderInt(\"slider int\", &i1, -1, 3);\r\n            ImGui::SameLine(); ShowHelpMarker(\"CTRL+click to input value.\");\r\n\r\n            static float f1=0.123f, f2=0.0f;\r\n            ImGui::SliderFloat(\"slider float\", &f1, 0.0f, 1.0f, \"ratio = %.3f\");\r\n            ImGui::SliderFloat(\"slider float (curve)\", &f2, -10.0f, 10.0f, \"%.4f\", 2.0f);\r\n            static float angle = 0.0f;\r\n            ImGui::SliderAngle(\"slider angle\", &angle);\r\n        }\r\n\r\n        {\r\n            static float col1[3] = { 1.0f,0.0f,0.2f };\r\n            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };\r\n            ImGui::ColorEdit3(\"color 1\", col1);\r\n            ImGui::SameLine(); ShowHelpMarker(\"Click on the colored square to open a color picker.\\nClick and hold to use drag and drop.\\nRight-click on the colored square to show options.\\nCTRL+click on individual component to input value.\\n\");\r\n\r\n            ImGui::ColorEdit4(\"color 2\", col2);\r\n        }\r\n\r\n        {\r\n            // List box\r\n            const char* listbox_items[] = { \"Apple\", \"Banana\", \"Cherry\", \"Kiwi\", \"Mango\", \"Orange\", \"Pineapple\", \"Strawberry\", \"Watermelon\" };\r\n            static int listbox_item_current = 1;\r\n            ImGui::ListBox(\"listbox\\n(single select)\", &listbox_item_current, listbox_items, IM_ARRAYSIZE(listbox_items), 4);\r\n\r\n            //static int listbox_item_current2 = 2;\r\n            //ImGui::PushItemWidth(-1);\r\n            //ImGui::ListBox(\"##listbox2\", &listbox_item_current2, listbox_items, IM_ARRAYSIZE(listbox_items), 4);\r\n            //ImGui::PopItemWidth();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    // Testing ImGuiOnceUponAFrame helper.\r\n    //static ImGuiOnceUponAFrame once;\r\n    //for (int i = 0; i < 5; i++)\r\n    //    if (once)\r\n    //        ImGui::Text(\"This will be displayed only once.\");\r\n\r\n    if (ImGui::TreeNode(\"Trees\"))\r\n    {\r\n        if (ImGui::TreeNode(\"Basic trees\"))\r\n        {\r\n            for (int i = 0; i < 5; i++)\r\n                if (ImGui::TreeNode((void*)(intptr_t)i, \"Child %d\", i))\r\n                {\r\n                    ImGui::Text(\"blah blah\");\r\n                    ImGui::SameLine();\r\n                    if (ImGui::SmallButton(\"button\")) { };\r\n                    ImGui::TreePop();\r\n                }\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Advanced, with Selectable nodes\"))\r\n        {\r\n            ShowHelpMarker(\"This is a more standard looking tree with selectable nodes.\\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.\");\r\n            static bool align_label_with_current_x_position = false;\r\n            ImGui::Checkbox(\"Align label with current X position)\", &align_label_with_current_x_position);\r\n            ImGui::Text(\"Hello!\");\r\n            if (align_label_with_current_x_position)\r\n                ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());\r\n\r\n            static int selection_mask = (1 << 2); // Dumb representation of what may be user-side selection state. You may carry selection state inside or outside your objects in whatever format you see fit.\r\n            int node_clicked = -1;                // Temporary storage of what node we have clicked to process selection at the end of the loop. May be a pointer to your own node type, etc.\r\n            ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, ImGui::GetFontSize()*3); // Increase spacing to differentiate leaves from expanded contents.\r\n            for (int i = 0; i < 6; i++)\r\n            {\r\n                // Disable the default open on single-click behavior and pass in Selected flag according to our selection state.\r\n                ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ((selection_mask & (1 << i)) ? ImGuiTreeNodeFlags_Selected : 0);\r\n                if (i < 3)\r\n                {\r\n                    // Node\r\n                    bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, \"Selectable Node %d\", i);\r\n                    if (ImGui::IsItemClicked())\r\n                        node_clicked = i;\r\n                    if (node_open)\r\n                    {\r\n                        ImGui::Text(\"Blah blah\\nBlah Blah\");\r\n                        ImGui::TreePop();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Leaf: The only reason we have a TreeNode at all is to allow selection of the leaf. Otherwise we can use BulletText() or TreeAdvanceToLabelPos()+Text().\r\n                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet\r\n                    ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, \"Selectable Leaf %d\", i);\r\n                    if (ImGui::IsItemClicked())\r\n                        node_clicked = i;\r\n                }\r\n            }\r\n            if (node_clicked != -1)\r\n            {\r\n                // Update selection state. Process outside of tree loop to avoid visual inconsistencies during the clicking-frame.\r\n                if (ImGui::GetIO().KeyCtrl)\r\n                    selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle\r\n                else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, this commented bit preserve selection when clicking on item that is part of the selection\r\n                    selection_mask = (1 << node_clicked);           // Click to single-select\r\n            }\r\n            ImGui::PopStyleVar();\r\n            if (align_label_with_current_x_position)\r\n                ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());\r\n            ImGui::TreePop();\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Collapsing Headers\"))\r\n    {\r\n        static bool closable_group = true;\r\n        ImGui::Checkbox(\"Enable extra group\", &closable_group);\r\n        if (ImGui::CollapsingHeader(\"Header\"))\r\n        {\r\n            ImGui::Text(\"IsItemHovered: %d\", ImGui::IsItemHovered());\r\n            for (int i = 0; i < 5; i++)\r\n                ImGui::Text(\"Some content %d\", i);\r\n        }\r\n        if (ImGui::CollapsingHeader(\"Header with a close button\", &closable_group))\r\n        {\r\n            ImGui::Text(\"IsItemHovered: %d\", ImGui::IsItemHovered());\r\n            for (int i = 0; i < 5; i++)\r\n                ImGui::Text(\"More content %d\", i);\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Bullets\"))\r\n    {\r\n        ImGui::BulletText(\"Bullet point 1\");\r\n        ImGui::BulletText(\"Bullet point 2\\nOn multiple lines\");\r\n        ImGui::Bullet(); ImGui::Text(\"Bullet point 3 (two calls)\");\r\n        ImGui::Bullet(); ImGui::SmallButton(\"Button\");\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Text\"))\r\n    {\r\n        if (ImGui::TreeNode(\"Colored Text\"))\r\n        {\r\n            // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.\r\n            ImGui::TextColored(ImVec4(1.0f,0.0f,1.0f,1.0f), \"Pink\");\r\n            ImGui::TextColored(ImVec4(1.0f,1.0f,0.0f,1.0f), \"Yellow\");\r\n            ImGui::TextDisabled(\"Disabled\");\r\n            ImGui::SameLine(); ShowHelpMarker(\"The TextDisabled color is stored in ImGuiStyle.\");\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Word Wrapping\"))\r\n        {\r\n            // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.\r\n            ImGui::TextWrapped(\"This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.\");\r\n            ImGui::Spacing();\r\n\r\n            static float wrap_width = 200.0f;\r\n            ImGui::SliderFloat(\"Wrap width\", &wrap_width, -20, 600, \"%.0f\");\r\n\r\n            ImGui::Text(\"Test paragraph 1:\");\r\n            ImVec2 pos = ImGui::GetCursorScreenPos();\r\n            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));\r\n            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);\r\n            ImGui::Text(\"The lazy dog is a good dog. This paragraph is made to fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.\", wrap_width);\r\n            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));\r\n            ImGui::PopTextWrapPos();\r\n\r\n            ImGui::Text(\"Test paragraph 2:\");\r\n            pos = ImGui::GetCursorScreenPos();\r\n            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));\r\n            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);\r\n            ImGui::Text(\"aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh\");\r\n            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));\r\n            ImGui::PopTextWrapPos();\r\n\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"UTF-8 Text\"))\r\n        {\r\n            // UTF-8 test with Japanese characters\r\n            // (Needs a suitable font, try Noto, or Arial Unicode, or M+ fonts. Read misc/fonts/README.txt for details.)\r\n            // - From C++11 you can use the u8\"my text\" syntax to encode literal strings as UTF-8\r\n            // - For earlier compiler, you may be able to encode your sources as UTF-8 (e.g. Visual Studio save your file as 'UTF-8 without signature')\r\n            // - FOR THIS DEMO FILE ONLY, BECAUSE WE WANT TO SUPPORT OLD COMPILERS, WE ARE *NOT* INCLUDING RAW UTF-8 CHARACTERS IN THIS SOURCE FILE.\r\n            //   Instead we are encoding a few strings with hexadecimal constants. Don't do this in your application!\r\n            //   Please use u8\"text in any language\" in your application!\r\n            // Note that characters values are preserved even by InputText() if the font cannot be displayed, so you can safely copy & paste garbled characters into another application.\r\n            ImGui::TextWrapped(\"CJK text will only appears if the font was loaded with the appropriate CJK character ranges. Call io.Font->AddFontFromFileTTF() manually to load extra character ranges. Read misc/fonts/README.txt for details.\");\r\n            ImGui::Text(\"Hiragana: \\xe3\\x81\\x8b\\xe3\\x81\\x8d\\xe3\\x81\\x8f\\xe3\\x81\\x91\\xe3\\x81\\x93 (kakikukeko)\"); // Normally we would use u8\"blah blah\" with the proper characters directly in the string.\r\n            ImGui::Text(\"Kanjis: \\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e (nihongo)\");\r\n            static char buf[32] = \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\";\r\n            //static char buf[32] = u8\"NIHONGO\"; // <- this is how you would write it with C++11, using real kanjis\r\n            ImGui::InputText(\"UTF-8 input\", buf, IM_ARRAYSIZE(buf));\r\n            ImGui::TreePop();\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Images\"))\r\n    {\r\n        ImGuiIO& io = ImGui::GetIO();\r\n        ImGui::TextWrapped(\"Below we are displaying the font texture (which is the only texture we have access to in this demo). Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. Hover the texture for a zoomed view!\");\r\n\r\n        // Here we are grabbing the font texture because that's the only one we have access to inside the demo code.\r\n        // Remember that ImTextureID is just storage for whatever you want it to be, it is essentially a value that will be passed to the render function inside the ImDrawCmd structure.\r\n        // If you use one of the default imgui_impl_XXXX.cpp renderer, they all have comments at the top of their file to specify what they expect to be stored in ImTextureID.\r\n        // (for example, the imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer. The imgui_impl_glfw_gl3.cpp renderer expect a GLuint OpenGL texture identifier etc.)\r\n        // If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers to ImGui::Image(), and gather width/height through your own functions, etc.\r\n        // Using ShowMetricsWindow() as a \"debugger\" to inspect the draw data that are being passed to your render will help you debug issues if you are confused about this.\r\n        // Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().\r\n        ImTextureID my_tex_id = io.Fonts->TexID;\r\n        float my_tex_w = (float)io.Fonts->TexWidth;\r\n        float my_tex_h = (float)io.Fonts->TexHeight;\r\n\r\n        ImGui::Text(\"%.0fx%.0f\", my_tex_w, my_tex_h);\r\n        ImVec2 pos = ImGui::GetCursorScreenPos();\r\n        ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));\r\n        if (ImGui::IsItemHovered())\r\n        {\r\n            ImGui::BeginTooltip();\r\n            float region_sz = 32.0f;\r\n            float region_x = io.MousePos.x - pos.x - region_sz * 0.5f; if (region_x < 0.0f) region_x = 0.0f; else if (region_x > my_tex_w - region_sz) region_x = my_tex_w - region_sz;\r\n            float region_y = io.MousePos.y - pos.y - region_sz * 0.5f; if (region_y < 0.0f) region_y = 0.0f; else if (region_y > my_tex_h - region_sz) region_y = my_tex_h - region_sz;\r\n            float zoom = 4.0f;\r\n            ImGui::Text(\"Min: (%.2f, %.2f)\", region_x, region_y);\r\n            ImGui::Text(\"Max: (%.2f, %.2f)\", region_x + region_sz, region_y + region_sz);\r\n            ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);\r\n            ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);\r\n            ImGui::Image(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, ImColor(255,255,255,255), ImColor(255,255,255,128));\r\n            ImGui::EndTooltip();\r\n        }\r\n        ImGui::TextWrapped(\"And now some textured buttons..\");\r\n        static int pressed_count = 0;\r\n        for (int i = 0; i < 8; i++)\r\n        {\r\n            ImGui::PushID(i);\r\n            int frame_padding = -1 + i;     // -1 = uses default padding\r\n            if (ImGui::ImageButton(my_tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/my_tex_w,32/my_tex_h), frame_padding, ImColor(0,0,0,255)))\r\n                pressed_count += 1;\r\n            ImGui::PopID();\r\n            ImGui::SameLine();\r\n        }\r\n        ImGui::NewLine();\r\n        ImGui::Text(\"Pressed %d times.\", pressed_count);\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Combo\"))\r\n    {\r\n        // Expose flags as checkbox for the demo\r\n        static ImGuiComboFlags flags = 0;\r\n        ImGui::CheckboxFlags(\"ImGuiComboFlags_PopupAlignLeft\", (unsigned int*)&flags, ImGuiComboFlags_PopupAlignLeft);\r\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_NoArrowButton\", (unsigned int*)&flags, ImGuiComboFlags_NoArrowButton))\r\n            flags &= ~ImGuiComboFlags_NoPreview;     // Clear the other flag, as we cannot combine both\r\n        if (ImGui::CheckboxFlags(\"ImGuiComboFlags_NoPreview\", (unsigned int*)&flags, ImGuiComboFlags_NoPreview))\r\n            flags &= ~ImGuiComboFlags_NoArrowButton; // Clear the other flag, as we cannot combine both\r\n\r\n        // General BeginCombo() API, you have full control over your selection data and display type.\r\n        // (your selection data could be an index, a pointer to the object, an id for the object, a flag stored in the object itself, etc.)\r\n        const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\", \"FFFF\", \"GGGG\", \"HHHH\", \"IIII\", \"JJJJ\", \"KKKK\", \"LLLLLLL\", \"MMMM\", \"OOOOOOO\" };\r\n        static const char* item_current = items[0];            // Here our selection is a single pointer stored outside the object.\r\n        if (ImGui::BeginCombo(\"combo 1\", item_current, flags)) // The second parameter is the label previewed before opening the combo.\r\n        {\r\n            for (int n = 0; n < IM_ARRAYSIZE(items); n++)\r\n            {\r\n                bool is_selected = (item_current == items[n]);\r\n                if (ImGui::Selectable(items[n], is_selected))\r\n                    item_current = items[n];\r\n                if (is_selected)\r\n                    ImGui::SetItemDefaultFocus();   // Set the initial focus when opening the combo (scrolling + for keyboard navigation support in the upcoming navigation branch)\r\n            }\r\n            ImGui::EndCombo();\r\n        }\r\n\r\n        // Simplified one-liner Combo() API, using values packed in a single constant string\r\n        static int item_current_2 = 0;\r\n        ImGui::Combo(\"combo 2 (one-liner)\", &item_current_2, \"aaaa\\0bbbb\\0cccc\\0dddd\\0eeee\\0\\0\");\r\n\r\n        // Simplified one-liner Combo() using an array of const char*\r\n        static int item_current_3 = -1; // If the selection isn't within 0..count, Combo won't display a preview\r\n        ImGui::Combo(\"combo 3 (array)\", &item_current_3, items, IM_ARRAYSIZE(items));\r\n\r\n        // Simplified one-liner Combo() using an accessor function\r\n        struct FuncHolder { static bool ItemGetter(void* data, int idx, const char** out_str) { *out_str = ((const char**)data)[idx]; return true; } };\r\n        static int item_current_4 = 0;\r\n        ImGui::Combo(\"combo 4 (function)\", &item_current_4, &FuncHolder::ItemGetter, items, IM_ARRAYSIZE(items));\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Selectables\"))\r\n    {\r\n        // Selectable() has 2 overloads:\r\n        // - The one taking \"bool selected\" as a read-only selection information. When Selectable() has been clicked is returns true and you can alter selection state accordingly.\r\n        // - The one taking \"bool* p_selected\" as a read-write selection information (convenient in some cases)\r\n        // The earlier is more flexible, as in real application your selection may be stored in a different manner (in flags within objects, as an external list, etc).\r\n        if (ImGui::TreeNode(\"Basic\"))\r\n        {\r\n            static bool selection[5] = { false, true, false, false, false };\r\n            ImGui::Selectable(\"1. I am selectable\", &selection[0]);\r\n            ImGui::Selectable(\"2. I am selectable\", &selection[1]);\r\n            ImGui::Text(\"3. I am not selectable\");\r\n            ImGui::Selectable(\"4. I am selectable\", &selection[3]);\r\n            if (ImGui::Selectable(\"5. I am double clickable\", selection[4], ImGuiSelectableFlags_AllowDoubleClick))\r\n                if (ImGui::IsMouseDoubleClicked(0))\r\n                    selection[4] = !selection[4];\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"Selection State: Single Selection\"))\r\n        {\r\n            static int selected = -1;\r\n            for (int n = 0; n < 5; n++)\r\n            {\r\n                char buf[32];\r\n                sprintf(buf, \"Object %d\", n);\r\n                if (ImGui::Selectable(buf, selected == n))\r\n                    selected = n;\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"Selection State: Multiple Selection\"))\r\n        {\r\n            ShowHelpMarker(\"Hold CTRL and click to select multiple items.\");\r\n            static bool selection[5] = { false, false, false, false, false };\r\n            for (int n = 0; n < 5; n++)\r\n            {\r\n                char buf[32];\r\n                sprintf(buf, \"Object %d\", n);\r\n                if (ImGui::Selectable(buf, selection[n]))\r\n                {\r\n                    if (!ImGui::GetIO().KeyCtrl)    // Clear selection when CTRL is not held\r\n                        memset(selection, 0, sizeof(selection));\r\n                    selection[n] ^= 1;\r\n                }\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"Rendering more text into the same line\"))\r\n        {\r\n            // Using the Selectable() override that takes \"bool* p_selected\" parameter and toggle your booleans automatically.\r\n            static bool selected[3] = { false, false, false };\r\n            ImGui::Selectable(\"main.c\",    &selected[0]); ImGui::SameLine(300); ImGui::Text(\" 2,345 bytes\");\r\n            ImGui::Selectable(\"Hello.cpp\", &selected[1]); ImGui::SameLine(300); ImGui::Text(\"12,345 bytes\");\r\n            ImGui::Selectable(\"Hello.h\",   &selected[2]); ImGui::SameLine(300); ImGui::Text(\" 2,345 bytes\");\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"In columns\"))\r\n        {\r\n            ImGui::Columns(3, NULL, false);\r\n            static bool selected[16] = { 0 };\r\n            for (int i = 0; i < 16; i++)\r\n            {\r\n                char label[32]; sprintf(label, \"Item %d\", i);\r\n                if (ImGui::Selectable(label, &selected[i])) {}\r\n                ImGui::NextColumn();\r\n            }\r\n            ImGui::Columns(1);\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"Grid\"))\r\n        {\r\n            static bool selected[16] = { true, false, false, false, false, true, false, false, false, false, true, false, false, false, false, true };\r\n            for (int i = 0; i < 16; i++)\r\n            {\r\n                ImGui::PushID(i);\r\n                if (ImGui::Selectable(\"Sailor\", &selected[i], 0, ImVec2(50,50)))\r\n                {\r\n                    int x = i % 4, y = i / 4;\r\n                    if (x > 0) selected[i - 1] ^= 1;\r\n                    if (x < 3) selected[i + 1] ^= 1;\r\n                    if (y > 0) selected[i - 4] ^= 1;\r\n                    if (y < 3) selected[i + 4] ^= 1;\r\n                }\r\n                if ((i % 4) < 3) ImGui::SameLine();\r\n                ImGui::PopID();\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Filtered Text Input\"))\r\n    {\r\n        static char buf1[64] = \"\"; ImGui::InputText(\"default\", buf1, 64);\r\n        static char buf2[64] = \"\"; ImGui::InputText(\"decimal\", buf2, 64, ImGuiInputTextFlags_CharsDecimal);\r\n        static char buf3[64] = \"\"; ImGui::InputText(\"hexadecimal\", buf3, 64, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);\r\n        static char buf4[64] = \"\"; ImGui::InputText(\"uppercase\", buf4, 64, ImGuiInputTextFlags_CharsUppercase);\r\n        static char buf5[64] = \"\"; ImGui::InputText(\"no blank\", buf5, 64, ImGuiInputTextFlags_CharsNoBlank);\r\n        struct TextFilters { static int FilterImGuiLetters(ImGuiInputTextCallbackData* data) { if (data->EventChar < 256 && strchr(\"imgui\", (char)data->EventChar)) return 0; return 1; } };\r\n        static char buf6[64] = \"\"; ImGui::InputText(\"\\\"imgui\\\" letters\", buf6, 64, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters);\r\n\r\n        ImGui::Text(\"Password input\");\r\n        static char bufpass[64] = \"password123\";\r\n        ImGui::InputText(\"password\", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);\r\n        ImGui::SameLine(); ShowHelpMarker(\"Display all characters as '*'.\\nDisable clipboard cut and copy.\\nDisable logging.\\n\");\r\n        ImGui::InputText(\"password (clear)\", bufpass, 64, ImGuiInputTextFlags_CharsNoBlank);\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Multi-line Text Input\"))\r\n    {\r\n        // Note: we are using a fixed-sized buffer for simplicity here. See ImGuiInputTextFlags_CallbackResize \r\n        // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.\r\n        static bool read_only = false;\r\n        static char text[1024*16] =\r\n            \"/*\\n\"\r\n            \" The Pentium F00F bug, shorthand for F0 0F C7 C8,\\n\"\r\n            \" the hexadecimal encoding of one offending instruction,\\n\"\r\n            \" more formally, the invalid operand with locked CMPXCHG8B\\n\"\r\n            \" instruction bug, is a design flaw in the majority of\\n\"\r\n            \" Intel Pentium, Pentium MMX, and Pentium OverDrive\\n\"\r\n            \" processors (all in the P5 microarchitecture).\\n\"\r\n            \"*/\\n\\n\"\r\n            \"label:\\n\"\r\n            \"\\tlock cmpxchg8b eax\\n\";\r\n\r\n        ShowHelpMarker(\"You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp)\");\r\n        ImGui::Checkbox(\"Read-only\", &read_only);\r\n        ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput | (read_only ? ImGuiInputTextFlags_ReadOnly : 0);\r\n        ImGui::InputTextMultiline(\"##source\", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), flags);\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Plots Widgets\"))\r\n    {\r\n        static bool animate = true;\r\n        ImGui::Checkbox(\"Animate\", &animate);\r\n\r\n        static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };\r\n        ImGui::PlotLines(\"Frame Times\", arr, IM_ARRAYSIZE(arr));\r\n\r\n        // Create a dummy array of contiguous float values to plot\r\n        // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float and the sizeof() of your structure in the Stride parameter.\r\n        static float values[90] = { 0 };\r\n        static int values_offset = 0;\r\n        static double refresh_time = 0.0;\r\n        if (!animate || refresh_time == 0.0f)\r\n            refresh_time = ImGui::GetTime();\r\n        while (refresh_time < ImGui::GetTime()) // Create dummy data at fixed 60 hz rate for the demo\r\n        {\r\n            static float phase = 0.0f;\r\n            values[values_offset] = cosf(phase);\r\n            values_offset = (values_offset+1) % IM_ARRAYSIZE(values);\r\n            phase += 0.10f*values_offset;\r\n            refresh_time += 1.0f/60.0f;\r\n        }\r\n        ImGui::PlotLines(\"Lines\", values, IM_ARRAYSIZE(values), values_offset, \"avg 0.0\", -1.0f, 1.0f, ImVec2(0,80));\r\n        ImGui::PlotHistogram(\"Histogram\", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0,80));\r\n\r\n        // Use functions to generate output\r\n        // FIXME: This is rather awkward because current plot API only pass in indices. We probably want an API passing floats and user provide sample rate/count.\r\n        struct Funcs\r\n        {\r\n            static float Sin(void*, int i) { return sinf(i * 0.1f); }\r\n            static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }\r\n        };\r\n        static int func_type = 0, display_count = 70;\r\n        ImGui::Separator();\r\n        ImGui::PushItemWidth(100); ImGui::Combo(\"func\", &func_type, \"Sin\\0Saw\\0\"); ImGui::PopItemWidth();\r\n        ImGui::SameLine();\r\n        ImGui::SliderInt(\"Sample count\", &display_count, 1, 400);\r\n        float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;\r\n        ImGui::PlotLines(\"Lines\", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));\r\n        ImGui::PlotHistogram(\"Histogram\", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));\r\n        ImGui::Separator();\r\n\r\n        // Animate a simple progress bar\r\n        static float progress = 0.0f, progress_dir = 1.0f;\r\n        if (animate)\r\n        {\r\n            progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;\r\n            if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }\r\n            if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }\r\n        }\r\n\r\n        // Typically we would use ImVec2(-1.0f,0.0f) to use all available width, or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.\r\n        ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));\r\n        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\r\n        ImGui::Text(\"Progress Bar\");\r\n\r\n        float progress_saturated = (progress < 0.0f) ? 0.0f : (progress > 1.0f) ? 1.0f : progress;\r\n        char buf[32];\r\n        sprintf(buf, \"%d/%d\", (int)(progress_saturated*1753), 1753);\r\n        ImGui::ProgressBar(progress, ImVec2(0.f,0.f), buf);\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Color/Picker Widgets\"))\r\n    {\r\n        static ImVec4 color = ImColor(114, 144, 154, 200);\r\n\r\n        static bool alpha_preview = true;\r\n        static bool alpha_half_preview = false;\r\n        static bool drag_and_drop = true;\r\n        static bool options_menu = true;\r\n        static bool hdr = false;\r\n        ImGui::Checkbox(\"With Alpha Preview\", &alpha_preview);\r\n        ImGui::Checkbox(\"With Half Alpha Preview\", &alpha_half_preview);\r\n        ImGui::Checkbox(\"With Drag and Drop\", &drag_and_drop);\r\n        ImGui::Checkbox(\"With Options Menu\", &options_menu); ImGui::SameLine(); ShowHelpMarker(\"Right-click on the individual color widget to show options.\");\r\n        ImGui::Checkbox(\"With HDR\", &hdr); ImGui::SameLine(); ShowHelpMarker(\"Currently all this does is to lift the 0..1 limits on dragging widgets.\");\r\n        int misc_flags = (hdr ? ImGuiColorEditFlags_HDR : 0) | (drag_and_drop ? 0 : ImGuiColorEditFlags_NoDragDrop) | (alpha_half_preview ? ImGuiColorEditFlags_AlphaPreviewHalf : (alpha_preview ? ImGuiColorEditFlags_AlphaPreview : 0)) | (options_menu ? 0 : ImGuiColorEditFlags_NoOptions);\r\n\r\n        ImGui::Text(\"Color widget:\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"Click on the colored square to open a color picker.\\nCTRL+click on individual component to input value.\\n\");\r\n        ImGui::ColorEdit3(\"MyColor##1\", (float*)&color, misc_flags);\r\n\r\n        ImGui::Text(\"Color widget HSV with Alpha:\");\r\n        ImGui::ColorEdit4(\"MyColor##2\", (float*)&color, ImGuiColorEditFlags_HSV | misc_flags);\r\n\r\n        ImGui::Text(\"Color widget with Float Display:\");\r\n        ImGui::ColorEdit4(\"MyColor##2f\", (float*)&color, ImGuiColorEditFlags_Float | misc_flags);\r\n\r\n        ImGui::Text(\"Color button with Picker:\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\\nWith the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only be used for the tooltip and picker popup.\");\r\n        ImGui::ColorEdit4(\"MyColor##3\", (float*)&color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | misc_flags);\r\n\r\n        ImGui::Text(\"Color button with Custom Picker Popup:\");\r\n\r\n        // Generate a dummy palette\r\n        static bool saved_palette_inited = false;\r\n        static ImVec4 saved_palette[32];\r\n        if (!saved_palette_inited)\r\n            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)\r\n            {\r\n                ImGui::ColorConvertHSVtoRGB(n / 31.0f, 0.8f, 0.8f, saved_palette[n].x, saved_palette[n].y, saved_palette[n].z);\r\n                saved_palette[n].w = 1.0f; // Alpha\r\n            }\r\n        saved_palette_inited = true;\r\n\r\n        static ImVec4 backup_color;\r\n        bool open_popup = ImGui::ColorButton(\"MyColor##3b\", color, misc_flags);\r\n        ImGui::SameLine();\r\n        open_popup |= ImGui::Button(\"Palette\");\r\n        if (open_popup)\r\n        {\r\n            ImGui::OpenPopup(\"mypicker\");\r\n            backup_color = color;\r\n        }\r\n        if (ImGui::BeginPopup(\"mypicker\"))\r\n        {\r\n            // FIXME: Adding a drag and drop example here would be perfect!\r\n            ImGui::Text(\"MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!\");\r\n            ImGui::Separator();\r\n            ImGui::ColorPicker4(\"##picker\", (float*)&color, misc_flags | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview);\r\n            ImGui::SameLine();\r\n            ImGui::BeginGroup();\r\n            ImGui::Text(\"Current\");\r\n            ImGui::ColorButton(\"##current\", color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40));\r\n            ImGui::Text(\"Previous\");\r\n            if (ImGui::ColorButton(\"##previous\", backup_color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40)))\r\n                color = backup_color;\r\n            ImGui::Separator();\r\n            ImGui::Text(\"Palette\");\r\n            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)\r\n            {\r\n                ImGui::PushID(n);\r\n                if ((n % 8) != 0)\r\n                    ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);\r\n                if (ImGui::ColorButton(\"##palette\", saved_palette[n], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip, ImVec2(20,20)))\r\n                    color = ImVec4(saved_palette[n].x, saved_palette[n].y, saved_palette[n].z, color.w); // Preserve alpha!\r\n\r\n                if (ImGui::BeginDragDropTarget())\r\n                {\r\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))\r\n                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);\r\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))\r\n                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);\r\n                    ImGui::EndDragDropTarget();\r\n                }\r\n\r\n                ImGui::PopID();\r\n            }\r\n            ImGui::EndGroup();\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        ImGui::Text(\"Color button only:\");\r\n        ImGui::ColorButton(\"MyColor##3c\", *(ImVec4*)&color, misc_flags, ImVec2(80,80));\r\n\r\n        ImGui::Text(\"Color picker:\");\r\n        static bool alpha = true;\r\n        static bool alpha_bar = true;\r\n        static bool side_preview = true;\r\n        static bool ref_color = false;\r\n        static ImVec4 ref_color_v(1.0f,0.0f,1.0f,0.5f);\r\n        static int inputs_mode = 2;\r\n        static int picker_mode = 0;\r\n        ImGui::Checkbox(\"With Alpha\", &alpha);\r\n        ImGui::Checkbox(\"With Alpha Bar\", &alpha_bar);\r\n        ImGui::Checkbox(\"With Side Preview\", &side_preview);\r\n        if (side_preview)\r\n        {\r\n            ImGui::SameLine();\r\n            ImGui::Checkbox(\"With Ref Color\", &ref_color);\r\n            if (ref_color)\r\n            {\r\n                ImGui::SameLine();\r\n                ImGui::ColorEdit4(\"##RefColor\", &ref_color_v.x, ImGuiColorEditFlags_NoInputs | misc_flags);\r\n            }\r\n        }\r\n        ImGui::Combo(\"Inputs Mode\", &inputs_mode, \"All Inputs\\0No Inputs\\0RGB Input\\0HSV Input\\0HEX Input\\0\");\r\n        ImGui::Combo(\"Picker Mode\", &picker_mode, \"Auto/Current\\0Hue bar + SV rect\\0Hue wheel + SV triangle\\0\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"User can right-click the picker to change mode.\");\r\n        ImGuiColorEditFlags flags = misc_flags;\r\n        if (!alpha) flags |= ImGuiColorEditFlags_NoAlpha; // This is by default if you call ColorPicker3() instead of ColorPicker4()\r\n        if (alpha_bar) flags |= ImGuiColorEditFlags_AlphaBar;\r\n        if (!side_preview) flags |= ImGuiColorEditFlags_NoSidePreview;\r\n        if (picker_mode == 1) flags |= ImGuiColorEditFlags_PickerHueBar;\r\n        if (picker_mode == 2) flags |= ImGuiColorEditFlags_PickerHueWheel;\r\n        if (inputs_mode == 1) flags |= ImGuiColorEditFlags_NoInputs;\r\n        if (inputs_mode == 2) flags |= ImGuiColorEditFlags_RGB;\r\n        if (inputs_mode == 3) flags |= ImGuiColorEditFlags_HSV;\r\n        if (inputs_mode == 4) flags |= ImGuiColorEditFlags_HEX;\r\n        ImGui::ColorPicker4(\"MyColor##4\", (float*)&color, flags, ref_color ? &ref_color_v.x : NULL);\r\n\r\n        ImGui::Text(\"Programmatically set defaults:\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"SetColorEditOptions() is designed to allow you to set boot-time default.\\nWe don't have Push/Pop functions because you can force options on a per-widget basis if needed, and the user can change non-forced ones with the options menu.\\nWe don't have a getter to avoid encouraging you to persistently save values that aren't forward-compatible.\");\r\n        if (ImGui::Button(\"Default: Uint8 + HSV + Hue Bar\"))\r\n            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_HSV | ImGuiColorEditFlags_PickerHueBar);\r\n        if (ImGui::Button(\"Default: Float + HDR + Hue Wheel\"))\r\n            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Float | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_PickerHueWheel);\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Range Widgets\"))\r\n    {\r\n        static float begin = 10, end = 90;\r\n        static int begin_i = 100, end_i = 1000;\r\n        ImGui::DragFloatRange2(\"range\", &begin, &end, 0.25f, 0.0f, 100.0f, \"Min: %.1f %%\", \"Max: %.1f %%\");\r\n        ImGui::DragIntRange2(\"range int (no bounds)\", &begin_i, &end_i, 5, 0, 0, \"Min: %d units\", \"Max: %d units\");\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Data Types\"))\r\n    {\r\n        // The DragScalar/InputScalar/SliderScalar functions allow various data types: signed/unsigned int/long long and float/double\r\n        // To avoid polluting the public API with all possible combinations, we use the ImGuiDataType enum to pass the type, \r\n        // and passing all arguments by address. \r\n        // This is the reason the test code below creates local variables to hold \"zero\" \"one\" etc. for each types.\r\n        // In practice, if you frequently use a given type that is not covered by the normal API entry points, you can wrap it \r\n        // yourself inside a 1 line function which can take typed argument as value instead of void*, and then pass their address \r\n        // to the generic function. For example:\r\n        //   bool MySliderU64(const char *label, u64* value, u64 min = 0, u64 max = 0, const char* format = \"%lld\") \r\n        //   { \r\n        //      return SliderScalar(label, ImGuiDataType_U64, value, &min, &max, format); \r\n        //   }\r\n\r\n        // Limits (as helper variables that we can take the address of)\r\n        // Note that the SliderScalar function has a maximum usable range of half the natural type maximum, hence the /2 below.\r\n        #ifndef LLONG_MIN\r\n        ImS64 LLONG_MIN = -9223372036854775807LL - 1;\r\n        ImS64 LLONG_MAX = 9223372036854775807LL;\r\n        ImU64 ULLONG_MAX = (2ULL * 9223372036854775807LL + 1);\r\n        #endif\r\n        const ImS32   s32_zero = 0,   s32_one = 1,   s32_fifty = 50, s32_min = INT_MIN/2,   s32_max = INT_MAX/2,    s32_hi_a = INT_MAX/2 - 100,    s32_hi_b = INT_MAX/2;\r\n        const ImU32   u32_zero = 0,   u32_one = 1,   u32_fifty = 50, u32_min = 0,           u32_max = UINT_MAX/2,   u32_hi_a = UINT_MAX/2 - 100,   u32_hi_b = UINT_MAX/2;\r\n        const ImS64   s64_zero = 0,   s64_one = 1,   s64_fifty = 50, s64_min = LLONG_MIN/2, s64_max = LLONG_MAX/2,  s64_hi_a = LLONG_MAX/2 - 100,  s64_hi_b = LLONG_MAX/2;\r\n        const ImU64   u64_zero = 0,   u64_one = 1,   u64_fifty = 50, u64_min = 0,           u64_max = ULLONG_MAX/2, u64_hi_a = ULLONG_MAX/2 - 100, u64_hi_b = ULLONG_MAX/2;\r\n        const float   f32_zero = 0.f, f32_one = 1.f, f32_lo_a = -10000000000.0f, f32_hi_a = +10000000000.0f;\r\n        const double  f64_zero = 0.,  f64_one = 1.,  f64_lo_a = -1000000000000000.0, f64_hi_a = +1000000000000000.0;\r\n\r\n        // State\r\n        static ImS32  s32_v = -1;\r\n        static ImU32  u32_v = (ImU32)-1;\r\n        static ImS64  s64_v = -1;\r\n        static ImU64  u64_v = (ImU64)-1;\r\n        static float  f32_v = 0.123f;\r\n        static double f64_v = 90000.01234567890123456789;\r\n\r\n        const float drag_speed = 0.2f;\r\n        static bool drag_clamp = false;\r\n        ImGui::Text(\"Drags:\");\r\n        ImGui::Checkbox(\"Clamp integers to 0..50\", &drag_clamp); ImGui::SameLine(); ShowHelpMarker(\"As with every widgets in dear imgui, we never modify values unless there is a user interaction.\\nYou can override the clamping limits by using CTRL+Click to input a value.\");\r\n        ImGui::DragScalar(\"drag s32\",       ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL);\r\n        ImGui::DragScalar(\"drag u32\",       ImGuiDataType_U32,    &u32_v, drag_speed, drag_clamp ? &u32_zero : NULL, drag_clamp ? &u32_fifty : NULL, \"%u ms\");\r\n        ImGui::DragScalar(\"drag s64\",       ImGuiDataType_S64,    &s64_v, drag_speed, drag_clamp ? &s64_zero : NULL, drag_clamp ? &s64_fifty : NULL);\r\n        ImGui::DragScalar(\"drag u64\",       ImGuiDataType_U64,    &u64_v, drag_speed, drag_clamp ? &u64_zero : NULL, drag_clamp ? &u64_fifty : NULL);\r\n        ImGui::DragScalar(\"drag float\",     ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, \"%f\", 1.0f);\r\n        ImGui::DragScalar(\"drag float ^2\",  ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, \"%f\", 2.0f); ImGui::SameLine(); ShowHelpMarker(\"You can use the 'power' parameter to increase tweaking precision on one side of the range.\");\r\n        ImGui::DragScalar(\"drag double\",    ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, NULL,     \"%.10f grams\", 1.0f);\r\n        ImGui::DragScalar(\"drag double ^2\", ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, &f64_one, \"0 < %.10f < 1\", 2.0f);\r\n\r\n        ImGui::Text(\"Sliders\");\r\n        ImGui::SliderScalar(\"slider s32 low\",     ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty,\"%d\");\r\n        ImGui::SliderScalar(\"slider s32 high\",    ImGuiDataType_S32,    &s32_v, &s32_hi_a, &s32_hi_b, \"%d\");\r\n        ImGui::SliderScalar(\"slider s32 full\",    ImGuiDataType_S32,    &s32_v, &s32_min,  &s32_max,  \"%d\");\r\n        ImGui::SliderScalar(\"slider u32 low\",     ImGuiDataType_U32,    &u32_v, &u32_zero, &u32_fifty,\"%u\");\r\n        ImGui::SliderScalar(\"slider u32 high\",    ImGuiDataType_U32,    &u32_v, &u32_hi_a, &u32_hi_b, \"%u\");\r\n        ImGui::SliderScalar(\"slider u32 full\",    ImGuiDataType_U32,    &u32_v, &u32_min,  &u32_max,  \"%u\");\r\n        ImGui::SliderScalar(\"slider s64 low\",     ImGuiDataType_S64,    &s64_v, &s64_zero, &s64_fifty,\"%I64d\");\r\n        ImGui::SliderScalar(\"slider s64 high\",    ImGuiDataType_S64,    &s64_v, &s64_hi_a, &s64_hi_b, \"%I64d\");\r\n        ImGui::SliderScalar(\"slider s64 full\",    ImGuiDataType_S64,    &s64_v, &s64_min,  &s64_max,  \"%I64d\");\r\n        ImGui::SliderScalar(\"slider u64 low\",     ImGuiDataType_U64,    &u64_v, &u64_zero, &u64_fifty,\"%I64u ms\");\r\n        ImGui::SliderScalar(\"slider u64 high\",    ImGuiDataType_U64,    &u64_v, &u64_hi_a, &u64_hi_b, \"%I64u ms\");\r\n        ImGui::SliderScalar(\"slider u64 full\",    ImGuiDataType_U64,    &u64_v, &u64_min,  &u64_max,  \"%I64u ms\");\r\n        ImGui::SliderScalar(\"slider float low\",   ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one);\r\n        ImGui::SliderScalar(\"slider float low^2\", ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one,  \"%.10f\", 2.0f);\r\n        ImGui::SliderScalar(\"slider float high\",  ImGuiDataType_Float,  &f32_v, &f32_lo_a, &f32_hi_a, \"%e\");\r\n        ImGui::SliderScalar(\"slider double low\",  ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  \"%.10f grams\", 1.0f);\r\n        ImGui::SliderScalar(\"slider double low^2\",ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  \"%.10f\", 2.0f);\r\n        ImGui::SliderScalar(\"slider double high\", ImGuiDataType_Double, &f64_v, &f64_lo_a, &f64_hi_a, \"%e grams\", 1.0f);\r\n\r\n        static bool inputs_step = true;\r\n        ImGui::Text(\"Inputs\");\r\n        ImGui::Checkbox(\"Show step buttons\", &inputs_step);\r\n        ImGui::InputScalar(\"input s32\",     ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, \"%d\");\r\n        ImGui::InputScalar(\"input s32 hex\", ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, \"%08X\", ImGuiInputTextFlags_CharsHexadecimal);\r\n        ImGui::InputScalar(\"input u32\",     ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, \"%u\");\r\n        ImGui::InputScalar(\"input u32 hex\", ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, \"%08X\", ImGuiInputTextFlags_CharsHexadecimal);\r\n        ImGui::InputScalar(\"input s64\",     ImGuiDataType_S64,    &s64_v, inputs_step ? &s64_one : NULL);\r\n        ImGui::InputScalar(\"input u64\",     ImGuiDataType_U64,    &u64_v, inputs_step ? &u64_one : NULL);\r\n        ImGui::InputScalar(\"input float\",   ImGuiDataType_Float,  &f32_v, inputs_step ? &f32_one : NULL);\r\n        ImGui::InputScalar(\"input double\",  ImGuiDataType_Double, &f64_v, inputs_step ? &f64_one : NULL);\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Multi-component Widgets\"))\r\n    {\r\n        static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };\r\n        static int vec4i[4] = { 1, 5, 100, 255 };\r\n\r\n        ImGui::InputFloat2(\"input float2\", vec4f);\r\n        ImGui::DragFloat2(\"drag float2\", vec4f, 0.01f, 0.0f, 1.0f);\r\n        ImGui::SliderFloat2(\"slider float2\", vec4f, 0.0f, 1.0f);\r\n        ImGui::InputInt2(\"input int2\", vec4i);\r\n        ImGui::DragInt2(\"drag int2\", vec4i, 1, 0, 255);\r\n        ImGui::SliderInt2(\"slider int2\", vec4i, 0, 255);\r\n        ImGui::Spacing();\r\n\r\n        ImGui::InputFloat3(\"input float3\", vec4f);\r\n        ImGui::DragFloat3(\"drag float3\", vec4f, 0.01f, 0.0f, 1.0f);\r\n        ImGui::SliderFloat3(\"slider float3\", vec4f, 0.0f, 1.0f);\r\n        ImGui::InputInt3(\"input int3\", vec4i);\r\n        ImGui::DragInt3(\"drag int3\", vec4i, 1, 0, 255);\r\n        ImGui::SliderInt3(\"slider int3\", vec4i, 0, 255);\r\n        ImGui::Spacing();\r\n\r\n        ImGui::InputFloat4(\"input float4\", vec4f);\r\n        ImGui::DragFloat4(\"drag float4\", vec4f, 0.01f, 0.0f, 1.0f);\r\n        ImGui::SliderFloat4(\"slider float4\", vec4f, 0.0f, 1.0f);\r\n        ImGui::InputInt4(\"input int4\", vec4i);\r\n        ImGui::DragInt4(\"drag int4\", vec4i, 1, 0, 255);\r\n        ImGui::SliderInt4(\"slider int4\", vec4i, 0, 255);\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Vertical Sliders\"))\r\n    {\r\n        const float spacing = 4;\r\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));\r\n\r\n        static int int_value = 0;\r\n        ImGui::VSliderInt(\"##int\", ImVec2(18,160), &int_value, 0, 5);\r\n        ImGui::SameLine();\r\n\r\n        static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };\r\n        ImGui::PushID(\"set1\");\r\n        for (int i = 0; i < 7; i++)\r\n        {\r\n            if (i > 0) ImGui::SameLine();\r\n            ImGui::PushID(i);\r\n            ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(i/7.0f, 0.5f, 0.5f));\r\n            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.5f));\r\n            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.5f));\r\n            ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(i/7.0f, 0.9f, 0.9f));\r\n            ImGui::VSliderFloat(\"##v\", ImVec2(18,160), &values[i], 0.0f, 1.0f, \"\");\r\n            if (ImGui::IsItemActive() || ImGui::IsItemHovered())\r\n                ImGui::SetTooltip(\"%.3f\", values[i]);\r\n            ImGui::PopStyleColor(4);\r\n            ImGui::PopID();\r\n        }\r\n        ImGui::PopID();\r\n\r\n        ImGui::SameLine();\r\n        ImGui::PushID(\"set2\");\r\n        static float values2[4] = { 0.20f, 0.80f, 0.40f, 0.25f };\r\n        const int rows = 3;\r\n        const ImVec2 small_slider_size(18, (160.0f-(rows-1)*spacing)/rows);\r\n        for (int nx = 0; nx < 4; nx++)\r\n        {\r\n            if (nx > 0) ImGui::SameLine();\r\n            ImGui::BeginGroup();\r\n            for (int ny = 0; ny < rows; ny++)\r\n            {\r\n                ImGui::PushID(nx*rows+ny);\r\n                ImGui::VSliderFloat(\"##v\", small_slider_size, &values2[nx], 0.0f, 1.0f, \"\");\r\n                if (ImGui::IsItemActive() || ImGui::IsItemHovered())\r\n                    ImGui::SetTooltip(\"%.3f\", values2[nx]);\r\n                ImGui::PopID();\r\n            }\r\n            ImGui::EndGroup();\r\n        }\r\n        ImGui::PopID();\r\n\r\n        ImGui::SameLine();\r\n        ImGui::PushID(\"set3\");\r\n        for (int i = 0; i < 4; i++)\r\n        {\r\n            if (i > 0) ImGui::SameLine();\r\n            ImGui::PushID(i);\r\n            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);\r\n            ImGui::VSliderFloat(\"##v\", ImVec2(40,160), &values[i], 0.0f, 1.0f, \"%.2f\\nsec\");\r\n            ImGui::PopStyleVar();\r\n            ImGui::PopID();\r\n        }\r\n        ImGui::PopID();\r\n        ImGui::PopStyleVar();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Drag and Drop\"))\r\n    {\r\n        {\r\n            // ColorEdit widgets automatically act as drag source and drag target.\r\n            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F and IMGUI_PAYLOAD_TYPE_COLOR_4F to allow your own widgets\r\n            // to use colors in their drag and drop interaction. Also see the demo in Color Picker -> Palette demo.\r\n            ImGui::BulletText(\"Drag and drop in standard widgets\");\r\n            ImGui::Indent();\r\n            static float col1[3] = { 1.0f,0.0f,0.2f };\r\n            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };\r\n            ImGui::ColorEdit3(\"color 1\", col1);\r\n            ImGui::ColorEdit4(\"color 2\", col2);\r\n            ImGui::Unindent();\r\n        }\r\n\r\n        {\r\n            ImGui::BulletText(\"Drag and drop to copy/swap items\");\r\n            ImGui::Indent();\r\n            enum Mode\r\n            {\r\n                Mode_Copy,\r\n                Mode_Move,\r\n                Mode_Swap\r\n            };\r\n            static int mode = 0;\r\n            if (ImGui::RadioButton(\"Copy\", mode == Mode_Copy)) { mode = Mode_Copy; } ImGui::SameLine();\r\n            if (ImGui::RadioButton(\"Move\", mode == Mode_Move)) { mode = Mode_Move; } ImGui::SameLine();\r\n            if (ImGui::RadioButton(\"Swap\", mode == Mode_Swap)) { mode = Mode_Swap; } \r\n            static const char* names[9] = { \"Bobby\", \"Beatrice\", \"Betty\", \"Brianna\", \"Barry\", \"Bernard\", \"Bibi\", \"Blaine\", \"Bryn\" };\r\n            for (int n = 0; n < IM_ARRAYSIZE(names); n++)\r\n            {\r\n                ImGui::PushID(n);\r\n                if ((n % 3) != 0)\r\n                    ImGui::SameLine();\r\n                ImGui::Button(names[n], ImVec2(60,60));\r\n\r\n                // Our buttons are both drag sources and drag targets here!\r\n                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))\r\n                {\r\n                    ImGui::SetDragDropPayload(\"DND_DEMO_CELL\", &n, sizeof(int));        // Set payload to carry the index of our item (could be anything)\r\n                    if (mode == Mode_Copy) { ImGui::Text(\"Copy %s\", names[n]); }        // Display preview (could be anything, e.g. when dragging an image we could decide to display the filename and a small preview of the image, etc.)\r\n                    if (mode == Mode_Move) { ImGui::Text(\"Move %s\", names[n]); }\r\n                    if (mode == Mode_Swap) { ImGui::Text(\"Swap %s\", names[n]); }\r\n                    ImGui::EndDragDropSource();\r\n                }\r\n                if (ImGui::BeginDragDropTarget())\r\n                {\r\n                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(\"DND_DEMO_CELL\"))\r\n                    {\r\n                        IM_ASSERT(payload->DataSize == sizeof(int));\r\n                        int payload_n = *(const int*)payload->Data;\r\n                        if (mode == Mode_Copy)\r\n                        {\r\n                            names[n] = names[payload_n];\r\n                        }\r\n                        if (mode == Mode_Move)\r\n                        {\r\n                            names[n] = names[payload_n];\r\n                            names[payload_n] = \"\";\r\n                        }\r\n                        if (mode == Mode_Swap)\r\n                        {\r\n                            const char* tmp = names[n];\r\n                            names[n] = names[payload_n];\r\n                            names[payload_n] = tmp;\r\n                        }\r\n                    }\r\n                    ImGui::EndDragDropTarget();\r\n                }\r\n                ImGui::PopID();\r\n            }\r\n            ImGui::Unindent();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Querying Status (Active/Focused/Hovered etc.)\"))\r\n    {\r\n        // Display the value of IsItemHovered() and other common item state functions. Note that the flags can be combined.\r\n        // (because BulletText is an item itself and that would affect the output of IsItemHovered() we pass all state in a single call to simplify the code).\r\n        static int item_type = 1;\r\n        static bool b = false;\r\n        static float col4f[4] = { 1.0f, 0.5, 0.0f, 1.0f };\r\n        ImGui::RadioButton(\"Text\", &item_type, 0);\r\n        ImGui::RadioButton(\"Button\", &item_type, 1);\r\n        ImGui::RadioButton(\"CheckBox\", &item_type, 2);\r\n        ImGui::RadioButton(\"SliderFloat\", &item_type, 3);\r\n        ImGui::RadioButton(\"ColorEdit4\", &item_type, 4);\r\n        ImGui::RadioButton(\"ListBox\", &item_type, 5);\r\n        ImGui::Separator();\r\n        bool ret = false;\r\n        if (item_type == 0) { ImGui::Text(\"ITEM: Text\"); }                                              // Testing text items with no identifier/interaction\r\n        if (item_type == 1) { ret = ImGui::Button(\"ITEM: Button\"); }                                    // Testing button\r\n        if (item_type == 2) { ret = ImGui::Checkbox(\"ITEM: CheckBox\", &b); }                            // Testing checkbox\r\n        if (item_type == 3) { ret = ImGui::SliderFloat(\"ITEM: SliderFloat\", &col4f[0], 0.0f, 1.0f); }   // Testing basic item\r\n        if (item_type == 4) { ret = ImGui::ColorEdit4(\"ITEM: ColorEdit4\", col4f); }                     // Testing multi-component items (IsItemXXX flags are reported merged)\r\n        if (item_type == 5) { const char* items[] = { \"Apple\", \"Banana\", \"Cherry\", \"Kiwi\" }; static int current = 1; ret = ImGui::ListBox(\"ITEM: ListBox\", &current, items, IM_ARRAYSIZE(items), IM_ARRAYSIZE(items)); }\r\n        ImGui::BulletText(\r\n            \"Return value = %d\\n\"\r\n            \"IsItemFocused() = %d\\n\"\r\n            \"IsItemHovered() = %d\\n\"\r\n            \"IsItemHovered(_AllowWhenBlockedByPopup) = %d\\n\"\r\n            \"IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\\n\"\r\n            \"IsItemHovered(_AllowWhenOverlapped) = %d\\n\"\r\n            \"IsItemHovered(_RectOnly) = %d\\n\"\r\n            \"IsItemActive() = %d\\n\"\r\n            \"IsItemEdited() = %d\\n\"\r\n            \"IsItemDeactivated() = %d\\n\"\r\n            \"IsItemDeactivatedEdit() = %d\\n\"\r\n            \"IsItemVisible() = %d\\n\"\r\n            \"GetItemRectMin() = (%.1f, %.1f)\\n\"\r\n            \"GetItemRectMax() = (%.1f, %.1f)\\n\"\r\n            \"GetItemRectSize() = (%.1f, %.1f)\",\r\n            ret,\r\n            ImGui::IsItemFocused(),\r\n            ImGui::IsItemHovered(),\r\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),\r\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),\r\n            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlapped),\r\n            ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly),\r\n            ImGui::IsItemActive(),\r\n            ImGui::IsItemEdited(),\r\n            ImGui::IsItemDeactivated(),\r\n            ImGui::IsItemDeactivatedAfterEdit(),\r\n            ImGui::IsItemVisible(),\r\n            ImGui::GetItemRectMin().x, ImGui::GetItemRectMin().y,\r\n            ImGui::GetItemRectMax().x, ImGui::GetItemRectMax().y,\r\n            ImGui::GetItemRectSize().x, ImGui::GetItemRectSize().y\r\n        );\r\n\r\n        static bool embed_all_inside_a_child_window = false;\r\n        ImGui::Checkbox(\"Embed everything inside a child window (for additional testing)\", &embed_all_inside_a_child_window);\r\n        if (embed_all_inside_a_child_window)\r\n            ImGui::BeginChild(\"outer_child\", ImVec2(0, ImGui::GetFontSize() * 20), true);\r\n\r\n        // Testing IsWindowFocused() function with its various flags. Note that the flags can be combined.\r\n        ImGui::BulletText(\r\n            \"IsWindowFocused() = %d\\n\"\r\n            \"IsWindowFocused(_ChildWindows) = %d\\n\"\r\n            \"IsWindowFocused(_ChildWindows|_RootWindow) = %d\\n\"\r\n            \"IsWindowFocused(_RootWindow) = %d\\n\"\r\n            \"IsWindowFocused(_AnyWindow) = %d\\n\",\r\n            ImGui::IsWindowFocused(),\r\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows),\r\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow),\r\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow),\r\n            ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow));\r\n\r\n        // Testing IsWindowHovered() function with its various flags. Note that the flags can be combined.\r\n        ImGui::BulletText(\r\n            \"IsWindowHovered() = %d\\n\"\r\n            \"IsWindowHovered(_AllowWhenBlockedByPopup) = %d\\n\"\r\n            \"IsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\\n\"\r\n            \"IsWindowHovered(_ChildWindows) = %d\\n\"\r\n            \"IsWindowHovered(_ChildWindows|_RootWindow) = %d\\n\"\r\n            \"IsWindowHovered(_RootWindow) = %d\\n\"\r\n            \"IsWindowHovered(_AnyWindow) = %d\\n\",\r\n            ImGui::IsWindowHovered(),\r\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),\r\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),\r\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows),\r\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow),\r\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow),\r\n            ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow));\r\n\r\n        ImGui::BeginChild(\"child\", ImVec2(0, 50), true);\r\n        ImGui::Text(\"This is another child window for testing with the _ChildWindows flag.\");\r\n        ImGui::EndChild();\r\n        if (embed_all_inside_a_child_window)\r\n            ImGui::EndChild();\r\n\r\n        // Calling IsItemHovered() after begin returns the hovered status of the title bar. \r\n        // This is useful in particular if you want to create a context menu (with BeginPopupContextItem) associated to the title bar of a window.\r\n        static bool test_window = false;\r\n        ImGui::Checkbox(\"Hovered/Active tests after Begin() for title bar testing\", &test_window);\r\n        if (test_window)\r\n        {\r\n            ImGui::Begin(\"Title bar Hovered/Active tests\", &test_window);\r\n            if (ImGui::BeginPopupContextItem()) // <-- This is using IsItemHovered()\r\n            {\r\n                if (ImGui::MenuItem(\"Close\")) { test_window = false; }\r\n                ImGui::EndPopup();\r\n            }\r\n            ImGui::Text(\r\n                \"IsItemHovered() after begin = %d (== is title bar hovered)\\n\"\r\n                \"IsItemActive() after begin = %d (== is window being clicked/moved)\\n\",\r\n                ImGui::IsItemHovered(), ImGui::IsItemActive());\r\n            ImGui::End();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n}\r\n\r\nstatic void ShowDemoWindowLayout()\r\n{\r\n    if (!ImGui::CollapsingHeader(\"Layout\"))\r\n        return;\r\n\r\n    if (ImGui::TreeNode(\"Child regions\"))\r\n    {\r\n        static bool disable_mouse_wheel = false;\r\n        static bool disable_menu = false;\r\n        ImGui::Checkbox(\"Disable Mouse Wheel\", &disable_mouse_wheel);\r\n        ImGui::Checkbox(\"Disable Menu\", &disable_menu);\r\n\r\n        static int line = 50;\r\n        bool goto_line = ImGui::Button(\"Goto\");\r\n        ImGui::SameLine();\r\n        ImGui::PushItemWidth(100);\r\n        goto_line |= ImGui::InputInt(\"##Line\", &line, 0, 0, ImGuiInputTextFlags_EnterReturnsTrue);\r\n        ImGui::PopItemWidth();\r\n\r\n        // Child 1: no border, enable horizontal scrollbar\r\n        {\r\n            ImGui::BeginChild(\"Child1\", ImVec2(ImGui::GetWindowContentRegionWidth() * 0.5f, 300), false, ImGuiWindowFlags_HorizontalScrollbar | (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0));\r\n            for (int i = 0; i < 100; i++)\r\n            {\r\n                ImGui::Text(\"%04d: scrollable region\", i);\r\n                if (goto_line && line == i)\r\n                    ImGui::SetScrollHereY();\r\n            }\r\n            if (goto_line && line >= 100)\r\n                ImGui::SetScrollHereY();\r\n            ImGui::EndChild();\r\n        }\r\n\r\n        ImGui::SameLine();\r\n\r\n        // Child 2: rounded border\r\n        {\r\n            ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 5.0f);\r\n            ImGui::BeginChild(\"Child2\", ImVec2(0, 300), true, (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0) | (disable_menu ? 0 : ImGuiWindowFlags_MenuBar));\r\n            if (!disable_menu && ImGui::BeginMenuBar())\r\n            {\r\n                if (ImGui::BeginMenu(\"Menu\"))\r\n                {\r\n                    ShowExampleMenuFile();\r\n                    ImGui::EndMenu();\r\n                }\r\n                ImGui::EndMenuBar();\r\n            }\r\n            ImGui::Columns(2);\r\n            for (int i = 0; i < 100; i++)\r\n            {\r\n                char buf[32];\r\n                sprintf(buf, \"%03d\", i);\r\n                ImGui::Button(buf, ImVec2(-1.0f, 0.0f));\r\n                ImGui::NextColumn();\r\n            }\r\n            ImGui::EndChild();\r\n            ImGui::PopStyleVar();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Widgets Width\"))\r\n    {\r\n        static float f = 0.0f;\r\n        ImGui::Text(\"PushItemWidth(100)\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"Fixed width.\");\r\n        ImGui::PushItemWidth(100);\r\n        ImGui::DragFloat(\"float##1\", &f);\r\n        ImGui::PopItemWidth();\r\n\r\n        ImGui::Text(\"PushItemWidth(GetWindowWidth() * 0.5f)\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"Half of window width.\");\r\n        ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.5f);\r\n        ImGui::DragFloat(\"float##2\", &f);\r\n        ImGui::PopItemWidth();\r\n\r\n        ImGui::Text(\"PushItemWidth(GetContentRegionAvailWidth() * 0.5f)\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"Half of available width.\\n(~ right-cursor_pos)\\n(works within a column set)\");\r\n        ImGui::PushItemWidth(ImGui::GetContentRegionAvailWidth() * 0.5f);\r\n        ImGui::DragFloat(\"float##3\", &f);\r\n        ImGui::PopItemWidth();\r\n\r\n        ImGui::Text(\"PushItemWidth(-100)\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"Align to right edge minus 100\");\r\n        ImGui::PushItemWidth(-100);\r\n        ImGui::DragFloat(\"float##4\", &f);\r\n        ImGui::PopItemWidth();\r\n\r\n        ImGui::Text(\"PushItemWidth(-1)\");\r\n        ImGui::SameLine(); ShowHelpMarker(\"Align to right edge\");\r\n        ImGui::PushItemWidth(-1);\r\n        ImGui::DragFloat(\"float##5\", &f);\r\n        ImGui::PopItemWidth();\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Basic Horizontal Layout\"))\r\n    {\r\n        ImGui::TextWrapped(\"(Use ImGui::SameLine() to keep adding items to the right of the preceding item)\");\r\n\r\n        // Text\r\n        ImGui::Text(\"Two items: Hello\"); ImGui::SameLine();\r\n        ImGui::TextColored(ImVec4(1,1,0,1), \"Sailor\");\r\n\r\n        // Adjust spacing\r\n        ImGui::Text(\"More spacing: Hello\"); ImGui::SameLine(0, 20);\r\n        ImGui::TextColored(ImVec4(1,1,0,1), \"Sailor\");\r\n\r\n        // Button\r\n        ImGui::AlignTextToFramePadding();\r\n        ImGui::Text(\"Normal buttons\"); ImGui::SameLine();\r\n        ImGui::Button(\"Banana\"); ImGui::SameLine();\r\n        ImGui::Button(\"Apple\"); ImGui::SameLine();\r\n        ImGui::Button(\"Corniflower\");\r\n\r\n        // Button\r\n        ImGui::Text(\"Small buttons\"); ImGui::SameLine();\r\n        ImGui::SmallButton(\"Like this one\"); ImGui::SameLine();\r\n        ImGui::Text(\"can fit within a text block.\");\r\n\r\n        // Aligned to arbitrary position. Easy/cheap column.\r\n        ImGui::Text(\"Aligned\");\r\n        ImGui::SameLine(150); ImGui::Text(\"x=150\");\r\n        ImGui::SameLine(300); ImGui::Text(\"x=300\");\r\n        ImGui::Text(\"Aligned\");\r\n        ImGui::SameLine(150); ImGui::SmallButton(\"x=150\");\r\n        ImGui::SameLine(300); ImGui::SmallButton(\"x=300\");\r\n\r\n        // Checkbox\r\n        static bool c1 = false, c2 = false, c3 = false, c4 = false;\r\n        ImGui::Checkbox(\"My\", &c1); ImGui::SameLine();\r\n        ImGui::Checkbox(\"Tailor\", &c2); ImGui::SameLine();\r\n        ImGui::Checkbox(\"Is\", &c3); ImGui::SameLine();\r\n        ImGui::Checkbox(\"Rich\", &c4);\r\n\r\n        // Various\r\n        static float f0 = 1.0f, f1 = 2.0f, f2 = 3.0f;\r\n        ImGui::PushItemWidth(80);\r\n        const char* items[] = { \"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\" };\r\n        static int item = -1;\r\n        ImGui::Combo(\"Combo\", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();\r\n        ImGui::SliderFloat(\"X\", &f0, 0.0f, 5.0f); ImGui::SameLine();\r\n        ImGui::SliderFloat(\"Y\", &f1, 0.0f, 5.0f); ImGui::SameLine();\r\n        ImGui::SliderFloat(\"Z\", &f2, 0.0f, 5.0f);\r\n        ImGui::PopItemWidth();\r\n\r\n        ImGui::PushItemWidth(80);\r\n        ImGui::Text(\"Lists:\");\r\n        static int selection[4] = { 0, 1, 2, 3 };\r\n        for (int i = 0; i < 4; i++)\r\n        {\r\n            if (i > 0) ImGui::SameLine();\r\n            ImGui::PushID(i);\r\n            ImGui::ListBox(\"\", &selection[i], items, IM_ARRAYSIZE(items));\r\n            ImGui::PopID();\r\n            //if (ImGui::IsItemHovered()) ImGui::SetTooltip(\"ListBox %d hovered\", i);\r\n        }\r\n        ImGui::PopItemWidth();\r\n\r\n        // Dummy\r\n        ImVec2 button_sz(40, 40);\r\n        ImGui::Button(\"A\", button_sz); ImGui::SameLine();\r\n        ImGui::Dummy(button_sz); ImGui::SameLine();\r\n        ImGui::Button(\"B\", button_sz);\r\n\r\n        // Manually wrapping (we should eventually provide this as an automatic layout feature, but for now you can do it manually)\r\n        ImGui::Text(\"Manually wrapping:\");\r\n        ImGuiStyle& style = ImGui::GetStyle();\r\n        int buttons_count = 20;\r\n        float window_visible_x2 = ImGui::GetWindowPos().x + ImGui::GetWindowContentRegionMax().x;\r\n        for (int n = 0; n < buttons_count; n++)\r\n        {\r\n            ImGui::PushID(n);\r\n            ImGui::Button(\"Box\", button_sz);\r\n            float last_button_x2 = ImGui::GetItemRectMax().x;\r\n            float next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line\r\n            if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)\r\n                ImGui::SameLine();\r\n            ImGui::PopID();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Groups\"))\r\n    {\r\n        ImGui::TextWrapped(\"(Using ImGui::BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.)\");\r\n        ImGui::BeginGroup();\r\n        {\r\n            ImGui::BeginGroup();\r\n            ImGui::Button(\"AAA\");\r\n            ImGui::SameLine();\r\n            ImGui::Button(\"BBB\");\r\n            ImGui::SameLine();\r\n            ImGui::BeginGroup();\r\n            ImGui::Button(\"CCC\");\r\n            ImGui::Button(\"DDD\");\r\n            ImGui::EndGroup();\r\n            ImGui::SameLine();\r\n            ImGui::Button(\"EEE\");\r\n            ImGui::EndGroup();\r\n            if (ImGui::IsItemHovered())\r\n                ImGui::SetTooltip(\"First group hovered\");\r\n        }\r\n        // Capture the group size and create widgets using the same size\r\n        ImVec2 size = ImGui::GetItemRectSize();\r\n        const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };\r\n        ImGui::PlotHistogram(\"##values\", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);\r\n\r\n        ImGui::Button(\"ACTION\", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));\r\n        ImGui::SameLine();\r\n        ImGui::Button(\"REACTION\", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));\r\n        ImGui::EndGroup();\r\n        ImGui::SameLine();\r\n\r\n        ImGui::Button(\"LEVERAGE\\nBUZZWORD\", size);\r\n        ImGui::SameLine();\r\n\r\n        if (ImGui::ListBoxHeader(\"List\", size))\r\n        {\r\n            ImGui::Selectable(\"Selected\", true);\r\n            ImGui::Selectable(\"Not Selected\", false);\r\n            ImGui::ListBoxFooter();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Text Baseline Alignment\"))\r\n    {\r\n        ImGui::TextWrapped(\"(This is testing the vertical alignment that occurs on text to keep it at the same baseline as widgets. Lines only composed of text or \\\"small\\\" widgets fit in less vertical spaces than lines with normal widgets)\");\r\n\r\n        ImGui::Text(\"One\\nTwo\\nThree\"); ImGui::SameLine();\r\n        ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\r\n        ImGui::Text(\"Banana\");\r\n\r\n        ImGui::Text(\"Banana\"); ImGui::SameLine();\r\n        ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\r\n        ImGui::Text(\"One\\nTwo\\nThree\");\r\n\r\n        ImGui::Button(\"HOP##1\"); ImGui::SameLine();\r\n        ImGui::Text(\"Banana\"); ImGui::SameLine();\r\n        ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\r\n        ImGui::Text(\"Banana\");\r\n\r\n        ImGui::Button(\"HOP##2\"); ImGui::SameLine();\r\n        ImGui::Text(\"Hello\\nWorld\"); ImGui::SameLine();\r\n        ImGui::Text(\"Banana\");\r\n\r\n        ImGui::Button(\"TEST##1\"); ImGui::SameLine();\r\n        ImGui::Text(\"TEST\"); ImGui::SameLine();\r\n        ImGui::SmallButton(\"TEST##2\");\r\n\r\n        ImGui::AlignTextToFramePadding(); // If your line starts with text, call this to align it to upcoming widgets.\r\n        ImGui::Text(\"Text aligned to Widget\"); ImGui::SameLine();\r\n        ImGui::Button(\"Widget##1\"); ImGui::SameLine();\r\n        ImGui::Text(\"Widget\"); ImGui::SameLine();\r\n        ImGui::SmallButton(\"Widget##2\"); ImGui::SameLine();\r\n        ImGui::Button(\"Widget##3\");\r\n\r\n        // Tree\r\n        const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;\r\n        ImGui::Button(\"Button##1\");\r\n        ImGui::SameLine(0.0f, spacing);\r\n        if (ImGui::TreeNode(\"Node##1\")) { for (int i = 0; i < 6; i++) ImGui::BulletText(\"Item %d..\", i); ImGui::TreePop(); }    // Dummy tree data\r\n\r\n        ImGui::AlignTextToFramePadding();         // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget. Otherwise you can use SmallButton (smaller fit).\r\n        bool node_open = ImGui::TreeNode(\"Node##2\");  // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add child content.\r\n        ImGui::SameLine(0.0f, spacing); ImGui::Button(\"Button##2\");\r\n        if (node_open) { for (int i = 0; i < 6; i++) ImGui::BulletText(\"Item %d..\", i); ImGui::TreePop(); }   // Dummy tree data\r\n\r\n        // Bullet\r\n        ImGui::Button(\"Button##3\");\r\n        ImGui::SameLine(0.0f, spacing);\r\n        ImGui::BulletText(\"Bullet text\");\r\n\r\n        ImGui::AlignTextToFramePadding();\r\n        ImGui::BulletText(\"Node\");\r\n        ImGui::SameLine(0.0f, spacing); ImGui::Button(\"Button##4\");\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Scrolling\"))\r\n    {\r\n        ImGui::TextWrapped(\"(Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given position.)\");\r\n        static bool track = true;\r\n        static int track_line = 50, scroll_to_px = 200;\r\n        ImGui::Checkbox(\"Track\", &track);\r\n        ImGui::PushItemWidth(100);\r\n        ImGui::SameLine(130); track |= ImGui::DragInt(\"##line\", &track_line, 0.25f, 0, 99, \"Line = %d\");\r\n        bool scroll_to = ImGui::Button(\"Scroll To Pos\");\r\n        ImGui::SameLine(130); scroll_to |= ImGui::DragInt(\"##pos_y\", &scroll_to_px, 1.00f, 0, 9999, \"Y = %d px\");\r\n        ImGui::PopItemWidth();\r\n        if (scroll_to) track = false;\r\n\r\n        for (int i = 0; i < 5; i++)\r\n        {\r\n            if (i > 0) ImGui::SameLine();\r\n            ImGui::BeginGroup();\r\n            ImGui::Text(\"%s\", i == 0 ? \"Top\" : i == 1 ? \"25%\" : i == 2 ? \"Center\" : i == 3 ? \"75%\" : \"Bottom\");\r\n            ImGui::BeginChild(ImGui::GetID((void*)(intptr_t)i), ImVec2(ImGui::GetWindowWidth() * 0.17f, 200.0f), true);\r\n            if (scroll_to)\r\n                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + scroll_to_px, i * 0.25f);\r\n            for (int line = 0; line < 100; line++)\r\n            {\r\n                if (track && line == track_line)\r\n                {\r\n                    ImGui::TextColored(ImVec4(1,1,0,1), \"Line %d\", line);\r\n                    ImGui::SetScrollHereY(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom\r\n                }\r\n                else\r\n                {\r\n                    ImGui::Text(\"Line %d\", line);\r\n                }\r\n            }\r\n            float scroll_y = ImGui::GetScrollY(), scroll_max_y = ImGui::GetScrollMaxY();\r\n            ImGui::EndChild();\r\n            ImGui::Text(\"%.0f/%0.f\", scroll_y, scroll_max_y);\r\n            ImGui::EndGroup();\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Horizontal Scrolling\"))\r\n    {\r\n        ImGui::Bullet(); ImGui::TextWrapped(\"Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.\");\r\n        ImGui::Bullet(); ImGui::TextWrapped(\"You may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().\");\r\n        static int lines = 7;\r\n        ImGui::SliderInt(\"Lines\", &lines, 1, 15);\r\n        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);\r\n        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));\r\n        ImGui::BeginChild(\"scrolling\", ImVec2(0, ImGui::GetFrameHeightWithSpacing() * 7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);\r\n        for (int line = 0; line < lines; line++)\r\n        {\r\n            // Display random stuff (for the sake of this trivial demo we are using basic Button+SameLine. If you want to create your own time line for a real application you may be better off\r\n            // manipulating the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets yourself. You may also want to use the lower-level ImDrawList API)\r\n            int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);\r\n            for (int n = 0; n < num_buttons; n++)\r\n            {\r\n                if (n > 0) ImGui::SameLine();\r\n                ImGui::PushID(n + line * 1000);\r\n                char num_buf[16];\r\n                sprintf(num_buf, \"%d\", n);\r\n                const char* label = (!(n%15)) ? \"FizzBuzz\" : (!(n%3)) ? \"Fizz\" : (!(n%5)) ? \"Buzz\" : num_buf;\r\n                float hue = n*0.05f;\r\n                ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));\r\n                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));\r\n                ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(hue, 0.8f, 0.8f));\r\n                ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));\r\n                ImGui::PopStyleColor(3);\r\n                ImGui::PopID();\r\n            }\r\n        }\r\n        float scroll_x = ImGui::GetScrollX(), scroll_max_x = ImGui::GetScrollMaxX();\r\n        ImGui::EndChild();\r\n        ImGui::PopStyleVar(2);\r\n        float scroll_x_delta = 0.0f;\r\n        ImGui::SmallButton(\"<<\"); if (ImGui::IsItemActive()) scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f; ImGui::SameLine();\r\n        ImGui::Text(\"Scroll from code\"); ImGui::SameLine();\r\n        ImGui::SmallButton(\">>\"); if (ImGui::IsItemActive()) scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f; ImGui::SameLine();\r\n        ImGui::Text(\"%.0f/%.0f\", scroll_x, scroll_max_x);\r\n        if (scroll_x_delta != 0.0f)\r\n        {\r\n            ImGui::BeginChild(\"scrolling\"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)\r\n            ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);\r\n            ImGui::End();\r\n        }\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Clipping\"))\r\n    {\r\n        static ImVec2 size(100, 100), offset(50, 20);\r\n        ImGui::TextWrapped(\"On a per-widget basis we are occasionally clipping text CPU-side if it won't fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.\");\r\n        ImGui::DragFloat2(\"size\", (float*)&size, 0.5f, 0.0f, 200.0f, \"%.0f\");\r\n        ImGui::TextWrapped(\"(Click and drag)\");\r\n        ImVec2 pos = ImGui::GetCursorScreenPos();\r\n        ImVec4 clip_rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);\r\n        ImGui::InvisibleButton(\"##dummy\", size);\r\n        if (ImGui::IsItemActive() && ImGui::IsMouseDragging()) { offset.x += ImGui::GetIO().MouseDelta.x; offset.y += ImGui::GetIO().MouseDelta.y; }\r\n        ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), IM_COL32(90, 90, 120, 255));\r\n        ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x + offset.x, pos.y + offset.y), IM_COL32(255, 255, 255, 255), \"Line 1 hello\\nLine 2 clip me!\", NULL, 0.0f, &clip_rect);\r\n        ImGui::TreePop();\r\n    }\r\n}\r\n\r\nstatic void ShowDemoWindowPopups()\r\n{\r\n    if (!ImGui::CollapsingHeader(\"Popups & Modal windows\"))\r\n        return;\r\n\r\n    // Popups are windows with a few special properties:\r\n    // - They block normal mouse hovering detection outside them. (*)\r\n    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.\r\n    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.\r\n    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.\r\n    // Those three properties are intimately connected. The library needs to hold their visibility state because it can close popups at any time.\r\n\r\n    // Typical use for regular windows:\r\n    //   bool my_tool_is_active = false; if (ImGui::Button(\"Open\")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin(\"My Tool\", &my_tool_is_active) { [...] } End();\r\n    // Typical use for popups:\r\n    //   if (ImGui::Button(\"Open\")) ImGui::OpenPopup(\"MyPopup\"); if (ImGui::BeginPopup(\"MyPopup\") { [...] EndPopup(); }\r\n\r\n    // With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.\r\n    // This may be a bit confusing at first but it should quickly make sense. Follow on the examples below. \r\n\r\n    if (ImGui::TreeNode(\"Popups\"))\r\n    {\r\n        ImGui::TextWrapped(\"When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.\");\r\n\r\n        static int selected_fish = -1;\r\n        const char* names[] = { \"Bream\", \"Haddock\", \"Mackerel\", \"Pollock\", \"Tilefish\" };\r\n        static bool toggles[] = { true, false, false, false, false };\r\n\r\n        // Simple selection popup\r\n        // (If you want to show the current selection inside the Button itself, you may want to build a string using the \"###\" operator to preserve a constant ID with a variable label)\r\n        if (ImGui::Button(\"Select..\"))\r\n            ImGui::OpenPopup(\"my_select_popup\");\r\n        ImGui::SameLine();\r\n        ImGui::TextUnformatted(selected_fish == -1 ? \"<None>\" : names[selected_fish]);\r\n        if (ImGui::BeginPopup(\"my_select_popup\"))\r\n        {\r\n            ImGui::Text(\"Aquarium\");\r\n            ImGui::Separator();\r\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\r\n                if (ImGui::Selectable(names[i]))\r\n                    selected_fish = i;\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        // Showing a menu with toggles\r\n        if (ImGui::Button(\"Toggle..\"))\r\n            ImGui::OpenPopup(\"my_toggle_popup\");\r\n        if (ImGui::BeginPopup(\"my_toggle_popup\"))\r\n        {\r\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\r\n                ImGui::MenuItem(names[i], \"\", &toggles[i]);\r\n            if (ImGui::BeginMenu(\"Sub-menu\"))\r\n            {\r\n                ImGui::MenuItem(\"Click me\");\r\n                ImGui::EndMenu();\r\n            }\r\n\r\n            ImGui::Separator();\r\n            ImGui::Text(\"Tooltip here\");\r\n            if (ImGui::IsItemHovered())\r\n                ImGui::SetTooltip(\"I am a tooltip over a popup\");\r\n\r\n            if (ImGui::Button(\"Stacked Popup\"))\r\n                ImGui::OpenPopup(\"another popup\");\r\n            if (ImGui::BeginPopup(\"another popup\"))\r\n            {\r\n                for (int i = 0; i < IM_ARRAYSIZE(names); i++)\r\n                    ImGui::MenuItem(names[i], \"\", &toggles[i]);\r\n                if (ImGui::BeginMenu(\"Sub-menu\"))\r\n                {\r\n                    ImGui::MenuItem(\"Click me\");\r\n                    ImGui::EndMenu();\r\n                }\r\n                ImGui::EndPopup();\r\n            }\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        // Call the more complete ShowExampleMenuFile which we use in various places of this demo\r\n        if (ImGui::Button(\"File Menu..\"))\r\n            ImGui::OpenPopup(\"my_file_popup\");\r\n        if (ImGui::BeginPopup(\"my_file_popup\"))\r\n        {\r\n            ShowExampleMenuFile();\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Context menus\"))\r\n    {\r\n        // BeginPopupContextItem() is a helper to provide common/simple popup behavior of essentially doing:\r\n        //    if (IsItemHovered() && IsMouseReleased(0))\r\n        //       OpenPopup(id);\r\n        //    return BeginPopup(id);\r\n        // For more advanced uses you may want to replicate and cuztomize this code. This the comments inside BeginPopupContextItem() implementation.\r\n        static float value = 0.5f;\r\n        ImGui::Text(\"Value = %.3f (<-- right-click here)\", value);\r\n        if (ImGui::BeginPopupContextItem(\"item context menu\"))\r\n        {\r\n            if (ImGui::Selectable(\"Set to zero\")) value = 0.0f;\r\n            if (ImGui::Selectable(\"Set to PI\")) value = 3.1415f;\r\n            ImGui::PushItemWidth(-1);\r\n            ImGui::DragFloat(\"##Value\", &value, 0.1f, 0.0f, 0.0f);\r\n            ImGui::PopItemWidth();\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        // We can also use OpenPopupOnItemClick() which is the same as BeginPopupContextItem() but without the Begin call.\r\n        // So here we will make it that clicking on the text field with the right mouse button (1) will toggle the visibility of the popup above.\r\n        ImGui::Text(\"(You can also right-click me to the same popup as above.)\");\r\n        ImGui::OpenPopupOnItemClick(\"item context menu\", 1);\r\n\r\n        // When used after an item that has an ID (here the Button), we can skip providing an ID to BeginPopupContextItem(). \r\n        // BeginPopupContextItem() will use the last item ID as the popup ID.\r\n        // In addition here, we want to include your editable label inside the button label. We use the ### operator to override the ID (read FAQ about ID for details)\r\n        static char name[32] = \"Label1\";\r\n        char buf[64]; sprintf(buf, \"Button: %s###Button\", name); // ### operator override ID ignoring the preceding label\r\n        ImGui::Button(buf);\r\n        if (ImGui::BeginPopupContextItem())\r\n        {\r\n            ImGui::Text(\"Edit name:\");\r\n            ImGui::InputText(\"##edit\", name, IM_ARRAYSIZE(name));\r\n            if (ImGui::Button(\"Close\"))\r\n                ImGui::CloseCurrentPopup();\r\n            ImGui::EndPopup();\r\n        }\r\n        ImGui::SameLine(); ImGui::Text(\"(<-- right-click here)\");\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Modals\"))\r\n    {\r\n        ImGui::TextWrapped(\"Modal windows are like popups but the user cannot close them by clicking outside the window.\");\r\n\r\n        if (ImGui::Button(\"Delete..\"))\r\n            ImGui::OpenPopup(\"Delete?\");\r\n        if (ImGui::BeginPopupModal(\"Delete?\", NULL, ImGuiWindowFlags_AlwaysAutoResize))\r\n        {\r\n            ImGui::Text(\"All those beautiful files will be deleted.\\nThis operation cannot be undone!\\n\\n\");\r\n            ImGui::Separator();\r\n\r\n            //static int dummy_i = 0;\r\n            //ImGui::Combo(\"Combo\", &dummy_i, \"Delete\\0Delete harder\\0\");\r\n\r\n            static bool dont_ask_me_next_time = false;\r\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\r\n            ImGui::Checkbox(\"Don't ask me next time\", &dont_ask_me_next_time);\r\n            ImGui::PopStyleVar();\r\n\r\n            if (ImGui::Button(\"OK\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\r\n            ImGui::SetItemDefaultFocus();\r\n            ImGui::SameLine();\r\n            if (ImGui::Button(\"Cancel\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        if (ImGui::Button(\"Stacked modals..\"))\r\n            ImGui::OpenPopup(\"Stacked 1\");\r\n        if (ImGui::BeginPopupModal(\"Stacked 1\"))\r\n        {\r\n            ImGui::Text(\"Hello from Stacked The First\\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.\");\r\n            static int item = 1;\r\n            ImGui::Combo(\"Combo\", &item, \"aaaa\\0bbbb\\0cccc\\0dddd\\0eeee\\0\\0\");\r\n            static float color[4] = { 0.4f,0.7f,0.0f,0.5f };\r\n            ImGui::ColorEdit4(\"color\", color);  // This is to test behavior of stacked regular popups over a modal\r\n\r\n            if (ImGui::Button(\"Add another modal..\"))\r\n                ImGui::OpenPopup(\"Stacked 2\");\r\n            if (ImGui::BeginPopupModal(\"Stacked 2\"))\r\n            {\r\n                ImGui::Text(\"Hello from Stacked The Second!\");\r\n                if (ImGui::Button(\"Close\"))\r\n                    ImGui::CloseCurrentPopup();\r\n                ImGui::EndPopup();\r\n            }\r\n\r\n            if (ImGui::Button(\"Close\"))\r\n                ImGui::CloseCurrentPopup();\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Menus inside a regular window\"))\r\n    {\r\n        ImGui::TextWrapped(\"Below we are testing adding menu items to a regular window. It's rather unusual but should work!\");\r\n        ImGui::Separator();\r\n        // NB: As a quirk in this very specific example, we want to differentiate the parent of this menu from the parent of the various popup menus above.\r\n        // To do so we are encloding the items in a PushID()/PopID() block to make them two different menusets. If we don't, opening any popup above and hovering our menu here\r\n        // would open it. This is because once a menu is active, we allow to switch to a sibling menu by just hovering on it, which is the desired behavior for regular menus.\r\n        ImGui::PushID(\"foo\");\r\n        ImGui::MenuItem(\"Menu item\", \"CTRL+M\");\r\n        if (ImGui::BeginMenu(\"Menu inside a regular window\"))\r\n        {\r\n            ShowExampleMenuFile();\r\n            ImGui::EndMenu();\r\n        }\r\n        ImGui::PopID();\r\n        ImGui::Separator();\r\n        ImGui::TreePop();\r\n    }\r\n}\r\n\r\nstatic void ShowDemoWindowColumns()\r\n{\r\n    if (!ImGui::CollapsingHeader(\"Columns\"))\r\n        return;\r\n\r\n    ImGui::PushID(\"Columns\");\r\n\r\n    // Basic columns\r\n    if (ImGui::TreeNode(\"Basic\"))\r\n    {\r\n        ImGui::Text(\"Without border:\");\r\n        ImGui::Columns(3, \"mycolumns3\", false);  // 3-ways, no border\r\n        ImGui::Separator();\r\n        for (int n = 0; n < 14; n++)\r\n        {\r\n            char label[32];\r\n            sprintf(label, \"Item %d\", n);\r\n            if (ImGui::Selectable(label)) {}\r\n            //if (ImGui::Button(label, ImVec2(-1,0))) {}\r\n            ImGui::NextColumn();\r\n        }\r\n        ImGui::Columns(1);\r\n        ImGui::Separator();\r\n\r\n        ImGui::Text(\"With border:\");\r\n        ImGui::Columns(4, \"mycolumns\"); // 4-ways, with border\r\n        ImGui::Separator();\r\n        ImGui::Text(\"ID\"); ImGui::NextColumn();\r\n        ImGui::Text(\"Name\"); ImGui::NextColumn();\r\n        ImGui::Text(\"Path\"); ImGui::NextColumn();\r\n        ImGui::Text(\"Hovered\"); ImGui::NextColumn();\r\n        ImGui::Separator();\r\n        const char* names[3] = { \"One\", \"Two\", \"Three\" };\r\n        const char* paths[3] = { \"/path/one\", \"/path/two\", \"/path/three\" };\r\n        static int selected = -1;\r\n        for (int i = 0; i < 3; i++)\r\n        {\r\n            char label[32];\r\n            sprintf(label, \"%04d\", i);\r\n            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))\r\n                selected = i;\r\n            bool hovered = ImGui::IsItemHovered();\r\n            ImGui::NextColumn();\r\n            ImGui::Text(names[i]); ImGui::NextColumn();\r\n            ImGui::Text(paths[i]); ImGui::NextColumn();\r\n            ImGui::Text(\"%d\", hovered); ImGui::NextColumn();\r\n        }\r\n        ImGui::Columns(1);\r\n        ImGui::Separator();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    // Create multiple items in a same cell before switching to next column\r\n    if (ImGui::TreeNode(\"Mixed items\"))\r\n    {\r\n        ImGui::Columns(3, \"mixed\");\r\n        ImGui::Separator();\r\n\r\n        ImGui::Text(\"Hello\");\r\n        ImGui::Button(\"Banana\");\r\n        ImGui::NextColumn();\r\n\r\n        ImGui::Text(\"ImGui\");\r\n        ImGui::Button(\"Apple\");\r\n        static float foo = 1.0f;\r\n        ImGui::InputFloat(\"red\", &foo, 0.05f, 0, \"%.3f\");\r\n        ImGui::Text(\"An extra line here.\");\r\n        ImGui::NextColumn();\r\n\r\n        ImGui::Text(\"Sailor\");\r\n        ImGui::Button(\"Corniflower\");\r\n        static float bar = 1.0f;\r\n        ImGui::InputFloat(\"blue\", &bar, 0.05f, 0, \"%.3f\");\r\n        ImGui::NextColumn();\r\n\r\n        if (ImGui::CollapsingHeader(\"Category A\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\r\n        if (ImGui::CollapsingHeader(\"Category B\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\r\n        if (ImGui::CollapsingHeader(\"Category C\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\r\n        ImGui::Columns(1);\r\n        ImGui::Separator();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    // Word wrapping\r\n    if (ImGui::TreeNode(\"Word-wrapping\"))\r\n    {\r\n        ImGui::Columns(2, \"word-wrapping\");\r\n        ImGui::Separator();\r\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\r\n        ImGui::TextWrapped(\"Hello Left\");\r\n        ImGui::NextColumn();\r\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\r\n        ImGui::TextWrapped(\"Hello Right\");\r\n        ImGui::Columns(1);\r\n        ImGui::Separator();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Borders\"))\r\n    {\r\n        // NB: Future columns API should allow automatic horizontal borders.\r\n        static bool h_borders = true;\r\n        static bool v_borders = true;\r\n        ImGui::Checkbox(\"horizontal\", &h_borders);\r\n        ImGui::SameLine();\r\n        ImGui::Checkbox(\"vertical\", &v_borders);\r\n        ImGui::Columns(4, NULL, v_borders);\r\n        for (int i = 0; i < 4*3; i++)\r\n        {\r\n            if (h_borders && ImGui::GetColumnIndex() == 0)\r\n                ImGui::Separator();\r\n            ImGui::Text(\"%c%c%c\", 'a'+i, 'a'+i, 'a'+i);\r\n            ImGui::Text(\"Width %.2f\\nOffset %.2f\", ImGui::GetColumnWidth(), ImGui::GetColumnOffset());\r\n            ImGui::NextColumn();\r\n        }\r\n        ImGui::Columns(1);\r\n        if (h_borders)\r\n            ImGui::Separator();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    // Scrolling columns\r\n    /*\r\n    if (ImGui::TreeNode(\"Vertical Scrolling\"))\r\n    {\r\n        ImGui::BeginChild(\"##header\", ImVec2(0, ImGui::GetTextLineHeightWithSpacing()+ImGui::GetStyle().ItemSpacing.y));\r\n        ImGui::Columns(3);\r\n        ImGui::Text(\"ID\"); ImGui::NextColumn();\r\n        ImGui::Text(\"Name\"); ImGui::NextColumn();\r\n        ImGui::Text(\"Path\"); ImGui::NextColumn();\r\n        ImGui::Columns(1);\r\n        ImGui::Separator();\r\n        ImGui::EndChild();\r\n        ImGui::BeginChild(\"##scrollingregion\", ImVec2(0, 60));\r\n        ImGui::Columns(3);\r\n        for (int i = 0; i < 10; i++)\r\n        {\r\n            ImGui::Text(\"%04d\", i); ImGui::NextColumn();\r\n            ImGui::Text(\"Foobar\"); ImGui::NextColumn();\r\n            ImGui::Text(\"/path/foobar/%04d/\", i); ImGui::NextColumn();\r\n        }\r\n        ImGui::Columns(1);\r\n        ImGui::EndChild();\r\n        ImGui::TreePop();\r\n    }\r\n    */\r\n\r\n    if (ImGui::TreeNode(\"Horizontal Scrolling\"))\r\n    {\r\n        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));\r\n        ImGui::BeginChild(\"##ScrollingRegion\", ImVec2(0, ImGui::GetFontSize() * 20), false, ImGuiWindowFlags_HorizontalScrollbar);\r\n        ImGui::Columns(10);\r\n        int ITEMS_COUNT = 2000;\r\n        ImGuiListClipper clipper(ITEMS_COUNT);  // Also demonstrate using the clipper for large list\r\n        while (clipper.Step())\r\n        {\r\n            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n                for (int j = 0; j < 10; j++)\r\n                {\r\n                    ImGui::Text(\"Line %d Column %d...\", i, j);\r\n                    ImGui::NextColumn();\r\n                }\r\n        }\r\n        ImGui::Columns(1);\r\n        ImGui::EndChild();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    bool node_open = ImGui::TreeNode(\"Tree within single cell\");\r\n    ImGui::SameLine(); ShowHelpMarker(\"NB: Tree node must be poped before ending the cell. There's no storage of state per-cell.\");\r\n    if (node_open)\r\n    {\r\n        ImGui::Columns(2, \"tree items\");\r\n        ImGui::Separator();\r\n        if (ImGui::TreeNode(\"Hello\")) { ImGui::BulletText(\"Sailor\"); ImGui::TreePop(); } ImGui::NextColumn();\r\n        if (ImGui::TreeNode(\"Bonjour\")) { ImGui::BulletText(\"Marin\"); ImGui::TreePop(); } ImGui::NextColumn();\r\n        ImGui::Columns(1);\r\n        ImGui::Separator();\r\n        ImGui::TreePop();\r\n    }\r\n    ImGui::PopID();\r\n}\r\n\r\nstatic void ShowDemoWindowMisc()\r\n{\r\n    if (ImGui::CollapsingHeader(\"Filtering\"))\r\n    {\r\n        static ImGuiTextFilter filter;\r\n        ImGui::Text(\"Filter usage:\\n\"\r\n                    \"  \\\"\\\"         display all lines\\n\"\r\n                    \"  \\\"xxx\\\"      display lines containing \\\"xxx\\\"\\n\"\r\n                    \"  \\\"xxx,yyy\\\"  display lines containing \\\"xxx\\\" or \\\"yyy\\\"\\n\"\r\n                    \"  \\\"-xxx\\\"     hide lines containing \\\"xxx\\\"\");\r\n        filter.Draw();\r\n        const char* lines[] = { \"aaa1.c\", \"bbb1.c\", \"ccc1.c\", \"aaa2.cpp\", \"bbb2.cpp\", \"ccc2.cpp\", \"abc.h\", \"hello, world\" };\r\n        for (int i = 0; i < IM_ARRAYSIZE(lines); i++)\r\n            if (filter.PassFilter(lines[i]))\r\n                ImGui::BulletText(\"%s\", lines[i]);\r\n    }\r\n\r\n    if (ImGui::CollapsingHeader(\"Inputs, Navigation & Focus\"))\r\n    {\r\n        ImGuiIO& io = ImGui::GetIO();\r\n\r\n        ImGui::Text(\"WantCaptureMouse: %d\", io.WantCaptureMouse);\r\n        ImGui::Text(\"WantCaptureKeyboard: %d\", io.WantCaptureKeyboard);\r\n        ImGui::Text(\"WantTextInput: %d\", io.WantTextInput);\r\n        ImGui::Text(\"WantSetMousePos: %d\", io.WantSetMousePos);\r\n        ImGui::Text(\"NavActive: %d, NavVisible: %d\", io.NavActive, io.NavVisible);\r\n\r\n        if (ImGui::TreeNode(\"Keyboard, Mouse & Navigation State\"))\r\n        {\r\n            if (ImGui::IsMousePosValid())\r\n                ImGui::Text(\"Mouse pos: (%g, %g)\", io.MousePos.x, io.MousePos.y);\r\n            else\r\n                ImGui::Text(\"Mouse pos: <INVALID>\");\r\n            ImGui::Text(\"Mouse delta: (%g, %g)\", io.MouseDelta.x, io.MouseDelta.y);\r\n            ImGui::Text(\"Mouse down:\");     for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (io.MouseDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text(\"b%d (%.02f secs)\", i, io.MouseDownDuration[i]); }\r\n            ImGui::Text(\"Mouse clicked:\");  for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseClicked(i))          { ImGui::SameLine(); ImGui::Text(\"b%d\", i); }\r\n            ImGui::Text(\"Mouse dbl-clicked:\"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDoubleClicked(i)) { ImGui::SameLine(); ImGui::Text(\"b%d\", i); }\r\n            ImGui::Text(\"Mouse released:\"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseReleased(i))         { ImGui::SameLine(); ImGui::Text(\"b%d\", i); }\r\n            ImGui::Text(\"Mouse wheel: %.1f\", io.MouseWheel);\r\n\r\n            ImGui::Text(\"Keys down:\");      for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (io.KeysDownDuration[i] >= 0.0f)     { ImGui::SameLine(); ImGui::Text(\"%d (%.02f secs)\", i, io.KeysDownDuration[i]); }\r\n            ImGui::Text(\"Keys pressed:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\r\n            ImGui::Text(\"Keys release:\");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyReleased(i))            { ImGui::SameLine(); ImGui::Text(\"%d\", i); }\r\n            ImGui::Text(\"Keys mods: %s%s%s%s\", io.KeyCtrl ? \"CTRL \" : \"\", io.KeyShift ? \"SHIFT \" : \"\", io.KeyAlt ? \"ALT \" : \"\", io.KeySuper ? \"SUPER \" : \"\");\r\n\r\n            ImGui::Text(\"NavInputs down:\"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputs[i] > 0.0f)                    { ImGui::SameLine(); ImGui::Text(\"[%d] %.2f\", i, io.NavInputs[i]); }\r\n            ImGui::Text(\"NavInputs pressed:\"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] == 0.0f)    { ImGui::SameLine(); ImGui::Text(\"[%d]\", i); }\r\n            ImGui::Text(\"NavInputs duration:\"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text(\"[%d] %.2f\", i, io.NavInputsDownDuration[i]); }\r\n\r\n            ImGui::Button(\"Hovering me sets the\\nkeyboard capture flag\");\r\n            if (ImGui::IsItemHovered())\r\n                ImGui::CaptureKeyboardFromApp(true);\r\n            ImGui::SameLine();\r\n            ImGui::Button(\"Holding me clears the\\nthe keyboard capture flag\");\r\n            if (ImGui::IsItemActive())\r\n                ImGui::CaptureKeyboardFromApp(false);\r\n\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Tabbing\"))\r\n        {\r\n            ImGui::Text(\"Use TAB/SHIFT+TAB to cycle through keyboard editable fields.\");\r\n            static char buf[32] = \"dummy\";\r\n            ImGui::InputText(\"1\", buf, IM_ARRAYSIZE(buf));\r\n            ImGui::InputText(\"2\", buf, IM_ARRAYSIZE(buf));\r\n            ImGui::InputText(\"3\", buf, IM_ARRAYSIZE(buf));\r\n            ImGui::PushAllowKeyboardFocus(false);\r\n            ImGui::InputText(\"4 (tab skip)\", buf, IM_ARRAYSIZE(buf));\r\n            //ImGui::SameLine(); ShowHelperMarker(\"Use ImGui::PushAllowKeyboardFocus(bool)\\nto disable tabbing through certain widgets.\");\r\n            ImGui::PopAllowKeyboardFocus();\r\n            ImGui::InputText(\"5\", buf, IM_ARRAYSIZE(buf));\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Focus from code\"))\r\n        {\r\n            bool focus_1 = ImGui::Button(\"Focus on 1\"); ImGui::SameLine();\r\n            bool focus_2 = ImGui::Button(\"Focus on 2\"); ImGui::SameLine();\r\n            bool focus_3 = ImGui::Button(\"Focus on 3\");\r\n            int has_focus = 0;\r\n            static char buf[128] = \"click on a button to set focus\";\r\n\r\n            if (focus_1) ImGui::SetKeyboardFocusHere();\r\n            ImGui::InputText(\"1\", buf, IM_ARRAYSIZE(buf));\r\n            if (ImGui::IsItemActive()) has_focus = 1;\r\n\r\n            if (focus_2) ImGui::SetKeyboardFocusHere();\r\n            ImGui::InputText(\"2\", buf, IM_ARRAYSIZE(buf));\r\n            if (ImGui::IsItemActive()) has_focus = 2;\r\n\r\n            ImGui::PushAllowKeyboardFocus(false);\r\n            if (focus_3) ImGui::SetKeyboardFocusHere();\r\n            ImGui::InputText(\"3 (tab skip)\", buf, IM_ARRAYSIZE(buf));\r\n            if (ImGui::IsItemActive()) has_focus = 3;\r\n            ImGui::PopAllowKeyboardFocus();\r\n\r\n            if (has_focus)\r\n                ImGui::Text(\"Item with focus: %d\", has_focus);\r\n            else\r\n                ImGui::Text(\"Item with focus: <none>\");\r\n\r\n            // Use >= 0 parameter to SetKeyboardFocusHere() to focus an upcoming item\r\n            static float f3[3] = { 0.0f, 0.0f, 0.0f };\r\n            int focus_ahead = -1;\r\n            if (ImGui::Button(\"Focus on X\")) focus_ahead = 0; ImGui::SameLine();\r\n            if (ImGui::Button(\"Focus on Y\")) focus_ahead = 1; ImGui::SameLine();\r\n            if (ImGui::Button(\"Focus on Z\")) focus_ahead = 2;\r\n            if (focus_ahead != -1) ImGui::SetKeyboardFocusHere(focus_ahead);\r\n            ImGui::SliderFloat3(\"Float3\", &f3[0], 0.0f, 1.0f);\r\n\r\n            ImGui::TextWrapped(\"NB: Cursor & selection are preserved when refocusing last used item in code.\");\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Dragging\"))\r\n        {\r\n            ImGui::TextWrapped(\"You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.\");\r\n            for (int button = 0; button < 3; button++)\r\n                ImGui::Text(\"IsMouseDragging(%d):\\n  w/ default threshold: %d,\\n  w/ zero threshold: %d\\n  w/ large threshold: %d\",\r\n                    button, ImGui::IsMouseDragging(button), ImGui::IsMouseDragging(button, 0.0f), ImGui::IsMouseDragging(button, 20.0f));\r\n            ImGui::Button(\"Drag Me\");\r\n            if (ImGui::IsItemActive())\r\n            {\r\n                // Draw a line between the button and the mouse cursor\r\n                ImDrawList* draw_list = ImGui::GetWindowDrawList();\r\n                draw_list->PushClipRectFullScreen();\r\n                draw_list->AddLine(io.MouseClickedPos[0], io.MousePos, ImGui::GetColorU32(ImGuiCol_Button), 4.0f);\r\n                draw_list->PopClipRect();\r\n\r\n                // Drag operations gets \"unlocked\" when the mouse has moved past a certain threshold (the default threshold is stored in io.MouseDragThreshold)\r\n                // You can request a lower or higher threshold using the second parameter of IsMouseDragging() and GetMouseDragDelta()\r\n                ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);\r\n                ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);\r\n                ImVec2 mouse_delta = io.MouseDelta;\r\n                ImGui::SameLine(); ImGui::Text(\"Raw (%.1f, %.1f), WithLockThresold (%.1f, %.1f), MouseDelta (%.1f, %.1f)\", value_raw.x, value_raw.y, value_with_lock_threshold.x, value_with_lock_threshold.y, mouse_delta.x, mouse_delta.y);\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n\r\n        if (ImGui::TreeNode(\"Mouse cursors\"))\r\n        {\r\n            const char* mouse_cursors_names[] = { \"Arrow\", \"TextInput\", \"Move\", \"ResizeNS\", \"ResizeEW\", \"ResizeNESW\", \"ResizeNWSE\", \"Hand\" };\r\n            IM_ASSERT(IM_ARRAYSIZE(mouse_cursors_names) == ImGuiMouseCursor_COUNT);\r\n\r\n            ImGui::Text(\"Current mouse cursor = %d: %s\", ImGui::GetMouseCursor(), mouse_cursors_names[ImGui::GetMouseCursor()]);\r\n            ImGui::Text(\"Hover to see mouse cursors:\");\r\n            ImGui::SameLine(); ShowHelpMarker(\"Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, otherwise your backend needs to handle it.\");\r\n            for (int i = 0; i < ImGuiMouseCursor_COUNT; i++)\r\n            {\r\n                char label[32];\r\n                sprintf(label, \"Mouse cursor %d: %s\", i, mouse_cursors_names[i]);\r\n                ImGui::Bullet(); ImGui::Selectable(label, false);\r\n                if (ImGui::IsItemHovered() || ImGui::IsItemFocused())\r\n                    ImGui::SetMouseCursor(i);\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] About Window / ShowAboutWindow()\r\n// Access from ImGui Demo -> Help -> About\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::ShowAboutWindow(bool* p_open)\r\n{\r\n    ImGui::Begin(\"About Dear ImGui\", p_open, ImGuiWindowFlags_AlwaysAutoResize);\r\n    ImGui::Text(\"Dear ImGui, %s\", ImGui::GetVersion());\r\n    ImGui::Separator();\r\n    ImGui::Text(\"By Omar Cornut and all dear imgui contributors.\");\r\n    ImGui::Text(\"Dear ImGui is licensed under the MIT License, see LICENSE for more information.\");\r\n\r\n    static bool show_config_info = false;\r\n    ImGui::Checkbox(\"Config/Build Information\", &show_config_info);\r\n    if (show_config_info)\r\n    {\r\n        ImGuiIO& io = ImGui::GetIO();\r\n        ImGuiStyle& style = ImGui::GetStyle();\r\n\r\n        bool copy_to_clipboard = ImGui::Button(\"Copy to clipboard\");\r\n        ImGui::BeginChildFrame(ImGui::GetID(\"cfginfos\"), ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18), ImGuiWindowFlags_NoMove);\r\n        if (copy_to_clipboard)\r\n            ImGui::LogToClipboard();\r\n\r\n        ImGui::Text(\"Dear ImGui %s (%d)\", IMGUI_VERSION, IMGUI_VERSION_NUM);\r\n        ImGui::Separator();\r\n        ImGui::Text(\"sizeof(size_t): %d, sizeof(ImDrawIdx): %d, sizeof(ImDrawVert): %d\", (int)sizeof(size_t), (int)sizeof(ImDrawIdx), (int)sizeof(ImDrawVert));\r\n        ImGui::Text(\"define: __cplusplus=%d\", (int)__cplusplus);\r\n#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_OBSOLETE_FUNCTIONS\");\r\n#endif\r\n#ifdef IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS\");\r\n#endif\r\n#ifdef IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS\");\r\n#endif\r\n#ifdef IMGUI_DISABLE_WIN32_FUNCTIONS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_WIN32_FUNCTIONS\");\r\n#endif\r\n#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS\");\r\n#endif\r\n#ifdef IMGUI_DISABLE_MATH_FUNCTIONS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_MATH_FUNCTIONS\");\r\n#endif\r\n#ifdef IMGUI_DISABLE_DEFAULT_ALLOCATORS\r\n        ImGui::Text(\"define: IMGUI_DISABLE_DEFAULT_ALLOCATORS\");\r\n#endif\r\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\r\n        ImGui::Text(\"define: IMGUI_USE_BGRA_PACKED_COLOR\");\r\n#endif\r\n#ifdef _WIN32\r\n        ImGui::Text(\"define: _WIN32\");\r\n#endif\r\n#ifdef _WIN64\r\n        ImGui::Text(\"define: _WIN64\");\r\n#endif\r\n#ifdef __linux__\r\n        ImGui::Text(\"define: __linux__\");\r\n#endif\r\n#ifdef __APPLE__\r\n        ImGui::Text(\"define: __APPLE__\");\r\n#endif\r\n#ifdef _MSC_VER\r\n        ImGui::Text(\"define: _MSC_VER=%d\", _MSC_VER);\r\n#endif\r\n#ifdef __MINGW32__\r\n        ImGui::Text(\"define: __MINGW32__\");\r\n#endif\r\n#ifdef __MINGW64__\r\n        ImGui::Text(\"define: __MINGW64__\");\r\n#endif\r\n#ifdef __GNUC__\r\n        ImGui::Text(\"define: __GNUC__=%d\", (int)__GNUC__);\r\n#endif\r\n#ifdef __clang_version__\r\n        ImGui::Text(\"define: __clang_version__=%s\", __clang_version__);\r\n#endif\r\n        ImGui::Separator();\r\n        ImGui::Text(\"io.ConfigFlags: 0x%08X\", io.ConfigFlags);\r\n        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)    ImGui::Text(\" NavEnableKeyboard\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad)     ImGui::Text(\" NavEnableGamepad\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) ImGui::Text(\" NavEnableSetMousePos\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard) ImGui::Text(\" NavNoCaptureKeyboard\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)              ImGui::Text(\" NoMouse\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)  ImGui::Text(\" NoMouseCursorChange\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_IsSRGB)               ImGui::Text(\" IsSRGB\");\r\n        if (io.ConfigFlags & ImGuiConfigFlags_IsTouchScreen)        ImGui::Text(\" IsTouchScreen\");\r\n        if (io.MouseDrawCursor)                                     ImGui::Text(\" MouseDrawCursor\");\r\n        if (io.ConfigMacOSXBehaviors)                               ImGui::Text(\" ConfigMacOSXBehaviors\");\r\n        if (io.ConfigInputTextCursorBlink)                          ImGui::Text(\" ConfigInputTextCursorBlink\");\r\n        if (io.ConfigResizeWindowsFromEdges)                        ImGui::Text(\" ConfigResizeWindowsFromEdges\");\r\n        ImGui::Text(\"io.BackendFlags: 0x%08X\", io.BackendFlags);\r\n        if (io.BackendFlags & ImGuiBackendFlags_HasGamepad)         ImGui::Text(\" HasGamepad\");\r\n        if (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)    ImGui::Text(\" HasMouseCursors\");\r\n        if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos)     ImGui::Text(\" HasSetMousePos\");\r\n        ImGui::Text(\"io.BackendPlatformName: %s\", io.BackendPlatformName ? io.BackendPlatformName : \"NULL\");\r\n        ImGui::Text(\"io.BackendRendererName: %s\", io.BackendRendererName ? io.BackendRendererName : \"NULL\");\r\n        ImGui::Separator();\r\n        ImGui::Text(\"io.Fonts: %d fonts, Flags: 0x%08X, TexSize: %d,%d\", io.Fonts->Fonts.Size, io.Fonts->Flags, io.Fonts->TexWidth, io.Fonts->TexHeight);\r\n        ImGui::Text(\"io.DisplaySize: %.2f,%.2f\", io.DisplaySize.x, io.DisplaySize.y);\r\n        ImGui::Separator();\r\n        ImGui::Text(\"style.WindowPadding: %.2f,%.2f\", style.WindowPadding.x, style.WindowPadding.y);\r\n        ImGui::Text(\"style.WindowBorderSize: %.2f\", style.WindowBorderSize);\r\n        ImGui::Text(\"style.FramePadding: %.2f,%.2f\", style.FramePadding.x, style.FramePadding.y);\r\n        ImGui::Text(\"style.FrameRounding: %.2f\", style.FrameRounding);\r\n        ImGui::Text(\"style.FrameBorderSize: %.2f\", style.FrameBorderSize);\r\n        ImGui::Text(\"style.ItemSpacing: %.2f,%.2f\", style.ItemSpacing.x, style.ItemSpacing.y);\r\n        ImGui::Text(\"style.ItemInnerSpacing: %.2f,%.2f\", style.ItemInnerSpacing.x, style.ItemInnerSpacing.y);\r\n\r\n        if (copy_to_clipboard)\r\n            ImGui::LogFinish();\r\n        ImGui::EndChildFrame();\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Style Editor / ShowStyleEditor()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demo helper function to select among default colors. See ShowStyleEditor() for more advanced options.\r\n// Here we use the simplified Combo() api that packs items into a single literal string. Useful for quick combo boxes where the choices are known locally.\r\nbool ImGui::ShowStyleSelector(const char* label)\r\n{\r\n    static int style_idx = -1;\r\n    if (ImGui::Combo(label, &style_idx, \"Classic\\0Dark\\0Light\\0\"))\r\n    {\r\n        switch (style_idx)\r\n        {\r\n        case 0: ImGui::StyleColorsClassic(); break;\r\n        case 1: ImGui::StyleColorsDark(); break;\r\n        case 2: ImGui::StyleColorsLight(); break;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n// Demo helper function to select among loaded fonts.\r\n// Here we use the regular BeginCombo()/EndCombo() api which is more the more flexible one.\r\nvoid ImGui::ShowFontSelector(const char* label)\r\n{\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    ImFont* font_current = ImGui::GetFont();\r\n    if (ImGui::BeginCombo(label, font_current->GetDebugName()))\r\n    {\r\n        for (int n = 0; n < io.Fonts->Fonts.Size; n++)\r\n            if (ImGui::Selectable(io.Fonts->Fonts[n]->GetDebugName(), io.Fonts->Fonts[n] == font_current))\r\n                io.FontDefault = io.Fonts->Fonts[n];\r\n        ImGui::EndCombo();\r\n    }\r\n    ImGui::SameLine();\r\n    ShowHelpMarker(\r\n        \"- Load additional fonts with io.Fonts->AddFontFromFileTTF().\\n\"\r\n        \"- The font atlas is built when calling io.Fonts->GetTexDataAsXXXX() or io.Fonts->Build().\\n\"\r\n        \"- Read FAQ and documentation in misc/fonts/ for more details.\\n\"\r\n        \"- If you need to add/remove fonts at runtime (e.g. for DPI change), do it before calling NewFrame().\");\r\n}\r\n\r\nvoid ImGui::ShowStyleEditor(ImGuiStyle* ref)\r\n{\r\n    // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it compares to an internally stored reference)\r\n    ImGuiStyle& style = ImGui::GetStyle();\r\n    static ImGuiStyle ref_saved_style;\r\n\r\n    // Default to using internal storage as reference\r\n    static bool init = true;\r\n    if (init && ref == NULL)\r\n        ref_saved_style = style;\r\n    init = false;\r\n    if (ref == NULL)\r\n        ref = &ref_saved_style;\r\n\r\n    ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);\r\n\r\n    if (ImGui::ShowStyleSelector(\"Colors##Selector\"))\r\n        ref_saved_style = style;\r\n    ImGui::ShowFontSelector(\"Fonts##Selector\");\r\n\r\n    // Simplified Settings\r\n    if (ImGui::SliderFloat(\"FrameRounding\", &style.FrameRounding, 0.0f, 12.0f, \"%.0f\"))\r\n        style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding\r\n    { bool window_border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox(\"WindowBorder\", &window_border)) style.WindowBorderSize = window_border ? 1.0f : 0.0f; }\r\n    ImGui::SameLine();\r\n    { bool frame_border = (style.FrameBorderSize > 0.0f); if (ImGui::Checkbox(\"FrameBorder\", &frame_border)) style.FrameBorderSize = frame_border ? 1.0f : 0.0f; }\r\n    ImGui::SameLine();\r\n    { bool popup_border = (style.PopupBorderSize > 0.0f); if (ImGui::Checkbox(\"PopupBorder\", &popup_border)) style.PopupBorderSize = popup_border ? 1.0f : 0.0f; }\r\n\r\n    // Save/Revert button\r\n    if (ImGui::Button(\"Save Ref\"))\r\n        *ref = ref_saved_style = style;\r\n    ImGui::SameLine();\r\n    if (ImGui::Button(\"Revert Ref\"))\r\n        style = *ref;\r\n    ImGui::SameLine();\r\n    ShowHelpMarker(\"Save/Revert in local non-persistent storage. Default Colors definition are not affected. Use \\\"Export Colors\\\" below to save them somewhere.\");\r\n\r\n    if (ImGui::TreeNode(\"Rendering\"))\r\n    {\r\n        ImGui::Checkbox(\"Anti-aliased lines\", &style.AntiAliasedLines); ImGui::SameLine(); ShowHelpMarker(\"When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.\");\r\n        ImGui::Checkbox(\"Anti-aliased fill\", &style.AntiAliasedFill);\r\n        ImGui::PushItemWidth(100);\r\n        ImGui::DragFloat(\"Curve Tessellation Tolerance\", &style.CurveTessellationTol, 0.02f, 0.10f, FLT_MAX, \"%.2f\", 2.0f);\r\n        if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;\r\n        ImGui::DragFloat(\"Global Alpha\", &style.Alpha, 0.005f, 0.20f, 1.0f, \"%.2f\"); // Not exposing zero here so user doesn't \"lose\" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.\r\n        ImGui::PopItemWidth();\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Settings\"))\r\n    {\r\n        ImGui::SliderFloat2(\"WindowPadding\", (float*)&style.WindowPadding, 0.0f, 20.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"PopupRounding\", &style.PopupRounding, 0.0f, 16.0f, \"%.0f\");\r\n        ImGui::SliderFloat2(\"FramePadding\", (float*)&style.FramePadding, 0.0f, 20.0f, \"%.0f\");\r\n        ImGui::SliderFloat2(\"ItemSpacing\", (float*)&style.ItemSpacing, 0.0f, 20.0f, \"%.0f\");\r\n        ImGui::SliderFloat2(\"ItemInnerSpacing\", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, \"%.0f\");\r\n        ImGui::SliderFloat2(\"TouchExtraPadding\", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"IndentSpacing\", &style.IndentSpacing, 0.0f, 30.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"ScrollbarSize\", &style.ScrollbarSize, 1.0f, 20.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"GrabMinSize\", &style.GrabMinSize, 1.0f, 20.0f, \"%.0f\");\r\n        ImGui::Text(\"BorderSize\");\r\n        ImGui::SliderFloat(\"WindowBorderSize\", &style.WindowBorderSize, 0.0f, 1.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"ChildBorderSize\", &style.ChildBorderSize, 0.0f, 1.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"PopupBorderSize\", &style.PopupBorderSize, 0.0f, 1.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"FrameBorderSize\", &style.FrameBorderSize, 0.0f, 1.0f, \"%.0f\");\r\n        ImGui::Text(\"Rounding\");\r\n        ImGui::SliderFloat(\"WindowRounding\", &style.WindowRounding, 0.0f, 14.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"ChildRounding\", &style.ChildRounding, 0.0f, 16.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"FrameRounding\", &style.FrameRounding, 0.0f, 12.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"ScrollbarRounding\", &style.ScrollbarRounding, 0.0f, 12.0f, \"%.0f\");\r\n        ImGui::SliderFloat(\"GrabRounding\", &style.GrabRounding, 0.0f, 12.0f, \"%.0f\");\r\n        ImGui::Text(\"Alignment\");\r\n        ImGui::SliderFloat2(\"WindowTitleAlign\", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, \"%.2f\");\r\n        ImGui::SliderFloat2(\"ButtonTextAlign\", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, \"%.2f\"); ImGui::SameLine(); ShowHelpMarker(\"Alignment applies when a button is larger than its text content.\");\r\n        ImGui::Text(\"Safe Area Padding\"); ImGui::SameLine(); ShowHelpMarker(\"Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).\");\r\n        ImGui::SliderFloat2(\"DisplaySafeAreaPadding\", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, \"%.0f\");\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    if (ImGui::TreeNode(\"Colors\"))\r\n    {\r\n        static int output_dest = 0;\r\n        static bool output_only_modified = true;\r\n        if (ImGui::Button(\"Export Unsaved\"))\r\n        {\r\n            if (output_dest == 0)\r\n                ImGui::LogToClipboard();\r\n            else\r\n                ImGui::LogToTTY();\r\n            ImGui::LogText(\"ImVec4* colors = ImGui::GetStyle().Colors;\" IM_NEWLINE);\r\n            for (int i = 0; i < ImGuiCol_COUNT; i++)\r\n            {\r\n                const ImVec4& col = style.Colors[i];\r\n                const char* name = ImGui::GetStyleColorName(i);\r\n                if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)\r\n                    ImGui::LogText(\"colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);\" IM_NEWLINE, name, 23-(int)strlen(name), \"\", col.x, col.y, col.z, col.w);\r\n            }\r\n            ImGui::LogFinish();\r\n        }\r\n        ImGui::SameLine(); ImGui::PushItemWidth(120); ImGui::Combo(\"##output_type\", &output_dest, \"To Clipboard\\0To TTY\\0\"); ImGui::PopItemWidth();\r\n        ImGui::SameLine(); ImGui::Checkbox(\"Only Modified Colors\", &output_only_modified);\r\n\r\n        ImGui::Text(\"Tip: Left-click on colored square to open color picker,\\nRight-click to open edit options menu.\");\r\n\r\n        static ImGuiTextFilter filter;\r\n        filter.Draw(\"Filter colors\", 200);\r\n\r\n        static ImGuiColorEditFlags alpha_flags = 0;\r\n        ImGui::RadioButton(\"Opaque\", &alpha_flags, 0); ImGui::SameLine();\r\n        ImGui::RadioButton(\"Alpha\", &alpha_flags, ImGuiColorEditFlags_AlphaPreview); ImGui::SameLine();\r\n        ImGui::RadioButton(\"Both\", &alpha_flags, ImGuiColorEditFlags_AlphaPreviewHalf);\r\n\r\n        ImGui::BeginChild(\"#colors\", ImVec2(0, 300), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_NavFlattened);\r\n        ImGui::PushItemWidth(-160);\r\n        for (int i = 0; i < ImGuiCol_COUNT; i++)\r\n        {\r\n            const char* name = ImGui::GetStyleColorName(i);\r\n            if (!filter.PassFilter(name))\r\n                continue;\r\n            ImGui::PushID(i);\r\n            ImGui::ColorEdit4(\"##color\", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);\r\n            if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)\r\n            {\r\n                // Tips: in a real user application, you may want to merge and use an icon font into the main font, so instead of \"Save\"/\"Revert\" you'd use icons.\r\n                // Read the FAQ and misc/fonts/README.txt about using icon fonts. It's really easy and super convenient!\r\n                ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button(\"Save\")) ref->Colors[i] = style.Colors[i];\r\n                ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button(\"Revert\")) style.Colors[i] = ref->Colors[i];\r\n            }\r\n            ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);\r\n            ImGui::TextUnformatted(name);\r\n            ImGui::PopID();\r\n        }\r\n        ImGui::PopItemWidth();\r\n        ImGui::EndChild();\r\n\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    bool fonts_opened = ImGui::TreeNode(\"Fonts\", \"Fonts (%d)\", ImGui::GetIO().Fonts->Fonts.Size);\r\n    if (fonts_opened)\r\n    {\r\n        ImFontAtlas* atlas = ImGui::GetIO().Fonts;\r\n        if (ImGui::TreeNode(\"Atlas texture\", \"Atlas texture (%dx%d pixels)\", atlas->TexWidth, atlas->TexHeight))\r\n        {\r\n            ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0,0), ImVec2(1,1), ImColor(255,255,255,255), ImColor(255,255,255,128));\r\n            ImGui::TreePop();\r\n        }\r\n        ImGui::PushItemWidth(100);\r\n        for (int i = 0; i < atlas->Fonts.Size; i++)\r\n        {\r\n            ImFont* font = atlas->Fonts[i];\r\n            ImGui::PushID(font);\r\n            bool font_details_opened = ImGui::TreeNode(font, \"Font %d: \\'%s\\', %.2f px, %d glyphs\", i, font->ConfigData ? font->ConfigData[0].Name : \"\", font->FontSize, font->Glyphs.Size);\r\n            ImGui::SameLine(); if (ImGui::SmallButton(\"Set as default\")) ImGui::GetIO().FontDefault = font;\r\n            if (font_details_opened)\r\n            {\r\n                ImGui::PushFont(font);\r\n                ImGui::Text(\"The quick brown fox jumps over the lazy dog\");\r\n                ImGui::PopFont();\r\n                ImGui::DragFloat(\"Font scale\", &font->Scale, 0.005f, 0.3f, 2.0f, \"%.1f\");   // Scale only this font\r\n                ImGui::SameLine(); ShowHelpMarker(\"Note than the default embedded font is NOT meant to be scaled.\\n\\nFont are currently rendered into bitmaps at a given size at the time of building the atlas. You may oversample them to get some flexibility with scaling. You can also render at multiple sizes and select which one to use at runtime.\\n\\n(Glimmer of hope: the atlas system should hopefully be rewritten in the future to make scaling more natural and automatic.)\");\r\n                ImGui::InputFloat(\"Font offset\", &font->DisplayOffset.y, 1, 1, \"%.0f\");\r\n                ImGui::Text(\"Ascent: %f, Descent: %f, Height: %f\", font->Ascent, font->Descent, font->Ascent - font->Descent);\r\n                ImGui::Text(\"Fallback character: '%c' (%d)\", font->FallbackChar, font->FallbackChar);\r\n                ImGui::Text(\"Texture surface: %d pixels (approx) ~ %dx%d\", font->MetricsTotalSurface, (int)sqrtf((float)font->MetricsTotalSurface), (int)sqrtf((float)font->MetricsTotalSurface));\r\n                for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)\r\n                    if (ImFontConfig* cfg = &font->ConfigData[config_i])\r\n                        ImGui::BulletText(\"Input %d: \\'%s\\', Oversample: (%d,%d), PixelSnapH: %d\", config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH);\r\n                if (ImGui::TreeNode(\"Glyphs\", \"Glyphs (%d)\", font->Glyphs.Size))\r\n                {\r\n                    // Display all glyphs of the fonts in separate pages of 256 characters\r\n                    for (int base = 0; base < 0x10000; base += 256)\r\n                    {\r\n                        int count = 0;\r\n                        for (int n = 0; n < 256; n++)\r\n                            count += font->FindGlyphNoFallback((ImWchar)(base + n)) ? 1 : 0;\r\n                        if (count > 0 && ImGui::TreeNode((void*)(intptr_t)base, \"U+%04X..U+%04X (%d %s)\", base, base+255, count, count > 1 ? \"glyphs\" : \"glyph\"))\r\n                        {\r\n                            float cell_size = font->FontSize * 1;\r\n                            float cell_spacing = style.ItemSpacing.y;\r\n                            ImVec2 base_pos = ImGui::GetCursorScreenPos();\r\n                            ImDrawList* draw_list = ImGui::GetWindowDrawList();\r\n                            for (int n = 0; n < 256; n++)\r\n                            {\r\n                                ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));\r\n                                ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);\r\n                                const ImFontGlyph* glyph = font->FindGlyphNoFallback((ImWchar)(base+n));\r\n                                draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255,255,255,100) : IM_COL32(255,255,255,50));\r\n                                if (glyph)\r\n                                    font->RenderChar(draw_list, cell_size, cell_p1, ImGui::GetColorU32(ImGuiCol_Text), (ImWchar)(base+n)); // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions available to generate a string.\r\n                                if (glyph && ImGui::IsMouseHoveringRect(cell_p1, cell_p2))\r\n                                {\r\n                                    ImGui::BeginTooltip();\r\n                                    ImGui::Text(\"Codepoint: U+%04X\", base+n);\r\n                                    ImGui::Separator();\r\n                                    ImGui::Text(\"AdvanceX: %.1f\", glyph->AdvanceX);\r\n                                    ImGui::Text(\"Pos: (%.2f,%.2f)->(%.2f,%.2f)\", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);\r\n                                    ImGui::Text(\"UV: (%.3f,%.3f)->(%.3f,%.3f)\", glyph->U0, glyph->V0, glyph->U1, glyph->V1);\r\n                                    ImGui::EndTooltip();\r\n                                }\r\n                            }\r\n                            ImGui::Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));\r\n                            ImGui::TreePop();\r\n                        }\r\n                    }\r\n                    ImGui::TreePop();\r\n                }\r\n                ImGui::TreePop();\r\n            }\r\n            ImGui::PopID();\r\n        }\r\n        static float window_scale = 1.0f;\r\n        ImGui::DragFloat(\"this window scale\", &window_scale, 0.005f, 0.3f, 2.0f, \"%.1f\");              // scale only this window\r\n        ImGui::DragFloat(\"global scale\", &ImGui::GetIO().FontGlobalScale, 0.005f, 0.3f, 2.0f, \"%.1f\"); // scale everything\r\n        ImGui::PopItemWidth();\r\n        ImGui::SetWindowFontScale(window_scale);\r\n        ImGui::TreePop();\r\n    }\r\n\r\n    ImGui::PopItemWidth();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate creating a fullscreen menu bar and populating it.\r\nstatic void ShowExampleAppMainMenuBar()\r\n{\r\n    if (ImGui::BeginMainMenuBar())\r\n    {\r\n        if (ImGui::BeginMenu(\"File\"))\r\n        {\r\n            ShowExampleMenuFile();\r\n            ImGui::EndMenu();\r\n        }\r\n        if (ImGui::BeginMenu(\"Edit\"))\r\n        {\r\n            if (ImGui::MenuItem(\"Undo\", \"CTRL+Z\")) {}\r\n            if (ImGui::MenuItem(\"Redo\", \"CTRL+Y\", false, false)) {}  // Disabled item\r\n            ImGui::Separator();\r\n            if (ImGui::MenuItem(\"Cut\", \"CTRL+X\")) {}\r\n            if (ImGui::MenuItem(\"Copy\", \"CTRL+C\")) {}\r\n            if (ImGui::MenuItem(\"Paste\", \"CTRL+V\")) {}\r\n            ImGui::EndMenu();\r\n        }\r\n        ImGui::EndMainMenuBar();\r\n    }\r\n}\r\n\r\nstatic void ShowExampleMenuFile()\r\n{\r\n    ImGui::MenuItem(\"(dummy menu)\", NULL, false, false);\r\n    if (ImGui::MenuItem(\"New\")) {}\r\n    if (ImGui::MenuItem(\"Open\", \"Ctrl+O\")) {}\r\n    if (ImGui::BeginMenu(\"Open Recent\"))\r\n    {\r\n        ImGui::MenuItem(\"fish_hat.c\");\r\n        ImGui::MenuItem(\"fish_hat.inl\");\r\n        ImGui::MenuItem(\"fish_hat.h\");\r\n        if (ImGui::BeginMenu(\"More..\"))\r\n        {\r\n            ImGui::MenuItem(\"Hello\");\r\n            ImGui::MenuItem(\"Sailor\");\r\n            if (ImGui::BeginMenu(\"Recurse..\"))\r\n            {\r\n                ShowExampleMenuFile();\r\n                ImGui::EndMenu();\r\n            }\r\n            ImGui::EndMenu();\r\n        }\r\n        ImGui::EndMenu();\r\n    }\r\n    if (ImGui::MenuItem(\"Save\", \"Ctrl+S\")) {}\r\n    if (ImGui::MenuItem(\"Save As..\")) {}\r\n    ImGui::Separator();\r\n    if (ImGui::BeginMenu(\"Options\"))\r\n    {\r\n        static bool enabled = true;\r\n        ImGui::MenuItem(\"Enabled\", \"\", &enabled);\r\n        ImGui::BeginChild(\"child\", ImVec2(0, 60), true);\r\n        for (int i = 0; i < 10; i++)\r\n            ImGui::Text(\"Scrolling Text %d\", i);\r\n        ImGui::EndChild();\r\n        static float f = 0.5f;\r\n        static int n = 0;\r\n        static bool b = true;\r\n        ImGui::SliderFloat(\"Value\", &f, 0.0f, 1.0f);\r\n        ImGui::InputFloat(\"Input\", &f, 0.1f);\r\n        ImGui::Combo(\"Combo\", &n, \"Yes\\0No\\0Maybe\\0\\0\");\r\n        ImGui::Checkbox(\"Check\", &b);\r\n        ImGui::EndMenu();\r\n    }\r\n    if (ImGui::BeginMenu(\"Colors\"))\r\n    {\r\n        float sz = ImGui::GetTextLineHeight();\r\n        for (int i = 0; i < ImGuiCol_COUNT; i++)\r\n        {\r\n            const char* name = ImGui::GetStyleColorName((ImGuiCol)i);\r\n            ImVec2 p = ImGui::GetCursorScreenPos();\r\n            ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui::GetColorU32((ImGuiCol)i));\r\n            ImGui::Dummy(ImVec2(sz, sz));\r\n            ImGui::SameLine();\r\n            ImGui::MenuItem(name);\r\n        }\r\n        ImGui::EndMenu();\r\n    }\r\n    if (ImGui::BeginMenu(\"Disabled\", false)) // Disabled\r\n    {\r\n        IM_ASSERT(0);\r\n    }\r\n    if (ImGui::MenuItem(\"Checked\", NULL, true)) {}\r\n    if (ImGui::MenuItem(\"Quit\", \"Alt+F4\")) {}\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate creating a simple console window, with scrolling, filtering, completion and history.\r\n// For the console example, here we are using a more C++ like approach of declaring a class to hold the data and the functions.\r\nstruct ExampleAppConsole\r\n{\r\n    char                  InputBuf[256];\r\n    ImVector<char*>       Items;\r\n    bool                  ScrollToBottom;\r\n    ImVector<char*>       History;\r\n    int                   HistoryPos;    // -1: new line, 0..History.Size-1 browsing history.\r\n    ImVector<const char*> Commands;\r\n\r\n    ExampleAppConsole()\r\n    {\r\n        ClearLog();\r\n        memset(InputBuf, 0, sizeof(InputBuf));\r\n        HistoryPos = -1;\r\n        Commands.push_back(\"HELP\");\r\n        Commands.push_back(\"HISTORY\");\r\n        Commands.push_back(\"CLEAR\");\r\n        Commands.push_back(\"CLASSIFY\");  // \"classify\" is only here to provide an example of \"C\"+[tab] completing to \"CL\" and displaying matches.\r\n        AddLog(\"Welcome to Dear ImGui!\");\r\n    }\r\n    ~ExampleAppConsole()\r\n    {\r\n        ClearLog();\r\n        for (int i = 0; i < History.Size; i++)\r\n            free(History[i]);\r\n    }\r\n\r\n    // Portable helpers\r\n    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }\r\n    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }\r\n    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = malloc(len); return (char*)memcpy(buff, (const void*)str, len); }\r\n    static void  Strtrim(char* str)                                  { char* str_end = str + strlen(str); while (str_end > str && str_end[-1] == ' ') str_end--; *str_end = 0; }\r\n\r\n    void    ClearLog()\r\n    {\r\n        for (int i = 0; i < Items.Size; i++)\r\n            free(Items[i]);\r\n        Items.clear();\r\n        ScrollToBottom = true;\r\n    }\r\n\r\n    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)\r\n    {\r\n        // FIXME-OPT\r\n        char buf[1024];\r\n        va_list args;\r\n        va_start(args, fmt);\r\n        vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);\r\n        buf[IM_ARRAYSIZE(buf)-1] = 0;\r\n        va_end(args);\r\n        Items.push_back(Strdup(buf));\r\n        ScrollToBottom = true;\r\n    }\r\n\r\n    void    Draw(const char* title, bool* p_open)\r\n    {\r\n        ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);\r\n        if (!ImGui::Begin(title, p_open))\r\n        {\r\n            ImGui::End();\r\n            return;\r\n        }\r\n\r\n        // As a specific feature guaranteed by the library, after calling Begin() the last Item represent the title bar. So e.g. IsItemHovered() will return true when hovering the title bar.\r\n        // Here we create a context menu only available from the title bar.\r\n        if (ImGui::BeginPopupContextItem())\r\n        {\r\n            if (ImGui::MenuItem(\"Close Console\"))\r\n                *p_open = false;\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        ImGui::TextWrapped(\"This example implements a console with basic coloring, completion and history. A more elaborate implementation may want to store entries along with extra data such as timestamp, emitter, etc.\");\r\n        ImGui::TextWrapped(\"Enter 'HELP' for help, press TAB to use text completion.\");\r\n\r\n        // TODO: display items starting from the bottom\r\n\r\n        if (ImGui::SmallButton(\"Add Dummy Text\")) { AddLog(\"%d some text\", Items.Size); AddLog(\"some more text\"); AddLog(\"display very important message here!\"); } ImGui::SameLine();\r\n        if (ImGui::SmallButton(\"Add Dummy Error\")) { AddLog(\"[error] something went wrong\"); } ImGui::SameLine();\r\n        if (ImGui::SmallButton(\"Clear\")) { ClearLog(); } ImGui::SameLine();\r\n        bool copy_to_clipboard = ImGui::SmallButton(\"Copy\"); ImGui::SameLine();\r\n        if (ImGui::SmallButton(\"Scroll to bottom\")) ScrollToBottom = true;\r\n        //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog(\"Spam %f\", t); }\r\n\r\n        ImGui::Separator();\r\n\r\n        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0,0));\r\n        static ImGuiTextFilter filter;\r\n        filter.Draw(\"Filter (\\\"incl,-excl\\\") (\\\"error\\\")\", 180);\r\n        ImGui::PopStyleVar();\r\n        ImGui::Separator();\r\n\r\n        const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing(); // 1 separator, 1 input text\r\n        ImGui::BeginChild(\"ScrollingRegion\", ImVec2(0, -footer_height_to_reserve), false, ImGuiWindowFlags_HorizontalScrollbar); // Leave room for 1 separator + 1 InputText\r\n        if (ImGui::BeginPopupContextWindow())\r\n        {\r\n            if (ImGui::Selectable(\"Clear\")) ClearLog();\r\n            ImGui::EndPopup();\r\n        }\r\n\r\n        // Display every line as a separate entry so we can change their color or add custom widgets. If you only want raw text you can use ImGui::TextUnformatted(log.begin(), log.end());\r\n        // NB- if you have thousands of entries this approach may be too inefficient and may require user-side clipping to only process visible items.\r\n        // You can seek and display only the lines that are visible using the ImGuiListClipper helper, if your elements are evenly spaced and you have cheap random access to the elements.\r\n        // To use the clipper we could replace the 'for (int i = 0; i < Items.Size; i++)' loop with:\r\n        //     ImGuiListClipper clipper(Items.Size);\r\n        //     while (clipper.Step())\r\n        //         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n        // However, note that you can not use this code as is if a filter is active because it breaks the 'cheap random-access' property. We would need random-access on the post-filtered list.\r\n        // A typical application wanting coarse clipping and filtering may want to pre-compute an array of indices that passed the filtering test, recomputing this array when user changes the filter,\r\n        // and appending newly elements as they are inserted. This is left as a task to the user until we can manage to improve this example code!\r\n        // If your items are of variable size you may want to implement code similar to what ImGuiListClipper does. Or split your data into fixed height items to allow random-seeking into your list.\r\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing\r\n        if (copy_to_clipboard)\r\n            ImGui::LogToClipboard();\r\n        ImVec4 col_default_text = ImGui::GetStyleColorVec4(ImGuiCol_Text);\r\n        for (int i = 0; i < Items.Size; i++)\r\n        {\r\n            const char* item = Items[i];\r\n            if (!filter.PassFilter(item))\r\n                continue;\r\n            ImVec4 col = col_default_text;\r\n            if (strstr(item, \"[error]\")) col = ImColor(1.0f,0.4f,0.4f,1.0f);\r\n            else if (strncmp(item, \"# \", 2) == 0) col = ImColor(1.0f,0.78f,0.58f,1.0f);\r\n            ImGui::PushStyleColor(ImGuiCol_Text, col);\r\n            ImGui::TextUnformatted(item);\r\n            ImGui::PopStyleColor();\r\n        }\r\n        if (copy_to_clipboard)\r\n            ImGui::LogFinish();\r\n        if (ScrollToBottom)\r\n            ImGui::SetScrollHereY(1.0f);\r\n        ScrollToBottom = false;\r\n        ImGui::PopStyleVar();\r\n        ImGui::EndChild();\r\n        ImGui::Separator();\r\n\r\n        // Command-line\r\n        bool reclaim_focus = false;\r\n        if (ImGui::InputText(\"Input\", InputBuf, IM_ARRAYSIZE(InputBuf), ImGuiInputTextFlags_EnterReturnsTrue|ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_CallbackHistory, &TextEditCallbackStub, (void*)this))\r\n        {\r\n            char* s = InputBuf;\r\n            Strtrim(s);\r\n            if (s[0])\r\n                ExecCommand(s);\r\n            strcpy(s, \"\");\r\n            reclaim_focus = true;\r\n        }\r\n\r\n        // Auto-focus on window apparition\r\n        ImGui::SetItemDefaultFocus();\r\n        if (reclaim_focus)\r\n            ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget\r\n\r\n        ImGui::End();\r\n    }\r\n\r\n    void    ExecCommand(const char* command_line)\r\n    {\r\n        AddLog(\"# %s\\n\", command_line);\r\n\r\n        // Insert into history. First find match and delete it so it can be pushed to the back. This isn't trying to be smart or optimal.\r\n        HistoryPos = -1;\r\n        for (int i = History.Size-1; i >= 0; i--)\r\n            if (Stricmp(History[i], command_line) == 0)\r\n            {\r\n                free(History[i]);\r\n                History.erase(History.begin() + i);\r\n                break;\r\n            }\r\n        History.push_back(Strdup(command_line));\r\n\r\n        // Process command\r\n        if (Stricmp(command_line, \"CLEAR\") == 0)\r\n        {\r\n            ClearLog();\r\n        }\r\n        else if (Stricmp(command_line, \"HELP\") == 0)\r\n        {\r\n            AddLog(\"Commands:\");\r\n            for (int i = 0; i < Commands.Size; i++)\r\n                AddLog(\"- %s\", Commands[i]);\r\n        }\r\n        else if (Stricmp(command_line, \"HISTORY\") == 0)\r\n        {\r\n            int first = History.Size - 10;\r\n            for (int i = first > 0 ? first : 0; i < History.Size; i++)\r\n                AddLog(\"%3d: %s\\n\", i, History[i]);\r\n        }\r\n        else\r\n        {\r\n            AddLog(\"Unknown command: '%s'\\n\", command_line);\r\n        }\r\n    }\r\n\r\n    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data) // In C++11 you are better off using lambdas for this sort of forwarding callbacks\r\n    {\r\n        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;\r\n        return console->TextEditCallback(data);\r\n    }\r\n\r\n    int     TextEditCallback(ImGuiInputTextCallbackData* data)\r\n    {\r\n        //AddLog(\"cursor: %d, selection: %d-%d\", data->CursorPos, data->SelectionStart, data->SelectionEnd);\r\n        switch (data->EventFlag)\r\n        {\r\n        case ImGuiInputTextFlags_CallbackCompletion:\r\n            {\r\n                // Example of TEXT COMPLETION\r\n\r\n                // Locate beginning of current word\r\n                const char* word_end = data->Buf + data->CursorPos;\r\n                const char* word_start = word_end;\r\n                while (word_start > data->Buf)\r\n                {\r\n                    const char c = word_start[-1];\r\n                    if (c == ' ' || c == '\\t' || c == ',' || c == ';')\r\n                        break;\r\n                    word_start--;\r\n                }\r\n\r\n                // Build a list of candidates\r\n                ImVector<const char*> candidates;\r\n                for (int i = 0; i < Commands.Size; i++)\r\n                    if (Strnicmp(Commands[i], word_start, (int)(word_end-word_start)) == 0)\r\n                        candidates.push_back(Commands[i]);\r\n\r\n                if (candidates.Size == 0)\r\n                {\r\n                    // No match\r\n                    AddLog(\"No match for \\\"%.*s\\\"!\\n\", (int)(word_end-word_start), word_start);\r\n                }\r\n                else if (candidates.Size == 1)\r\n                {\r\n                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing\r\n                    data->DeleteChars((int)(word_start-data->Buf), (int)(word_end-word_start));\r\n                    data->InsertChars(data->CursorPos, candidates[0]);\r\n                    data->InsertChars(data->CursorPos, \" \");\r\n                }\r\n                else\r\n                {\r\n                    // Multiple matches. Complete as much as we can, so inputing \"C\" will complete to \"CL\" and display \"CLEAR\" and \"CLASSIFY\"\r\n                    int match_len = (int)(word_end - word_start);\r\n                    for (;;)\r\n                    {\r\n                        int c = 0;\r\n                        bool all_candidates_matches = true;\r\n                        for (int i = 0; i < candidates.Size && all_candidates_matches; i++)\r\n                            if (i == 0)\r\n                                c = toupper(candidates[i][match_len]);\r\n                            else if (c == 0 || c != toupper(candidates[i][match_len]))\r\n                                all_candidates_matches = false;\r\n                        if (!all_candidates_matches)\r\n                            break;\r\n                        match_len++;\r\n                    }\r\n\r\n                    if (match_len > 0)\r\n                    {\r\n                        data->DeleteChars((int)(word_start - data->Buf), (int)(word_end-word_start));\r\n                        data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);\r\n                    }\r\n\r\n                    // List matches\r\n                    AddLog(\"Possible matches:\\n\");\r\n                    for (int i = 0; i < candidates.Size; i++)\r\n                        AddLog(\"- %s\\n\", candidates[i]);\r\n                }\r\n\r\n                break;\r\n            }\r\n        case ImGuiInputTextFlags_CallbackHistory:\r\n            {\r\n                // Example of HISTORY\r\n                const int prev_history_pos = HistoryPos;\r\n                if (data->EventKey == ImGuiKey_UpArrow)\r\n                {\r\n                    if (HistoryPos == -1)\r\n                        HistoryPos = History.Size - 1;\r\n                    else if (HistoryPos > 0)\r\n                        HistoryPos--;\r\n                }\r\n                else if (data->EventKey == ImGuiKey_DownArrow)\r\n                {\r\n                    if (HistoryPos != -1)\r\n                        if (++HistoryPos >= History.Size)\r\n                            HistoryPos = -1;\r\n                }\r\n\r\n                // A better implementation would preserve the data on the current input line along with cursor position.\r\n                if (prev_history_pos != HistoryPos)\r\n                {\r\n                    const char* history_str = (HistoryPos >= 0) ? History[HistoryPos] : \"\";\r\n                    data->DeleteChars(0, data->BufTextLen);\r\n                    data->InsertChars(0, history_str);\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n\r\nstatic void ShowExampleAppConsole(bool* p_open)\r\n{\r\n    static ExampleAppConsole console;\r\n    console.Draw(\"Example: Console\", p_open);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Usage:\r\n//  static ExampleAppLog my_log;\r\n//  my_log.AddLog(\"Hello %d world\\n\", 123);\r\n//  my_log.Draw(\"title\");\r\nstruct ExampleAppLog\r\n{\r\n    ImGuiTextBuffer     Buf;\r\n    ImGuiTextFilter     Filter;\r\n    ImVector<int>       LineOffsets;        // Index to lines offset\r\n    bool                ScrollToBottom;\r\n\r\n    void    Clear()     { Buf.clear(); LineOffsets.clear(); }\r\n\r\n    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)\r\n    {\r\n        int old_size = Buf.size();\r\n        va_list args;\r\n        va_start(args, fmt);\r\n        Buf.appendfv(fmt, args);\r\n        va_end(args);\r\n        for (int new_size = Buf.size(); old_size < new_size; old_size++)\r\n            if (Buf[old_size] == '\\n')\r\n                LineOffsets.push_back(old_size);\r\n        ScrollToBottom = true;\r\n    }\r\n\r\n    void    Draw(const char* title, bool* p_open = NULL)\r\n    {\r\n        ImGui::SetNextWindowSize(ImVec2(500,400), ImGuiCond_FirstUseEver);\r\n        if (!ImGui::Begin(title, p_open))\r\n        {\r\n            ImGui::End();\r\n            return;\r\n        }\r\n        if (ImGui::Button(\"Clear\")) Clear();\r\n        ImGui::SameLine();\r\n        bool copy = ImGui::Button(\"Copy\");\r\n        ImGui::SameLine();\r\n        Filter.Draw(\"Filter\", -100.0f);\r\n        ImGui::Separator();\r\n        ImGui::BeginChild(\"scrolling\", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);\r\n        if (copy) ImGui::LogToClipboard();\r\n\r\n        if (Filter.IsActive())\r\n        {\r\n            const char* buf_begin = Buf.begin();\r\n            const char* line = buf_begin;\r\n            for (int line_no = 0; line != NULL; line_no++)\r\n            {\r\n                const char* line_end = (line_no < LineOffsets.Size) ? buf_begin + LineOffsets[line_no] : NULL;\r\n                if (Filter.PassFilter(line, line_end))\r\n                    ImGui::TextUnformatted(line, line_end);\r\n                line = line_end && line_end[1] ? line_end + 1 : NULL;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            ImGui::TextUnformatted(Buf.begin());\r\n        }\r\n\r\n        if (ScrollToBottom)\r\n            ImGui::SetScrollHereY(1.0f);\r\n        ScrollToBottom = false;\r\n        ImGui::EndChild();\r\n        ImGui::End();\r\n    }\r\n};\r\n\r\n// Demonstrate creating a simple log window with basic filtering.\r\nstatic void ShowExampleAppLog(bool* p_open)\r\n{\r\n    static ExampleAppLog log;\r\n\r\n    // Demo: add random items (unless Ctrl is held)\r\n    static double last_time = -1.0;\r\n    double time = ImGui::GetTime();\r\n    if (time - last_time >= 0.20f && !ImGui::GetIO().KeyCtrl)\r\n    {\r\n        const char* random_words[] = { \"system\", \"info\", \"warning\", \"error\", \"fatal\", \"notice\", \"log\" };\r\n        log.AddLog(\"[%s] Hello, time is %.1f, frame count is %d\\n\", random_words[rand() % IM_ARRAYSIZE(random_words)], time, ImGui::GetFrameCount());\r\n        last_time = time;\r\n    }\r\n\r\n    log.Draw(\"Example: Log\", p_open);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate create a window with multiple child windows.\r\nstatic void ShowExampleAppLayout(bool* p_open)\r\n{\r\n    ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);\r\n    if (ImGui::Begin(\"Example: Layout\", p_open, ImGuiWindowFlags_MenuBar))\r\n    {\r\n        if (ImGui::BeginMenuBar())\r\n        {\r\n            if (ImGui::BeginMenu(\"File\"))\r\n            {\r\n                if (ImGui::MenuItem(\"Close\")) *p_open = false;\r\n                ImGui::EndMenu();\r\n            }\r\n            ImGui::EndMenuBar();\r\n        }\r\n\r\n        // left\r\n        static int selected = 0;\r\n        ImGui::BeginChild(\"left pane\", ImVec2(150, 0), true);\r\n        for (int i = 0; i < 100; i++)\r\n        {\r\n            char label[128];\r\n            sprintf(label, \"MyObject %d\", i);\r\n            if (ImGui::Selectable(label, selected == i))\r\n                selected = i;\r\n        }\r\n        ImGui::EndChild();\r\n        ImGui::SameLine();\r\n\r\n        // right\r\n        ImGui::BeginGroup();\r\n            ImGui::BeginChild(\"item view\", ImVec2(0, -ImGui::GetFrameHeightWithSpacing())); // Leave room for 1 line below us\r\n                ImGui::Text(\"MyObject: %d\", selected);\r\n                ImGui::Separator();\r\n                ImGui::TextWrapped(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \");\r\n            ImGui::EndChild();\r\n            if (ImGui::Button(\"Revert\")) {}\r\n            ImGui::SameLine();\r\n            if (ImGui::Button(\"Save\")) {}\r\n        ImGui::EndGroup();\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate create a simple property editor.\r\nstatic void ShowExampleAppPropertyEditor(bool* p_open)\r\n{\r\n    ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiCond_FirstUseEver);\r\n    if (!ImGui::Begin(\"Example: Property editor\", p_open))\r\n    {\r\n        ImGui::End();\r\n        return;\r\n    }\r\n\r\n    ShowHelpMarker(\"This example shows how you may implement a property editor using two columns.\\nAll objects/fields data are dummies here.\\nRemember that in many simple cases, you can use ImGui::SameLine(xxx) to position\\nyour cursor horizontally instead of using the Columns() API.\");\r\n\r\n    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));\r\n    ImGui::Columns(2);\r\n    ImGui::Separator();\r\n\r\n    struct funcs\r\n    {\r\n        static void ShowDummyObject(const char* prefix, int uid)\r\n        {\r\n            ImGui::PushID(uid);                      // Use object uid as identifier. Most commonly you could also use the object pointer as a base ID.\r\n            ImGui::AlignTextToFramePadding();  // Text and Tree nodes are less high than regular widgets, here we add vertical spacing to make the tree lines equal high.\r\n            bool node_open = ImGui::TreeNode(\"Object\", \"%s_%u\", prefix, uid);\r\n            ImGui::NextColumn();\r\n            ImGui::AlignTextToFramePadding();\r\n            ImGui::Text(\"my sailor is rich\");\r\n            ImGui::NextColumn();\r\n            if (node_open)\r\n            {\r\n                static float dummy_members[8] = { 0.0f,0.0f,1.0f,3.1416f,100.0f,999.0f };\r\n                for (int i = 0; i < 8; i++)\r\n                {\r\n                    ImGui::PushID(i); // Use field index as identifier.\r\n                    if (i < 2)\r\n                    {\r\n                        ShowDummyObject(\"Child\", 424242);\r\n                    }\r\n                    else\r\n                    {\r\n                        // Here we use a TreeNode to highlight on hover (we could use e.g. Selectable as well)\r\n                        ImGui::AlignTextToFramePadding();\r\n                        ImGui::TreeNodeEx(\"Field\", ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_Bullet, \"Field_%d\", i);\r\n                        ImGui::NextColumn();\r\n                        ImGui::PushItemWidth(-1);\r\n                        if (i >= 5)\r\n                            ImGui::InputFloat(\"##value\", &dummy_members[i], 1.0f);\r\n                        else\r\n                            ImGui::DragFloat(\"##value\", &dummy_members[i], 0.01f);\r\n                        ImGui::PopItemWidth();\r\n                        ImGui::NextColumn();\r\n                    }\r\n                    ImGui::PopID();\r\n                }\r\n                ImGui::TreePop();\r\n            }\r\n            ImGui::PopID();\r\n        }\r\n    };\r\n\r\n    // Iterate dummy objects with dummy members (all the same data)\r\n    for (int obj_i = 0; obj_i < 3; obj_i++)\r\n        funcs::ShowDummyObject(\"Object\", obj_i);\r\n\r\n    ImGui::Columns(1);\r\n    ImGui::Separator();\r\n    ImGui::PopStyleVar();\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate/test rendering huge amount of text, and the incidence of clipping.\r\nstatic void ShowExampleAppLongText(bool* p_open)\r\n{\r\n    ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);\r\n    if (!ImGui::Begin(\"Example: Long text display\", p_open))\r\n    {\r\n        ImGui::End();\r\n        return;\r\n    }\r\n\r\n    static int test_type = 0;\r\n    static ImGuiTextBuffer log;\r\n    static int lines = 0;\r\n    ImGui::Text(\"Printing unusually long amount of text.\");\r\n    ImGui::Combo(\"Test type\", &test_type, \"Single call to TextUnformatted()\\0Multiple calls to Text(), clipped manually\\0Multiple calls to Text(), not clipped (slow)\\0\");\r\n    ImGui::Text(\"Buffer contents: %d lines, %d bytes\", lines, log.size());\r\n    if (ImGui::Button(\"Clear\")) { log.clear(); lines = 0; }\r\n    ImGui::SameLine();\r\n    if (ImGui::Button(\"Add 1000 lines\"))\r\n    {\r\n        for (int i = 0; i < 1000; i++)\r\n            log.appendf(\"%i The quick brown fox jumps over the lazy dog\\n\", lines+i);\r\n        lines += 1000;\r\n    }\r\n    ImGui::BeginChild(\"Log\");\r\n    switch (test_type)\r\n    {\r\n    case 0:\r\n        // Single call to TextUnformatted() with a big buffer\r\n        ImGui::TextUnformatted(log.begin(), log.end());\r\n        break;\r\n    case 1:\r\n        {\r\n            // Multiple calls to Text(), manually coarsely clipped - demonstrate how to use the ImGuiListClipper helper.\r\n            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));\r\n            ImGuiListClipper clipper(lines);\r\n            while (clipper.Step())\r\n                for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n                    ImGui::Text(\"%i The quick brown fox jumps over the lazy dog\", i);\r\n            ImGui::PopStyleVar();\r\n            break;\r\n        }\r\n    case 2:\r\n        // Multiple calls to Text(), not clipped (slow)\r\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));\r\n        for (int i = 0; i < lines; i++)\r\n            ImGui::Text(\"%i The quick brown fox jumps over the lazy dog\", i);\r\n        ImGui::PopStyleVar();\r\n        break;\r\n    }\r\n    ImGui::EndChild();\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate creating a window which gets auto-resized according to its content.\r\nstatic void ShowExampleAppAutoResize(bool* p_open)\r\n{\r\n    if (!ImGui::Begin(\"Example: Auto-resizing window\", p_open, ImGuiWindowFlags_AlwaysAutoResize))\r\n    {\r\n        ImGui::End();\r\n        return;\r\n    }\r\n\r\n    static int lines = 10;\r\n    ImGui::Text(\"Window will resize every-frame to the size of its content.\\nNote that you probably don't want to query the window size to\\noutput your content because that would create a feedback loop.\");\r\n    ImGui::SliderInt(\"Number of lines\", &lines, 1, 20);\r\n    for (int i = 0; i < lines; i++)\r\n        ImGui::Text(\"%*sThis is line %d\", i * 4, \"\", i); // Pad with space to extend size horizontally\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate creating a window with custom resize constraints.\r\nstatic void ShowExampleAppConstrainedResize(bool* p_open)\r\n{\r\n    struct CustomConstraints // Helper functions to demonstrate programmatic constraints\r\n    {\r\n        static void Square(ImGuiSizeCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }\r\n        static void Step(ImGuiSizeCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }\r\n    };\r\n\r\n    static bool auto_resize = false;\r\n    static int type = 0;\r\n    static int display_lines = 10;\r\n    if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only\r\n    if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only\r\n    if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100\r\n    if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(400, -1),  ImVec2(500, -1));          // Width 400-500\r\n    if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 400),  ImVec2(-1, 500));          // Height 400-500\r\n    if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);          // Always Square\r\n    if (type == 6) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)100);// Fixed Step\r\n\r\n    ImGuiWindowFlags flags = auto_resize ? ImGuiWindowFlags_AlwaysAutoResize : 0;\r\n    if (ImGui::Begin(\"Example: Constrained Resize\", p_open, flags))\r\n    {\r\n        const char* desc[] =\r\n        {\r\n            \"Resize vertical only\",\r\n            \"Resize horizontal only\",\r\n            \"Width > 100, Height > 100\",\r\n            \"Width 400-500\",\r\n            \"Height 400-500\",\r\n            \"Custom: Always Square\",\r\n            \"Custom: Fixed Steps (100)\",\r\n        };\r\n        if (ImGui::Button(\"200x200\")) { ImGui::SetWindowSize(ImVec2(200, 200)); } ImGui::SameLine();\r\n        if (ImGui::Button(\"500x500\")) { ImGui::SetWindowSize(ImVec2(500, 500)); } ImGui::SameLine();\r\n        if (ImGui::Button(\"800x200\")) { ImGui::SetWindowSize(ImVec2(800, 200)); }\r\n        ImGui::PushItemWidth(200);\r\n        ImGui::Combo(\"Constraint\", &type, desc, IM_ARRAYSIZE(desc));\r\n        ImGui::DragInt(\"Lines\", &display_lines, 0.2f, 1, 100);\r\n        ImGui::PopItemWidth();\r\n        ImGui::Checkbox(\"Auto-resize\", &auto_resize);\r\n        for (int i = 0; i < display_lines; i++)\r\n            ImGui::Text(\"%*sHello, sailor! Making this line long enough for the example.\", i * 4, \"\");\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate creating a simple static window with no decoration + a context-menu to choose which corner of the screen to use.\r\nstatic void ShowExampleAppSimpleOverlay(bool* p_open)\r\n{\r\n    const float DISTANCE = 10.0f;\r\n    static int corner = 0;\r\n    ImVec2 window_pos = ImVec2((corner & 1) ? ImGui::GetIO().DisplaySize.x - DISTANCE : DISTANCE, (corner & 2) ? ImGui::GetIO().DisplaySize.y - DISTANCE : DISTANCE);\r\n    ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);\r\n    if (corner != -1)\r\n        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);\r\n    ImGui::SetNextWindowBgAlpha(0.3f); // Transparent background\r\n    if (ImGui::Begin(\"Example: Simple Overlay\", p_open, (corner != -1 ? ImGuiWindowFlags_NoMove : 0) | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav))\r\n    {\r\n        ImGui::Text(\"Simple overlay\\n\" \"in the corner of the screen.\\n\" \"(right-click to change position)\");\r\n        ImGui::Separator();\r\n        if (ImGui::IsMousePosValid())\r\n            ImGui::Text(\"Mouse Position: (%.1f,%.1f)\", ImGui::GetIO().MousePos.x, ImGui::GetIO().MousePos.y);\r\n        else\r\n            ImGui::Text(\"Mouse Position: <invalid>\");\r\n        if (ImGui::BeginPopupContextWindow())\r\n        {\r\n            if (ImGui::MenuItem(\"Custom\",       NULL, corner == -1)) corner = -1;\r\n            if (ImGui::MenuItem(\"Top-left\",     NULL, corner == 0)) corner = 0;\r\n            if (ImGui::MenuItem(\"Top-right\",    NULL, corner == 1)) corner = 1;\r\n            if (ImGui::MenuItem(\"Bottom-left\",  NULL, corner == 2)) corner = 2;\r\n            if (ImGui::MenuItem(\"Bottom-right\", NULL, corner == 3)) corner = 3;\r\n            if (p_open && ImGui::MenuItem(\"Close\")) *p_open = false;\r\n            ImGui::EndPopup();\r\n        }\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate using \"##\" and \"###\" in identifiers to manipulate ID generation.\r\n// This apply to all regular items as well. Read FAQ section \"How can I have multiple widgets with the same label? Can I have widget without a label? (Yes). A primer on the purpose of labels/IDs.\" for details.\r\nstatic void ShowExampleAppWindowTitles(bool*)\r\n{\r\n    // By default, Windows are uniquely identified by their title.\r\n    // You can use the \"##\" and \"###\" markers to manipulate the display/ID.\r\n\r\n    // Using \"##\" to display same title but have unique identifier.\r\n    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);\r\n    ImGui::Begin(\"Same title as another window##1\");\r\n    ImGui::Text(\"This is window 1.\\nMy title is the same as window 2, but my identifier is unique.\");\r\n    ImGui::End();\r\n\r\n    ImGui::SetNextWindowPos(ImVec2(100, 200), ImGuiCond_FirstUseEver);\r\n    ImGui::Begin(\"Same title as another window##2\");\r\n    ImGui::Text(\"This is window 2.\\nMy title is the same as window 1, but my identifier is unique.\");\r\n    ImGui::End();\r\n\r\n    // Using \"###\" to display a changing title but keep a static identifier \"AnimatedTitle\"\r\n    char buf[128];\r\n    sprintf(buf, \"Animated title %c %d###AnimatedTitle\", \"|/-\\\\\"[(int)(ImGui::GetTime() / 0.25f) & 3], ImGui::GetFrameCount());\r\n    ImGui::SetNextWindowPos(ImVec2(100, 300), ImGuiCond_FirstUseEver);\r\n    ImGui::Begin(buf);\r\n    ImGui::Text(\"This window has a changing title.\");\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\r\n//-----------------------------------------------------------------------------\r\n\r\n// Demonstrate using the low-level ImDrawList to draw custom shapes.\r\nstatic void ShowExampleAppCustomRendering(bool* p_open)\r\n{\r\n    ImGui::SetNextWindowSize(ImVec2(350, 560), ImGuiCond_FirstUseEver);\r\n    if (!ImGui::Begin(\"Example: Custom rendering\", p_open))\r\n    {\r\n        ImGui::End();\r\n        return;\r\n    }\r\n\r\n    // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of overloaded operators, etc.\r\n    // Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your types and ImVec2/ImVec4.\r\n    // ImGui defines overloaded operators but they are internal to imgui.cpp and not exposed outside (to avoid messing with your types)\r\n    // In this example we are not using the maths operators!\r\n    ImDrawList* draw_list = ImGui::GetWindowDrawList();\r\n\r\n    // Primitives\r\n    ImGui::Text(\"Primitives\");\r\n    static float sz = 36.0f;\r\n    static float thickness = 4.0f;\r\n    static ImVec4 col = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);\r\n    ImGui::DragFloat(\"Size\", &sz, 0.2f, 2.0f, 72.0f, \"%.0f\");\r\n    ImGui::DragFloat(\"Thickness\", &thickness, 0.05f, 1.0f, 8.0f, \"%.02f\");\r\n    ImGui::ColorEdit3(\"Color\", &col.x);\r\n    {\r\n        const ImVec2 p = ImGui::GetCursorScreenPos();\r\n        const ImU32 col32 = ImColor(col);\r\n        float x = p.x + 4.0f, y = p.y + 4.0f, spacing = 8.0f;\r\n        for (int n = 0; n < 2; n++)\r\n        {\r\n            float curr_thickness = (n == 0) ? 1.0f : thickness;\r\n            draw_list->AddCircle(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 20, curr_thickness); x += sz+spacing;\r\n            draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 0.0f, ImDrawCornerFlags_All, curr_thickness); x += sz+spacing;\r\n            draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ImDrawCornerFlags_All, curr_thickness); x += sz+spacing;\r\n            draw_list->AddRect(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotRight, curr_thickness); x += sz+spacing;\r\n            draw_list->AddTriangle(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32, curr_thickness); x += sz+spacing;\r\n            draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y   ), col32, curr_thickness); x += sz+spacing;   // Horizontal line (note: drawing a filled rectangle will be faster!)\r\n            draw_list->AddLine(ImVec2(x, y), ImVec2(x,    y+sz), col32, curr_thickness); x += spacing;      // Vertical line (note: drawing a filled rectangle will be faster!)\r\n            draw_list->AddLine(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, curr_thickness); x += sz+spacing;   // Diagonal line\r\n            draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x+sz*1.3f,y+sz*0.3f), ImVec2(x+sz-sz*1.3f,y+sz-sz*0.3f), ImVec2(x+sz, y+sz), col32, curr_thickness);\r\n            x = p.x + 4;\r\n            y += sz+spacing;\r\n        }\r\n        draw_list->AddCircleFilled(ImVec2(x+sz*0.5f, y+sz*0.5f), sz*0.5f, col32, 32); x += sz+spacing;\r\n        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32); x += sz+spacing;\r\n        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f); x += sz+spacing;\r\n        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+sz), col32, 10.0f, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotRight); x += sz+spacing;\r\n        draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f, y), ImVec2(x+sz,y+sz-0.5f), ImVec2(x,y+sz-0.5f), col32); x += sz+spacing;\r\n        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+sz, y+thickness), col32); x += sz+spacing;          // Horizontal line (faster than AddLine, but only handle integer thickness)\r\n        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+thickness, y+sz), col32); x += spacing+spacing;     // Vertical line (faster than AddLine, but only handle integer thickness)\r\n        draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x+1, y+1), col32);          x += sz;                  // Pixel (faster than AddLine)\r\n        draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x+sz, y+sz), IM_COL32(0,0,0,255), IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255));\r\n        ImGui::Dummy(ImVec2((sz+spacing)*8, (sz+spacing)*3));\r\n    }\r\n    ImGui::Separator();\r\n    {\r\n        static ImVector<ImVec2> points;\r\n        static bool adding_line = false;\r\n        ImGui::Text(\"Canvas example\");\r\n        if (ImGui::Button(\"Clear\")) points.clear();\r\n        if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button(\"Undo\")) { points.pop_back(); points.pop_back(); } }\r\n        ImGui::Text(\"Left-click and drag to add lines,\\nRight-click to undo\");\r\n\r\n        // Here we are using InvisibleButton() as a convenience to 1) advance the cursor and 2) allows us to use IsItemHovered()\r\n        // But you can also draw directly and poll mouse/keyboard by yourself. You can manipulate the cursor using GetCursorPos() and SetCursorPos().\r\n        // If you only use the ImDrawList API, you can notify the owner window of its extends by using SetCursorPos(max).\r\n        ImVec2 canvas_pos = ImGui::GetCursorScreenPos();            // ImDrawList API uses screen coordinates!\r\n        ImVec2 canvas_size = ImGui::GetContentRegionAvail();        // Resize canvas to what's available\r\n        if (canvas_size.x < 50.0f) canvas_size.x = 50.0f;\r\n        if (canvas_size.y < 50.0f) canvas_size.y = 50.0f;\r\n        draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(50, 50, 50, 255), IM_COL32(50, 50, 60, 255), IM_COL32(60, 60, 70, 255), IM_COL32(50, 50, 60, 255));\r\n        draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(255, 255, 255, 255));\r\n\r\n        bool adding_preview = false;\r\n        ImGui::InvisibleButton(\"canvas\", canvas_size);\r\n        ImVec2 mouse_pos_in_canvas = ImVec2(ImGui::GetIO().MousePos.x - canvas_pos.x, ImGui::GetIO().MousePos.y - canvas_pos.y);\r\n        if (adding_line)\r\n        {\r\n            adding_preview = true;\r\n            points.push_back(mouse_pos_in_canvas);\r\n            if (!ImGui::IsMouseDown(0))\r\n                adding_line = adding_preview = false;\r\n        }\r\n        if (ImGui::IsItemHovered())\r\n        {\r\n            if (!adding_line && ImGui::IsMouseClicked(0))\r\n            {\r\n                points.push_back(mouse_pos_in_canvas);\r\n                adding_line = true;\r\n            }\r\n            if (ImGui::IsMouseClicked(1) && !points.empty())\r\n            {\r\n                adding_line = adding_preview = false;\r\n                points.pop_back();\r\n                points.pop_back();\r\n            }\r\n        }\r\n        draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), true);      // clip lines within the canvas (if we resize it, etc.)\r\n        for (int i = 0; i < points.Size - 1; i += 2)\r\n            draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i + 1].x, canvas_pos.y + points[i + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);\r\n        draw_list->PopClipRect();\r\n        if (adding_preview)\r\n            points.pop_back();\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n// End of Demo code\r\n#else\r\n\r\nvoid ImGui::ShowAboutWindow(bool*) {}\r\nvoid ImGui::ShowDemoWindow(bool*) {}\r\nvoid ImGui::ShowUserGuide() {}\r\nvoid ImGui::ShowStyleEditor(ImGuiStyle*) {}\r\n\r\n#endif\r\n","// Copyright 2012 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n#include <emscripten/bind.h>\n#ifdef USE_CXA_DEMANGLE\n#include <../lib/libcxxabi/include/cxxabi.h>\n#endif\n#include <list>\n#include <vector>\n#include <typeinfo>\n#include <algorithm>\n#include <emscripten/emscripten.h>\n#include <emscripten/wire.h>\n#include <climits>\n#include <limits>\n\nusing namespace emscripten;\n\nextern \"C\" {\n    const char* EMSCRIPTEN_KEEPALIVE __getTypeName(const std::type_info* ti) {\n        if (has_unbound_type_names) {\n#ifdef USE_CXA_DEMANGLE\n            int stat;\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\n            if (stat == 0 && demangled) {\n                return demangled;\n            }\n\n            switch (stat) {\n                case -1:\n                    return strdup(\"<allocation failure>\");\n                case -2:\n                    return strdup(\"<invalid C++ symbol>\");\n                case -3:\n                    return strdup(\"<invalid argument>\");\n                default:\n                    return strdup(\"<unknown error>\");\n            }\n#else\n            return strdup(ti->name());\n#endif\n        } else {\n            char str[80];\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\n            return strdup(str);\n        }\n    }\n}\n\nnamespace {\n    template<typename T>\n    static void register_integer(const char* name) {\n        using namespace internal;\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\n    }\n\n    template<typename T>\n    static void register_float(const char* name) {\n        using namespace internal;\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\n    }\n\n\n    // matches typeMapping in embind.js\n    enum TypedArrayIndex {\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n    };\n\n    template<typename T>\n    constexpr TypedArrayIndex getTypedArrayIndex() {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type does not map to a typed array\");\n        return std::is_floating_point<T>::value\n            ? (sizeof(T) == 4\n               ? Float32Array\n               : Float64Array)\n            : (sizeof(T) == 1\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\n               : (sizeof(T) == 2\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\n    }\n\n    template<typename T>\n    static void register_memory_view(const char* name) {\n        using namespace internal;\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\n    }\n}\n\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\n    using namespace emscripten::internal;\n\n    _embind_register_void(TypeID<void>::get(), \"void\");\n\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\n\n    register_integer<char>(\"char\");\n    register_integer<signed char>(\"signed char\");\n    register_integer<unsigned char>(\"unsigned char\");\n    register_integer<signed short>(\"short\");\n    register_integer<unsigned short>(\"unsigned short\");\n    register_integer<signed int>(\"int\");\n    register_integer<unsigned int>(\"unsigned int\");\n    register_integer<signed long>(\"long\");\n    register_integer<unsigned long>(\"unsigned long\");\n\n    register_float<float>(\"float\");\n    register_float<double>(\"double\");\n\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\n\n    // Some of these types are aliases for each other. Luckily,\n    // embind.js's _embind_register_memory_view ignores duplicate\n    // registrations rather than asserting, so the first\n    // register_memory_view call for a particular type will take\n    // precedence.\n\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\n\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\n\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\n\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\n#if __SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !defined(_LIBCPP_ABI_MICROSOFT)\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\n#if defined(_LIBCPP_ABI_MICROSOFT)\n    mutable struct {\n      const char *__undecorated_name;\n      const char __decorated_name[1];\n    } __data;\n\n    int __compare(const type_info &__rhs) const _NOEXCEPT;\n#endif // _LIBCPP_ABI_MICROSOFT\n\nprotected:\n#if !defined(_LIBCPP_ABI_MICROSOFT)\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n#endif // ! _LIBCPP_ABI_MICROSOFT\n\npublic:\n    _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE\n    virtual ~type_info();\n\n#if defined(_LIBCPP_ABI_MICROSOFT)\n    const char *name() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT {\n      return __compare(__arg) < 0;\n    }\n\n    size_t hash_code() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT {\n      return __compare(__arg) == 0;\n    }\n#else\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n#endif // _LIBCPP_ABI_MICROSOFT\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n"]}